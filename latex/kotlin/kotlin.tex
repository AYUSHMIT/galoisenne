%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan,nonacm]{acmart}
\documentclass[sigplan,review,anonymous,acmsmall]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[POPL'24]{Symposium on the Principles of Programming Languages}{January 17-19, 2024}{London, United Kingdom}
%\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{acmart}

\input{preamble.tex}
\begin{document}

%% Title information
\title{Syntax Error Correction For All}
\begin{abstract}
In this work, we illustrate how to lower context-free language recognition onto a tensor algebra over finite fields. In addition to its theoretical value, this connection has yielded surprisingly useful applications in incremental parsing, code completion and program repair. For example, we use it to repair syntax errors, perform sketch-based program synthesis, and decide various language induction and membership queries. This line of research provides an elegant unification of context-free program repair, code completion and sketch-based program synthesis. To accelerate code completion, we design and implement a novel incremental parser-synthesizer that transforms CFGs onto a dynamical system over finite field arithmetic, enabling us to suggest syntax repairs in-between keystrokes.
\end{abstract}

\maketitle

\section{Introduction}

  Our tool accepts an arbitrary sequence of lexical tokens and suggests a set of possible syntax repairs. We evaluate it using a corpus of syntactically correct single-line statements containing between 10-80 lexical tokens in various programming languages (e.g., Java, Kotlin and Python), synthetically corrupted by erasing up to three uniformly at random. The tool suggests a repair in less than 0.1 seconds on average, and the original statement is ranked within the first ten in P\% of the cases.

  We also evaluate it on a corpus of natural syntax errors, and find the tool is able to suggest at least one syntactically valid repair within 20 seconds in 100\% of the cases presented, and typically several hundred depending on the length of the fragment and grammar, as well as the number of available processor cores. For example, consider the following text that was synthetically corrupted:

\begin{tcolorbox}[left skip=0.7cm,
top=0.1cm,
middle=0mm,
boxsep=0mm,
underlay unbroken and first={%
  \path[draw=none] (interior.north west) rectangle node[white]{\includegraphics[width=4mm]{../figures/tidyparse_logo.png}} ([xshift=-10mm,yshift=-9mm]interior.north west);
}]
\begin{lstlisting} [language=tidy, basicstyle=\ttfamily\small, escapeinside={(*@}{@*)}]
 Original:  val splitTokens : MutableList < String > = ArrayList ( )
Corrupted:  (*@\hlred{var}@*) splitTokens : MutableList < String > = ArrayList ( )
\end{lstlisting}
\tcblower
\begin{lstlisting} [language=tidy, basicstyle=\ttfamily\small, escapeinside={(*@}{@*)}]
D=1 repair: (*@\hlgreen{var}@*) splitTokens : MutableList < String > = ArrayList ( )
D=1 repair: (*@\hlgreen{val}@*) splitTokens : MutableList < String > = ArrayList ( )
D=2 repair: (*@\hlorange{var}@*) (*@\hlgreen{protected}@*) : MutableList < String > = ArrayList ( )
D=2 repair: (*@\hlgreen{var}@*) splitTokens : MutableList < (*@\hlorange{tailrec}@*) > = ArrayList ( )
D=2 repair: (*@\hlgreen{var}@*) splitTokens : MutableList < String > = (*@\hlorange{inline}@*) ( )
D=2 repair: (*@\hlgreen{val}@*) splitTokens : MutableList < (*@\hlorange{override}@*) > = ArrayList ( )
...
Found 426 valid repairs in 13062ms, or roughly ~32.61 repairs per second.
Original string was ranked #1 in repair proposals!
\end{lstlisting}
\end{tcolorbox}

In the following paper, we will describe the theory and practice of real-time syntactic error correction, and demonstrate how the same techniques can be used to accelerate code completion, program repair and sketch-based program synthesis. Although we primarily focus on the Kotlin language, the techniques described are applicable to any language whose syntax can be expressed as a context-free language. In practice, this includes a substantial fragment of most programming languages. We will also describe how the techniques described can be extended to support certain context-sensitive languages and thereby used to correct various kinds of semantic errors.

\end{document}