%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
\documentclass[sigplan,nonacm]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
%\acmConference[ARRAY'22]{ACM SIGPLAN Conference on Programming Languages}{June 13, 2022}{San Diego, CA, USA}
%\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\usepackage{dsfont}
\usepackage{colortbl}
\usepackage{hyperref}


%% Bibliography style
\bibliographystyle{acmart}

\input{preamble.tex}
\begin{document}

  \title{A Tree Sampler for Bounded Context-Free Languages}
  \begin{abstract}
    The class of bounded context-free languages (BCFLs) consists of the subset of context-free languages which are finite. We provide a novel algorithm for sampling trees in BCFLs with and without replacement. Once the data structure is constructed, sampling trees is a straightforward matter of sampling integers uniformly without a replacement from a finite range. We demonstrate the utility of this technique on a dataset of Python statements.
  \end{abstract}

  \author{Breandan Considine}
  \affiliation{\institution{McGill University}}
  \email{breandan.considine@mail.mcgill.ca}

  \maketitle

  \section{Introduction}

  Recall that a CFG is a quadruple consisting of terminals $(\Sigma)$, nonterminals $(V)$, productions $(P\colon V \rightarrow (V \mid \Sigma)^*)$, and a start symbol, $(S)$. It is a well-known fact that every CFG is reducible to \textit{Chomsky Normal Form}, $P'\colon V \rightarrow (V^2 \mid \Sigma)$, in which every production takes one of two forms, either $w \rightarrow xz$, or $w \rightarrow t$, where $w, x, z: V$ and $t: \Sigma$. For example, the CFG, $P:=\{S \rightarrow S S \mid ( S ) \mid ()\}$, corresponds to the CNF:\vspace{-3pt}

  \begin{table}[H]
    \begin{tabular}{llll}
      $P'=\big\{\;S\rightarrow QR \mid SS \mid LR,$ & $L \rightarrow (,$ & $R \rightarrow ),$ & $Q\rightarrow LS\;\big\}$
    \end{tabular}
  \end{table}\vspace{-8pt}

  \noindent Given a CFG, $\mathcal{G}' : \langle \Sigma, V, P, S\rangle$ in CNF, we can construct a recognizer $R: \mathcal{G}' \rightarrow \Sigma^n \rightarrow \mathbb{B}$ for strings $\sigma: \Sigma^n$ as follows. Let $2^V$ be our domain, $0$ be $\varnothing$, $\oplus$ be $\cup$, and $\otimes$ be defined as:\vspace{-10pt}

  \begin{align}
    X \otimes Z := \big\{\;w \mid \langle x, z\rangle \in X \times Z, (w\rightarrow xz) \in P\;\big\}
  \end{align}

  \noindent If we define $\sigma_r^{\shur} \coloneqq \{w \mid (w \rightarrow \sigma_r) \in P\}$, then initialize $M^0_{r+1=c}(\mathcal{G}', e) := \;\sigma_r^{\shur}$ and solve for the fixpoint $M^* = M + M^2$,\vspace{-10pt}

  \begin{align*}
      M^0:=\begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
               \varnothing & \sigma_1^\shri & \varnothing & \Cdots & \varnothing \\
               \Vdots      & \Ddots         & \Ddots      & \Ddots & \Vdots\\
                           &                &             &        & \varnothing\\
                           &                &             &        & \sigma_n^\shup \\
               \varnothing & \Cdots         &             &        & \varnothing
      \end{pNiceMatrix} &\Rightarrow M^* =
      \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
        \varnothing & \sigma_1^\shri & \Lambda & \Cdots & \Lambda^*_\sigma\\
        \Vdots      & \Ddots         & \Ddots  & \Ddots & \Vdots\\
                    &                &         &        & \Lambda\\
                    &                &         &        & \sigma_n^\shup \\
        \varnothing & \Cdots         &         &        & \varnothing
      \end{pNiceMatrix}
  \end{align*}

  \noindent we obtain the recognizer, $R(\mathcal{G}', \sigma) := S \in \Lambda^*_\sigma? \Leftrightarrow \sigma \in \mathcal{L}(\mathcal{G})?$

  \noindent Full details of the bisimilarity between parsing and matrix multiplication can be found in Valiant~\cite{valiant1975general} and Lee~\cite{lee2002fast}, who shows its time complexity to be $\mathcal{O}(n^\omega)$ where $\omega$ is the least matrix multiplication upper bound (currently, $\omega < 2.77$).

  \pagebreak\section{Method}\label{sec:method}

  We define the porous completion problem as follows:

  \begin{definition}[Completion]
    Let $\underline\Sigma \coloneqq \Sigma \cup \{\_\}$, where $\_$ represents a hole. We denote $\sqsubseteq: \Sigma^n \times \underline\Sigma^n$ as the relation $\{\langle\sigma', \sigma\rangle \mid \sigma_i: \Sigma \implies \sigma_i' = \sigma_i\}$ and the set $\{\sigma': \Sigma^+ \mid \sigma' \sqsubseteq \sigma\}$ as $\text{H}(\sigma)$. Given $\sigma: \underline\Sigma^+$ we want to sample $\sigma' \sim \text{H}(\sigma)\cap\ell$.
  \end{definition}

  $\text{H}(\sigma)\cap\ell$ is often a large-cardinality set, so we want a procedure which samples uniformly without replacement from the set, without enumerating the whole set and shuffling it.

   We define an algebraic data type $\mathbb{T}_3 = (V \cup \Sigma) \rightharpoonup \mathbb{T}_2$ where $\mathbb{T}_2 = (V \cup \Sigma) \times (\mathbb{N} \rightharpoonup \mathbb{T}_2\times\mathbb{T}_2)$\footnote{Hereinafter, given a concrete $T:\mathbb{T}_2$, we shall refer to $\pi_1(T), \pi_2(T)$ as $\texttt{root}(T)$ and $\texttt{children}(T)$ respectively.}. Morally, we can think of $\mathbb{T}_2$ as an implicit set of possible trees sharing the same root, and $\mathbb{T}_3$ as a dictionary of possible $\mathbb{T}_2$ values indexed by possible roots, given by a specific CFG under a finite-length porous string. We construct $\hat\sigma_r = \dot{p}(\sigma_r)$ as follows:

\begin{equation*}
\dot{p}(s: \Sigma) \mapsto \Big\{\mathbb{T}_2\big(w, \big[\langle\mathbb{T}_2(s), \mathbb{T}_2(\varepsilon)\rangle\big]\big) \mid (w \rightarrow s)\in P\Big\}
\end{equation*}

\begin{equation*}
\dot{p}(\_) \mapsto \bigoplus_{s\in \Sigma} p(s)
\end{equation*}

\noindent We then compute the fixpoint $M_\infty$ by redefining $\oplus, \otimes: \mathbb{T}_3 \times \mathbb{T}_3 \rightarrow \mathbb{T}_3$ as follows:

  \begin{footnotesize}
\begin{equation*}
  X \oplus Z \mapsto \bigcup_{k\in \pi_1(X \cup Z)}\big\{k \Rightarrow \mathbb{T}_2(k, Q_x \cup Q_z) \mid Q_x \in \pi_2(X\circ k), Q_z \in \pi_2(Z\circ k)\big\}
\end{equation*}

\begin{equation*}
  X \otimes Z \mapsto \bigoplus_{w, x, z}\Big\{\mathbb{T}_2\big(w, \big[\langle X\circ x, Z\circ z\rangle\big]\big) \mid (w\rightarrow xz) \in P, x \in \pi_1(X), z \in \pi_1(Z)\Big\}
\end{equation*}
\end{footnotesize}

Decoding trees from $(\Lambda_\sigma^* \circ S): \mathbb{T}_2$ becomes a straightforward matter of enumeration using a recursive choice function that emits a sequence of binary trees generated by the CFG. We define this construction more precisely in \S~\ref{sec:pairing}.

%\begin{equation*}
%  \mathcal{C}(T: \mathbb{T}_2) \mapsto \begin{cases}
%    \texttt{root}(T) & \text{if $T$ is a leaf,} \\
%    \big\{x z \mid \langle X, Z\rangle \in \texttt{children}(T), x \in \mathcal{C}(X), z \in \mathcal{C}(Z)\big\} & \text{otherwise.}%\text{if $d \leq \max(|\err{\sigma}|, \min_{\sigma \in \mathcal{L}(G')}|\sigma|)$}.
%  \end{cases}
%\end{equation*}

In our experiments, we provide a comparison of the performance of the SAT algebra and these two semirings, evaluated on a dataset of Python statements.

\pagebreak\subsection{Pairing Breadth-Bounded Binary Trees}\label{sec:pairing}

The type $\mathbb{T}_2$ of all possible trees that can be generated by a CFG in Chomksy Normal Form is identified by a recurrence relation:

\begin{equation*}
  L(p) = 1 + p L(p) \phantom{addspace} P(a) = 1 + a L(P(a)^2)
\end{equation*}

  We depict it as a tree, where red nodes are \texttt{root}s and blue nodes are \texttt{children}:

\resizebox{0.9\columnwidth}{!}{
  \begin{tikzpicture}
  [
    grow                    = right,
    sibling distance        = 3em,
    level distance          = 5em,
    edge from parent/.style = {draw, -latex},
    every node/.style       = {font=\footnotesize},
    sloped
  ]
  \node [root] {S}
    child { node [env] {BC}
  child { node [root] {B}
  child { node [env] {RD}
    child { node [root] {R} edge from parent node [above] }
    child { node [root] {D} edge from parent node [above] }
  edge from parent node [above] }
  edge from parent node [below] }
  child { node [root] {C}
  child { node [env] {\ldots\vphantom{BB}} edge from parent node [below] }
%  child { edge from parent node [above] {\ldots} }
  edge from parent node [below] }
  edge from parent node [above] }
  child { node [env] {\ldots\vphantom{BB}} edge from parent node [below] }
    child { node [env] {AB}
    child { node [root] {A}
    child {
      node [env] {QC}
      child { node [root] {Q} edge from parent node [above] }
      child { node [root] {C} edge from parent node [above] }
      edge from parent node [above]
    }
%    child { node [env] {ZQ} edge from parent node [above] }
    child { node [env] {\ldots\vphantom{BB}} edge from parent node [below] }
    edge from parent node [below] }
    child { node [root] {B}
  child { node [env] {RD}
  child { node [root] {R} edge from parent node [above] }
  child { node [root] {D} edge from parent node [above] }
  edge from parent node [above] }
  edge from parent node [below] }
    edge from parent node [above] };
  \end{tikzpicture}
}

The number of binary trees inhabiting a single instance of $\mathbb{T}_2$ is sensititive to the number of nonterminals and rule expansions in the grammar. To obtain the total number of trees with breadth $n$, we can take the intersection between a CFG and the regular language, $\mathcal{L}(G^\cap) \coloneqq \mathcal{L}(\mathcal{G}) \cap \Sigma^n$, abstractly parse the string containing all holes, let $T=\Lambda_{\underline\sigma}^* \circ S$, and compute the total number of trees using the following recurrence:

\begin{equation*}
  |T: \mathbb{T}_2| \mapsto \begin{cases}
%    \big|\{s \mid \big(\texttt{root}(T) \rightarrow s\big) \in P^\cap\}\big| & \text{if $T$ is a leaf,} \\
    1  & \text{if $T$ is a leaf,} \\
    \sum_{\langle T_1, T_2\rangle \in \texttt{children}(T)} |T_1| \cdot |T_2| & \text{otherwise.}
  \end{cases}
\end{equation*}

To sample all trees in a given $T: \mathbb{T}_2$ uniformly without replacement, we first define a pairing function $\varphi: \mathbb{T}_2 \rightarrow \mathbb{Z}_{|T|} \rightarrow \texttt{BTree}$ as follows:

\begin{small}
\begin{equation*}
  \varphi(T: \mathbb{T}_2, i: \mathbb{Z}_{|T|}) \mapsto \begin{cases}
  \Big\langle\texttt{BTree}\big(\texttt{root}(T)\big), i\Big\rangle & \text{if $T$ is a leaf,} \vspace{5pt}\\
  \text{Let } b = |\texttt{children}(T)|,\\
  \phantom{\text{Let }} q_1, r=\big\langle\lfloor\frac{i}{b}\rfloor, i \pmod{b}\big\rangle,\\
  \phantom{\text{Let }} lb, rb = \texttt{children}[r],\\
  \phantom{\text{Let }} T_1, q_2 = \varphi(lb, q_1),\\
  \phantom{\text{Let }} T_2, q_3 = \varphi(rb, q_2) \text{ in } \\
  \Big\langle\texttt{BTree}\big(\texttt{root}(T), T_1, T_2\big), q_3\Big\rangle & \text{otherwise.} \\
  \end{cases}
\end{equation*}
\end{small}

Then, instead of sampling trees, we can simply sample integers uniformly without replacement from $\mathbb{Z}_{|T|}$ using the construction defined in \S~\ref{sec:method}, and lazily decode them into trees.

  \section{Prior Work}

  Piantodosi define a similar construction, but it assumes the CFL is infinite and makes some additional assumptions about the CFG~\cite{piantadosi2023enumerate}. We provide a more general construction which works for any CFG. Sampling parse trees in CFGs can be viewed as sampling proofs in a limited kind of proof system~\cite{opedal2023efficient}.

  \section{Conclusion}

  We have presented a novel algorithm for sampling trees in bounded context-free languages with and without replacement. This technique has applications to code completion and program repair.
  \bibliography{../bib/acmart}
\end{document}