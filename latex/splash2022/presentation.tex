\documentclass{beamer}
\usetheme{Madrid}
\beamertemplatenavigationsymbolsempty

\input{preamble.tex}

\usepackage{pgf-soroban}
\usetikzlibrary{shapes.geometric,calc,decorations.text,bayesnet,arrows,backgrounds}
\usepackage{circledsteps}
\usepackage{epigraph}
\usepackage{array}
\setmonofont{JetBrains Mono}[
    Contextuals = Alternate,
    Ligatures = TeX,
]
\lstset{
    basicstyle = \ttfamily,
    columns = flexible,
}
%\makeatletter
%\renewcommand*\verbatim@nolig@list{}
%\makeatother
\usepackage{pmboxdraw}
\usetikzlibrary{cd}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\setbeamertemplate{footline}
{
    \leavevmode%
    \hbox{%
        \begin{beamercolorbox}[wd=.25\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
            \usebeamerfont{author in head/foot}\insertshortauthor{}{~~(\insertshortinstitute)}
        \end{beamercolorbox}%
        \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
            \usebeamerfont{title in head/foot}\insertshorttitle
        \end{beamercolorbox}%
        \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
            \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
            \insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
        \end{beamercolorbox}}%
    \vskip0pt%
}
\makeatother

\title[Tidyparse: Real-Time Context-free Error Correction]{Tidyparse: Real-Time Context-free Error Correction}
\titlegraphic{\includegraphics[width=0.2\textwidth]{../figures/tidyparse_logo.png}}
\author[Considine, Guo, Si]{\textbf{Breandan Considine}, Jin Guo, Xujie Si}
\institute[McGill]{
    McGill University, Mila IQIA\\
    \medskip
    \textit{bre@ndan.co}
}
\date{\today}

\begin{document}
    \begin{frame}
        \titlepage
    \end{frame}

    \begin{frame}{Overview}
        \tableofcontents
    \end{frame}

    
    \section{Algebraic Parsing}\label{sec:algebraic-parsing}

    %------------------------------------------------------------------------------------------------

    \begin{frame}[fragile]{Background: Regular grammars}
        A regular grammar is a 4-tuple $\mathcal{G} = \langle V, \Sigma, P, S\rangle$ where $V$ is the set of nonterminals, $\Sigma$ are the terminals, $P: V\times (V \cup \Sigma)^{\leq 2}$ are the productions, and $S\in V$ is the start symbol, i.e., all productions are of the form $A \rightarrow a$, $A \rightarrow a B$ (right-regular), or $A \rightarrow B a$ (left-regular). Regular langauges are closed under union, complementation, concatenation, and Kleene star.

        % https://www3.nd.edu/~kogge/courses/cse30151-fa17/Public/other/tikz_tutorial.pdf
        % Glushkov's algorithm: https://www.irif.fr/~jep/PDF/MPRI/MPRI.pdf#subsection.3.5.2
        \begin{figure}
            \hspace{-1cm}\begin{minipage}[t]{0.25\linewidth}
                \vspace{-2.3cm}\scalebox{0.6}{
            \begin{aligned}[t]
                S &\rightarrow Q_0 \mid Q_2 \mid Q_3 \mid Q_5\\
                Q_0 &\rightarrow \varepsilon \\
                Q_1 &\rightarrow Q_0 b \mid Q_2 b\\
                Q_2 &\rightarrow Q_1 a \\
                Q_3 &\rightarrow Q_0 a \mid Q_3 a \mid Q_5 a \\
                Q_4 &\rightarrow Q_3 a \mid Q_5 a \\
                Q_5 &\rightarrow Q_4 b \\
            \end{aligned}}
                \end{minipage}
            \hspace{0.5cm}\begin{minipage}[t]{0.48\linewidth}
            \scalebox{0.5}{
            \begin{tikzpicture}[->, >=stealth,]
                \node[state, initial above, accepting] (Q0) {$Q_0$};
                \node[state, left of=Q0] (Q1) {$Q_1$};
                \node[state, accepting, left of=Q1] (Q2) {$Q_2$};
                \node[state, accepting, right of=Q0] (Q3) {$Q_3$};
                \node[state, above right of=Q3] (Q4) {$Q_4$};
                \node[state, accepting, below right of=Q3] (Q5) {$Q_5$};
                \draw
        %        (Q0) edge[loop above] (Q0)
                (Q0) edge node{\ttinline b} (Q1)
                (Q0) edge node{\ttinline a} (Q3)
                (Q1) edge[bend right] node{\ttinline a} (Q2)
                (Q2) edge[bend right] node{\ttinline b} (Q1)
                (Q3) edge[loop above] node{\ttinline a} (Q3)
                (Q3) edge node{\ttinline a} (Q4)
                (Q5) edge node{\ttinline a} (Q3)
                (Q4) edge[bend left] node{\ttinline b} (Q5)
                (Q5) edge[bend left] node{\ttinline a} (Q4)
            \end{tikzpicture}
            }
            \end{minipage}
            \caption{RG and NFA corresponding to the language defined by \tinline{(a(ab)*)*(ba)*}.}
            \label{fig:regex_to_nfa}
        \end{figure}

        \begin{center}
            \scalebox{0.8}{
            \begin{tikzpicture}[font=\sffamily,breathe dist/.initial=4ex]
                \foreach \X [count=\Y,remember=\Y as \LastY] in
                    {finite,regular}
                    {\ifnum\Y=1
                \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
                \else
                \path[decoration={text along path,
                text={|\sffamily|\X},text align=center,raise=0.9ex},decorate]
                let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
                in (F-\LastY.west) arc(180:0:\x1 and \y1);
                \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
                -(F-\LastY.south)$),
                \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
                in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
                node[minimum height=\y1,minimum width={\y1*\x2/\y3},
                draw,ellipse,inner sep=0pt, fill=black!30!white] (F-\Y){};
                \fi
                }
                \foreach \X [count=\Y,remember=\Y as \LastY] in
                    {finite,regular,context-free}
                    {\ifnum\Y=1
                \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
                \else
                \path[decoration={text along path,
                text={|\sffamily|\X},text align=center,raise=0.9ex},decorate]
                let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
                in (F-\LastY.west) arc(180:0:\x1 and \y1);
                \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
                -(F-\LastY.south)$),
                \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
                in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
                node[minimum height=\y1,minimum width={\y1*\x2/\y3},
                draw,ellipse,inner sep=0pt] (F-\Y){};
                \fi}
            \end{tikzpicture}
            }
        \end{center}
    \end{frame}

    \begin{frame}{Background: Context-free grammars}
        In a context-free grammar $\mathcal{G} = \langle V, \Sigma, P, S\rangle$ all productions are of the form $P: V\times (V \cup \Sigma)^+$, i.e., RHS may contain any number of nonterminals, $V$. Recognition decidable in $n^\omega$, n.b. CFLs are \textbf{not} closed under intersection!\newline\\
        %
        For example, consider the grammar $\underline{S \rightarrow S S \mid ( S ) \mid ()}$. This represents the language of balanced parentheses, e.g. $(), ()(), (()), ()(()), (()()), (())()\ldots$\newline\\
        %
        Every CFG has a normal form $P^*: V \times (V^2 \mid \Sigma)$, i.e., every production can be refactored into either $v_0 \rightarrow v_1 v_2$ or $v_0 \rightarrow \sigma$, where $v_{0\ldots2}: V$ and $\sigma: \Sigma$, e.g., $\{S \rightarrow S S \mid ( S ) \mid ()\}\Leftrightarrow^*\{S\rightarrow XR \mid SS \mid LR, L \rightarrow (, R \rightarrow ), X\rightarrow LS\}$

        \begin{center}
            \scalebox{0.8}{
            \begin{tikzpicture}[font=\sffamily,breathe dist/.initial=4ex]
                \foreach \X [count=\Y,remember=\Y as \LastY] in
                    {finite,regular,context-free}
                    {\ifnum\Y=1
                \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
                \else
                \path[decoration={text along path,
                text={|\sffamily|\X},text align=center,raise=0.9ex},decorate]
                let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
                in (F-\LastY.west) arc(180:0:\x1 and \y1);
                \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
                -(F-\LastY.south)$),
                \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
                in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
                node[minimum height=\y1,minimum width={\y1*\x2/\y3},
                draw,ellipse,inner sep=0pt, fill=black!30!white] (F-\Y){};
                \fi
                }
                \foreach \X [count=\Y,remember=\Y as \LastY] in
                    {finite,regular,context-free,conjunctive}
                    {\ifnum\Y=1
                \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
                \else
                \path[decoration={text along path,
                text={|\sffamily|\X},text align=center,raise=0.9ex},decorate]
                let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
                in (F-\LastY.west) arc(180:0:\x1 and \y1);
                \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
                -(F-\LastY.south)$),
                \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
                in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
                node[minimum height=\y1,minimum width={\y1*\x2/\y3},
                draw,ellipse,inner sep=0pt] (F-\Y){};
                \fi}
            \end{tikzpicture}
            }
        \end{center}
    \end{frame}

    \begin{frame}{Background: Conjunctive grammars}
        Conjunctive grammars naturally extend CFGs with CFL union and intersection, respecting closure under those operations. Equivalent to trellis automata, which are like contractive elementary cellular automata. Language inclusion is decidable in P.\\

        \begin{prooftree}
            \AxiomC{$\Gamma \vdash \mathcal{G}_1, \mathcal{G}_2 : \texttt{CG}$}
            \RightLabel{$\cap$}
            \UnaryInfC{$\Gamma \vdash \exists \:\mathcal{G}_3: \texttt{CG}\:.\:\mathcal{L}_{\mathcal{G}_1} \cap \mathcal{L}_{\mathcal{G}_1} \leftrightarrow \mathcal{G}_3$}
        \end{prooftree}

        \begin{center}
            \scalebox{0.8}{
            \begin{tikzpicture}[font=\sffamily,breathe dist/.initial=4ex]
                \foreach \X [count=\Y,remember=\Y as \LastY] in
                    {finite,regular,context-free,conjunctive}
                    {\ifnum\Y=1
                \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
                \else
                \path[decoration={text along path,
                text={|\sffamily|\X},text align=center,raise=0.9ex},decorate]
                let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
                in (F-\LastY.west) arc(180:0:\x1 and \y1);
                \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
                -(F-\LastY.south)$),
                \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
                in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
                node[minimum height=\y1,minimum width={\y1*\x2/\y3},
                draw,ellipse,inner sep=0pt, fill=black!30!white] (F-\Y){};
                \fi
                }
                \foreach \X [count=\Y,remember=\Y as \LastY] in
                    {finite,regular,context-free,conjunctive,context sensitive}
                    {\ifnum\Y=1
                \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
                \else
                \path[decoration={text along path,
                text={|\sffamily|\X},text align=center,raise=0.9ex},decorate]
                let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
                in (F-\LastY.west) arc(180:0:\x1 and \y1);
                \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
                -(F-\LastY.south)$),
                \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
                in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
                node[minimum height=\y1,minimum width={\y1*\x2/\y3},
                draw,ellipse,inner sep=0pt] (F-\Y){};
                \fi}
            \end{tikzpicture}
            }
        \end{center}
    \end{frame}


    \begin{frame}[fragile]{Background: Closure properties of formal languages}
        Formal languages are not closed, e.g., CFL $\cap$ CFL is not CFL in general. Let $\cdot$ denote concatenation, $\star$ be Kleene star, and $\complement$ be complementation:\\
        \begin{table}
            \begin{tabular}{c|ccccc}
                & $\cup$ & $\cap$ & $\cdot$ & $\star$ & $\complement$ \\
                \hline
                Finite & \cmark & \cmark & \cmark & \cmark & \cmark \\
                Regular & \cmark & \cmark & \cmark & \cmark & \cmark \\
                Context-free & \cmark & \xmark & \cmark & \cmark & \xmark \\
                Conjunctive & \cmark & \cmark & \cmark & \cmark & ? \\
                Context-sensitive & \cmark & \cmark & \cmark & + & \cmark \\
                Recursively Enumerable & \cmark & \cmark & \cmark & \cmark & \xmark \\
            \end{tabular}
        \end{table}
    \end{frame}


    \begin{frame}[fragile]{Context-free parsing, distilled}
        Given a CFG $\mathcal{G} \coloneqq \langle V, \Sigma, P, S\rangle$ in Chomsky Normal Form, we can construct a recognizer $R_\mathcal{G}: \Sigma^n \rightarrow \mathbb{B}$ for strings $\sigma: \Sigma^n$ as follows. Let $2^V$ be our domain, $0$ be $\varnothing$, $\oplus$ be $\cup$, and $\otimes$ be defined as follows:

        \vspace{-7pt}
        \[
            s_1 \otimes s_2 \coloneqq \{C \mid \langle A, B\rangle \in s_1 \times s_2, (C\rightarrow AB) \in P\}\\
            \text{e.g.},
                \{A \rightarrow BC, C \rightarrow AD, D \rightarrow BA\} \subseteq P \vdash \{A, B, C\} \otimes \{B, C, D\} = \{A, C\}
        \]
        \vspace{-20pt}

         \noindent If we define $\sigma_r^{\shur} \coloneqq \{w \mid (w \rightarrow \sigma_r) \in P\}$, then initialize $M^0_{r+1=c}(\mathcal{G}', e) := \;\sigma_r^{\shur}$ and solve for the fixpoint $M^* = M + M^2$,\vspace{-10pt}

        \begin{align*}
          M^0:=\begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
            \varnothing & \sigma_1^\shri & \varnothing & \Cdots & \varnothing \\
            \Vdots      & \Ddots         & \Ddots      & \Ddots & \Vdots\\
                        &                &             &        & \varnothing\\
                        &                &             &        & \sigma_n^\shup \\
            \varnothing & \Cdots         &             &        & \varnothing
          \end{pNiceMatrix} &\Rightarrow M^* =
          \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
            \varnothing & \sigma_1^\shri & \Lambda & \Cdots & \Lambda^*_\sigma\\
            \Vdots      & \Ddots         & \Ddots  & \Ddots & \Vdots\\
                        &                &         &        & \Lambda\\
                        &                &         &        & \sigma_n^\shup \\
            \varnothing & \Cdots         &         &        & \varnothing
          \end{pNiceMatrix}
        \end{align*}

        \noindent Valiant (1975) shows that $\sigma \in \mathcal{L}(\mathcal{G})$ iff $S \in \mathcal{T}$, i.e., $\mathds{1}_{\mathcal{T}}(S) \iff \mathds{1}_{\mathcal{L}(\mathcal{G})}(\sigma)$.
    \end{frame}

    \begin{frame}[fragile]{Lattices, Matrices and Trellises}
      The art of treillage has been practiced from ancient through modern times.
      \begin{center}
        \begin{tabular}{ c c c c c }
          \includegraphics[width=0.17\textwidth]{../figures/trellis.png} & & \includegraphics[width=0.12\textwidth]{../figures/grid_topiary.jpeg} & & \includegraphics[width=0.23\textwidth]{../figures/tree_pyramid.jpeg} \\\\
          \includegraphics[width=0.17\textwidth]{../figures/jiaxian_triangle.png} & &
          \rotatebox{37}{\scalebox{0.9}{$\begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted,delimiters-color=gray]
            \sigma_1^\shri & \Lambda & \Cdots & \Lambda^*_\sigma\\
                           & \Ddots  & \Ddots & \Vdots\\
                           &         &        & \Lambda\\
                           &         &        & \sigma_n^\shup \\
          \end{pNiceMatrix}$}} & & \scalebox{0.23}{\mkTrellis{9}}\\
          Jia Xian Triangle && CYK Parsing && Trellis Automaton\\
          Jia, $\sim$1030 A.D. && Sakai, 1961 A.D. && Dyer, 1980 A.D.\\
        \end{tabular}
      \end{center}
    \end{frame}

    \begin{frame}{A few observations on algebraic parsing}
        \begin{itemize}
            \item The matrix $\mathbf M^*$ is strictly upper triangular, i.e., nilpotent of degree $n$
            \item Recognizer can be translated into a parser by storing backpointers\\\\
        \end{itemize}\vspace{0.2cm}
        \begin{tabular}{ c c c }
            \small{$\mathbf{M}_1 = \mathbf{M}_0 + \mathbf{M}_0^2$} & \small{$\mathbf{M}_2 = \mathbf{M}_1 + \mathbf{M}_1^2$} & \small{$\mathbf{M}_3 = \mathbf{M}_2 + \mathbf{M}_2^2 = \mathbf{M}_4$} \\
            \includegraphics[trim=420 288 0 0,clip, width=3.6cm]{../figures/parse2.png} &
            \includegraphics[trim=420 285 0 0,clip, width=3.6cm]{../figures/parse3.png} &
            \includegraphics[trim=420 287 0 0,clip, width=3.63cm]{../figures/parse4.png}
        \end{tabular}
        \begin{itemize}
            \item The $\otimes$ operator is \textit{not} associative: $S \otimes (S \otimes S) \neq (S \otimes S) \otimes S$
            \item Built-in error recovery: nonempty submatrices = parsable fragments
            \item \texttt{seekFixpoint \{ it + it * it \}} is sufficient but unnecessary
            \item If we had a way to solve for $\mathbf{M = M + M}^2$ directly, power iteration would be unnecessary, could solve for $\mathbf{M = M}^2$ above superdiagonal
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Satisfiability + holes (our contribution)}
        \begin{itemize}
            \item Can be lowered onto a Boolean tensor $\mathbb{B}_2^{n\times n \times |V|}$ (Valiant, 1975)
            \item Binarized CYK parser can be efficiently compiled to a SAT solver
            \item Enables sketch-based synthesis in either $\sigma$ or $\mathcal G$: just use variables!
            \item We simply encode the characteristic function, i.e. $\mathds{1}_{\subseteq V}: V\rightarrow \mathbb{Z}_2^{|V|}$
            \item $\oplus, \otimes$ are defined as $\boxplus, \boxtimes$, so that the following diagram commutes:
            \[\begin{tikzcd}
                  2^V \times 2^V \arrow[r, "\oplus/\otimes"] \arrow[d, "\mathds{1}^2"]
                  & 2^V \arrow[d, "\mathds{1}\phantom{^{-1}}"] \\
                  \mathbb{Z}_2^{|V|} \times \mathbb{Z}_2^{|V|} \arrow[r, "\boxplus/\boxtimes", labels=below] \arrow[u, "\mathds{1}^{-2}"]
                  & \mathbb{Z}_2^{|V|} \arrow[u, "\mathds{1}^{-1}"]
            \end{tikzcd}\]
            \item These operators can be lifted into matrices/tensors in the usual way
            \item In most cases, only a few nonterminals are active at any given time
            \item More sophisticated representations are known for $\binom{n}{0 \leq k}$ subsets
            \item If density is desired, possible to use the Maculay representation
%            \item Set joins are an active topic of research in SQL query optimization
            \item If you know of a more efficient encoding, please let us know!
        \end{itemize}
    \end{frame}

    \begin{frame}{Incremental parsing}
        Should only need to recompute submatrices affected by individual edits. In the worst case, each edit requires quadratic complexity in terms of $|\Sigma^*|$.
        \begin{center}
            \begin{tabular}{ c c c c c }
                \scalebox{0.32}{\mkTrellisAppend{7}} && \scalebox{0.32}{\mkTrellisInsert{6}} && \scalebox{0.32}{\mkTrellisInsert{7}}  \\
                Append && Delete && Insert \\
                $\mathcal{O}(n)$&&$\mathcal{O}\left(\frac{1}{4}(n-1)^2\right)$ && $\mathcal{O}\left(\frac{1}{4}(n+1)^2\right)$\\
            \end{tabular}
        \end{center}
        Related to \textbf{dynamic matrix inverse} and \textbf{incremental transitive closure} with vertex updates. With a careful encoding, we can incrementally update SAT constraints as new keystrokes are received to eliminate redundancy.
    \end{frame}

    \begin{frame}[fragile]{Conjunctive parsing}
        It is well-known that the family of CFLs is not closed under intersection. For example, consider $\mathcal{L}_\cap := \mathcal{L}(\mathcal{G}_1) \cap \mathcal{L}(\mathcal{G}_2)$:

        \begin{table}[H]
            \begin{tabular}{llll}
                $P_1 := \big\{\;S \rightarrow L R,$ & $L \rightarrow a b \mid a L b,$ & $R \rightarrow c \mid c R\;\big\}$\vspace{5pt}\\
                $P_2 := \big\{\;S \rightarrow L R,$ & $R \rightarrow b c \mid b R c,$ & $L \rightarrow a \mid a L\;\big\}$
            \end{tabular}
        \end{table}

        \noindent Note that $\mathcal{L}_\cap$ generates the language $\big\{\;a^d b^d c^d \mid d > 0\;\big\}$, which according to the pumping lemma is not context-free. To encode $\mathcal{L}_\cap$, we intersect all terminals $\Sigma_\cap := \bigcap_{i=1}^c \Sigma_i$, then for each $t_\cap \in \Sigma_\cap$ and CFG, construct an equivalence class $E(t_\cap, \mathcal{G}_i) = \{ w_i \mid (w_i \rightarrow t_\cap) \in P_i\}$ as follows:\vspace{-5pt}

        \begin{align}
            \bigwedge_{t\in\Sigma_\cap}\bigwedge_{j = 1}^{c-1}\bigwedge_{i=1}^{|\sigma|} E(t_{\cap}, \mathcal{G}_j) \equiv_{\sigma_i} E(t_{\cap}, \mathcal{G}_{j+1})
        \end{align}
        % Generated by cfl4_intersection.vox, open with https://voxelator.com/
        \begin{figure}[H]
            \includegraphics[height=0.093\textwidth]{../figures/angle1.png}\hspace{-5pt}
            \includegraphics[height=0.093\textwidth]{../figures/angle2.png}\hspace{-5pt}
            \includegraphics[height=0.093\textwidth]{../figures/angle5.png}\hspace{-5pt}
            \includegraphics[height=0.093\textwidth]{../figures/angle3.png}\hspace{-3pt}
            \includegraphics[height=0.093\textwidth]{../figures/angle4.png}
        \end{figure}
    \end{frame}

    \begin{frame}[fragile]{A birds eye view of the algorithm}
    We can lower Valiant's algorithm onto a polynomial system of equations over finite fields, allowing us to solve for holes and parse trees.
    \begin{figure}[H]
      \adjustbox{scale=0.75,center}{%
        \[\begin{tikzcd}[row sep=large, column sep=huge]
          \langle\mathcal{G}', \highlight{\Sigma}^{n-1}\rangle \arrow[leftrightarrow, drrr, shorten=-1mm] & & [-135pt] & \vspace{20pt}\text{Set} \arrow[d, phantom] & \text{Bit} \arrow[d, phantom] & [-90pt] & \langle\mathcal{G}', \Sigma^{n-1}\rangle \arrow[drr, shorten=-2mm] & [-90pt] & \text{SAT} \arrow[d, phantom]\\[-30pt]
          \text{Rubix}  \arrow[rr, phantom] & & [-135pt] & M \times M \arrow[r, "\mathds{1}^{2^{n\times n}}", labels=above] \arrow[d, "\hspace{-13.9pt}\bigoplus\:\bigotimes"] & \mathbb{Z}_2^{|V|^{n\times n}} \times \mathbb{Z}_2^{|V|^{n\times n}} \arrow[d, "\hspace{-16.3pt}\highlight{+}\:\highlight{*}"] \arrow[l, "\mathds{1}^{-2^{n\times n}}", labels=below] \arrow[rrrr, rightarrowtail, "\varphi^{2^{n\times n}}", labels=above] & [-90pt] & & [-90pt] & \mathcal{M} \times \mathcal{M} \arrow[llll, rightharpoonup, shorten=1mm, "\varphi^{-2^{n\times n}}", labels=below] \arrow[d, "\hspace{-12pt}+\:\:\:*"] \\
          \text{Matrix} \arrow[rr, phantom] & & [-135pt] & 2^V \times 2^V \arrow[r, "\mathds{1}^{2}", labels=above] \arrow[d, "\hspace{-10pt}\oplus\:\otimes"] & \mathbb{Z}_2^{|V|} \times \mathbb{Z}_2^{|V|} \arrow[d, "\hspace{-15.8pt}\highlight{\boxplus}\:\highlight{\boxtimes}"] \arrow[l, "\mathds{1}^{-2}", labels=below] \arrow[rrrr, rightarrowtail, "\varphi^2", labels=above] & [-90pt] & & [-90pt] & \mathcal{V} \times \mathcal{V} \arrow[llll, rightharpoonup, shorten=1mm, "\varphi^{-2}", labels=below] \arrow[d, "\hspace{-9.7pt}\boxplus\:\boxtimes"] \arrow[u] \\
          \text{Vector} \arrow[rr, phantom] & & [-135pt] & 2^V \arrow[r, "\mathds{1}", labels=above] & \mathbb{Z}_2^{|V|} \arrow[l, "\mathds{1}^{-1}", labels=below] \arrow[rrrr, rightarrowtail, "\varphi", labels=above] & [-90pt] & & [-90pt] & \mathcal{V} \arrow[llll, rightharpoonup, shorten=1mm, "\varphi^{-1}", labels=below] \arrow[u]
        \end{tikzcd}\]
      }
    \end{figure}
        So far, we only consider Cartesian closed categories, however, we can also consider other categories, such as the category of CFLs under conjunction, which allows us to encode the intersection of two CFGs.
    \end{frame}

    \begin{frame}[fragile]{Kotlin implementation: CFG definition}
        \begin{lstlisting}[language=Kotlin, gobble=8, basicstyle=\scriptsize\ttfamily]
        typealias Production = Pair<String, List<String>>
        typealias CFG = Set<Production>
        val Production.LHS: String get() = first
        val Production.RHS: List<String> get() = second
        val CFG.nonterminals: Set<String> by cache { map { it.LHS }.toSet() }
        val CFG.words: Set<String> by cache { nonterminals + flatMap { it.RHS } }
        val CFG.terminals: Set<String> by cache { words - nonterminals }
        // Many-to-many mapping of nonterminals to RHS expansions
        val CFG.bimap: BidirectionalMap by cache { BidirectionalMap(this) }

        fun CFG.makeAlgebra(): Ring<Set<String>> =
          Ring.of(
            // 0 = @\color{gray}\texttt{∅}@
            nil = setOf(),
            // x + y = x @\color{gray}\texttt{∪}@ y
            plus = { x, y -> x union y },
            // x · y = { A0 | A1 @\color{gray}\texttt{∈}@ x, A2 @\color{gray}\texttt{∈}@ y, (A0 -> A1 A2) @\color{gray}\texttt{∈}@ P }
            times = { x, y -> join(x, y) }
          )

        fun CFG.join(ls: Set<String>, rs: Set<String>): Set<String> =
          (ls * rs).flatMap { (l, r) -> bimap[listOf(l, r)] }.toSet()
        \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]{Kotlin implementation: the recognizer}
        \begin{lstlisting}[language=Kotlin, gobble=8, basicstyle=\scriptsize\ttfamily]
        // Constructs initial matrix according to: M@\color{gray}\textsubscript{i+1=j}@ = { A | (A -> @\color{gray}\texttt{σ}\textsubscript{i}@) @\color{gray}\texttt{∈}@ P }
        fun CFG.initialMatrix(str: List<String>): Matrix<Set<String>> =
          Matrix(makeAlgebra(), str.size + 1) { i, j ->
            // Aligns nonterminals matching each terminal along superdiagonal
            if (i + 1 != j) emptySet() else bimap[listOf(str[j - 1])].toSet()
          }

        // Computes the fixpoint of an abstract matrix function
        tailrec fun <T: Matrix<S>, S> T.seekFixpoint(op: (T) -> T): T {
          val next = op(this)
          return if (this == next) next else next.seekFixpoint(op)
        }

        // Checks whether start symbol is contained in the northeasternmost entry
        fun CFG.check(s: String): Boolean = START in parse(tokenize(s))[0].last()

        // Since matrix is strictly UT, this converges in at most |tokens| steps
        fun CFG.parse(tokens: List<String>): Matrix<Set<String>> =
            initialMatrix(tokens).seekFixpoint { it + it * it }
        \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]{Tidyparse IDE plugin}
        \href{https://github.com/breandan/tidyparse}{\includegraphics[width=\textwidth]{../figures/tidyparse.png}}
    \end{frame}

    \begin{frame}{Abbreviated history of algebraic parsing}
        \begin{itemize}
            \item \href{http://www-igm.univ-mlv.fr/~berstel/Mps/Travaux/A/1963-7ChomskyAlgebraic.pdf}{Chomsky \& Sch\"utzenberger (1959) - The algebraic theory of CFLs}
            \item Cocke–Younger–Kasami (1961) - Bottom-up matrix-based parsing
            \item \href{https://dl.acm.org/doi/10.1145/321239.321249}{Brzozowski (1964) - Derivatives of regular expressions}
            \item \href{https://dl.acm.org/doi/10.1145/362007.362035}{Earley (1968) - top-down dynamic programming (no CNF needed)}
            \item \href{http://theory.stanford.edu/~virgi/cs367/papers/valiantcfg.pdf}{Valiant (1975) - first realizes the Boolean matrix correspondence}
            \begin{itemize}
                \item Na\"ively, has complexity $\mathcal{O}(n^4)$, can be reduced to $\mathcal{O}(n^\omega)$, $\omega < 2.763$
            \end{itemize}
            \item \href{https://www.cs.cornell.edu/home/llee/papers/bmmcfl-jacm.pdf}{Lee (1997) - Fast CFG Parsing $\Longleftrightarrow$ Fast BMM, formalizes reduction}
            \item \href{https://matt.might.net/papers/might2011derivatives.pdf}{Might et al. (2011) - Parsing with derivatives (Brzozowski $\Rightarrow$ CFL)}
            \item \href{https://users.math-cs.spbu.ru/~okhotin/papers/formal_languages_gf2.pdf}{Bakinova, Okhotin et al. (2010) - Formal languages over GF(2)}
            \item \href{https://arxiv.org/pdf/1601.07724.pdf}{Bernady \& Jansson (2015) - Certifies Valiant (1975) in Agda}
            \item \href{https://arxiv.org/pdf/1504.08342.pdf}{Cohen \& Gildea (2016) - Generalizes Valiant (1975) to parse and recognize mildly context sensitive languages, e.g. LCFRS, TAG, CCG}
            \item \textbf{Considine, Guo \& Si (2022) - SAT + Valiant (1975) + holes}
        \end{itemize}
    \end{frame}

    \section{Typelevel Programming}

    \begin{frame}{Abacus arithmetic}
        \begin{itemize}
        \item Computational complexity of arithmetic is notation-dependent(!)
        \item For example, $\pm$ in unary arithmetic is concatenation and decatenation
        \item Multiplication and division by natural powers of the radix is $\mathcal{O}(1)$
        \item We can describe the abacus as a kind of abstract rewriting system
        \end{itemize}
        \ladj{0.25}
        \begin{prooftree}
            \AxiomC{
                \tikz \fill [white] (0,0) rectangle (1,2);
            }
            \UnaryInfC{
                \begin{tikzpicture}
                    \tige{1}{0}{0}
                    \tige{2}{0}{0}
                    \tige{3}{0}{0}
                    \cadre{3}
                \end{tikzpicture}
            }
            \DisplayProof
            \hskip 1em
            \AxiomC{
                \begin{tikzpicture}
                    \tige{1}{0}{0}
                    \barres{1}
                \end{tikzpicture}$_n+10^n$
            }
            \UnaryInfC{
                \begin{tikzpicture}
                    \tige{1}{1}{0}
                    \barres{1}
                \end{tikzpicture}$_n\phantom{n+0^n}$
            }
            \DisplayProof
            \hskip 1em
            \AxiomC{
                \begin{tikzpicture}
                    \tige{1}{4}{0}
                    \barres{1}
                \end{tikzpicture}$_n+10^n$
            }
            \UnaryInfC{
                \begin{tikzpicture}
                    \tige{1}{5}{0}
                    \barres{1}
                \end{tikzpicture}$_n\phantom{n+0^n}$
            }
            \DisplayProof
            \hskip 1em
            \AxiomC{
                \begin{tikzpicture}
                    \tige{1}{0}{0}
                    \barres{1}
                    \tige[2]{1}{9}{0}
                    \barres[2]{1}
                \end{tikzpicture}$_n+10^n$
            }
            \UnaryInfC{
                \begin{tikzpicture}
                \tige{1}{1}{0}
                \barres{1}
                \tige[2]{1}{0}{0}
                \barres[2]{1}
                \end{tikzpicture}$_n\phantom{n+0^n}$
            }
        \end{prooftree}
    \end{frame}

    \begin{frame}[fragile]{Abacus dependent types}
        \begin{lstlisting}[language=Kotlin, gobble=7]
        sealed class B<X, P : B<X, P>>(open val x: X? = null) {
          val T: T<P> get() = T(this as P)
          val F: F<P> get() = F(this as P)
        }

        class U(val i: Int) : B<Any, U>() // Checked at runtime

        object Ø: B<Ø, Ø>(null) // Denotes the end of a bitlist

        class T<X>(override val x: X = Ø as X) : B<X, T<X>>(x)
          { companion object: T<Ø>(Ø) }

        class F<X>(override val x: X = Ø as X) : B<X, F<X>>(x)
          { companion object: F<Ø>(Ø) }

        val b0: F<Ø> = F
        val b1: T<Ø> = T
        val b2: F<T<Ø>> = T.F // Note the raw type is reversed
        val b4: F<F<T<Ø>>> = T.F.F
        \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]{Abacus dependent types}
        \begin{lstlisting}[language=Kotlin, gobble=7]
        typealias B_0<K> = F<K> // Type synonyms for legibility
        typealias B_1<K> = T<K>
        typealias B_2<K> = F<T<K>>
        typealias B_3<K> = T<T<K>>
        typealias B_4<K> = F<F<T<K>>>
        typealias B_7<K> = T<T<T<K>>>
        typealias B_8<K> = F<F<F<T<K>>>>

        // Calculates k + 1 for all k == 2@\color{gray}\textsuperscript{n}@ - 1, 0 <= n < 4
        operator fun Ø.plus(t: T<Ø>) = b1
        operator fun B_0<Ø>.plus(t: T<Ø>) = b1
        operator fun B_1<Ø>.plus(t: T<Ø>): B_2<Ø> = F(x + b1)
        operator fun B_3<Ø>.plus(t: T<Ø>): B_4<Ø> = F(x + b1)
        operator fun B_7<Ø>.plus(t: T<Ø>): B_8<Ø> = F(x + b1)

        // Calculates k + 1 for all k @≡@ 2@\color{gray}\textsuperscript{n}@ - 1 (mod 2@\color{gray}\textsuperscript{n+1}@), 1 <= n < 4
        operator fun <K: B<*, *>> B_0<K>.plus(t: T<Ø>) = T(x)
        operator fun <K: B<*, *>> B_1<F<K>>.plus(t: T<Ø>) = F(x + b1)
        operator fun <K: B<*, *>> B_3<F<K>>.plus(t: T<Ø>) = F(x + b1)
        operator fun <K: B<*, *>> B_7<F<K>>.plus(t: T<Ø>) = F(x + b1)
        \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]{Abacus dependent types: birds eye view}
        \begin{tiny}
        \begin{verbatim}
             i\j│  0  1  …  k-1  k  │  k+1  k+2  …  k+c  │  k+c+1  …  k+c+d-1
             ───┼───────────────────┼────────────────────┼────────────────────┐
              0 │                   │                    │                  __|
              1 │                   │                    │               __/░░
              … │       i ± j       │        i + j       │            __/░░░░░
              … │       j ± i       │        j ± i       │         __/░░░░░░░░
            k-1 │                   │                    │      __/░░░░░░░░░░░
              k │                   │                    │   __╱░░░░░░░░░░░░░░
            ────┼───────────────────┼────────────────────┴──┘░░░░░░░░░░░░░░░░░
            k+1 │                   │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
            k+2 │                   │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
              … │       i ± j       │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
              … │       j + i       │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
          k+c-1 │                   │░░░░░░░░░░░░                ░░░░░░░░░░░░░
            k+c │                   │░░░░░░░░░░░░    Run-time    ░░░░░░░░░░░░░
           ─────┼───────────────────┤░░░░░░░░░░░░                ░░░░░░░░░░░░░
          k+c+1 │                __/░░░░░░░░░░░░░  type checked  ░░░░░░░░░░░░░
          k+c+2 │             __/░░░░░░░░░░░░░░░░                ░░░░░░░░░░░░░
              … │          __/░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
              … │       __/░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
        k+c+d-2 │    __/░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
        k+c+d-1 │___/░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
        \end{verbatim}
        \end{tiny}
    \end{frame}

    \begin{frame}{Annotated history of typed eDSLs}
        \begin{itemize}
            \item \href{https://www.cs.utexas.edu/~wcook/papers/FBound89/CookFBound89.pdf}{Canning et al. (1989) - F-Bounded Polymorphism is first invented}
            \item \href{https://ecommons.cornell.edu/bitstream/handle/1813/5614/TR2003-1901.pdf}{Cheney \& Hinze (2003) - Phantom types (good for type-safe builders)}
            \item \href{https://dl.acm.org/doi/pdf/10.1145/1142473.1142552}{Meijer et al. (2006) - Language integrated querying (LINQ)}
            \item \href{https://jooq.org}{Eder (2011) - Commercial reimplementation LINQ in Java/jOOQ}
            \item \href{https://arxiv.org/pdf/1605.05274.pdf}{Grigore (2016) - Java Generics shown to be Turing Complete}
            \item \href{https://github.com/erdos/java-logic}{Erdős (2017) - Encodes Boolean logic into Java type system}
            \item \href{https://dl.acm.org/doi/10.1145/3136040.3136041}{Nakamaru et al. (2017) - Silverchain: a fluent API generator}
            \item \href{http://breandan.net/public/masters_thesis.pdf#2}{\textbf{Considine (2019) - Shape-safe matrix multiplication in Kotlin$\nabla$}}
            \item \href{https://drops.dagstuhl.de/opus/volltexte/2019/10805/pdf/LIPIcs-ECOOP-2019-13.pdf}{Gil \& Roth (2019) - Fling, a fluent API parser generator}
            \item \href{https://github.com/tribbloid/shapesafe}{Cheng (2020) - Automatic theorem proving in the Scala type system}
            \item \href{https://arxiv.org/pdf/2109.03950.pdf}{Roth (2021) - Encodes CFL into Nominal Subtyping with Variance}
            \item \href{https://github.com/breandan/galoisenne}{\textbf{Considine (2021) - Arithmetic in Kotlin via typelevel abacus}}
            \item We know how to lower parsing onto types, what about vis versa?
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]{Can we lower type checking onto parsing?}
        First, let us consider the untyped version:
        \begin{lstlisting}[language=Kotlin, gobble=5]
        Exp -> 0 | 1 | ... | T | F
        Exp -> Exp Op Exp | if ( Exp ) Exp else Exp
        Op -> and | or | + | *
        \end{lstlisting}
        Now, let us consider the GADT/HOAS version:
        \begin{lstlisting}[language=Kotlin, gobble=5]
        Exp<Bool> -> T | F
        Op<Bool> -> and | or
        Exp<Int> -> 0 | 1 | ... | 9
        Op<Int> -> + | *
        Exp<E> -> Exp<E> Op<E> Exp<E> // Es must be exactly the same!
        Exp<E> -> if ( Exp<Bool> ) Exp<E> else Exp<E>
        \end{lstlisting}
        We can eliminate contextuality by concretizing over \lstinline[language=Kotlin]{E -> Bool | Int}:
        \begin{lstlisting}[language=Kotlin, gobble=5]
        Exp<Bool> -> T | F
        Exp<Bool> -> Exp<Bool> or Exp<Bool> | Exp<Bool> and Exp<Bool>
        Exp<Bool> -> if ( Exp<Bool> ) Exp<Bool> else Exp<Bool>
        Exp<Int> -> 0 | 1 | ... | 9
        Exp<Int> -> Exp<Int> + Exp<Int> | Exp<Int> * Exp<Int>
        Exp<Int> -> if ( Exp<Bool> ) Exp<Int> else Exp<Int>
        \end{lstlisting}
    \end{frame}

    \section{Graph Programming}

    \begin{frame}[fragile]{Inductive and algberaic graph representations}
        We can represent a graph inductively, using a CFG/ADT:
        \begin{align*}
           \textsc{Vertex} &\phantom{\vee}\rightarrow\phantom{\vee} \textsc{Int}\\
           \textsc{Neighbors} &\phantom{\vee}\rightarrow\phantom{\vee} \textsc{Vertex}\phantom{\vee} \mid \phantom{\vee}\textsc{Vertex} \phantom{\vee} \textsc{Neighbors} \\
           \textsc{Context} &\phantom{\vee}\rightarrow\phantom{\vee} ([\textsc{Neighbors}], \textsc{Vertex}, [\textsc{Neighbors}]) \\
           \textsc{Graph} &\phantom{\vee}\rightarrow\phantom{\vee} \textsc{Empty}\phantom{\vee} \mid\phantom{\vee} \textsc{Context} \phantom{\vee} \textsc{Graph}
        \end{align*}

        We can also represent graphs algebraically using the graph Laplacian:
        \[
            \mathcal{L}_{i,j} := \begin{cases}
               \deg(v_i) & \mbox{if}\ i = j \\
               -1 & \mbox{if}\ i \neq j\ \mbox{and}\ (v_i \rightarrow v_j) \in E \\
               0 & \mbox{otherwise},
        \end{cases}\]

        The latter form is preferred for representation learning [\href{https://www.cs.mcgill.ca/~wlh/grl_book/}{Hamilton (2020)}].
    \end{frame}

    \begin{frame}[fragile]{Graph combinator}
    To merge two unlabeled graphs, apply $G_1 \oplus G_2 = (V_1\cup V_2) \times (E_1\cup E_2)$:

\begin{figure}[H]
    \begin{center}
 \scalebox{0.8}{
 \begin{tikzpicture}[scale=0.8]
  \node[shape=circle,draw=black] (A) at (0,2.5)  {$s_1$};
  \node[shape=circle,draw=black] (B) at (2.5,4)  {$s_2$};
  \node[shape=circle,draw=black] (C) at (2.5,1)  {$s_3$};

  \node[shape=circle,draw=black] (D) at (6.5,2.5){$s_4$};
  \node[shape=circle,draw=black] (E) at (4,4)    {$s_2$};
  \node[shape=circle,draw=black] (F) at (4,1)    {$s_3$};

  \path [->] (A) edge node[left] {} (B);
  \path [->](A) edge node[left] {} (C);
  \path [->](C) edge node[top] {\hspace{3.3em}$\oplus$} (B);

  \path [->] (D) edge node[left] {} (E);
  \path [->](D) edge node[left] {} (F);
  \path [->](F) edge node[top] {\hspace{15em}$=$} (E);
\end{tikzpicture}
\begin{tikzpicture}[scale=0.8]
  \node[shape=circle,draw=black] (A) at (0,2.5) {$s_1$};
  \node[shape=circle,draw=black] (B) at (2.5,4) {$s_2$};
  \node[shape=circle,draw=black] (C) at (2.5,1) {$s_3$};

  \node[shape=circle,draw=black] (D) at (5,2.5) {$s_4$};

  \path [->] (A) edge node[left] {} (B);
  \path [->](A) edge node[left] {} (C);
  \path [->](C) edge node[top] {} (B);

  \path [->] (D) edge node[left] {} (B);
  \path [->](D) edge node[left] {} (C);
\end{tikzpicture}
 }
    \end{center}
\end{figure}

Can be specialized to join ADTs, e.g.: $G_1 \oplus G_2 = (V_1 \cup V_2) \times (E_1 \Join E_2)$:

    \begin{figure}[H]
        \begin{center}
  \scalebox{0.8}{
  \begin{tikzpicture}[scale=0.8]
    \node[shape=circle,draw=black] (A) at (0,2.5) {$s_1$};
    \node[shape=circle,draw=black] (B) at (2.5,4) {$s_2$};
    \node[shape=circle,draw=black] (C) at (2.5,1) {$s_3$};

    \node[shape=circle,draw=black] (D) at (5,2.5) {$s_4$};

    \path [->] (A) edge node[left] {} (B);
    \path [->](A) edge node[left] {} (C);

    \path [->](C) edge [bend left] node[top] {\colorbox{white}{\texttt{ab}}} (B);
    \path [->](C) edge [bend right] node[top] {\colorbox{white}{\texttt{bc}}} (B);

    \path [->] (D) edge node[left] {} (B);
    \path [->](D) edge node[left] {} (C);
  \end{tikzpicture}
  \hspace{5em}
  \begin{tikzpicture}[scale=0.8]
    \node[shape=circle,draw=black] (A) at (0,2.5) {$s_1$};
    \node[shape=circle,draw=black] (B) at (2.5,4) {$s_2$};
    \node[shape=circle,draw=black] (C) at (2.5,1) {$s_3$};

    \node[shape=circle,draw=black] (D) at (5,2.5) {$s_4$};

    \path [->] (A) edge node[left] {} (B);
    \path [->](A) edge node[left] {} (C);

    \path [->](C) edge node[top] {\colorbox{white}{\texttt{ab, bc}}} (B);

    \path [->] (D) edge node[left] {} (B);
    \path [->](D) edge node[left] {} (C);
  \end{tikzpicture}
 }
  \end{center}
\end{figure}
    \end{frame}

    \begin{frame}[fragile]{A type family for graphs}
        \begin{lstlisting}[language=Kotlin, gobble=8]
        interface IGF<G, E, V> where
          G: IGraph<G, E, V>, E: IEdge<G, E, V>, V: IVertex<G, E, V> {
            val G: (vertices: Set<V>) -> G
            val E: (s: V, t: V) -> E
            val V: (old: V, edgeMap: (V) -> Set<E>) -> V

            fun G(vararg graphs: G): G = G(graphs.toList())
            fun G(vararg vertices: V): G = G(vertices.map { it.graph })
            fun G(l: List<Any>): G = when {
              l allAre G -> l.fold(G()) { it, acc -> it + acc as G }
              l allAre V -> list.map { it as V }.toSet()
            }.let { G(it) }

            operator fun G.plus(that: G): G =
              G((this - that) + (this join that) + (that - this))

            operator fun G.minus(that: G): G = G(vertices - that.vertices)

            infix fun G.join(that: G): Set<V> = TODO("Override me!")
        }
        \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]{Classical programs are graphs}
    Programs can be compiled into DFGs and represented using a big matrix.
    \begin{table}[H]
        \centering
        \begin{tabular}{lcc}
            \textbf{Program} & \textbf{Dataflow Graph} & \textbf{Matrix} \\
%            \begin{tabular}[c]{@{}l@{}} $\hat y = θx + b$\\ $l = ||\hat y - y||_2$\end{tabular}
%              &
\begin{adjustbox}{minipage={.25\textwidth}, height=0.14\textwidth, margin*=-0.8cm 0cm 0cm 0.1cm}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
sum = 0
l = [0, 0, 0, 0]
for i in range(0, 4):
  l[i] += θ[i] * x[i]
for i in range(0, 4):
  l[i] -= y[i] - b
for i in range(0, 4):
  l[i] *= l[i]
for i in range(0, 4):
  sum += l[i]
l = sqrt(sum)
\end{lstlisting}
\end{adjustbox}
    & \begin{adjustbox}{minipage={.25\textwidth}, height=0.14\textwidth, margin*=0cm 0cm 0cm 0.1cm}
    \digraph[scale=0.1]{prograph}{
    node[ fontname="Helvetica" fontsize=20 shape=Mrecord ];
    edge[ fontname="Helvetica" fontsize=18 ];

    graph ["concentrate"="true","rankdir"="LR","bgcolor"="transparent","margin"="0.0","compound"="true","nslimit"="20"]
    "eeba8" ["label"="+"]
    "a8416" ["label"="+"]
    "4500f" ["label"="pow"]
    "a67f9" ["label"="*"]
    "0.5" ["label"="0.5"]
    "f14a3" ["label"="*"]
    "9c49d" ["label"="*"]
    "59c48" ["label"="+"]
    "980bd" ["label"="+"]
    "8f532" ["label"="+"]
    "1a609" ["label"="+"]
    "e58c4" ["label"="+"]
    "23f5b" ["label"="+"]
    "d829b" ["label"="+"]
    "y₀" ["label"="y₀"]
    "2783d" ["label"="+"]
    "8bd47" ["label"="+"]
    "y₂" ["label"="y₂"]
    "517e6" ["label"="+"]
    "8caa0" ["label"="+"]
    "y₁" ["label"="y₁"]
    "7da0d" ["label"="+"]
    "b12cb" ["label"="+"]
    "b" ["label"="b"]
    "f8941" ["label"="+"]
    "3eecd" ["label"="+"]
    "2e83a" ["label"="+"]
    "b59fd" ["label"="+"]
    "dae83" ["label"="+"]
    "b11ba" ["label"="*"]
    "3bb89" ["label"="*"]
    "b2454" ["label"="*"]
    "7bed4" ["label"="*"]
    "39644" ["label"="*"]
    "12c32" ["label"="*"]
    "d58d1" ["label"="*"]
    "6c64d" ["label"="*"]
    "fb0f0" ["label"="*"]
    "6c2be" ["label"="*"]
    "57fd4" ["label"="*"]
    "a9bc3" ["label"="*"]
    "x₀" ["label"="x₀"]
    "θ₀" ["label"="θ₀"]
    "x₂" ["label"="x₂"]
    "θ₁" ["label"="θ₁"]
    "x₂" ["label"="x₂"]
    "x₄" ["label"="x₄"]
    "x₁" ["label"="x₁"]
    "x₃" ["label"="x₃"]
    "eeba8" -> "a8416"
    "a8416" -> "4500f"
    "a67f9" -> "a8416"
    "0.5" -> "4500f"
    "f14a3" -> "eeba8"
    "9c49d" -> "eeba8"
    "59c48" -> "a67f9"
    "980bd" -> "a67f9"
    "8f532" -> "f14a3"
    "1a609" -> "f14a3"
    "e58c4" -> "9c49d"
    "23f5b" -> "9c49d"
    "d829b" -> "59c48"
    "y₀" -> "59c48"
    "y₀" -> "980bd"
    "2783d" -> "980bd"
    "8bd47" -> "8f532"
    "y₂" -> "8f532"
    "y₂" -> "1a609"
    "517e6" -> "1a609"
    "8caa0" -> "e58c4"
    "y₁" -> "e58c4"
    "y₁" -> "23f5b"
    "7da0d" -> "23f5b"
    "b12cb" -> "d829b"
    "b" -> "d829b"
    "b" -> "2783d"
    "b" -> "8bd47"
    "b" -> "517e6"
    "b" -> "8caa0"
    "b" -> "7da0d"
    "f8941" -> "2783d"
    "3eecd" -> "8bd47"
    "2e83a" -> "517e6"
    "b59fd" -> "8caa0"
    "dae83" -> "7da0d"
    "b11ba" -> "b12cb"
    "3bb89" -> "b12cb"
    "b2454" -> "f8941"
    "7bed4" -> "f8941"
    "39644" -> "3eecd"
    "12c32" -> "3eecd"
    "d58d1" -> "2e83a"
    "6c64d" -> "2e83a"
    "fb0f0" -> "b59fd"
    "6c2be" -> "b59fd"
    "57fd4" -> "dae83"
    "a9bc3" -> "dae83"
    "x₀" -> "b11ba"
    "x₀" -> "b2454"
    "θ₀" -> "b11ba"
    "θ₀" -> "b2454"
    "θ₀" -> "39644"
    "θ₀" -> "d58d1"
    "θ₀" -> "fb0f0"
    "θ₀" -> "57fd4"
    "x₂" -> "3bb89"
    "x₂" -> "7bed4"
    "θ₁" -> "3bb89"
    "θ₁" -> "7bed4"
    "θ₁" -> "12c32"
    "θ₁" -> "6c64d"
    "θ₁" -> "6c2be"
    "θ₁" -> "a9bc3"
    "x₂" -> "39644"
    "x₂" -> "d58d1"
    "x₄" -> "12c32"
    "x₄" -> "6c64d"
    "x₁" -> "fb0f0"
    "x₁" -> "57fd4"
    "x₃" -> "6c2be"
    "x₃" -> "a9bc3"
    } \end{adjustbox} &
            \begin{adjustbox}{minipage={.15\textwidth}, height=0.14\textwidth, margin*=-0.2cm 0cm 0cm 0.5cm}
            \includegraphics[scale=0.15]{../figures/adj_prog.png}
            \end{adjustbox}
        \end{tabular}
    \end{table}
        This representation allows us to solve for their fixedpoints as eigenvectors.
    \end{frame}

    \begin{frame}[fragile]{Probabilistic programs are also graphs}
    A Bayesian Belief Network (BN) is an acyclic DGM of the following form:

    \tikzset{latent/.append style={minimum size=14pt, inner sep=1pt, node distance=10pt, draw,circle, inner sep=1pt}, obs/.append style={minimum size=14pt, inner sep=1pt, node distance=10pt, draw,circle, inner sep=1pt}}
    \makeatletter
    \newcommand\ccirc[1]{%
    \mathpalette\@ccirc{#1}%
    }
    \newcommand\@ccirc[2]{%
    \tikz[baseline=(math.base)] \node (math) {$\m@th#1#2$};%
    }
    \newcommand\gcirc[1]{%
    \mathpalette\@gcirc{#1}%
    }
    \newcommand\@gcirc[2]{%
    \tikz[baseline=(math.base)] \node[fill=gray!30] (math) {$\m@th#1#2$};%
    }
    \makeatother
% http://maximustann.github.io/mach/2015/07/06/belief-network-2/
% http://frnsys.com/notes/ai/foundations/probabilistic_graphical_models.html
    \begin{prooftree}
        \AxiomC{$X \cancel\perp Y \mid Z$}
        \RightLabel{\textsc{V}}
        \UnaryInfC{
        \begin{tikzpicture}
            \node[obs] (z) {$Z$};%
            \node[latent,above=of z,xshift=-1cm,fill] (x) {$X$}; %
            \node[latent,above=of z,xshift=1cm] (y) {$Y$}; %
            \edge {x,y} {z}
        \end{tikzpicture}
        }
        \DisplayProof
        \AxiomC{$X \perp Y \mid Z$}
        \RightLabel{\textsc{Fork}}
        \UnaryInfC{
        \begin{tikzpicture}
            \node[obs] (z) {$Z$};%
            \node[latent,below=of z,xshift=-1cm,fill] (x) {$X$}; %
            \node[latent,below=of z,xshift=1cm] (y) {$Y$}; %
            \edge {z} {x,y}
        \end{tikzpicture}
        }
        \DisplayProof
        \AxiomC{$X \perp Y \mid Z$}
        \RightLabel{\textsc{Ch}}
        \UnaryInfC{
        \begin{tikzpicture}
            \node[obs] (z) {$Z$};%
            \node[latent,above=of z,yshift=-11pt, xshift=-32pt,fill] (x) {$X$}; %
            \node[latent,below=of z,yshift=11pt, xshift=32pt] (y) {$Y$}; %
            \edge {x} {z}
            \edge {z} {y}
        \end{tikzpicture}
        }
    \end{prooftree}

    \begin{equation*}
        P(x_1,\ldots,x_D)=\prod_{i=1}^D P(x_i \mid \texttt{parents}(x_i))
    \end{equation*}

    Translatable to a probabilistic circuit a.k.a. Sum Product Network (SPN):

    \begin{tabular}{cc}
        \hspace{-1.8cm}
        \begin{minipage}[c]{0.5\textwidth}
            \centering
            \begin{tabular}{l}
                $PC \rightarrow v \sim \mathcal{D}$ \\
                $PC \rightarrow PC \oplus PC$ \\
                $PC \rightarrow PC \otimes PC$
            \end{tabular}
        \end{minipage}
        &
        \begin{minipage}[c]{0.5\textwidth}
            \centering
            \digraph[scale=0.4]{spn1}{
                margin=0
                compound=true
                rankdir=LR
                node [shape=Mrecord,fontname="JetBrains Mono"]
                edge [fontsize=8,fontcolor=indigo]
                bgcolor=transparent
                nslimit=20

                g0 [label="{{μ|σ}|Normal|{<Out0>g0}}"]
                g1 [label="{{μ|σ}|Normal|{<Out0>g1}}"]
                g2 [label="{{μ|σ}|Normal|{<Out0>g2}}"]
                g3 [label="{{μ|σ}|Normal|{<Out0>g3}}"]

                f4 [label="{{<In0>g0|<In1>g1|<In2>g2}|Σ|{<Out0>f4}}"]
                f5 [label="{{<In0>f4|<In1>g3}|Π|{<Out0>f5}}"]

                g0:Out0 -> f4:In0
                g1:Out0 -> f4:In1
                g2:Out0 -> f4:In2
                g3:Out0 -> f5:In1
                f4:Out0 -> f5:In0


                out1 [style=invis,shape=point]
                out2 [style=invis,shape=point]

                f5 -> out1
            }
        \end{minipage}
    \end{tabular}
    \end{frame}

    \begin{frame}[fragile]{Message passing \& path algebras}
    A semiring algebra, denoted $(S, \oplus, \otimes, \circled{0}, \circled{1})$, is a set together with two binary operators $\oplus, \otimes: S \times S \rightarrow S$ such that $(S, \oplus, \circled{0})$ is a commutative monoid and $(S, \otimes, \circled{1})$ is a monoid. Furthermore, we have distributivity:

    \begin{prooftree}
        \bottomAlignProof
        \AxiomC{$a • (b • c)$}
        \RightLabel{\small\textsc{Assoc}}
        \UnaryInfC{$(a • b) • c$}
        \DisplayProof
        \hskip 2.5em
        \bottomAlignProof
        \AxiomC{$a • \circled 1$}
        \RightLabel{\small\textsc{Neutral}}
        \UnaryInfC{$a$\vphantom{$()$}}
        \DisplayProof
        \hskip 2.5em
        \bottomAlignProof
        \AxiomC{$a • b$}
        \RightLabel{\small\textsc{Comm}}
        \UnaryInfC{$b • a$\vphantom{$()$}}
    \end{prooftree}

    \begin{prooftree}
        \bottomAlignProof
        \AxiomC{$a \otimes (b \oplus c)$}
        \UnaryInfC{$(a \otimes b) \oplus (a \otimes c)$}
        \AxiomC{$(a \oplus b) \otimes c$}
        \RightLabel{\small\textsc{Dist}}
        \UnaryInfC{$(a \otimes c) \oplus (b \otimes c)$}
        \DisplayProof
        \hskip 2.5em
        \bottomAlignProof
        \AxiomC{$a \otimes \circled 0$}
        \RightLabel{\small\textsc{Annhil}}
        \UnaryInfC{$\circled 0$\vphantom{$()$}}
    \end{prooftree}
    \vspace{2pt}
    These operators can be lifted to matrices to form \textit{path algebras}:
    \begin{center}
        \begin{tabular}{lcr}
            $\delta_{st} = \overbrace{\underset{P\in P_{st}^*}{\bigoplus}\underbrace{\underset{e\in P}{\bigotimes}W_{e}}_{\text{Aggregate}}}^{\text{Update}}$ & &
            \bgroup
            \def\arraystretch{1.2}
            \begin{tabular}{c{1cm}c{1cm}|c{1cm}c{1cm}|c}
                $\oplus$ & $\otimes$ & $\circled{0}$ & $\circled{1}$ & Path     \\\hline
                min      & +         &   $\infty$    &      0        & Shortest \\
                max      & +         &   $-\infty$   &      0        & Longest  \\
                max      & min       &       0       &   $\infty$    & Widest   \\
                $\underline\vee$   & $\land$ &  $\circ$   &  $\top$  & Random \\
            \end{tabular}
            \egroup
        \end{tabular}
%        \begin{tabular}{lc|cr}
%            $δ_{st} = \overbrace{\underset{P\in P_{st}^*}{\bigoplus}\underbrace{\underset{e\in P}{\bigotimes}W_{e}}_{\text{Aggregate}}}^{\text{Update}}$ & & &
%            \bgroup
%            \def\arraystretch{1.2}
%            \begin{tabular}{c|c{1cm}c{1cm}|c{1cm}c{1cm}|c}
%                S                           & $\oplus$ & $\otimes$ & $\circled{0}$ & $\circled{1}$ & Path     \\\hline
%                $\mathbb R \cup \{\infty\}$ & min      & +         &   $\infty$    &      0        & Shortest \\
%                $\mathbb R \cup \{\infty\}$ & max      & +         &   $-\infty$   &      0        & Longest  \\
%                $\mathbb R \cup \{\infty\}$ & max      & min       &       0       &   $\infty$    & Widest   \\
%            \end{tabular}
%            \egroup
%        \end{tabular}
    \end{center}
    \end{frame}

    \section{Random Numbers}

    \begin{frame}{Linear Finite State Registers}
        Let $\textbf{M}: \text{GF}(2^{n\times n})$ be a square matrix $\mathbf{M}^0_{r, c} = P_c \text{ if } r=0 \text{ else } \mathds{1}[c = r - 1]$, where $P$ is a feedback polynomial over $GF(2^n)$ with coefficients $P_{1\ldots n}$ and semiring operators $\oplus := \veebar, \otimes := \land$:\\

        \[
            \mathbf{M}^tV = \begin{pmatrix}
                P_1 & P_2 & P_3 & P_4 & P_5 \\
                \top & \circ & \circ & \circ & \circ \\
                \circ & \top & \circ & \circ & \circ \\
                \circ & \circ & \top & \circ & \circ \\
                \circ & \circ & \circ & \top & \circ
            \end{pmatrix}^t
            \begin{pmatrix}
                V_1 \\
                V_2 \\
                V_3 \\
                V_4 \\
                V_5
            \end{pmatrix}
        \]\\

        Selecting any $V \neq \mathbf{0}$ and coefficients $P_j$ from a known \textit{primitive polynomial} then powering the matrix $\mathbf{M}$ generates an ergodic sequence over GF$(2^n)$:\\

        \[
        \mathbf{S} = \begin{pmatrix}V & \mathbf{M}V & \mathbf{M}^{2}V & \mathbf{M}^{3}V & \cdots & \mathbf{M}^{2^n-1}V \end{pmatrix}
        \]

        This sequence has \textit{full periodicity}, i.e., for all $i, j \in [0, 2^n), \mathbf{S}_i = \mathbf{S}_j \Rightarrow i = j$.
    \end{frame}

    \begin{frame}[fragile]{Linear finite state registers}
        \begin{verbatim}
 a  b  c  d  e     V₁             1  +  x³ +  x⁵
 1  0  0  0  0     V₂    P = 20 = 0  0  1  0  1
 0  1  0  0  0  *  V₃             ∥  ∥  ∥  ∥  ∥
 0  0  1  0  0     V₄             a  b  c  d  e
 0  0  0  1  0     V₅       ╭────────── ⊗ ────╮
                            │           │     │
       M        *  V        0 ──► 1  0  1  1  1 ──►
                                        ╰──┬──╯
 S₄ = M … S₁ = M * V                    "taps"
 ∥        ∥        ∥
 0        0        1        S₀ = 1  0  1  1  1
 0        1        0        S₁ = 0  1  0  1  1
 1        0        1        S₂ = 1  0  1  0  1
 0        1        1        S₃ = 0  1  0  1  0
 1        0        1        S₄ = 0  0  1  0  1
        \end{verbatim}
    \end{frame}

    \begin{frame}[fragile]{Multidimensional sampling: the hasty pudding trick}
        \definecolor{R}{RGB}{202,65,55}
        \definecolor{G}{RGB}{151,216,56}
        \definecolor{B}{RGB}{0,0,0}
        \definecolor{W}{RGB}{255,255,255}
        \definecolor{X}{RGB}{65,65,65}

        \newcommand{\TikZRubikFaceLeft}[9]{\def\myarrayL{#1,#2,#3,#4,#5,#6,#7,#8,#9}}
        \newcommand{\TikZRubikFaceRight}[9]{\def\myarrayR{#1,#2,#3,#4,#5,#6,#7,#8,#9}}
        \newcommand{\TikZRubikFaceTop}[9]{\def\myarrayT{#1,#2,#3,#4,#5,#6,#7,#8,#9}}
        \newcommand{\BuildArray}{\foreach \X [count=\Y] in \myarrayL%
        {\ifnum\Y=1%
        \xdef\myarray{"\X"}%
        \else%
        \xdef\myarray{\myarray,"\X"}%
        \fi}%
        \foreach \X in \myarrayR%
        {\xdef\myarray{\myarray,"\X"}}%
        \foreach \X in \myarrayT%
        {\xdef\myarray{\myarray,"\X"}}%
        \xdef\myarray{{\myarray}}%
        }
        \TikZRubikFaceLeft
        {X}{W}{W}
        {W}{X}{X}
        {X}{W}{W}
        \TikZRubikFaceRight
        {W}{X}{W}
        {X}{W}{X}
        {W}{X}{W}
        \TikZRubikFaceTop
        {X}{W}{X}
        {W}{W}{X}
        {W}{X}{W}
        \BuildArray
        \pgfmathsetmacro\radius{0.1}
        \tdplotsetmaincoords{55}{135}

        \showcellnumberfalse


        \bgroup

        \begin{figure}
        \hspace{-0.5cm}\begin{minipage}[l]{5cm}
        \begin{tikzpicture}
        \clip (-3,-2.5) rectangle (3,2.5);
        \begin{scope}[tdplot_main_coords]
            \filldraw [canvas is yz plane at x=1.5] (-1.5,-1.5) rectangle (1.5,1.5);
            \filldraw [canvas is xz plane at y=1.5] (-1.5,-1.5) rectangle (1.5,1.5);
            \filldraw [canvas is yx plane at z=1.5] (-1.5,-1.5) rectangle (1.5,1.5);
            \foreach \X [count=\XX starting from 0] in {-1.5,-0.5,0.5}{
            \foreach \Y [count=\YY starting from 0] in {-1.5,-0.5,0.5}{
            \pgfmathtruncatemacro{\Z}{\XX+3*(2-\YY)}
            \pgfmathsetmacro{\mycolor}{\myarray[\Z]}
            \draw [thick,canvas is yz plane at x=1.5,shift={(\X,\Y)},fill=\mycolor] (0.5,0) -- ({1-\radius},0) arc (-90:0:\radius) -- (1,{1-\radius}) arc (0:90:\radius) -- (\radius,1) arc (90:180:\radius) -- (0,\radius) arc (180:270:\radius) -- cycle;
            \ifshowcellnumber
            \node[canvas is yz plane at x=1.5,shift={(\X+0.5,\Y+0.5)}] {\Z};
            \fi
            \pgfmathtruncatemacro{\Z}{2-\XX+3*(2-\YY)+9}
            \pgfmathsetmacro{\mycolor}{\myarray[\Z]}
            \draw [thick,canvas is xz plane at y=1.5,shift={(\X,\Y)},fill=\mycolor] (0.5,0) -- ({1-\radius},0) arc (-90:0:\radius) -- (1,{1-\radius}) arc (0:90:\radius) -- (\radius,1) arc (90:180:\radius) -- (0,\radius) arc (180:270:\radius) -- cycle;
            \ifshowcellnumber
            \node[canvas is xz plane at y=1.5,shift={(\X+0.5,\Y+0.5)},xscale=-1] {\Z};
            \fi
            \pgfmathtruncatemacro{\Z}{2-\YY+3*\XX+18}
            \pgfmathsetmacro{\mycolor}{\myarray[\Z]}
            \draw [thick,canvas is yx plane at z=1.5,shift={(\X,\Y)},fill=\mycolor] (0.5,0) -- ({1-\radius},0) arc (-90:0:\radius) -- (1,{1-\radius}) arc (0:90:\radius) -- (\radius,1) arc (90:180:\radius) -- (0,\radius) arc (180:270:\radius) -- cycle;
            \ifshowcellnumber
            \node[canvas is yx plane at z=1.5,shift={(\X+0.5,\Y+0.5)},xscale=-1,rotate=-90] {\Z};
            \fi
            }
            }

            \draw [decorate,decoration={calligraphic brace,amplitude=10pt,mirror},yshift=0pt, line width=1.25pt]
            (3,0) -- (3,3) node [black,midway,xshift=-8pt, yshift=-14pt] {\footnotesize $|\Sigma|$};
            \draw [decorate,decoration={calligraphic brace,amplitude=10pt},yshift=0pt, line width=1.25pt]
            (3,0) -- (0,-3) node [black,midway,xshift=-16pt, yshift=0pt] {\footnotesize $|\Sigma|$};
            \draw [decorate,decoration={calligraphic brace,amplitude=10pt},yshift=0pt, line width=1.25pt]
            (0,-3) -- (-3,-3) node [black,midway,xshift=-8pt, yshift=14pt] {\footnotesize $|\Sigma|$};
        \end{scope}
        \end{tikzpicture}
        \end{minipage}\hspace{1cm}
        \begin{minipage}[c]{5.5cm}
        To uniformly sample $\bm\sigma \sim \Sigma^n$ without replacement, we could track historical samples, or, we can form an injection $GF(2^n)\rightharpoonup\Sigma^d$, cycle a primitive polynomial over $GF(2^n)$, then discard samples that do not identify an element in any indexed dimension. This procedure rejects $(1 - |\Sigma|2^{-\lceil\log_2|\Sigma|\rceil})^d$ samples on average and requires $\sim\mathcal{O}(1)$.
        \end{minipage}
        \end{figure}
        \begin{small}
            \begin{verbatim}
                   e.g., Σ² = {A, B, C}², x⁴ + x³ + 1

   S₀     S₁     S₂     S₃     S₄     S₅     S₆     S₇
   ||     ||     ||     ||     ||     ||     ||     ||
 [1000] [0100] [0010] [1001] [1100] [0110] [1011] [0101]
  C A    B A    A C    C B           B C           B B
            \end{verbatim}
        \end{small}
    \egroup
    \end{frame}

    \begin{frame}[fragile]{Multidimensional no-replacement sampler}
        \begin{lstlisting}[language=Kotlin, gobble=8]
        fun List<Int>.bitLens() = map { ceil(log2(it.toDouble())).toInt() }

        // Splits a bitvector into designated chunks and returns indices
        // (10101011, [3, 2, 3]) -> [101, 01, 011] -> [4, 1, 3]
        fun List<Boolean>.toIndexes(bitLens: List<Int>): List<Int> =
          bitLens.fold(listOf<List<Boolean>>() to this) { (a, b), i ->
            (a + listOf(b.take(i))) to b.drop(i)
          }.first.map { it.toInt() }

        fun Sequence<List<Boolean>>.hastyPudding(lengths: List<Int>) =
          map { it.toIndexes(lengths.bitLens()) }
           .filter { it.zip(lengths).all { (a, b) -> a < b } }

        fun <T> List<Set<T>>.sampleWithoutReplacement(
          lengths: List<Int> = map { it.size },
          bitLens: List<Int> = map(Set<T>::size).bitLens(),
          degree: Int = bitLens.sum().also { println("LFSR(GF(2^$it))") }
        ): Sequence<List<T>> =
          LFSR(degree).hastyPudding(lengths)
            .map { zip(it).map { (dims, idx) -> dims[idx] } }
        \end{lstlisting}
    \end{frame}

    \section{Finite Fields}\label{sec:finite-fields}

    \begin{frame}{Recap: Classical logic in a nutshell}
        \begin{prooftree}
            \bottomAlignProof
            \AxiomC{$a \veebar b$}
            \RightLabel{XOR}
            \UnaryInfC{$(p \vee q)\land \neg (p\land q)\phantom{()}$}
            \DisplayProof
            \hskip 1.5em
            \bottomAlignProof
            \AxiomC{$a \to b$}
            \RightLabel{Impl}
            \UnaryInfC{$\neg a \vee b$}
            \DisplayProof
            \hskip 1.5em
            \bottomAlignProof
            \AxiomC{$a \leftrightarrow b$}
            \RightLabel{Iff}
            \UnaryInfC{$(\neg a \vee b)\land (\neg b\vee a)$}
            \DisplayProof
            \vskip 2.5em

            \bottomAlignProof
            \AxiomC{$\neg\neg a\phantom{()}$}
            \RightLabel{2Neg}
            \UnaryInfC{$a\phantom{()}$}
            \DisplayProof
            \hskip 2.5em
            \bottomAlignProof
            \AxiomC{$a • (b • c)$}
            \RightLabel{Assoc$_{\land\vee}$}
            \UnaryInfC{$(a • b) • c$}
            \DisplayProof
            \hskip 2.5em
            \bottomAlignProof
            \AxiomC{$a • b$}
            \RightLabel{Comm$_{\land\vee}$}
            \UnaryInfC{$b • a$}
            \DisplayProof
            \vskip 2.5em

            \bottomAlignProof
            \AxiomC{$a \land (b \vee c)$}
            \RightLabel{Dist$_\land$}
            \UnaryInfC{$(a \land b) \vee (a \land c)$}
            \DisplayProof
            \hskip 2.5em
            \bottomAlignProof
            \AxiomC{$a \vee (b \land c)$}
            \RightLabel{Dist$_\vee$}
            \UnaryInfC{$(a \vee b) \land (a \vee c)$}
            \DisplayProof
            \vskip 2.5em

            \bottomAlignProof
            \AxiomC{$\neg (a \vee b)$}
            \RightLabel{DeMorgan$_\vee$}
            \UnaryInfC{$\neg a \land \neg b$}
            \DisplayProof
            \hskip 2.5em
            \bottomAlignProof
            \AxiomC{$\neg (a \land b)$}
            \RightLabel{DeMorgan$_\land$}
            \UnaryInfC{$\neg a \vee \neg b$}
        \end{prooftree}
    \end{frame}

    \begin{frame}{Normalization in classical logic}
        \begin{columns}[t]
            \begin{column}{0.55\textwidth}
                \begin{center}
                    \textbf{Conjunctive Normal Form}
                    \phantom{()}\\
                    \begin{align*}
                        \textsc{Conj} &\rightarrow (\textsc{Disj}) \mid \textsc{Conj} \land (\textsc{Disj})\\
                        \textsc{Unit} &\rightarrow \textsc{Var} \mid \neg \textsc{Var} \mid \bot \mid \top \\
                        \textsc{Disj} &\rightarrow \textsc{Unit} \mid \textsc{Disj} \vee \textsc{Disj}
                    \end{align*}
                    \begin{prooftree}
                        \AxiomC{$\neg (x\vee \neg y)\vee \neg \neg z$}
                        \RightLabel{2Neg}
                        \UnaryInfC{$\neg (x\vee \neg y)\vee z$}
                        \RightLabel{DeMorgan}
                        \UnaryInfC{$(\neg x\land  \neg \neg y)\vee z$}
                        \RightLabel{2Neg}
                        \UnaryInfC{$(\neg x\land  y)\vee z$}
                        \RightLabel{Dist}
                        \UnaryInfC{$(\neg x\vee z)\land  (y\vee z)$}
                    \end{prooftree}\\
                    \phantom{()}\\
                    \phantom{Solved with SAT (e.g., DPLL/CDCL/Survey Prop).}\\
                \end{center}
            \end{column}
            \begin{column}{0.45\textwidth}
                \begin{center}
                    \textbf{Zhegalkin Normal Form}
                    \phantom{()}\\
                    \[
                        f(x_1, \ldots x_n) = \bigoplus_{i\subseteq\{1,\ldots, n\}}a_i x^i
                    \]
                    i.e., $a_i$'s filter the powerset.
                    \phantom{()}\\
                    \begin{prooftree}
                        \AxiomC{$x + (y \land \neg z)$}
                        \RightLabel{}
                        \UnaryInfC{$x + y(1 \oplus z)$}
                        \RightLabel{}
                        \UnaryInfC{$x + (y \oplus yz)$}
                        \RightLabel{}
                        \UnaryInfC{$x \oplus (y \oplus yz) \oplus x(y \oplus yz)$}
                        \RightLabel{}
                        \UnaryInfC{$x \oplus y \oplus xy \oplus yz \oplus xyz$}
                    \end{prooftree}
                \end{center}\\
                \phantom{()}\\
                \phantom{Solved with rootfinding (e.g., power iteration, Gr\"obner basis).}\\
                \phantom{()}\\
            \end{column}
        \end{columns}
    \end{frame}

    \begin{frame}{Some common algebraic and logical forms}
    \begingroup
    \setlength{\tabcolsep}{7.5pt} % Default value: 6pt
    \begin{tabular}{c|c|c|c|c|c|c}
    a_1 & a_2 & a_3 & a_4 & ZNF    & Logical                      & CNF                                    \\
    \hline
    0 & 0 & 0 & 0 & 0              & $\bot                      $ & $x \land \neg x                       $\\
    1 & 0 & 0 & 0 & 1              & $\top                      $ & $x \vee \neg x                        $\\
    0 & 1 & 0 & 0 & x              & $x                         $ & $x                                    $\\
    1 & 1 & 0 & 0 & 1 + x          & $\neg x                    $ & $\neg x                               $\\
    0 & 0 & 1 & 0 & y              & $y                         $ & $y                                    $\\
    1 & 0 & 1 & 0 & 1 + y          & $\neg y                    $ & $\neg y                               $\\
    0 & 1 & 1 & 0 & x + y          & $x \oplus y                $ & $(x \vee y) \land (\neg x \vee \neg y)$\\
    1 & 1 & 1 & 0 & 1 + x + y      & $ x \Longleftrightarrow y  $ & $(x \vee \neg y) \land (\neg x \vee y)$\\
    0 & 0 & 0 & 1 & xy             & $x \land y                 $ & $x \land y                            $\\
    1 & 0 & 0 & 1 & 1 + xy         & $\neg(x \land y)           $ & $(\neg x) \vee (\neg y)               $\\
    0 & 1 & 0 & 1 & x + xy         & $x \land (\neg y)          $ & $x \land (\neg y)                     $\\
    1 & 1 & 0 & 1 & 1 + x + xy     & $x \Longrightarrow y       $ & $(\neg x) \vee y                      $\\
    0 & 0 & 1 & 1 & y + xy         & $(\neg x) \land y          $ & $(\neg x) \land y                     $\\
    1 & 0 & 1 & 1 & 1 + y + xy     & $x \Longleftarrow y        $ & $x \vee (\neg y)                      $\\
    0 & 1 & 1 & 1 & x + y + xy     & $x \vee y                  $ & $x \vee y                             $\\
    1 & 1 & 1 & 1 & 1 + x + y + xy & $\neg(x \vee y)            $ & $(\neg x) \land (\neg y)              $\\
    \end{tabular}
    \endgroup
    \end{frame}

    \begin{frame}{Facts about finite fields}
        \begin{itemize}
            \item For every prime number p and positive integer n, there exists a finite field with $p^n$ elements, denoted $GF(p^n)$, $\mathbb{Z}/p^n$ or $\mathbb{F}_p^n$.
            \item The following instruction sets have identical expressivity:
            \begin{itemize}
                \item Pairs: $\{\vee, \neg\}, \{\wedge, \neg\}, \{\to, \neg\}, \{\to, \bot\}, \{\to, \veebar\}, \{\land, \veebar\}, \ldots$
                \item Triples: $\{\lor, =, \veebar\}, \{\lor, \veebar, \top\}, \{\land, =, \bot\}, \{\land, =, \veebar\}, \{\land, \veebar, \top\}, \ldots$
            \end{itemize}
            \item In other words, we can compute any Boolean function $\mathbb{B}^n\rightarrow\mathbb{B}$ by composing any one of the above operator sets in an orderly fashion.
            \item $\mathbb{F}_2$ corresponds to arithmetic modulo 2, i.e., $\oplus := \veebar, \otimes := \land$.
            \item There are (at least) two schools of thought about Boolean circuits:
            \begin{itemize}
                \item Logical: Conjunctive Normal Form (CNF). May not be unique.
                \item Algebra: Zhegalkin Normal Form (ZNF). Always unique.
            \end{itemize}
            \item The type $\mathbb{F}_2^n\rightarrow\mathbb{F}_2$ possesses $2^{2^{n}}$ inhabitants.
        \end{itemize}
    \end{frame}

    \begin{frame}{Preface to “Two Memoirs on Pure Analysis”}
        \setlength{\epigraphwidth}{0.97\textwidth}
        \epigraph{``\textit{Long algebraic calculations were at first hardly necessary for mathematical progress... It was only since Euler that concision has become indispensable to continuing the work this great geometer has given to science. Since Euler, calculation has become more and more necessary and... the algorithms so complicated that progress would be nearly impossible without the elegance that modern geometers have brought to bear on their research, and by which means the mind can promptly and with a glance grasp a large number of operations.}\\

        \vspace{5pt}
        \ldots\\
        \vspace{5pt}

        \textit{It is clear that elegance, so admirably and aptly named, has no other purpose.}\\

        \vspace{5pt}
        \ldots\\
        \vspace{5pt}

        \textit{Jump headlong into the calculations! Group the operations, classify them by their difficulties and not their appearances. This, I believe, is the mission of future geometers. This is the road on which I am embarking in this work.}''}{\'Evariste Galois, 1811-1832}
    \end{frame}

    \section{Future Work}

    \begin{frame}{What's the point?}
        \begin{itemize}
            \item Algebraists have developed a powerful language for rootfinding
            \item Tradition handed down from Euler, Galois, Borel, Kleene, Chomsky
            \item We know closed forms for exponentials of structured matrices
%            \item Characteristic polynomials, companion matrices, eigenvalues
            \item Solving these forms can be much faster than power iteration
            \item Unifies many problems in PL, probability and graph theory
            \item Context-free parsing is just rootfinding on a semiring algebra
            \item Type checking sans recursive types is just graph reachability
            \item Unification/simplification is lazy hypergraph search
            \item Bounded program synthesis is matrix factorization/completion
            \item By doing so, we can leverage well-known algebraic techniques
        \end{itemize}
    \end{frame}

    \begin{frame}{Future work}
        Parsing
        \begin{itemize}
            \item The line between parsing and computation is blurry
            \item Investigate connection between dynamical and term rewrite systems
            \item Extend Valiant's parser to tensors/context-sensitive languages
            \item Recover the original parse tree or eliminate Chomsky Normal Form
            \item What is the connection to Leibnizian differentiability?
%            \item What is the meaning of abstract algebraic eigenvalues?
        \end{itemize}
        \phantom{space}\\
        Probability
        \begin{itemize}
            \item Look into Markov chains (detailed balance, stationarity, reversibility)
        \item Fuse Valiant parser and probabilistic context-free grammar
        \item Message passing and graph diffusion processes
        \item Look into constrained optimization (e.g., L/QP) to rank feasible set
        \end{itemize}
    \end{frame}

    \begin{frame}{Special thanks}
            \begin{center}
                \LARGE{
                    Nghi D. Q. Bui\\
                    Zhixin Xiong\\
                    Brigitte Pientka\\
                    David Yu-Tung Hui\\
                    Ori Roth\\
                    \phantom{}\\
                }
                \href{https://cs.mcgill.ca}{\includegraphics[scale=0.08]{../figures/mcgill_logo.png}}
                \href{https://www.fpt-software.com}{\includegraphics[scale=0.19]{../figures/fpt_logo.png}}
                \href{https://mila.quebec}{\includegraphics[scale=0.13]{../figures/mila_logo.png}}
            \end{center}
    \end{frame}

    \begin{frame}
        \begin{center}
            \Huge{Learn more at: \\~\\
            \href{http://oplss22.ndan.co}{\color{blue}{http://oplss22.ndan.co}}}
        \end{center}
    \end{frame}
\end{document}