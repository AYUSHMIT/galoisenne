%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
\documentclass[sigplan,nonacm]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[ARRAY'22]{ACM SIGPLAN Conference on Programming Languages}{June 13, 2022}{San Diego, CA, USA}
%\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage{colortbl}

%% Bibliography style
\bibliographystyle{acmart}

\input{preamble.tex}
\begin{document}

%% Title information
\title{Tidyparse: Real-Time Context Free Error Correction}
\begin{abstract}
Tidyparse is a program synthesizer that performs real-time error correction for context free languages.
Given both an arbitrary context free grammar (CFG) and an invalid string, the tool lazily generates admissible repairs while the author is typing, ranked by Levenshtein edit distance.
 Repairs are guaranteed to be sound, complete, syntactically valid and minimal.
 Tidyparse is the first system of its kind offering these guarantees in a real-time editor. To accelerate code completion, we design and implement a novel incremental parser-synthesizer that transforms CFGs onto a dynamical system over finite field arithmetic, enabling us to suggest syntax repairs in-between keystrokes. We have released an IDE plugin demonsrating the system described.\footnote{https://plugins.jetbrains.com/plugin/19570-tidyparse}
\end{abstract}

\author{Breandan Mark Considine}
\affiliation{
  \institution{McGill University}
}
\email{bre@ndan.co}

\author{Jin Guo}
\affiliation{
  \institution{McGill University}
}
\email{jguo@cs.mcgill.ca}

\author{Xujie Si}
\affiliation{
  \institution{McGill University}
}
\email{xsi@cs.mcgill.ca}

\maketitle

\section{Introduction}

Modern research on error correction can be traced back to the early days of coding theory, when researchers designed \textit{error-correcting codes} (ECCs) to denoise transmission errors induced by external interference, whether due to collision with a high-energy proton, manipulation by an adversary or some typographical mistake. In this context, \textit{code} can be any logical representation for communicating information between two parties (such as a human and a computer), and an ECC is a carefully-designed code which ensures that even if some portion of the message should be corrupted through accidental or intentional means, one can still recover the original message by solving a linear system of equations. In particular, we frame our work inside the context of errors arising from human factors in computer programming.

In programming, most such errors initially manifest as syntax errors, and though often cosmetic, manual repair can present a significant challenge for novice programmers. The ECC problem may be refined by introducing a language, $\mathcal{L} \subset \Sigma^*$ and considering admissible edits transforming an arbitrary string, $s \in \Sigma^*$ into a string, $s'\in\mathcal{L}$. Known as \textit{error-correcting parsing} (ECP), this problem was well-studied in the early parsing literature, cf. Aho and Peterson~\cite{aho1972minimum}, but fell out of favor for many years, perhaps due to its perceived complexity. By considering only minimal-length edits, ECP can be reduced to the so-called \textit{language edit distance} (LED) problem, recently shown to be subcubic~\cite{bringmann2019truly}, suggesting its possible tractability. Previous results on ECP and LED were primarily of a theorietical nature, but now, thanks to our contributions, we have finally realized a practical prototype.

%String constraints
%
%Word equations

\section{Toy Example}

Suppose we are given the following context free grammar:

\begin{tidyinput}
S -> S and S | S or S | ( S ) | true | false | ! S
\end{tidyinput}

\noindent For reasons that will become clear in the following section, this is automatically rewritten into the equivalent grammar:

\begin{verbatim}
 F.! → !  ε+ → ε      S → false    F.and → and
 F.( → (  ε+ → ε+ ε+  S → F.! S      S.) → S F.)
 F.) → )   S → <S>    S → S or.S    or.S → F.or S
 F.ε → ε   S → true   S → S and.S  and.S → F.and S
F.or → or  S → S ε+   S → F.( S.)
\end{verbatim}

%\noindent We can visualize the CFG as either a graph or a matrix:
%
%\begin{figure}[H]
%    \includegraphics[width=3.5cm]{../figures/bool_arith_cfg_graph.png}
%    \hspace{20pt}
%    \includegraphics[width=3.5cm]{../figures/bool_arith_cfg_mat.bmp}
%\end{figure}

\noindent If provided with a string containing a number of holes, our tool will return a dozen completions in a few milliseconds:

\begin{tidyinput}
true _ _ _ ( false _ ( _ _ _ _ ! _ _ ) _ _ _ _
\end{tidyinput}

\begin{tidyoutput}
true or ! ( false or ( <S> ) or ! <S> ) or <S>
true or ! ( false and ( <S> ) or ! <S> ) or <S>
true or ! ( false and ( <S> ) and ! <S> ) or <S>
true or ! ( false and ( <S> ) and ! <S> ) and <S>
true and ( false and ( <S> ) and ! ! <S> ) and <S>
true or ! ( false or ( ! <S> ) or ! <S> ) or <S>
true or ! ( false or ( <S> ) or ! ! <S> ) and <S>
true or ! ( false and ( <S> ) or ! ! <S> ) and <S>
true or ! ( false and ( ! <S> ) and ! <S> ) and <S>
true and ! ( false and ( <S> ) and ! ! <S> ) and <S>
true or ! ( false or ( ! <S> and ! ! <S> ) or <S> )
true or ( ( false and ( <S> ) and ! ! <S> ) or <S> )
\end{tidyoutput}

\noindent Similarly, if provided with a string containing various errors, Tidyparse will return several suggestions how to fix it, where \hlgreen{green} is insertion, \hlorange{orange} is substitution and \hlred{red} is deletion.

\begin{tidyinput}
true and ( false or and true false
\end{tidyinput}

\begin{tidyoutput}
1.) true and ( false or (*@\hlorange{!}@*) true (*@\hlorange{)}@*)
2.) true and ( false or (*@\hlgreen{<S>}@*) and true (*@\hlorange{)}@*)
3.) true and ( false or (*@\hlorange{(}@*) true (*@\hlorange{)}@*) (*@\hlgreen{)}@*)
4.) true and ( false or (*@\hlorange{!}@*) (*@\hlorange{!}@*) false (*@\hlgreen{)}@*)
5.) true and ( false or (*@\hlorange{<S>}@*) (*@\hlorange{or}@*) false (*@\hlgreen{)}@*)
6.) true and ( false or (*@\hlgreen{!}@*) (*@\hlgreen{<S>}@*) and true (*@\hlorange{)}@*)
7.) true and ( false or (*@\hlorange{!}@*) (*@\hlorange{(}@*) false (*@\hlgreen{)}@*) (*@\hlgreen{)}@*)
8.) true and ( false or (*@\hlorange{!}@*) true (*@\hlorange{)}@*) (*@\hlgreen{or}@*) (*@\hlgreen{<S>}@*)
9.) true and ( false or (*@\hlgreen{!}@*) (*@\hlgreen{<S>}@*) (*@\hlgreen{)}@*) and true (*@\hlred{false} @*)
\end{tidyoutput}

\noindent In the following paper, we will describe how we built it.

% TODO: https://muug.ca/mirror/ctan/macros/latex/contrib/qtree/qtreenotes.pdf
%\begin{figure}[H]
%\resizebox{.45\textwidth}{!}{
%  \Tree [.\texttt{S} \texttt{true} \texttt{and} [.\texttt{S} !\qsetw{-3cm} \texttt{(} [.\texttt{S} [.\texttt{S} \texttt{false} \texttt{or} \texttt{<S>} ] \texttt{and} \texttt{true} ] \texttt{)} ] ]
%}
%\end{figure}

%\noindent All the above visualizations were generated automatically.

\section{Matrix Theory}

We recall that a CFG is a quadruple consisting of terminals, $\Sigma$, nonterminals, $V$, productions, $P: V \rightarrow (V \mid \Sigma)^*$, and the start symbol, $S$. It is a well-known fact that every CFG can be reduced to \textit{Chomsky Normal Form} (CNF), $P^*: V \rightarrow (V^2 \mid \Sigma)$, in which every production takes one of two forms, either $v_0 \rightarrow v_1 v_2$, or $v_0 \rightarrow \sigma$, where $v_{0, 1, 2}: V$ and $\sigma: \Sigma$. For example, we can rewrite the CFG $\{S \rightarrow S S \mid ( S ) \mid ()\}$, into CNF as:

\[
\{S\rightarrow XR \mid SS \mid LR,\; L \rightarrow (,\; R \rightarrow ),\; X\rightarrow LS\}
\]

\noindent Given a CFG, $\mathcal{G} : \Sigma, \langle V, P, S\rangle$ in CNF, we can construct a recognizer $R_\mathcal{G}: \Sigma^n \rightarrow \mathbb{B}$ for strings $\sigma: \Sigma^n$ as follows. Let $\mathcal P(V)$ be our domain, $0$ be $\varnothing$, $\oplus$ be $\cup$, and $\otimes$ be defined as:

\begin{align}
a \otimes b := \{C \mid \langle A, B\rangle \in a \times b, (C\rightarrow AB) \in P\}
\end{align}

\noindent We initialize $\mathbf{M}^0_{r,c}(\mathcal{G}, \sigma) \coloneqq \{V \mid c = r + 1, (V \rightarrow \sigma_r) \in P\}$ and search for a matrix $\mathbf{M}^*$ via fixpoint iteration,

\begin{align}
\mathbf{M}^* = \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
   \varnothing & \{V\}_{\sigma_1} & \Cdots                  &                            & \mathcal{T} \\
   \Vdots      & \Ddots           & \Ddots[shorten=-0.1cm]  & \phantom{\{V\}_{\sigma_2}} & \Vdots \\
               &                  &                         &                            & \\
               &                  &                         &                            & \{V\}_{\sigma_n} \\
   \varnothing & \Cdots           &                         &                            & \varnothing
\end{pNiceMatrix}
\end{align}

\noindent where $\mathbf{M}^*$ is the least solution to $\mathbf{M} = \mathbf{M} + \mathbf{M}^2$. We can then define the recognizer as: $S \in \mathcal{T}? \iff \sigma \in \mathcal{L}(\mathcal{G})?$ %\footnote{Strictly speaking, $\mathbf{M} = \mathbf{M} + \mathbf{M}^2$ is only necessary if we need to do fixedpoint iteration. Since we solve for $\mathbf{M}^*$ and $S \in \mathcal{T}$ directly, then unlike Valiant, we can solve for the computationally more efficient fixpoint $\mathbf{M} = \mathbf{M}^2$.}

While theoretically elegant, this decision procedure can be optimized by lowering onto a rank-3 binary tensor. We do so simply by noting that $\bigoplus_{k = 1}^n \mathbf{M}_{ik} \otimes \mathbf{M}_{kj}$ has cardinality bounded by $|V|$ and is thus representable as a fixed-length vector using the characteristic function, $\mathds{1}$. In particular, $\oplus, \otimes$ are defined as $\boxplus, \boxtimes$, so that the following diagram commutes:

\[\begin{tikzcd}[row sep=huge, column sep=huge]
  V \times V \arrow[r, "\oplus/\otimes"] \arrow[d, "\mathds{1}^2"]
  & V \arrow[d, "\mathds{1}\phantom{^{-1}}"] \\
  \mathbb{B}^{|V|} \times \mathbb{B}^{|V|} \arrow[r, "\boxplus/\boxtimes", labels=below] \arrow[u, "\mathds{1}^{-2}"]
  & \mathbb{B}^{|V|} \arrow[u, "\mathds{1}^{-1}"]
\end{tikzcd}\]

Though convenient for SAT encoding, the compactness of this representation can be improved using a combinatorial number system without loss of generality. By allowing the matrix $\mathbf{M}^0_{r, c}$ to contain bitvector variables $\mathcal{B}^{|V|}$ representing holes in the string, we obtain a set of multilinear equations whose solutions exactly correspond to the set of admissible repairs and their corresponding parse trees. This is described in further detail in \S\ref{sec:sat}.

Full details of the bisimilarity between parsing and matrix multiplication can be found in Valiant~\cite{valiant1975general}, who shows its time complexity to be $\mathcal{O}(n^\omega)$ where $\omega$ is the matrix multiplication bound, and Lee~\cite{lee2002fast}, showing that speedups to Boolean matrix multiplication may be translated back into CFG parsing. By assuming sparsity, this technique can typically be reduced to linearithmic time, and is currently the best known asymptotic bound for CFL recognition to date.

\subsection{Sampling k-combinations without replacement}

\noindent Let $\textbf{M}: \text{GF}(2^{n\times n})$ be a matrix with the structure $\mathbf{M}^0_{r, c} = P_c \text{ if } r=0 \text{ else } \mathds{1}[c = r - 1]$, where $P$ is a feedback polynomial over $GF(2^n)$ with coefficients $P_{1\ldots n}$ and semiring operators $\oplus := \veebar, \otimes := \land$:\\

\begin{align}
    \mathbf{M}^tV = \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
        P_1    & \Cdots &        &       &        & P_n \\
        \top   & \circ  & \Cdots &       &        & \circ \\
        \circ  & \Ddots & \Ddots &       &        & \Vdots \\
        \Vdots & \Ddots &        &       &        & \\
               &        &        &       &        & \\
        \circ  & \Cdots &        & \circ & \top   & \circ
    \end{pNiceMatrix}^t
    \begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
        V_1 \\
        \Vdots \\
        \\
        \\
        \\
       V_n
    \end{pNiceMatrix}
\end{align}

Selecting any $V \neq \mathbf{0}$ and coefficients $P_{1\ldots n}$ from a known \textit{primitive polynomial} then powering the matrix $\mathbf{M}$ generates an ergodic sequence over GF$(2^n)$:\\

\begin{align}
    \mathbf{S} = \begin{pmatrix}V & \mathbf{M}V & \mathbf{M}^{2}V & \mathbf{M}^{3}V & \cdots & \mathbf{M}^{2^n-1}V \end{pmatrix}
\end{align}

\noindent This sequence has \textit{full periodicity}, in other words, for all $i, j \in [0, 2^n), \mathbf{S}_i = \mathbf{S}_j \Rightarrow i = j$.


To uniformly sample $\bm\sigma \sim \Sigma^n$ without replacement, we could track historical samples and do rejection sampling, or, we can form an injection $GF(2^n)\rightharpoonup\Sigma^d$, cycle a primitive polynomial over $GF(2^n)$, then discard samples that do not identify an element in any indexed dimension. This procedure rejects $(1 - |\Sigma|2^{-\lceil\log_2|\Sigma|\rceil})^d$ samples on average and requires $\sim\mathcal{O}(1)$ per sample and $\mathcal{O}(2^n)$ to exhaustively search the space.

For example if we wanted to sample $\Sigma^2 = \{A, B, C\}^2$, we can use the primitive polynomial $x^4 + x^3 +1$

\begin{verbatim}
   S₀    S₁    S₂    S₃    S₄    S₅    S₆    S₇
  1000  0100  0010  1001  1100  0110  1011  0101
  C A   B A   A C   C B         B C         B B
\end{verbatim}

\pagebreak
\section{SAT Encoding}\label{sec:sat}

Specifically, the repairs occur along holes in the superdiagonal $\mathbf{M}^*_{r+1 = c}$, and the upper-triangular entries $\mathbf{M}^*_{r + 1 < c}$ represent the corresponding parse forests. If no solution exists, then the upper triangular entries will appear as a jagged-shaped ridge whose peaks represent the roots of the parsable subtree. We illustrate this fact in \S\ref{sec:error}:

\begin{figure}[H]
    \includegraphics[width=2cm]{../figures/parse1.png}
    \includegraphics[width=2cm]{../figures/parse2.png}
    \includegraphics[width=2cm]{../figures/parse3.png}
    \includegraphics[width=2cm]{../figures/parse4.png}
\end{figure}

We precompute the shadow of fully-resolved substrings before feeding it to the SAT solver. If the substring is known, we can simply compute this directly outside the SAT solver. Shadow regions are bitvector literals and light regions correspond to bitvector variables.

\newcommand\ddd{\Ddots}
\newcommand\vdd{\Vdots}
\newcommand\cdd{\Cdots}
\newcommand\lds{\ldots}
\newcommand\vno{\varnothing}
\newcommand{\ts}[1]{\textsuperscript{#1}}
\newcommand\non{1\ts{st}}
\newcommand\ntw{2\ts{nd}}
\newcommand\nth{3\ts{rd}}
\newcommand\nfo{4\ts{th}}
\newcommand\nfi{5\ts{th}}
\newcommand\nsi{6\ts{th}}
\newcommand\nse{7\ts{th}}
\newcommand{\vs}[1]{\{V\}_{\sigma_{#1}}}
\newcommand\rcr{\rowcolor{black!15}}
\newcommand\rcw{\rowcolor{white}}
\newcommand\pcd{\cdot}
\newcommand\pcp{\phantom\cdot}
\newcommand\ppp{\phantom{\nse}}

\begin{figure}[H]
\[
  \mathbf{M} = \begin{pNiceArray}{>{\strut}ccccccc}[margin, extra-margin=2pt,colortbl-like, xdots/line-style=loosely dotted]
    \vno & \rcr \vs{1} &  \mathcal{L}_{1,3} & \mathcal{L}_{1,3} & \rcw \mathcal{V}_{1,4} & \cdd                 & \mathcal{V}_{1,n} \\
    \vdd & \ddd        &  \rcr\vs{2}        & \mathcal{L}_{2,3} & \rcw \mathcal{V}_{2,4} & \cdd                 & \mathcal{V}_{2,n} \\
         &             &                    & \rcr\vs{3}        & \rcw \mathcal{V}_{3,4} & \cdd                 & \mathcal{V}_{3,n} \\
         &             &                    &                   & \mathcal{V}_{4,4}      &                      & \vdd \\
         &             &                    &                   &                        & \ddd[shorten=-0.1cm] &      \\
         &             &                    &                   &                        &                      & \mathcal{V}_{n,n} \\
    \vno & \cdd        &                    &                   &                        &                      & \vno
  \end{pNiceArray}
\]

\caption{SAT tensor representing the string \hlgray{$\sigma_1\:\sigma_2\:\sigma_3$}$\:\_\:\_\:\ldots\:\_$ in which shaded regions demarcate precomputed bitvector literals $\mathcal{L}_{r,c}$ (i.e., representing resolved nonterminal forests) and unshaded regions correspond to bitvector variables $\mathcal{V}_{r,c}$ (i.e., representing seeded nonterminal forests to be grown).}
\end{figure}


\pagebreak\section{Error Recovery}\label{sec:error}

Unlike classical parsers which totally fail on an error or need special support for error-recovery, if the tree cannot parse, we can do error recovery with partial subtrees. These subtrees provide a natural debugging environment to aid the repair process.

\begin{tidyinput}
true and true ! and false or true ! true and false
\end{tidyinput}

\begin{verbatim}
 Parseable subtrees (3 leaves / 2 branches)
\end{verbatim}
\hspace{0.64cm}\emoji{herb}\hspace{1.70cm}\emoji{herb}\hspace{1.98cm}\emoji{herb}\vspace{-14pt}
\begin{verbatim}
    └── ! [3]   └── and [4]   └── or [6]
\end{verbatim}
\hspace{0.63cm}\emoji{herb}\hspace{3.4cm}\emoji{herb}\vspace{-14pt}
\begin{verbatim}
    └── S [0..2]          └── S [8..11]
        ├── true [0]          ├── S [8..9]
        ├── and [1]           │   ├── ! [8]
        └── true [2]          │   └── true [9]
                              ├── and [10]
                              └── false [11]
\end{verbatim}

\noindent These branches correspond to peaks on the upper triangular (UT) matrix ridge. We traverse the peaks by elevation from highest to lowest to collect the partial AST branches.

\begin{figure}[H]
\[
  \setcounter{MaxMatrixCols}{30}
  \begin{NiceMatrix}
                 & \nse & \nsi & \nfi & \nfo & \nth & \ntw & \non & \ppp & \ppp \\
                 &      & \ddd & \ddd & \ddd & \ddd & \ddd & \ddd & \ddd & \ppp \\
\{V\}_{\sigma_1} & \cdd &      & A    &      &      &      &      &      & \ppp \\
\varnothing      & \ddd &  T_A & \vdd &      &      &      &      &      & \ppp \\
\vdd             & \ddd &      & \pcd & \cdd &      & B    &      &      & \ppp \\
                 &      &      &      &      & T_B  & \vdd &      &      & \ppp \\
                 &      &      &      &      &      & \pcd & \cdd &      & C    \\
                 &      &      &      &      &      &      &      & T_C & \vdd \\
                 &      &      &      &      &      &      & \text{\emoji{cross-mark}} &      & \\
                 &      &      &      &      &      &      &      &      & \\
                 &      &      &      &      &      &      &      &      & \\
                 &      &      &      &      &      &      &      & \ppp & \{V\}_{\sigma_n} \\
\varnothing      & \cdd &      &      &      &      &      &      & \varnothing &
  \end{NiceMatrix}
\]
    \caption{Peaks along the UT matrix ridge correspond to maximally parseable substrings. By recursing over upper diagonals of decreasing elevation and discarding all subtrees that fall under the shadow of another's canopy, we can recover the partial AST branches. The example depicted above contains three such branches, rooted at nonterminals $C, B, A$.}
\end{figure}

\pagebreak\section{Hollowing Procedure}

So we have a procedure $P: \mathcal{G} \times \Sigma^d \rightarrow \{\Sigma^d\}$. But where do we put the holes? For a given number of holes, k, there are roughly ${n \choose k}$ possible repairs. In practice the cardinality of this space can be very large. In order to sample without replacement from this space, we generate the repairs in the following order.

\begin{enumerate}
  \item We exclude parsable substrings from hollowing.
  \item Lazily enumerate all possible hole configurations of increasing length.
  \item For each size, sample uniformly without replacement using a Galois field.
  \item Hole configurations are prioritized by distance to caret location.
  \item Hole configurations are prioritized by distance to fishy locations.
  \item We feed the hole configurations to the incremental SAT solver.
  \item The first dozen results are decoded and displayed to the user in order of increasing Levenshtein distance.
\end{enumerate}

The entire procedure is lazy and intermediate results are cached to avoid recomputation. Incoming keystrokes interrupt the solver.

\section{Implementation}

Tidyparse accepts a CFG and a string to parse and returns a set of candidate strings, ordered by their Levenshtein edit distance to the original string. Our method lowers the CFG and candidate string onto a matrix dynamical system using an extended version of Valiant's construction and solves for the fixpoint matrix using an incremental SAT solver.

    Here is how we implemented it (and so can you)~\cite{valiant1975general}.
\section{Examples}
There are some more examples too.

The line between parsing and computation is blurry.

\section{Conclusion}

Our approach to parsing has many advantages...

\section{Acknowledgements}
The first author would like to thank his co-advisor Xujie Si for providing many helpful suggestions during the development of this project, including the optimized fixpoint, test cases, and tree denomalization procedure, and collaborator Nghi Bui for early feedback.

\bibliography{../bib/acmart}
\end{document}