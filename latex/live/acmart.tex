%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
\documentclass[sigplan,nonacm]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[ARRAY'22]{ACM SIGPLAN Conference on Programming Languages}{June 13, 2022}{San Diego, CA, USA}
%\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage{colortbl}

%% Bibliography style
\bibliographystyle{acmart}

\input{preamble.tex}
\begin{document}

%% Title information
\title{Tidyparse: Real-Time Context Free Error Correction}
\begin{abstract}
Tidyparse is a program synthesizer that performs real-time error correction for context free languages.
Given an arbitrary context free grammar (CFG) and candidate string to parse, the tool will lazily generate admissible repairs while the author is typing, ranked in order of Levenshtein edit distance.
 Repairs are guaranteed to be sound and complete, syntactically valid and minimal.
 Tidyparse is the first system of its kind which offers these guarantees in a real-time editor. To accelerate code completion, we implement a novel incremental parsing algorithm that lowers CFGs onto a dynamical system over finite field arithmetic, which enables us to suggest syntax repairs in-between keystrokes. We have released an IDE plugin implementing the system described.\footnote{https://plugins.jetbrains.com/plugin/19570-tidyparse}
\end{abstract}

\author{Breandan Mark Considine}
\affiliation{
  \institution{McGill University}
}
\email{bre@ndan.co}

\author{Jin Guo}
\affiliation{
  \institution{McGill University}
}
\email{jguo@cs.mcgill.ca}

\author{Xujie Si}
\affiliation{
  \institution{McGill University}
}
\email{xsi@cs.mcgill.ca}

\maketitle

\section{Introduction}

Modern research on error correction can be traced back to the early days of coding theory, when researchers designed \textit{error-correcting codes} to denoise transmission errors induced by external interference, for instance, collision with a high-energy proton, manipulation by a cryptographic adversary, typographical error, or mistranslation from a natural to a formal language, such as English and code. In this context, \textit{code} is simply a logical representation for communicating information between two parties, e.g., a human and a computer. An \textit{error-correcting code} (ECC) is a mapping from a $k$-dimensional vector space to a $n$-dimensional vector space which promises that, even if $t$ or fewer coordinates of the output space are corrupted, the original message can be recovered by solving a linear system of at most $t$ equations. % The largest possible value of $k/n$ is called the \textit{rate} of the code. For example, the Hamming code, discovered by Richard Hamming in the 1950s, has a rate of $1/2$ and can correct up to one error. Others, such as BCH, Shannon, Huffman, Turbo and Reedâ€“Solomon have improved upon $k/n$ and $t$.

In programming, most errors initially manifest as syntax errors, and though often cosmetic, manual repair can present a significant obstacle for novice programmers. We can refine the concept of error correction by introducing a language $\mathcal{L} \subset \Sigma^*$ and considering the minimal number of tokenwise edits that transform an arbitrary string $\Sigma^*$ into a string in $\mathcal{L}$. Known as \textit{language edit distance} (LED), this problem was recently proven to be subcubic~\cite{bringmann2019truly}, strongly indicating its tractability: by considering not only distance, but the specific repair, we obtain an \textit{error-correcting parser} (ECP), which historically were big in early parsing literature but fell out of favor for many years. Alfred Aho~\cite{aho1972minimum} looked into it. Leslie Valiant~\cite{valiant1975general} looked into it. Prior results were primarily of a theorietical nature, but now, thanks to our contributions, we finally have a practical prototype.

%String constraints
%
%Word equations


\section{Theory}

Tidyparse is a plugin that takes a CFG and a string to parse and returns a set of candidate strings. We compile the parser into a matrix using a modified version of Valiant's construction and solve the matrix completion problem using an incremental SAT solver.

\section{Implementation}
    Here is how we implemented it (and so can you)~\cite{valiant1975general}.
\section{Examples}
    There are examples too.
\bibliography{../bib/acmart}
\end{document}