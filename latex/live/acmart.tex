%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review,anonymous]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
\documentclass[sigplan,nonacm]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[ARRAY'22]{ACM SIGPLAN Conference on Programming Languages}{June 13, 2022}{San Diego, CA, USA}
%\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage{colortbl}

%% Bibliography style
\bibliographystyle{acmart}

\input{preamble.tex}
\begin{document}

%% Title information
\title{Tidyparse: Real-Time Context Free Error Correction}
\begin{abstract}
Tidyparse is a program synthesizer that performs real-time error correction for context free languages.
Given an arbitrary context free grammar (CFG) and candidate string to parse, the tool will lazily generate admissible repairs while the author is typing, ranked in order of Levenshtein edit distance.
 Repairs are guaranteed to be sound and complete, syntactically valid and minimal.
 Tidyparse is the first system of its kind which offers these guarantees in a real-time editor. To accelerate code completion, we implement a novel incremental parsing algorithm that lowers CFGs onto a dynamical system over finite field arithmetic, which enables us to suggest syntax repairs in-between keystrokes. We have released an IDE plugin implementing the system described.\footnote{https://plugins.jetbrains.com/plugin/19570-tidyparse}
\end{abstract}

\author{Breandan Mark Considine}
\affiliation{
  \institution{McGill University}
}
\email{bre@ndan.co}

\author{Jin Guo}
\affiliation{
  \institution{McGill University}
}
\email{jguo@cs.mcgill.ca}

\author{Xujie Si}
\affiliation{
  \institution{McGill University}
}
\email{xsi@cs.mcgill.ca}

\maketitle

\section{Introduction}

Modern research on error correction can be traced back to the early days of coding theory, when researchers designed \textit{error-correcting codes} to denoise transmission errors induced by external interference, for instance, collision with a high-energy proton, adversarial manipulation, typographical mistakes, or mistranslation across natural and formal languages, such as English and code. In general, \textit{code} is simply a representation of symbolic information shared between two or more communicating agents, e.g., humans and computers. Most programming errors initially manifest as syntax errors, the correction of which has the potential to lift a significant barrier to programmer productivity.

Coding theory -

e.g., BCH, Shannon, Huffman, Reedâ€“Solomon

String constraints

Word equations

Historically error correcting parsers were big in the early days of parsing theory but somehow fell out of favor. Aho looked into it. Valiant looked into it. And finally, thanks to our contributions, we now have a working prototype.

\section{Theory}

Tidyparse is a plugin that takes a CFG and a string to parse and returns a set of candidate strings. We compile the grammar into a matrix.

\section{Implementation}
    Here is how we implemented it (and so can you)~\cite{valiant1975general}.
\section{Examples}
    There are examples too.
\bibliography{../bib/acmart}
\end{document}