\documentclass{beamer}
\usetheme{Madrid}
\beamertemplatenavigationsymbolsempty
\usepackage{graphicx}
\usepackage{pgf-soroban}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric,calc,decorations.text}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{dsfont}
\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{fontspec}
\setmonofont{JetBrains Mono}[
    Contextuals = Alternate,
    Ligatures = TeX,
]
\usepackage{listings}

\lstdefinelanguage{Kotlin}{
    basicstyle = \footnotesize\ttfamily,
    comment=[l]{//},
    commentstyle={\color{gray}\ttfamily},
    emph={delegate, filter, first, firstOrNull, forEach, lazy, map, mapNotNull, println, return@},
    emphstyle={\color{red}},
    identifierstyle=\color{black},
    keywords={abstract, actual, as, as?, break, by, class, companion, continue, data, do, dynamic, else, enum, expect, false, final, for, fun, get, if, import, in, interface, internal, is, null, object, operator, override, package, private, public, return, sealed, set, super, suspend, this, throw, true, try, typealias, val, var, vararg, when, where, while},
    keywordstyle={\color{blue}\bfseries},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[s]{"""*}{*"""},
    ndkeywords={@Deprecated, @JvmField, @JvmName, @JvmOverloads, @JvmStatic, @JvmSynthetic, Array, Byte, Double, Float, Int, Integer, Iterable, Long, Runnable, Short, String},
    ndkeywordstyle={\color{Orange}\bfseries},
    sensitive=true,
    stringstyle={\color{green}\ttfamily},
    showstringspaces=false,
}
\makeatletter
\renewcommand*\verbatim@nolig@list{}
\makeatother

\title[Array Programming on $GF(2^n)$]{Probabilistic Array Programming on Galois Fields}
\author[Considine, Guo, Si]{Breandan Considine, Jin Guo, Xujie Si}
\institute[McGill]{
    McGill University, Mila IQIA\\
    \medskip
    \textit{breandan.considine@mail.mcgill.ca}
}
\date{\today}

\begin{document}
    \begin{frame}
        \titlepage
    \end{frame}

    \begin{frame}
        \frametitle{Overview}
        \tableofcontents
    \end{frame}

    \section{Algebraic Parsing}\label{sec:algebraic-parsing}

    %------------------------------------------------------------------------------------------------

    \begin{frame}
        \frametitle{Recap: Context Free Grammars}
        Suppose we have a context free grammar (CFG) $G = \langle V, \Sigma, P, S\rangle$ where $V$ is the set of nonterminals, $\Sigma$ is the terminals, $P: V\times (V \cup \Sigma)^+$ are the productions, $S\in V$ is the start symbol and $+$ is the Kleene plus.\newline\\
        %
        For example, consider the grammar $S \rightarrow S S \mid ( S ) \mid ()$. This represents the language of balanced parentheses, e.g. $(), ()(), (()), ()(()), (()()), (())()\ldots$\newline\\
        %
        Every CFG has a normal form $P^*: V \times (V^2 \mid \Sigma)$, i.e., every production can be refactored into either $v_0 \rightarrow v_1 v_2$ or $v_0 \rightarrow \sigma$, where $v_{0\ldots2}: V$ and $\sigma: \Sigma$, e.g., $\underline{S \rightarrow S S \mid ( S ) \mid ()}\Leftrightarrow^*\underline{S\rightarrow XR \mid SS \mid LR, L \rightarrow (, R \rightarrow ), X\rightarrow LS}$

        \begin{center}
        \begin{tikzpicture}[font=\sffamily,breathe dist/.initial=4ex]
            \foreach \X [count=\Y,remember=\Y as \LastY] in
                {regular,context free}
                {\ifnum\Y=1
            \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
            \else
            \path[decoration={text along path,
            text={|\sffamily|\X},text align=center,raise=0.3ex},decorate]
        let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
            in (F-\LastY.west) arc(180:0:\x1 and \y1);
            \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
            -(F-\LastY.south)$),
            \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
            in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
            node[minimum height=\y1,minimum width={\y1*\x2/\y3},
            draw,ellipse,inner sep=0pt, fill=black!30!white] (F-\Y){};
            \fi
            }
            \foreach \X [count=\Y,remember=\Y as \LastY] in
                {regular,context free,context sensitive,recursively enumerable}
                {\ifnum\Y=1
            \node[ellipse,draw,outer sep=0pt] (F-\Y) {\X};
            \else
            \path[decoration={text along path,
            text={|\sffamily|\X},text align=center,raise=0.3ex},decorate]
        let \p1=($(F-\LastY.north)-(F-\LastY.west)$)
            in (F-\LastY.west) arc(180:0:\x1 and \y1);
            \path let \p1=($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)
            -(F-\LastY.south)$),
            \p2=($(F-1.east)-(F-1.west)$),\p3=($(F-1.north)-(F-1.south)$)
            in ($([yshift=\pgfkeysvalueof{/tikz/breathe dist}]F-\LastY.north)!0.5!(F-\LastY.south)$)
            node[minimum height=\y1,minimum width={\y1*\x2/\y3},
            draw,ellipse,inner sep=0pt] (F-\Y){};
            \fi}
        \end{tikzpicture}
        \end{center}
    \end{frame}


    \begin{frame}
        \frametitle{Algebraic Parsing}
        Given a CFG $\mathcal{G} \coloneqq \langle V, \Sigma, P, S\rangle$ in Chomsky Normal Form, we can construct a recognizer $R_\mathcal{G}: \Sigma^n \rightarrow \mathbb{B}$ for strings $\sigma: \Sigma^n$ as follows. Let $\mathcal P(V)$ be our domain, $0$ be $\varnothing$, $\oplus$ be $\cup$, and $\otimes$ be defined as:

        \vspace{-7pt}
        \[
            a \otimes b \coloneqq \{C \mid \langle A, B\rangle \in a \times b, (C\rightarrow AB) \in P\}
        \]

        \noindent We initialize $\mathbf{M}^0_{r,c}(\mathcal{G}, \sigma) \coloneqq \{V \mid c = r + 1, (V \rightarrow \sigma_r) \in P\}$ and search for a matrix $\mathbf{M}^*$ via fixpoint iteration,

        \vspace{-5}
        \[
            \mathbf{M}^* = \begin{pmatrix}
                               \varnothing & \{V\}_{\sigma_1} & \ldots & \ldots & \mathcal{T} \\
                               \varnothing & \varnothing & \{V\}_{\sigma_2} & \ldots & \ldots \\
                               \varnothing & \varnothing & \varnothing & \{V\}_{\sigma_3} & \ldots \\
                               \varnothing & \varnothing & \varnothing & \varnothing & \{V\}_{\sigma_4} \\
                               \varnothing & \varnothing & \varnothing & \varnothing & \varnothing
            \end{pmatrix}
        \]

        \noindent where $\mathbf{M}^*$ is the least solution to $\mathbf{M} = \mathbf{M} + \mathbf{M}^2$. We can then define the recognizer as $R \coloneqq \mathds{1}_{\mathcal{T}}(S) \iff \mathds{1}_{\mathcal{L}(\mathcal{G})}(\sigma)$.
    \end{frame}

    \begin{frame}
        \frametitle{Observations}
        \begin{itemize}
            \item The matrix $\mathbf M^*$ is strictly upper triangular, i.e., nilpotent of degree $n$
            \item The $\otimes$ operator is (sadly) \textit{not} associative TODO: give example
            \item A na\"ive solver has complexity $\mathcal{O}(n^4)$, this can be reduced to $\mathcal{O}(n^\omega)$
            \item Recognizer be easily translated into a parser by storing backpointers
            \item Built-in error recovery: nonempty submatrices = parsable fragments
            \item Binarized parser can be efficiently compiled to a SAT solver
            \item Supports sketch-based synthesis in the string or grammar
        \end{itemize}
    \end{frame}

    \begin{frame}
        \frametitle{Binarization}
        \begin{itemize}
            \item Can be lowered onto a Boolean tensor $\mathbb{B}^{n\times n \times |V|}$ (Valiant, 1975)
            \item We simply encode the characteristic function $\mathds{1}_{\subseteq V}: V\rightarrow \mathbb{B}^{|V|}$
            \item $\oplus$ is defined as $\boxplus$ and $\otimes$ is $\boxtimes$, where $\boxplus, \boxtimes: \mathbb{B}^{|V|}\times\mathbb{B}^{|V|} \rightarrow \mathbb{B}^{|V|}$
            \item For most grammars, only a few nonterminals are active at any time
            \item More sophisticated encodings are known for $\binom{n}{0 \leq k}$ subsets
            \item If density is needed, possible to use the Maculay representation
            \item These operators can be lifted into matrices/tensors in the usual way
            \item Set joins are an active topic of research in SQL query optimization
            \item If you know of a more efficient encoding, I want to talk to you!
        \end{itemize}
    \end{frame}

%    \section{IDE Tool}\label{sec:ide}
%
%    \section{Tidyparse tool}\label{sec:tidyparse}

    \section{The Abacus}

    \begin{frame}
        We can describe the abacus as a kind of reduction system.
        \ladj{0.25}
        \frametitle{Abacus}
        \begin{prooftree}
            \AxiomC{
                \begin{tikzpicture}
                    \tige{1}{0}{0}
                    \barres{1}
                \end{tikzpicture}
            }
            \AxiomC{$+1$}
            \BinaryInfC{
                \begin{tikzpicture}
                    \tige{1}{1}{0}
                    \barres{1}
                \end{tikzpicture}
            }
            \DisplayProof
            \hskip 1.5em
            \AxiomC{
                \begin{tikzpicture}
                    \tige{1}{4}{0}
                    \barres{1}
                \end{tikzpicture}
            }
            \AxiomC{$+1$}
            \BinaryInfC{
                \begin{tikzpicture}
                    \tige{1}{5}{0}
                    \barres{1}
                \end{tikzpicture}
            }
            \DisplayProof
            \hskip 1.5em
            \AxiomC{
                \begin{tikzpicture}
                    \tige{1}{0}{0}
                    \barres{1}
                    \tige[2]{1}{9}{0}
                    \barres[2]{1}
                \end{tikzpicture}
            }
            \AxiomC{$+1$}
            \BinaryInfC{
                \begin{tikzpicture}
                \tige{1}{1}{0}
                \barres{1}
                \tige[2]{1}{0}{0}
                \barres[2]{1}
                \end{tikzpicture}
            }
        \end{prooftree}
    \end{frame}

    \begin{frame}[fragile]
        \frametitle{Dependent types}
%        \ladj{0.25}
%        \begin{tikzpicture}
%            \tige{1}{0}{0}
%            \tige{2}{3}{0}
%            \tige{3}{2}{0}
%            \tige{4}{1}{0}
%            \tige{5}{4}{0}
%            \tige{6}{9}{0}
%            \cadre{6}
%        \end{tikzpicture}
        \begin{lstlisting}[language=Kotlin, gobble=7]
        sealed class B<X, P : B<X, P>>(open val x: X? = null) {
          val T: T<P> get() = T(this as P)
          val F: F<P> get() = F(this as P)
        }

        class T<X>(override val x: X = Ø as X) : B<X, T<X>>(x) {
          companion object: T<Ø>(Ø)
        }

        class F<X>(override val x: X = Ø as X) : B<X, F<X>>(x) {
          companion object: F<Ø>(Ø)
        }

        val b0: F<Ø> = F
        val b1: T<Ø> = T
        val b2: F<T<Ø>> = T.F
        val b3: T<T<Ø>> = T.T
        val b4: F<F<T<Ø>>> = T.F.F
        \end{lstlisting}
    \end{frame}


    \begin{frame}[fragile]
        \frametitle{Dependent types}
%        \ladj{0.25}
%        \begin{tikzpicture}
%            \tige{1}{0}{0}
%            \tige{2}{3}{0}
%            \tige{3}{2}{0}
%            \tige{4}{1}{0}
%            \tige{5}{4}{0}
%            \tige{6}{9}{0}
%            \cadre{6}
%        \end{tikzpicture}
        \begin{lstlisting}[language=Kotlin, gobble=7]
        typealias B_0<B> = F<B>             typealias BØ = F<Ø>
        typealias B_1<B> = T<B>             typealias B1 = T<Ø>
        typealias B_2<B> = F<T<B>>          typealias B2 = F<T<Ø>>
        typealias B_3<B> = T<T<B>>          typealias B3 = T<T<Ø>>
        typealias B_4<B> = F<F<T<B>>>       typealias B4 = F<F<T<Ø>>>
        typealias B_5<B> = T<F<T<B>>>       typealias B5 = T<F<T<Ø>>>
        typealias B_6<B> = F<T<T<B>>>       typealias B6 = F<T<T<Ø>>>
        typealias B_7<B> = T<T<T<B>>>       typealias B7 = T<T<T<Ø>>>
        typealias B_8<B> = F<F<F<T<B>>>>

        operator fun Ø.plus(t: T<Ø>) = b1
        operator fun B_0<Ø>.plus(t: T<Ø>) = b1
        operator fun B_1<Ø>.plus(t: T<Ø>): B_2<Ø> = F(x + b1)
        operator fun B_3<Ø>.plus(t: T<Ø>): B_4<Ø> = F(x + b1)
        operator fun B_7<Ø>.plus(t: T<Ø>): B_8<Ø> = F(x + b1)

        operator fun <K: B<*, *>> B_0<K>.plus(t: T<Ø>) = T(x)
        operator fun <K: B<*, *>> B_1<F<K>>.plus(t: T<Ø>) = F(x + b1)
        operator fun <K: B<*, *>> B_3<F<K>>.plus(t: T<Ø>) = F(x + b1)
        operator fun <K: B<*, *>> B_7<F<K>>.plus(t: T<Ø>) = F(x + b1)
        \end{lstlisting}
    \end{frame}

    \begin{frame}
        \begin{center}
            \Huge{Learn more at: \\~\\
            \href{http://array22.ndan.co}{\color{blue}{http://array22.ndan.co}}}
        \end{center}
    \end{frame}

    \begin{frame}
        \frametitle{Special thanks}
            \begin{center}
                \LARGE{
                    Nghi D. Q. Bui\\
                    Zhixin Xiong\\
                    Jaylene Zhang\\
                    David Yu-Tung Hui\\
                    Fabian Muehlboeck\\
                    Ben Greenman
                }

                \includegraphics[scale=0.3]{../figures/fpt_logo.png}
                \includegraphics[scale=0.2]{../figures/mila_logo.png}
            \end{center}
    \end{frame}
\end{document}