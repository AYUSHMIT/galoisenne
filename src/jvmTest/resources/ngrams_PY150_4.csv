NAME . NAME ( ::: 2757170
. NAME ( NAME ::: 1541629
) : NEWLINE INDENT ::: 1338771
NAME ( NAME ) ::: 1289469
: NEWLINE INDENT NAME ::: 1260666
NEWLINE NAME . NAME ::: 1117390
= NAME . NAME ::: 1073075
NAME ( NAME , ::: 1053383
NAME ) : NEWLINE ::: 1041208
NAME = NAME . ::: 1036034
. NAME . NAME ::: 1030619
NAME . NAME . ::: 1018214
( NAME , NAME ::: 966173
def NAME ( NAME ::: 836759
) NEWLINE NAME . ::: 784150
( NAME . NAME ::: 778121
NEWLINE NAME = NAME ::: 766586
NAME , NAME ) ::: 700555
NAME ( NAME . ::: 697045
. NAME ( ) ::: 651778
NAME , NAME , ::: 628607
, NAME , NAME ::: 620868
NEWLINE INDENT NAME = ::: 608351
DEDENT def NAME ( ::: 602624
. NAME ( STRING ::: 586855
( NAME ) : ::: 575148
) NEWLINE NAME = ::: 573528
NAME ) NEWLINE NAME ::: 520879
NAME = NAME ( ::: 502055
NAME : NEWLINE INDENT ::: 492995
NEWLINE DEDENT def NAME ::: 491062
NAME . NAME ) ::: 490278
NAME ( ) NEWLINE ::: 483455
NAME ) NEWLINE DEDENT ::: 477572
NAME . NAME = ::: 461552
NEWLINE INDENT NAME . ::: 454923
INDENT NAME . NAME ::: 454900
( NAME ) NEWLINE ::: 444682
NAME . NAME , ::: 443201
NAME , NAME = ::: 442735
INDENT NAME = NAME ::: 439301
, NAME . NAME ::: 416011
NAME ( STRING ) ::: 408835
STRING , STRING , ::: 378219
, NAME = NAME ::: 357576
NUMBER , NUMBER , ::: 353480
, NUMBER , NUMBER ::: 349334
, STRING , STRING ::: 347817
, NAME ) : ::: 335024
NAME ( STRING , ::: 330624
= NAME ( NAME ::: 315472
, NAME ) NEWLINE ::: 312710
: NEWLINE INDENT STRING ::: 306368
NEWLINE INDENT STRING NEWLINE ::: 306265
. NAME = NAME ::: 301811
. NAME , NAME ::: 297790
) NEWLINE DEDENT def ::: 291569
NAME [ STRING ] ::: 286204
. NAME ) NEWLINE ::: 284802
STRING ) NEWLINE NAME ::: 262261
( ) NEWLINE NAME ::: 258476
NAME ( NAME = ::: 250166
) NEWLINE DEDENT DEDENT ::: 250147
: NEWLINE INDENT return ::: 243590
NAME , NAME . ::: 240359
( STRING ) NEWLINE ::: 237253
NEWLINE def NAME ( ::: 229983
NAME . NAME NEWLINE ::: 229702
NAME import NAME NEWLINE ::: 226931
STRING , NAME = ::: 224246
STRING NEWLINE NAME = ::: 219557
STRING : STRING , ::: 218664
( STRING , NAME ::: 213585
STRING , STRING : ::: 211943
: STRING , STRING ::: 210701
NAME NEWLINE from NAME ::: 207390
. NAME import NAME ::: 204608
, STRING : STRING ::: 203098
, NAME = STRING ::: 202992
NAME . NAME import ::: 200699
from NAME . NAME ::: 197708
for NAME in NAME ::: 195968
{ STRING : STRING ::: 195416
NEWLINE from NAME . ::: 186024
NAME = NAME NEWLINE ::: 185700
NAME . NAME [ ::: 183519
) ) NEWLINE NAME ::: 180391
: NEWLINE INDENT if ::: 179936
import NAME NEWLINE from ::: 179091
NAME = STRING NEWLINE ::: 177223
if NAME . NAME ::: 175754
STRING : STRING } ::: 175062
NAME ) ) NEWLINE ::: 168659
NAME ( NAME ( ::: 168610
NAME [ NUMBER ] ::: 168237
) ) NEWLINE DEDENT ::: 165003
class NAME ( NAME ::: 163502
( STRING , STRING ::: 158700
, STRING ) NEWLINE ::: 158053
) . NAME ( ::: 156649
NAME . NAME : ::: 155646
INDENT STRING NEWLINE NAME ::: 155638
else : NEWLINE INDENT ::: 155241
DEDENT else : NEWLINE ::: 155126
NEWLINE INDENT return NAME ::: 153588
return NAME . NAME ::: 151203
, { STRING : ::: 148576
) NEWLINE DEDENT NAME ::: 147505
NAME = STRING , ::: 145613
NEWLINE INDENT if NAME ::: 143015
NAME NEWLINE NAME = ::: 141285
) NEWLINE if NAME ::: 140091
= STRING , NAME ::: 139658
. NAME : NEWLINE ::: 138982
( ) NEWLINE DEDENT ::: 136764
NEWLINE DEDENT NAME = ::: 136656
STRING ) NEWLINE DEDENT ::: 135123
) , STRING : ::: 134369
NAME NEWLINE NAME . ::: 133848
NEWLINE DEDENT else : ::: 133288
STRING , STRING ) ::: 132539
( NAME ( NAME ::: 131782
( STRING , [ ::: 131601
NAME [ NAME ] ::: 131085
= STRING NEWLINE NAME ::: 128593
: ( STRING , ::: 128283
, STRING : ( ::: 128279
NUMBER ) NEWLINE NAME ::: 127778
: STRING } ) ::: 127673
NAME = NUMBER NEWLINE ::: 127313
NEWLINE import NAME NEWLINE ::: 126210
NEWLINE NAME = STRING ::: 125789
return NAME NEWLINE DEDENT ::: 124889
STRING : ( STRING ::: 124500
, NAME = None ::: 124441
STRING , [ ] ::: 121439
, [ ] , ::: 120760
DEDENT NAME = NAME ::: 119998
NAME , STRING ) ::: 119526
in NAME . NAME ::: 119441
[ ] , { ::: 117837
= NAME NEWLINE NAME ::: 117749
NAME NEWLINE DEDENT def ::: 116659
NAME = NAME , ::: 116321
NAME = STRING ) ::: 115744
DEDENT NAME . NAME ::: 115710
] , { STRING ::: 115483
( NAME , STRING ::: 111751
DEDENT DEDENT def NAME ::: 111562
NAME = NAME ) ::: 111444
NAME NEWLINE import NAME ::: 109378
= NAME , NAME ::: 109263
( NAME = NAME ::: 104165
} ) , STRING ::: 102994
STRING } ) , ::: 101963
DEDENT class NAME ( ::: 101928
. NAME ( NUMBER ::: 100906
NEWLINE DEDENT if NAME ::: 100634
= NUMBER NEWLINE NAME ::: 99751
( NAME ) ) ::: 99568
) NEWLINE NAME ( ::: 99279
] NEWLINE NAME = ::: 98815
NAME ( ) : ::: 98297
( ) : NEWLINE ::: 97332
NEWLINE DEDENT NAME . ::: 97221
NAME in NAME . ::: 96823
NAME ( NAME [ ::: 96515
. NAME NEWLINE NAME ::: 96381
in NAME : NEWLINE ::: 96006
NAME ( ) ) ::: 95159
NUMBER NEWLINE NAME = ::: 94396
, NUMBER ) NEWLINE ::: 92464
NEWLINE for NAME in ::: 92369
, STRING : NAME ::: 92262
try : NEWLINE INDENT ::: 91788
NAME = NAME [ ::: 91057
, NAME = NUMBER ::: 90609
NEWLINE DEDENT DEDENT def ::: 90336
import NAME NEWLINE import ::: 89609
from NAME import NAME ::: 88971
NAME NEWLINE def NAME ::: 88837
NUMBER , NUMBER ) ::: 88716
NEWLINE NAME = NUMBER ::: 87781
= NAME ) NEWLINE ::: 87725
. NAME , STRING ::: 87642
= NAME ( ) ::: 85569
NEWLINE from NAME import ::: 85252
NEWLINE NAME = [ ::: 84981
NAME ) NEWLINE if ::: 84981
NEWLINE NAME ( NAME ::: 84100
, NAME = True ::: 83781
( NUMBER , NUMBER ::: 83361
] ) NEWLINE NAME ::: 82965
: NEWLINE INDENT raise ::: 82569
[ STRING ] = ::: 82449
) NEWLINE return NAME ::: 82001
STRING , NAME . ::: 81564
. NAME NEWLINE DEDENT ::: 80954
None : NEWLINE INDENT ::: 80456
NAME ( NUMBER ) ::: 80388
: NAME . NAME ::: 79949
NEWLINE INDENT NAME ( ::: 79300
NEWLINE INDENT raise NAME ::: 79107
NAME ) . NAME ::: 78691
INDENT return NAME . ::: 78404
= NAME NEWLINE DEDENT ::: 77917
. NAME ) : ::: 76990
NAME = None , ::: 76175
NAME ( NUMBER , ::: 75995
, ( STRING , ::: 75908
, ** NAME ) ::: 75732
if NAME : NEWLINE ::: 75502
STRING : NEWLINE INDENT ::: 75150
NEWLINE if NAME . ::: 74682
if NAME ( NAME ::: 73759
= NAME ( STRING ::: 73504
) , NAME = ::: 72975
= STRING ) NEWLINE ::: 72503
NEWLINE DEDENT DEDENT DEDENT ::: 72187
NEWLINE DEDENT return NAME ::: 72050
NAME , NAME NEWLINE ::: 71713
, NAME ( NAME ::: 71560
None , NAME = ::: 71349
return NAME ( NAME ::: 71019
) NEWLINE DEDENT else ::: 70938
STRING . NAME ( ::: 70861
) , ( STRING ::: 70534
DEDENT DEDENT class NAME ::: 70359
NAME in NAME : ::: 70305
STRING NEWLINE NAME . ::: 70035
[ NAME . NAME ::: 69942
NUMBER : NEWLINE INDENT ::: 69835
= None , NAME ::: 69798
NAME ) , NAME ::: 69647
NUMBER , NAME = ::: 69143
STRING % ( NAME ::: 68475
NAME ( STRING % ::: 68465
NEWLINE DEDENT @ NAME ::: 68392
NAME = True ) ::: 67275
, STRING ) , ::: 67121
NAME , STRING : ::: 66749
NAME , ** NAME ::: 66732
NAME NEWLINE DEDENT DEDENT ::: 66426
== STRING : NEWLINE ::: 66298
( NAME = STRING ::: 66268
( ) ) NEWLINE ::: 66047
= { STRING : ::: 65913
: NEWLINE INDENT def ::: 65871
NEWLINE INDENT def NAME ::: 65869
INDENT def NAME ( ::: 65869
) NEWLINE DEDENT if ::: 65613
) NEWLINE def NAME ::: 65247
[ STRING , STRING ::: 64286
NEWLINE DEDENT except NAME ::: 64242
, STRING , NAME ::: 64182
NAME = { STRING ::: 64020
. NAME [ STRING ::: 63442
, NAME ) ) ::: 63306
: { STRING : ::: 63010
NAME = NUMBER ) ::: 62917
. NAME [ NAME ::: 62882
NAME = [ ] ::: 62476
STRING , NAME ) ::: 62335
[ STRING ] ) ::: 62104
STRING : { STRING ::: 61375
NAME = None NEWLINE ::: 60570
NEWLINE DEDENT DEDENT class ::: 60013
NAME = NUMBER , ::: 59832
NAME . NAME == ::: 59785
INDENT NAME = STRING ::: 59681
) , NAME ( ::: 59650
= [ ] NEWLINE ::: 59342
NAME , STRING , ::: 59106
INDENT raise NAME ( ::: 59096
NAME ( ) , ::: 58822
NEWLINE class NAME ( ::: 58210
import NAME , NAME ::: 57926
[ STRING ] NEWLINE ::: 57737
, NAME = False ::: 57687
[ STRING ] , ::: 57396
= NUMBER , NAME ::: 56971
] ) NEWLINE DEDENT ::: 56198
NEWLINE DEDENT elif NAME ::: 56089
STRING , STRING ] ::: 55735
NAME == STRING : ::: 55607
STRING ) ) NEWLINE ::: 55396
STRING : NAME . ::: 55116
INDENT if NAME . ::: 54880
STRING ] ) NEWLINE ::: 54811
NAME = None ) ::: 54752
( NAME ) , ::: 54627
NAME in NAME ( ::: 54044
{ STRING : NAME ::: 53631
STRING ) : NEWLINE ::: 53565
NAME = [ NAME ::: 53531
STRING ) , NAME ::: 53391
NAME import NAME , ::: 53199
STRING ] = NAME ::: 53158
. NAME ) ) ::: 53141
not NAME . NAME ::: 52681
raise NAME ( STRING ::: 52666
None ) : NEWLINE ::: 52499
DEDENT return NAME NEWLINE ::: 52130
NEWLINE return NAME NEWLINE ::: 52084
) NEWLINE DEDENT except ::: 51765
) NEWLINE DEDENT return ::: 51427
@ NAME NEWLINE def ::: 51250
) NEWLINE for NAME ::: 50535
NEWLINE INDENT NAME [ ::: 50521
) , NAME . ::: 50504
NAME ) NEWLINE return ::: 50282
= None ) : ::: 50045
def NAME ( ) ::: 49998
. NAME [ NUMBER ::: 49980
NAME = [ STRING ::: 49714
NEWLINE return NAME . ::: 49483
. NAME ( [ ::: 48630
] NEWLINE NAME . ::: 47769
NAME is not None ::: 47370
** NAME ) : ::: 47333
NUMBER ) NEWLINE DEDENT ::: 47151
NUMBER , STRING : ::: 47104
INDENT NAME ( NAME ::: 46890
STRING : NUMBER , ::: 46771
( STRING ) ) ::: 46731
[ NUMBER ] NEWLINE ::: 46564
NEWLINE NAME = { ::: 46191
, NUMBER ) , ::: 46052
( ) . NAME ::: 46046
NAME ( ) . ::: 45992
NEWLINE if NAME : ::: 45932
} , STRING : ::: 45499
( NUMBER ) NEWLINE ::: 45484
, STRING : NUMBER ::: 45343
NUMBER , NUMBER ] ::: 45318
NEWLINE if not NAME ::: 45205
NEWLINE try : NEWLINE ::: 45075
: NUMBER , STRING ::: 44905
STRING NEWLINE def NAME ::: 44602
INDENT return NAME ( ::: 44084
DEDENT except NAME : ::: 44032
except NAME : NEWLINE ::: 44001
NEWLINE DEDENT DEDENT NAME ::: 43787
DEDENT @ NAME NEWLINE ::: 43685
[ NUMBER , NUMBER ::: 43395
STRING : NAME , ::: 43310
NEWLINE NAME [ STRING ::: 43158
( STRING ) , ::: 42961
( NAME [ STRING ::: 42496
in NAME ( NAME ::: 42075
] . NAME ( ::: 41886
NAME . NAME ] ::: 41697
import NAME NEWLINE NAME ::: 41669
) NEWLINE assert NAME ::: 41614
( STRING % NAME ::: 41568
[ NUMBER ] ) ::: 41549
: NEWLINE INDENT pass ::: 41524
NEWLINE INDENT pass NEWLINE ::: 41521
NAME , NAME in ::: 41384
for NAME , NAME ::: 41342
INDENT pass NEWLINE DEDENT ::: 41255
STRING ] NEWLINE NAME ::: 40901
] = NAME NEWLINE ::: 40833
, NAME in NAME ::: 40699
) NEWLINE DEDENT @ ::: 40441
NAME NEWLINE DEDENT NAME ::: 40392
is None : NEWLINE ::: 40231
( NAME [ NUMBER ::: 40132
= True ) NEWLINE ::: 40052
NAME is None : ::: 39656
INDENT STRING NEWLINE if ::: 39515
) ) ) NEWLINE ::: 39496
[ NAME ] NEWLINE ::: 39176
* NAME , ** ::: 38975
NAME = False ) ::: 38958
: NEWLINE INDENT for ::: 38943
] , NAME = ::: 38874
= NAME [ STRING ::: 38810
: NAME , STRING ::: 38645
@ NAME . NAME ::: 38619
STRING ] , NAME ::: 38440
NEWLINE INDENT for NAME ::: 38371
, NAME ( STRING ::: 38079
] [ STRING ] ::: 37702
assert NAME . NAME ::: 37503
is not None : ::: 37482
NEWLINE DEDENT class NAME ::: 37366
BOS NEWLINE from NAME ::: 37353
NAME , NUMBER ) ::: 37252
NAME = True , ::: 36918
NUMBER ] ) NEWLINE ::: 36911
DEDENT if NAME . ::: 36879
not None : NEWLINE ::: 36762
STRING ) , ( ::: 36708
INDENT STRING NEWLINE return ::: 36605
[ NAME ] = ::: 36549
NAME = { } ::: 36478
NAME NEWLINE class NAME ::: 36406
( ) , NAME ::: 36273
NAME = True NEWLINE ::: 36147
, NAME ) . ::: 36090
[ STRING ] [ ::: 35985
STRING NEWLINE if NAME ::: 35667
NEWLINE if NAME is ::: 35549
[ NUMBER ] , ::: 35505
NAME ] = NAME ::: 35415
= NUMBER ) NEWLINE ::: 35374
) NEWLINE NAME [ ::: 35348
INDENT NAME = [ ::: 35287
( NUMBER , NAME ::: 35250
( STRING , NUMBER ::: 35077
NAME , NAME ( ::: 35025
not NAME : NEWLINE ::: 35001
NUMBER ] . NAME ::: 34962
True , NAME = ::: 34841
. NAME ) , ::: 34839
, STRING : { ::: 34823
NAME ] ) NEWLINE ::: 34768
as NAME : NEWLINE ::: 34686
if not NAME . ::: 34572
NUMBER ] NEWLINE NAME ::: 34490
% ( NAME , ::: 34387
= True , NAME ::: 34332
** NAME ) NEWLINE ::: 34273
NUMBER ) ) NEWLINE ::: 33900
, NAME NEWLINE from ::: 33845
( NAME = NUMBER ::: 33320
STRING NEWLINE return NAME ::: 33277
= { } NEWLINE ::: 33275
if NAME is None ::: 33270
NAME = False NEWLINE ::: 33047
NEWLINE NAME , NAME ::: 32645
. NAME ( ( ::: 32604
NEWLINE assert NAME . ::: 32412
. NAME = STRING ::: 32342
INDENT STRING NEWLINE def ::: 32304
NAME as NAME NEWLINE ::: 32274
NEWLINE if NAME ( ::: 32224
NAME ( [ NAME ::: 32133
NEWLINE NAME = ( ::: 32116
) NEWLINE DEDENT elif ::: 32095
NEWLINE DEDENT DEDENT EOS ::: 31932
NAME NEWLINE if NAME ::: 31860
] : NEWLINE INDENT ::: 31609
: NEWLINE INDENT try ::: 31584
NEWLINE INDENT try : ::: 31584
, NAME ) , ::: 31559
INDENT for NAME in ::: 31494
] = NAME . ::: 31459
NAME . NAME is ::: 31392
== NAME . NAME ::: 31265
INDENT try : NEWLINE ::: 31194
, NAME = [ ::: 31126
STRING , NAME , ::: 31083
STRING , NUMBER ) ::: 31059
if NAME == STRING ::: 30953
NAME ] NEWLINE DEDENT ::: 30906
) for NAME in ::: 30847
if not NAME : ::: 30847
( NAME ( STRING ::: 30730
( ) NEWLINE if ::: 30556
NEWLINE return NAME ( ::: 30493
[ NUMBER ] . ::: 30484
} NEWLINE NAME = ::: 30402
NUMBER ] , NAME ::: 30298
True ) NEWLINE NAME ::: 30258
= None NEWLINE NAME ::: 30070
{ STRING : { ::: 30024
: STRING } , ::: 29994
( STRING % ( ::: 29932
NUMBER NEWLINE NAME . ::: 29897
, ( NUMBER , ::: 29830
NAME ] NEWLINE NAME ::: 29792
NAME = ( NAME ::: 29474
= [ STRING , ::: 29190
and NAME . NAME ::: 28957
NAME , * NAME ::: 28706
STRING ) . NAME ::: 28697
NUMBER ) : NEWLINE ::: 28523
) , NAME ) ::: 28411
NAME ( * NAME ::: 28248
= STRING NEWLINE DEDENT ::: 28160
= NAME [ NUMBER ::: 28007
== NUMBER : NEWLINE ::: 28003
BOS NEWLINE STRING NEWLINE ::: 27655
NAME ( ( NAME ::: 27467
. NAME = None ::: 27396
) ) : NEWLINE ::: 27321
NEWLINE NAME ( STRING ::: 27076
NEWLINE INDENT NAME , ::: 27063
NAME = False , ::: 26999
] NEWLINE for NAME ::: 26975
+ NAME . NAME ::: 26970
STRING % NAME ) ::: 26791
DEDENT DEDENT NAME = ::: 26721
) NEWLINE if not ::: 26661
NEWLINE assert NAME ( ::: 26588
INDENT NAME , NAME ::: 26551
[ ] NEWLINE NAME ::: 26506
NAME = STRING % ::: 26437
, NUMBER ) ) ::: 26373
BOS NEWLINE import NAME ::: 26273
NUMBER ) , NAME ::: 26229
if NAME is not ::: 26156
. NAME , NUMBER ::: 25916
NUMBER ) , ( ::: 25910
. NAME = NUMBER ::: 25892
= NAME [ NAME ::: 25760
% NAME . NAME ::: 25672
INDENT NAME [ STRING ::: 25639
NEWLINE INDENT if not ::: 25592
assert NAME ( NAME ::: 25527
STRING , NAME ( ::: 25481
% NAME ) NEWLINE ::: 25461
False , NAME = ::: 25159
with NAME . NAME ::: 25055
. NAME == NAME ::: 24980
= False , NAME ::: 24764
INDENT if not NAME ::: 24661
DEDENT DEDENT if NAME ::: 24616
import NAME NEWLINE class ::: 24575
, STRING ) ) ::: 24561
. NAME = [ ::: 24536
DEDENT @ NAME . ::: 24468
) [ NUMBER ] ::: 24433
} ) NEWLINE NAME ::: 24381
import NAME as NAME ::: 24334
( STRING . NAME ::: 24296
NAME == NAME . ::: 24288
INDENT if NAME ( ::: 24090
NEWLINE DEDENT DEDENT if ::: 24048
STRING ] [ STRING ::: 24041
STRING % NAME . ::: 24018
NAME NEWLINE DEDENT else ::: 23992
[ NAME ] ) ::: 23902
, ( NAME , ::: 23867
NAME [ NAME . ::: 23729
% ( NAME . ::: 23496
, NUMBER ] , ::: 23414
) , NUMBER ) ::: 23291
( STRING ) : ::: 23156
) , ( NUMBER ::: 22950
NAME = ( STRING ::: 22894
, None ) NEWLINE ::: 22839
NEWLINE for NAME , ::: 22793
STRING ] . NAME ::: 22749
NEWLINE INDENT return STRING ::: 22721
[ STRING ] . ::: 22675
NAME ( STRING . ::: 22626
NEWLINE DEDENT DEDENT return ::: 22569
] , NAME [ ::: 22364
STRING ) NEWLINE def ::: 22347
) , STRING ) ::: 22329
DEDENT DEDENT else : ::: 22205
NAME . NAME + ::: 22051
NAME NEWLINE from . ::: 22039
( NAME ) . ::: 21996
] NEWLINE if NAME ::: 21955
NAME ( STRING STRING ::: 21801
DEDENT DEDENT return NAME ::: 21775
] , STRING : ::: 21774
) NEWLINE DEDENT EOS ::: 21582
( { STRING : ::: 21572
STRING STRING STRING STRING ::: 21545
) ) , ( ::: 21489
STRING : NAME } ::: 21396
DEDENT DEDENT DEDENT def ::: 21226
, STRING ) : ::: 21216
INDENT NAME [ NAME ::: 21213
. NAME == STRING ::: 21209
] ) ) NEWLINE ::: 21152
NAME ) for NAME ::: 21053
NEWLINE if NAME == ::: 20985
, * NAME , ::: 20938
STRING } , STRING ::: 20892
NAME ( { STRING ::: 20823
) NEWLINE try : ::: 20820
DEDENT if NAME == ::: 20737
) as NAME : ::: 20600
DEDENT for NAME in ::: 20568
INDENT return NAME NEWLINE ::: 20552
] [ NUMBER ] ::: 20518
( NAME = True ::: 20421
NAME NEWLINE DEDENT if ::: 20384
, NAME [ STRING ::: 20371
NAME ) ) ) ::: 20365
[ NAME ( NAME ::: 20330
not NAME ( NAME ::: 20285
= [ NAME . ::: 20067
[ NAME , NAME ::: 20061
NAME for NAME in ::: 20024
, NAME [ NUMBER ::: 20016
INDENT NAME ( STRING ::: 19962
DEDENT elif NAME == ::: 19953
, [ NUMBER , ::: 19950
STRING ) NEWLINE if ::: 19945
DEDENT if NAME : ::: 19887
NEWLINE DEDENT for NAME ::: 19730
( NAME , * ::: 19718
( NAME [ NAME ::: 19700
NUMBER , NAME . ::: 19682
NEWLINE NAME = None ::: 19552
( NAME , NUMBER ::: 19440
NAME ( [ STRING ::: 19437
= STRING . NAME ::: 19436
, NAME , STRING ::: 19303
STRING ] , STRING ::: 19182
( NAME ) == ::: 19084
NUMBER ] , [ ::: 19062
DEDENT return NAME . ::: 19044
] NEWLINE DEDENT def ::: 19035
NEWLINE DEDENT DEDENT else ::: 19007
NUMBER , - NUMBER ::: 19003
[ ] NEWLINE for ::: 18920
import NAME . NAME ::: 18918
= [ STRING ] ::: 18917
. NAME ( { ::: 18902
STRING ) , STRING ::: 18831
+ NAME ( NAME ::: 18806
, STRING : [ ::: 18786
) NEWLINE NAME , ::: 18694
[ ( STRING , ::: 18656
NAME = NAME + ::: 18652
if STRING in NAME ::: 18649
DEDENT DEDENT DEDENT DEDENT ::: 18585
elif NAME . NAME ::: 18585
NAME , NAME ] ::: 18581
= False ) NEWLINE ::: 18530
NEWLINE INDENT NAME += ::: 18529
NAME ) NEWLINE for ::: 18518
NAME ) , STRING ::: 18501
DEDENT DEDENT NAME . ::: 18490
NAME ] , NAME ::: 18484
, NAME = { ::: 18388
DEDENT elif NAME . ::: 18376
NUMBER ] NEWLINE DEDENT ::: 18344
NAME [ NUMBER : ::: 18330
: NEWLINE INDENT from ::: 18233
STRING ] NEWLINE DEDENT ::: 18231
( * NAME , ::: 18182
NAME in NAME ] ::: 18059
. NAME NEWLINE def ::: 18015
NAME = STRING . ::: 17942
= STRING ) , ::: 17927
= True NEWLINE NAME ::: 17884
) , ( NAME ::: 17818
, STRING ] ) ::: 17740
( STRING ) . ::: 17728
DEDENT if not NAME ::: 17696
, STRING ] NEWLINE ::: 17695
= False NEWLINE NAME ::: 17648
return False NEWLINE DEDENT ::: 17646
] , [ NUMBER ::: 17640
NAME , NAME [ ::: 17466
[ NUMBER ] [ ::: 17432
} NEWLINE NAME . ::: 17379
STRING : NAME ( ::: 17376
NEWLINE from . NAME ::: 17336
NEWLINE import NAME . ::: 17315
. NAME NEWLINE if ::: 17183
from . NAME import ::: 17143
) ) NEWLINE if ::: 17126
, NUMBER , NAME ::: 17125
STRING ) NEWLINE return ::: 17103
( ( NAME , ::: 17075
NAME ) NEWLINE def ::: 17037
. NAME is not ::: 17028
] , NAME . ::: 17013
INDENT NAME = { ::: 16992
] NEWLINE DEDENT DEDENT ::: 16977
NEWLINE INDENT from NAME ::: 16960
NAME . NAME and ::: 16917
None NEWLINE NAME . ::: 16839
NAME NEWLINE DEDENT @ ::: 16790
INDENT NAME = NUMBER ::: 16772
{ } NEWLINE NAME ::: 16765
[ - NUMBER ] ::: 16640
NAME ) NEWLINE assert ::: 16629
False ) NEWLINE NAME ::: 16512
NAME ] . NAME ::: 16456
NAME == NUMBER : ::: 16448
= None NEWLINE DEDENT ::: 16348
, NAME = ( ::: 16329
) ) , NAME ::: 16294
STRING ] : NEWLINE ::: 16217
{ STRING : NUMBER ::: 16196
NAME NEWLINE DEDENT return ::: 16121
= ( STRING , ::: 16120
or NAME . NAME ::: 16020
> NUMBER : NEWLINE ::: 15998
NAME += NUMBER NEWLINE ::: 15957
NAME ) , ( ::: 15939
NAME ) == NUMBER ::: 15914
STRING , None ) ::: 15891
if not NAME ( ::: 15813
DEDENT if NAME ( ::: 15716
+ STRING + NAME ::: 15571
False ) : NEWLINE ::: 15541
DEDENT try : NEWLINE ::: 15519
) ] ) NEWLINE ::: 15510
None ) NEWLINE NAME ::: 15452
) NEWLINE class NAME ::: 15418
] , NAME ) ::: 15406
. NAME = True ::: 15401
DEDENT return NAME ( ::: 15349
* NAME . NAME ::: 15261
return True NEWLINE DEDENT ::: 15251
NAME ) ) : ::: 15202
pass NEWLINE DEDENT def ::: 15166
NAME import * NEWLINE ::: 15137
) NEWLINE @ NAME ::: 15136
NEWLINE DEDENT if not ::: 15124
] NEWLINE DEDENT NAME ::: 15116
return None NEWLINE DEDENT ::: 15075
) ) NEWLINE return ::: 15062
] = NAME ( ::: 15050
= NUMBER NEWLINE DEDENT ::: 15043
if NAME in NAME ::: 15014
NAME = [ ( ::: 15011
[ NAME ] [ ::: 14989
[ NAME ] , ::: 14968
STRING NEWLINE import NAME ::: 14889
, NAME NEWLINE DEDENT ::: 14886
: NAME ( NAME ::: 14864
, STRING ] , ::: 14811
, ) NEWLINE NAME ::: 14780
NAME NEWLINE DEDENT except ::: 14757
NAME and NAME . ::: 14698
( ) NEWLINE return ::: 14698
) } , STRING ::: 14637
as NAME NEWLINE from ::: 14636
NEWLINE NAME [ NAME ::: 14613
} ) NEWLINE DEDENT ::: 14563
None NEWLINE NAME = ::: 14551
= True NEWLINE DEDENT ::: 14551
raise NAME . NAME ::: 14517
STRING STRING ) NEWLINE ::: 14510
NAME NEWLINE return NAME ::: 14497
NAME : NAME . ::: 14495
) ] NEWLINE NAME ::: 14483
STRING NEWLINE from NAME ::: 14444
NAME , NUMBER , ::: 14390
NEWLINE DEDENT NAME ( ::: 14366
NAME ( NAME + ::: 14346
: NEWLINE INDENT assert ::: 14294
STRING : NUMBER } ::: 14293
= STRING % ( ::: 14227
STRING } ) } ::: 14210
) NEWLINE with NAME ::: 14191
NAME import NAME as ::: 14184
NAME as NAME : ::: 14120
. NAME ] NEWLINE ::: 14068
NAME [ - NUMBER ::: 14039
DEDENT @ NAME ( ::: 14026
== NAME : NEWLINE ::: 14011
STRING in NAME : ::: 13951
} ) } , ::: 13928
. NAME = { ::: 13874
NAME , NAME : ::: 13836
= False ) : ::: 13831
NEWLINE with NAME . ::: 13829
[ NAME ] . ::: 13789
DEDENT DEDENT @ NAME ::: 13787
STRING ] = STRING ::: 13764
NAME not in NAME ::: 13719
class NAME : NEWLINE ::: 13650
NEWLINE DEDENT try : ::: 13629
( STRING , None ::: 13623
lambda NAME : NAME ::: 13591
. NAME = False ::: 13415
: NEWLINE INDENT with ::: 13374
NEWLINE INDENT with NAME ::: 13365
STRING : [ STRING ::: 13315
DEDENT if NAME is ::: 13215
, [ STRING , ::: 13159
, - NUMBER , ::: 13103
= NAME ( [ ::: 13103
( [ STRING , ::: 13064
elif NAME == STRING ::: 13056
NEWLINE INDENT return NEWLINE ::: 12998
INDENT NAME = ( ::: 12950
INDENT return NEWLINE DEDENT ::: 12949
= NAME ( NUMBER ::: 12925
] = STRING NEWLINE ::: 12898
. NAME and NAME ::: 12889
INDENT if NAME : ::: 12889
NUMBER , NAME ) ::: 12887
NAME , ( NAME ::: 12859
= STRING % NAME ::: 12821
NAME = - NUMBER ::: 12815
NUMBER , STRING ) ::: 12800
except : NEWLINE INDENT ::: 12744
NAME ( STRING + ::: 12718
DEDENT except : NEWLINE ::: 12692
NAME ) , NUMBER ::: 12607
DEDENT NAME = [ ::: 12570
, NUMBER ] ) ::: 12563
[ NUMBER : ] ::: 12553
NEWLINE NAME = False ::: 12545
in NAME ( NUMBER ::: 12469
: NEWLINE INDENT continue ::: 12451
) NEWLINE DEDENT class ::: 12450
NEWLINE NAME = True ::: 12448
NEWLINE INDENT continue NEWLINE ::: 12431
INDENT continue NEWLINE DEDENT ::: 12426
NEWLINE @ NAME . ::: 12373
( STRING + NAME ::: 12314
. NAME == NUMBER ::: 12298
[ STRING ] : ::: 12282
NEWLINE INDENT NAME STRING ::: 12277
NAME ( ) [ ::: 12272
INDENT if NAME is ::: 12218
( ) NEWLINE for ::: 12185
True ) NEWLINE DEDENT ::: 12114
. NAME ) . ::: 12061
STRING ) ) , ::: 12033
= NUMBER ) : ::: 11980
( NAME , [ ::: 11967
raise NAME ( NAME ::: 11944
return NEWLINE DEDENT NAME ::: 11928
NAME . NAME != ::: 11906
: NEWLINE INDENT import ::: 11903
NEWLINE INDENT import NAME ::: 11902
STRING NEWLINE DEDENT def ::: 11849
NEWLINE STRING NEWLINE import ::: 11836
STRING + NAME ( ::: 11815
] = NAME [ ::: 11781
STRING NEWLINE DEDENT NAME ::: 11781
STRING % NAME NEWLINE ::: 11770
( STRING STRING ) ::: 11729
- NUMBER , NUMBER ::: 11697
. NAME import * ::: 11695
return STRING NEWLINE DEDENT ::: 11692
except NAME . NAME ::: 11678
) ) . NAME ::: 11678
NEWLINE DEDENT DEDENT @ ::: 11657
DEDENT elif NAME ( ::: 11655
DEDENT except NAME . ::: 11650
INDENT if NAME == ::: 11631
if NAME == NAME ::: 11630
= ( NAME . ::: 11609
NEWLINE STRING NEWLINE from ::: 11579
( NAME ( ) ::: 11560
] NEWLINE DEDENT else ::: 11534
elif NAME ( NAME ::: 11526
STRING , NUMBER , ::: 11495
= [ NAME ( ::: 11464
NAME NEWLINE NAME [ ::: 11385
DEDENT NAME ( NAME ::: 11365
} , { STRING ::: 11352
) NEWLINE DEDENT for ::: 11320
in NAME ] NEWLINE ::: 11316
NAME ) ] NEWLINE ::: 11314
. NAME ( * ::: 11304
with NAME ( NAME ::: 11296
( NAME , ** ::: 11290
] , STRING ) ::: 11277
NAME . NAME as ::: 11268
. NAME as NAME ::: 11264
{ STRING : [ ::: 11229
, ) ) NEWLINE ::: 11214
NAME NEWLINE DEDENT elif ::: 11151
NEWLINE DEDENT except : ::: 11150
, { } ) ::: 11103
+ STRING ) NEWLINE ::: 11066
NEWLINE INDENT assert NAME ::: 11056
( NUMBER ) ) ::: 11042
INDENT raise NAME . ::: 10960
( ) , STRING ::: 10920
NEWLINE INDENT return False ::: 10880
STRING NEWLINE DEDENT DEDENT ::: 10863
NAME , ) NEWLINE ::: 10812
NEWLINE return NEWLINE DEDENT ::: 10806
( ( STRING , ::: 10805
- NAME . NAME ::: 10803
. NAME ] ) ::: 10785
NAME NEWLINE DEDENT EOS ::: 10779
( [ NAME . ::: 10758
( NAME , ) ::: 10743
, NAME NEWLINE NAME ::: 10739
= STRING ) : ::: 10718
] ) , NAME ::: 10711
. NAME is None ::: 10696
except NAME as NAME ::: 10681
def NAME ( * ::: 10672
DEDENT except NAME as ::: 10669
NAME ( ** NAME ::: 10667
NUMBER NEWLINE DEDENT DEDENT ::: 10649
NAME == NAME : ::: 10641
NAME } ) NEWLINE ::: 10619
INDENT return False NEWLINE ::: 10615
( NAME , ( ::: 10554
NUMBER , NAME ( ::: 10519
, NAME , ** ::: 10518
: STRING } NEWLINE ::: 10497
, NAME [ NAME ::: 10487
if NAME not in ::: 10471
) NEWLINE NAME += ::: 10456
( NUMBER , STRING ::: 10427
NUMBER : STRING , ::: 10408
[ ] NEWLINE DEDENT ::: 10397
) == NUMBER : ::: 10394
} , NAME = ::: 10385
[ STRING ] == ::: 10371
STRING in NAME . ::: 10358
NAME in NAME [ ::: 10358
INDENT NAME = None ::: 10353
) , NAME , ::: 10348
DEDENT DEDENT DEDENT class ::: 10346
( ( NUMBER , ::: 10309
NAME ( [ NUMBER ::: 10301
NAME , None ) ::: 10276
, STRING % NAME ::: 10268
and NAME ( NAME ::: 10217
= NAME NEWLINE if ::: 10211
STRING ) as NAME ::: 10207
@ NAME ( NAME ::: 10162
NAME ( ) ] ::: 10149
NAME + STRING + ::: 10137
NAME = ( NUMBER ::: 10107
NEWLINE INDENT return None ::: 10092
NAME ( ) == ::: 10087
[ NUMBER ] == ::: 10033
NAME ) > NUMBER ::: 10023
STRING + NAME . ::: 10017
( NAME ) ] ::: 9996
NAME + NUMBER ) ::: 9989
NAME ) ) , ::: 9969
* NAME ) NEWLINE ::: 9959
( STRING , ) ::: 9956
NUMBER ] [ NUMBER ::: 9954
( ) ) ) ::: 9953
not in NAME : ::: 9945
STRING } ) NEWLINE ::: 9943
( NAME ) for ::: 9933
= True ) ) ::: 9930
, [ ] ) ::: 9920
, NAME ( NUMBER ::: 9886
[ { STRING : ::: 9879
STRING NEWLINE if not ::: 9847
: NEWLINE INDENT yield ::: 9826
( STRING , ( ::: 9817
= STRING NEWLINE def ::: 9817
STRING , { STRING ::: 9815
INDENT from NAME . ::: 9785
pass NEWLINE DEDENT DEDENT ::: 9764
NAME . NAME or ::: 9743
, * NAME ) ::: 9735
, NAME ( ) ::: 9697
, NUMBER : STRING ::: 9687
- NUMBER NEWLINE NAME ::: 9685
STRING , NUMBER : ::: 9683
: STRING , NUMBER ::: 9677
[ NAME for NAME ::: 9676
= [ ( STRING ::: 9671
INDENT return None NEWLINE ::: 9662
import NAME NEWLINE def ::: 9654
) ] NEWLINE DEDENT ::: 9638
True ) : NEWLINE ::: 9575
NAME . NAME } ::: 9547
if NAME [ STRING ::: 9544
DEDENT DEDENT elif NAME ::: 9522
return NAME , NAME ::: 9508
: NAME } ) ::: 9492
, [ STRING ] ::: 9467
( NAME ) + ::: 9465
True NEWLINE NAME = ::: 9435
] [ NAME ] ::: 9434
False NEWLINE NAME = ::: 9400
DEDENT NAME = STRING ::: 9384
( NAME ( NUMBER ::: 9364
, ) NEWLINE DEDENT ::: 9356
NUMBER NEWLINE DEDENT def ::: 9345
NAME + NAME . ::: 9330
NEWLINE @ NAME NEWLINE ::: 9271
( ** NAME ) ::: 9258
STRING ] ) ) ::: 9228
INDENT return STRING NEWLINE ::: 9219
) . NAME NEWLINE ::: 9200
STRING NEWLINE for NAME ::: 9199
NAME NEWLINE NAME ( ::: 9196
= - NUMBER NEWLINE ::: 9161
INDENT NAME ( ) ::: 9146
raise NAME NEWLINE DEDENT ::: 9117
DEDENT DEDENT DEDENT NAME ::: 9068
: STRING , } ::: 9035
NEWLINE DEDENT DEDENT elif ::: 9034
NAME NEWLINE assert NAME ::: 9014
- NUMBER ] NEWLINE ::: 9007
[ ] ) NEWLINE ::: 8985
) NEWLINE return NEWLINE ::: 8976
NUMBER NEWLINE DEDENT NAME ::: 8970
= True ) : ::: 8956
* NAME ) : ::: 8934
NEWLINE DEDENT DEDENT except ::: 8893
NAME + STRING ) ::: 8879
( NAME ) > ::: 8872
, NAME : NEWLINE ::: 8870
. NAME + NAME ::: 8866
: NAME } NEWLINE ::: 8860
( NUMBER ) , ::: 8848
NAME , STRING % ::: 8827
NEWLINE NAME += NAME ::: 8813
NEWLINE DEDENT NAME [ ::: 8811
) > NUMBER : ::: 8780
INDENT return STRING % ::: 8771
) , ) NEWLINE ::: 8744
NUMBER ] ) ) ::: 8709
if NAME == NUMBER ::: 8707
STRING NEWLINE NAME ( ::: 8694
( STRING , { ::: 8690
INDENT import NAME NEWLINE ::: 8682
= ( NUMBER , ::: 8639
+= NUMBER NEWLINE DEDENT ::: 8626
None ) NEWLINE DEDENT ::: 8625
import NAME NEWLINE DEDENT ::: 8606
( [ NUMBER , ::: 8598
( NAME = [ ::: 8566
DEDENT NAME = { ::: 8562
NAME NEWLINE try : ::: 8562
return STRING % ( ::: 8554
( NAME - NAME ::: 8548
STRING , ) NEWLINE ::: 8538
NUMBER NEWLINE if NAME ::: 8534
- NUMBER , - ::: 8533
STRING ) NEWLINE assert ::: 8514
NAME ( ( NUMBER ::: 8507
@ NAME ( STRING ::: 8506
: - NUMBER ] ::: 8485
!= NAME . NAME ::: 8450
STRING % NAME ( ::: 8439
STRING NEWLINE assert NAME ::: 8430
DEDENT DEDENT except NAME ::: 8412
= False NEWLINE DEDENT ::: 8402
NAME . NAME += ::: 8398
. NAME + STRING ::: 8365
= [ NAME ] ::: 8343
, NAME ] ) ::: 8322
] = NUMBER NEWLINE ::: 8309
= ( NAME , ::: 8306
} NEWLINE for NAME ::: 8302
] for NAME in ::: 8279
( NAME = False ::: 8279
NUMBER NEWLINE assert NAME ::: 8239
] ) : NEWLINE ::: 8235
( NAME + NAME ::: 8223
NAME ) == NAME ::: 8218
+ NAME ) NEWLINE ::: 8201
NAME or NAME . ::: 8184
NAME + STRING NEWLINE ::: 8176
STRING NEWLINE try : ::: 8174
continue NEWLINE DEDENT NAME ::: 8169
NUMBER ] , STRING ::: 8163
) , ] NEWLINE ::: 8136
if NAME and NAME ::: 8130
NEWLINE import NAME as ::: 8119
NAME = lambda NAME ::: 8116
, True ) NEWLINE ::: 8113
not in NAME . ::: 8106
( STRING STRING STRING ::: 8093
NEWLINE with NAME ( ::: 8069
] == STRING : ::: 8037
NAME ) NEWLINE try ::: 8022
. NAME ( ** ::: 8007
False ) NEWLINE DEDENT ::: 7988
NUMBER ) . NAME ::: 7981
+ NAME + STRING ::: 7961
, NAME , NUMBER ::: 7960
finally : NEWLINE INDENT ::: 7952
DEDENT finally : NEWLINE ::: 7951
None NEWLINE DEDENT def ::: 7950
. NAME : NAME ::: 7938
= STRING ) ) ::: 7933
NAME [ : , ::: 7928
, } NEWLINE NAME ::: 7914
STRING : NAME [ ::: 7899
, STRING , NUMBER ::: 7867
, STRING ) as ::: 7862
INDENT with NAME . ::: 7858
NEWLINE if ( NAME ::: 7852
( ) [ NUMBER ::: 7845
= NAME + NAME ::: 7837
( ) ) , ::: 7826
, NAME , * ::: 7815
if ( NAME . ::: 7808
, ) , NAME ::: 7805
, STRING , None ::: 7793
NAME = [ NUMBER ::: 7791
) and NAME . ::: 7789
] NEWLINE DEDENT if ::: 7775
NUMBER ) ) , ::: 7771
STRING , NAME [ ::: 7770
STRING not in NAME ::: 7760
( ( NAME . ::: 7739
STRING + NAME + ::: 7732
, NAME ) for ::: 7709
NAME = STRING + ::: 7705
] NEWLINE def NAME ::: 7705
= NAME [ : ::: 7704
NEWLINE raise NAME ( ::: 7700
. NAME ( None ::: 7681
False NEWLINE NAME . ::: 7673
NEWLINE if STRING in ::: 7668
DEDENT DEDENT DEDENT EOS ::: 7667
NAME . NAME in ::: 7666
INDENT NAME = True ::: 7663
, False ) NEWLINE ::: 7660
( STRING ) [ ::: 7641
as NAME NEWLINE import ::: 7640
) == NUMBER NEWLINE ::: 7632
NEWLINE INDENT return True ::: 7630
NEWLINE INDENT return [ ::: 7630
NUMBER ] [ STRING ::: 7605
NUMBER NEWLINE for NAME ::: 7603
+= NAME . NAME ::: 7596
( * NAME ) ::: 7586
return NAME ( STRING ::: 7577
NAME ) + STRING ::: 7577
NAME , { STRING ::: 7574
NAME NEWLINE for NAME ::: 7562
True NEWLINE NAME . ::: 7529
STRING , [ STRING ::: 7529
return NUMBER NEWLINE DEDENT ::: 7517
None NEWLINE DEDENT DEDENT ::: 7512
: NEWLINE INDENT break ::: 7509
NEWLINE NAME [ NUMBER ::: 7504
NEWLINE INDENT yield NAME ::: 7500
INDENT return True NEWLINE ::: 7484
INDENT break NEWLINE DEDENT ::: 7474
NEWLINE INDENT break NEWLINE ::: 7474
NAME ] NEWLINE if ::: 7464
- NUMBER ) NEWLINE ::: 7450
STRING NEWLINE DEDENT else ::: 7445
, - NUMBER ) ::: 7435
. NAME , [ ::: 7434
True NEWLINE DEDENT DEDENT ::: 7427
, STRING ) ] ::: 7422
% NAME ( NAME ::: 7410
break NEWLINE DEDENT DEDENT ::: 7399
NAME ( ( STRING ::: 7389
INDENT if NAME [ ::: 7384
, NAME ) = ::: 7356
, None , None ::: 7350
< NUMBER : NEWLINE ::: 7341
[ : NUMBER ] ::: 7322
( NAME + STRING ::: 7315
] ) NEWLINE if ::: 7306
, ( NAME . ::: 7269
NAME ) = NAME ::: 7264
NAME ) and NAME ::: 7264
False NEWLINE DEDENT DEDENT ::: 7262
NEWLINE STRING NEWLINE NAME ::: 7256
] NEWLINE NAME [ ::: 7250
STRING } NEWLINE NAME ::: 7247
NUMBER ] == STRING ::: 7243
True : NEWLINE INDENT ::: 7242
NEWLINE NAME ( ) ::: 7239
in ( STRING , ::: 7238
, NUMBER , - ::: 7237
, ] NEWLINE NAME ::: 7236
True ) ) , ::: 7235
NAME STRING NEWLINE NAME ::: 7227
NAME import ( NAME ::: 7220
NEWLINE if NAME [ ::: 7183
( STRING ) ( ::: 7182
INDENT from NAME import ::: 7175
NEWLINE if NAME in ::: 7172
NAME NEWLINE @ NAME ::: 7161
{ } NEWLINE for ::: 7158
NAME , ) ) ::: 7151
[ NUMBER ] = ::: 7147
in NAME [ STRING ::: 7146
, STRING : True ::: 7140
NAME += NAME . ::: 7133
: [ STRING ] ::: 7130
+ STRING NEWLINE NAME ::: 7124
NAME - NAME ) ::: 7119
. NAME , ) ::: 7111
( ) NEWLINE def ::: 7111
NAME , [ NAME ::: 7105
!= STRING : NEWLINE ::: 7098
STRING : True , ::: 7095
, NUMBER ) : ::: 7093
NAME . NAME - ::: 7008
, STRING . NAME ::: 7007
NAME and not NAME ::: 7006
STRING ] ) , ::: 7001
INDENT if NAME in ::: 7001
STRING ) NEWLINE @ ::: 6979
NUMBER ] ) , ::: 6966
NAME > NUMBER : ::: 6966
NAME + NAME ) ::: 6920
STRING ) ( NAME ::: 6919
) NEWLINE from NAME ::: 6917
= NAME NEWLINE return ::: 6899
import ( NAME , ::: 6884
, NUMBER ) ] ::: 6874
STRING ] [ NUMBER ::: 6872
= STRING + NAME ::: 6871
INDENT for NAME , ::: 6864
NAME ( lambda NAME ::: 6861
== NUMBER NEWLINE assert ::: 6860
, NUMBER , STRING ::: 6845
, NAME ) ] ::: 6817
NAME != NAME . ::: 6794
yield NAME . NAME ::: 6765
NEWLINE @ NAME ( ::: 6739
( NAME + NUMBER ::: 6731
return STRING . NAME ::: 6720
) ) NEWLINE for ::: 6704
. NAME for NAME ::: 6702
NAME , NAME + ::: 6701
{ } NEWLINE DEDENT ::: 6699
NAME NEWLINE DEDENT class ::: 6697
: NAME [ STRING ::: 6694
NAME in NAME ) ::: 6691
in NAME ) NEWLINE ::: 6687
( ) NEWLINE assert ::: 6677
: [ STRING , ::: 6665
NEWLINE INDENT return ( ::: 6656
STRING ) NEWLINE for ::: 6649
STRING STRING STRING ) ::: 6647
NUMBER ] = NAME ::: 6620
NAME ( None , ::: 6617
] . NAME , ::: 6612
NAME ) in NAME ::: 6610
= lambda NAME : ::: 6597
pass NEWLINE DEDENT class ::: 6583
. NAME != NAME ::: 6580
None NEWLINE DEDENT NAME ::: 6572
NEWLINE from . . ::: 6565
) NEWLINE raise NAME ::: 6562
NEWLINE if NAME != ::: 6560
!= NUMBER : NEWLINE ::: 6555
( NAME = None ::: 6534
, STRING ) . ::: 6527
NAME [ NAME : ::: 6519
= NUMBER ) ) ::: 6510
. NAME [ : ::: 6495
) ( NAME = ::: 6494
NAME : STRING , ::: 6481
= NAME ) ) ::: 6477
STRING % NAME , ::: 6473
DEDENT NAME , NAME ::: 6470
= NAME + STRING ::: 6469
NAME ] ) ) ::: 6463
: NAME ( STRING ::: 6452
NAME . NAME for ::: 6450
NEWLINE assert NAME == ::: 6449
INDENT STRING NEWLINE try ::: 6438
NAME ) [ NUMBER ::: 6436
] NEWLINE DEDENT except ::: 6433
, NAME NEWLINE import ::: 6425
NEWLINE DEDENT if STRING ::: 6420
{ } ) NEWLINE ::: 6419
NUMBER ) ) ) ::: 6416
NUMBER ] NEWLINE if ::: 6392
] , NUMBER ) ::: 6391
if NAME [ NUMBER ::: 6379
) NEWLINE NAME STRING ::: 6372
* NAME ( NAME ::: 6368
: NEWLINE INDENT class ::: 6368
NEWLINE INDENT class NAME ::: 6368
STRING ) ) ) ::: 6367
( [ NAME , ::: 6365
NUMBER ) , STRING ::: 6361
NAME + NAME NEWLINE ::: 6348
. NAME or NAME ::: 6344
= [ NAME for ::: 6307
NAME } NEWLINE NAME ::: 6300
] NEWLINE return NAME ::: 6284
( lambda NAME : ::: 6264
) , STRING , ::: 6264
+ NAME NEWLINE DEDENT ::: 6264
except NAME , NAME ::: 6262
DEDENT except NAME , ::: 6262
: STRING , NAME ::: 6256
NAME ] [ NAME ::: 6253
NAME ] : NEWLINE ::: 6237
, STRING , ] ::: 6224
True , STRING : ::: 6221
: True , STRING ::: 6218
and not NAME . ::: 6215
INDENT NAME += STRING ::: 6208
NEWLINE pass NEWLINE DEDENT ::: 6208
, STRING : None ::: 6201
] , [ STRING ::: 6183
NAME = NAME - ::: 6175
None , None , ::: 6170
True NEWLINE DEDENT def ::: 6151
NAME . NAME * ::: 6127
NAME = NAME or ::: 6126
NEWLINE NAME STRING NEWLINE ::: 6120
) ) NEWLINE assert ::: 6104
STRING ) [ NUMBER ::: 6100
= NUMBER NEWLINE for ::: 6099
, NAME ] NEWLINE ::: 6099
STRING NEWLINE DEDENT class ::: 6074
NAME ) as NAME ::: 6074
del NAME . NAME ::: 6066
NEWLINE DEDENT finally : ::: 6063
NEWLINE class NAME : ::: 6061
+ NAME NEWLINE NAME ::: 6056
( NAME , None ::: 6056
DEDENT DEDENT DEDENT if ::: 6055
NEWLINE assert NAME [ ::: 6046
NEWLINE DEDENT NAME , ::: 6045
NAME ( [ ( ::: 6042
NAME == NUMBER NEWLINE ::: 6025
in NAME ] ) ::: 5996
INDENT STRING NEWLINE DEDENT ::: 5987
. NAME import ( ::: 5983
DEDENT DEDENT DEDENT return ::: 5976
NAME [ : NUMBER ::: 5972
) == NAME ( ::: 5968
NUMBER ) NEWLINE if ::: 5955
STRING : None , ::: 5950
DEDENT DEDENT for NAME ::: 5934
is not None and ::: 5917
NAME : NAME ( ::: 5914
[ NUMBER ] ] ::: 5909
STRING , False ) ::: 5901
, NAME ) in ::: 5899
NUMBER : ] NEWLINE ::: 5896
!= NAME : NEWLINE ::: 5880
NAME ( ) + ::: 5875
: NEWLINE INDENT @ ::: 5872
INDENT NAME += NAME ::: 5869
[ NAME [ NUMBER ::: 5869
STRING : False , ::: 5868
= NAME NEWLINE def ::: 5868
NEWLINE INDENT @ NAME ::: 5867
STRING ) , ) ::: 5866
= [ NUMBER , ::: 5862
from . . NAME ::: 5839
] ] ) NEWLINE ::: 5837
NEWLINE if NAME and ::: 5835
NAME in NAME if ::: 5835
( ) ) : ::: 5825
, STRING : False ::: 5818
NUMBER , NAME , ::: 5802
DEDENT class NAME : ::: 5797
. NAME ] = ::: 5793
NAME ( - NUMBER ::: 5790
NAME - NUMBER ) ::: 5754
None , STRING : ::: 5751
INDENT NAME = False ::: 5745
. NAME = ( ::: 5731
NAME [ NAME , ::: 5718
NEWLINE continue NEWLINE DEDENT ::: 5710
= STRING NEWLINE if ::: 5705
INDENT raise NAME NEWLINE ::: 5703
] . NAME ) ::: 5702
NEWLINE NAME += NUMBER ::: 5702
NAME [ NAME [ ::: 5699
] . NAME . ::: 5694
} NEWLINE if NAME ::: 5693
} NEWLINE DEDENT def ::: 5692
== NAME ( NAME ::: 5691
DEDENT if STRING in ::: 5688
NEWLINE INDENT if STRING ::: 5683
NEWLINE break NEWLINE DEDENT ::: 5677
STRING ] , [ ::: 5663
[ ( NAME , ::: 5659
NAME += STRING NEWLINE ::: 5657
STRING , None , ::: 5656
) NEWLINE DEDENT try ::: 5656
NAME += NAME NEWLINE ::: 5612
, NAME ] , ::: 5609
, STRING % ( ::: 5601
NUMBER , STRING , ::: 5597
% NAME NEWLINE DEDENT ::: 5588
NAME ] [ STRING ::: 5564
= None NEWLINE if ::: 5561
NAME ) ] ) ::: 5561
NAME ) : return ::: 5557
( NAME * NAME ::: 5556
- NUMBER , NAME ::: 5553
( [ NAME ] ::: 5547
NAME in ( STRING ::: 5544
] ) . NAME ::: 5542
STRING NEWLINE pass NEWLINE ::: 5537
NUMBER ) NEWLINE assert ::: 5525
STRING NEWLINE NAME , ::: 5525
NAME * NAME . ::: 5508
: None , STRING ::: 5507
INDENT STRING NEWLINE pass ::: 5495
INDENT STRING NEWLINE for ::: 5492
[ STRING ] ] ::: 5488
return { STRING : ::: 5476
STRING ] == STRING ::: 5471
== STRING NEWLINE assert ::: 5469
STRING NEWLINE DEDENT if ::: 5458
- NUMBER ] ) ::: 5453
, NUMBER ] NEWLINE ::: 5451
] NEWLINE DEDENT return ::: 5443
import * NEWLINE from ::: 5441
NAME , [ STRING ::: 5437
. NAME NEWLINE import ::: 5437
NAME ) + NAME ::: 5432
import * NEWLINE def ::: 5431
* NEWLINE def NAME ::: 5431
None ) NEWLINE if ::: 5426
, } ) NEWLINE ::: 5418
( ) , NUMBER ::: 5417
( [ STRING ] ::: 5413
STRING + NAME NEWLINE ::: 5403
% NAME NEWLINE NAME ::: 5400
NAME [ : NAME ::: 5398
. NAME NEWLINE assert ::: 5380
( [ NAME ( ::: 5372
, [ NAME ] ::: 5372
NAME = ( ( ::: 5363
. NAME ( True ::: 5362
pass NEWLINE DEDENT NAME ::: 5360
for NAME in [ ::: 5359
continue NEWLINE DEDENT if ::: 5341
NAME + STRING , ::: 5334
( - NUMBER , ::: 5329
STRING NEWLINE NAME [ ::: 5324
NAME = { NAME ::: 5318
NAME == STRING NEWLINE ::: 5318
( STRING ) ] ::: 5308
= NAME ) : ::: 5304
NUMBER : NUMBER ] ::: 5304
in [ STRING , ::: 5301
NEWLINE NAME = - ::: 5289
, NAME : NAME ::: 5288
, [ NAME . ::: 5284
NAME = NAME * ::: 5274
. NAME ) == ::: 5270
} NEWLINE def NAME ::: 5267
( NAME ) [ ::: 5256
: NAME , } ::: 5251
= NAME ( ( ::: 5242
) ) ) ) ::: 5239
, NAME NEWLINE class ::: 5239
: NEWLINE INDENT del ::: 5233
STRING , ) , ::: 5226
DEDENT except ( NAME ::: 5226
INDENT NAME STRING NEWLINE ::: 5217
% ( NAME ( ::: 5216
NEWLINE INDENT if ( ::: 5212
None NEWLINE if NAME ::: 5202
[ NAME [ STRING ::: 5201
. NAME in NAME ::: 5197
) ) , STRING ::: 5196
NAME [ NAME ( ::: 5194
] , NAME , ::: 5179
+= NUMBER NEWLINE NAME ::: 5178
INDENT with NAME ( ::: 5174
STRING ) , ] ::: 5172
( NAME [ : ::: 5171
[ NUMBER : NUMBER ::: 5157
NUMBER ] : NEWLINE ::: 5157
STRING ) ] NEWLINE ::: 5154
( STRING in NAME ::: 5144
) = NAME . ::: 5141
( ) NEWLINE try ::: 5138
= NUMBER ) , ::: 5135
[ NAME ( STRING ::: 5123
[ : - NUMBER ::: 5121
NAME ) NEWLINE class ::: 5120
) NEWLINE if ( ::: 5116
STRING ] NEWLINE if ::: 5111
NEWLINE INDENT del NAME ::: 5109
STRING NEWLINE raise NAME ::: 5104
. NAME NEWLINE return ::: 5098
DEDENT for NAME , ::: 5096
. NAME ) ] ::: 5094
( NUMBER ) : ::: 5090
: NUMBER } , ::: 5088
NAME < NUMBER : ::: 5086
NAME - NAME . ::: 5071
NEWLINE DEDENT with NAME ::: 5062
: ] NEWLINE NAME ::: 5060
NAME + NUMBER NEWLINE ::: 5046
STRING ) , NUMBER ::: 5044
[ ] , NAME ::: 5043
[ STRING ] } ::: 5041
INDENT return NAME [ ::: 5039
* NAME * NAME ::: 5028
( NAME , { ::: 5027
False NEWLINE DEDENT def ::: 5025
DEDENT NAME [ STRING ::: 5018
in NAME if NAME ::: 5016
STRING NEWLINE class NAME ::: 5015
( STRING STRING % ::: 5012
False , STRING : ::: 5006
while True : NEWLINE ::: 5006
) , ) , ::: 4996
) for NAME , ::: 4991
. NAME , ( ::: 4981
NEWLINE return NAME , ::: 4975
) + STRING + ::: 4972
STRING ) ] ) ::: 4945
NEWLINE INDENT return NUMBER ::: 4942
NAME NEWLINE if not ::: 4928
if NAME != NAME ::: 4911
: False , STRING ::: 4910
NUMBER NEWLINE DEDENT else ::: 4908
NAME [ NAME + ::: 4905
} } NEWLINE NAME ::: 4901
not None and NAME ::: 4890
NAME * NAME ) ::: 4883
NAME = NAME = ::: 4877
= [ NAME , ::: 4854
NAME != STRING : ::: 4845
= NAME - NAME ::: 4836
] NEWLINE assert NAME ::: 4827
, NUMBER ] ] ::: 4825
NAME ) * NAME ::: 4823
= True ) , ::: 4816
STRING + NAME ) ::: 4811
( ) ] NEWLINE ::: 4807
) : return NAME ::: 4804
, ) , ( ::: 4797
( None , NAME ::: 4787
NAME , } NEWLINE ::: 4783
NAME ( None ) ::: 4782
+ NUMBER ) NEWLINE ::: 4769
) ] , NAME ::: 4748
: STRING } } ::: 4741
NAME [ : - ::: 4724
NAME ( True ) ::: 4723
NAME , STRING NEWLINE ::: 4722
if STRING not in ::: 4722
. NAME , { ::: 4713
for ( NAME , ::: 4711
STRING } , { ::: 4702
raise NAME ( ) ::: 4678
+ STRING NEWLINE DEDENT ::: 4662
NUMBER ) , NUMBER ::: 4640
- NAME ( NAME ::: 4639
. NAME : STRING ::: 4638
] NEWLINE NAME ( ::: 4621
. NAME ( - ::: 4618
NAME + NUMBER ] ::: 4612
NEWLINE DEDENT DEDENT for ::: 4612
NAME ) NEWLINE from ::: 4611
) NEWLINE if STRING ::: 4610
NAME + NUMBER , ::: 4608
NEWLINE DEDENT NAME += ::: 4603
| NAME . NAME ::: 4600
DEDENT NAME [ NAME ::: 4597
NAME , [ ] ::: 4594
= ( STRING STRING ::: 4593
[ [ NUMBER , ::: 4582
) [ STRING ] ::: 4579
) == STRING NEWLINE ::: 4575
, NAME + NUMBER ::: 4574
] ) NEWLINE return ::: 4572
STRING NEWLINE DEDENT elif ::: 4569
NAME . NAME if ::: 4566
. NAME , None ::: 4549
NAME and NAME ( ::: 4548
NUMBER ] , NUMBER ::: 4546
NAME [ : ] ::: 4545
NAME ( NAME - ::: 4544
] . NAME NEWLINE ::: 4540
: ] NEWLINE DEDENT ::: 4540
] , [ NAME ::: 4537
: NUMBER } ) ::: 4536
NAME != NAME : ::: 4529
== STRING NEWLINE DEDENT ::: 4528
) NEWLINE DEDENT finally ::: 4521
) + NAME ( ::: 4518
NUMBER NEWLINE def NAME ::: 4518
NUMBER ) ] NEWLINE ::: 4517
) ) for NAME ::: 4507
or NAME ( NAME ::: 4504
NEWLINE return ( NAME ::: 4496
INDENT class NAME ( ::: 4486
, STRING , { ::: 4475
, None ) , ::: 4470
{ STRING : True ::: 4470
NUMBER NEWLINE DEDENT if ::: 4467
) ) NEWLINE def ::: 4454
NAME in [ STRING ::: 4449
* NEWLINE from NAME ::: 4448
, None , NAME ::: 4447
INDENT assert NAME ( ::: 4442
STRING : True } ::: 4438
+ NAME , NAME ::: 4435
INDENT NAME += NUMBER ::: 4433
. import NAME NEWLINE ::: 4425
) or NAME . ::: 4416
if NAME > NUMBER ::: 4415
( NAME ) - ::: 4411
) . NAME ) ::: 4399
None , ** NAME ::: 4396
STRING ] [ NAME ::: 4394
NAME ] [ NUMBER ::: 4393
. . NAME import ::: 4383
= NAME ) . ::: 4372
STRING , ( NUMBER ::: 4365
NEWLINE DEDENT except ( ::: 4365
] NEWLINE DEDENT elif ::: 4361
from . import NAME ::: 4359
NAME ( [ ] ::: 4359
NEWLINE NAME += STRING ::: 4358
NAME STRING , NAME ::: 4354
) + NAME . ::: 4345
+ NUMBER , NAME ::: 4332
. NAME - NAME ::: 4330
, STRING , [ ::: 4327
, STRING , ) ::: 4320
NAME , True ) ::: 4315
= None , ** ::: 4301
[ NUMBER ] + ::: 4291
return NEWLINE DEDENT if ::: 4285
+ STRING , NAME ::: 4284
NUMBER ] ] ) ::: 4282
, STRING ] : ::: 4282
{ NAME . NAME ::: 4282
INDENT if STRING in ::: 4282
INDENT if ( NAME ::: 4277
for NAME in ( ::: 4276
( True ) NEWLINE ::: 4268
+ NUMBER ) ) ::: 4265
. NAME ] , ::: 4259
, STRING NEWLINE DEDENT ::: 4259
[ ] NEWLINE if ::: 4255
DEDENT if NAME [ ::: 4253
] ) , ( ::: 4251
- NUMBER ] , ::: 4239
. NAME if NAME ::: 4237
NAME ) NEWLINE with ::: 4233
NAME += NAME ( ::: 4221
. NAME += NUMBER ::: 4221
False NEWLINE DEDENT NAME ::: 4217
NEWLINE assert ( NAME ::: 4216
NAME ( ) - ::: 4207
) , NUMBER : ::: 4207
* NAME NEWLINE NAME ::: 4198
NAME ( NAME * ::: 4194
STRING ) and NAME ::: 4192
except ( NAME , ::: 4190
: return NAME . ::: 4187
NAME if NAME . ::: 4173
INDENT STRING NEWLINE raise ::: 4167
< NAME : NEWLINE ::: 4164
( STRING , False ::: 4163
NUMBER : ] ) ::: 4153
NAME | NAME . ::: 4147
INDENT return NUMBER NEWLINE ::: 4142
NAME . NAME > ::: 4136
] , { } ::: 4131
[ ( NUMBER , ::: 4129
NEWLINE return True NEWLINE ::: 4127
INDENT if NAME not ::: 4125
( STRING ) == ::: 4124
== NUMBER NEWLINE DEDENT ::: 4123
) . NAME , ::: 4119
NEWLINE if NAME > ::: 4114
STRING ) NEWLINE class ::: 4109
NAME ) ) . ::: 4107
NEWLINE DEDENT if ( ::: 4105
NAME , None , ::: 4099
+ NAME * NAME ::: 4097
STRING , { } ::: 4091
elif NAME == NAME ::: 4090
STRING : [ { ::: 4087
import NAME NEWLINE try ::: 4084
( NUMBER , ) ::: 4083
NAME ( [ [ ::: 4078
: [ { STRING ::: 4075
DEDENT return NAME , ::: 4075
- NUMBER ) , ::: 4073
) . NAME . ::: 4066
NAME NEWLINE NAME , ::: 4057
( NUMBER * NAME ::: 4052
STRING , ( STRING ::: 4051
. NAME * NAME ::: 4039
( NAME ) != ::: 4035
= NAME * NAME ::: 4033
return STRING % NAME ::: 4024
NAME == NAME NEWLINE ::: 4011
, [ NAME , ::: 3990
STRING : [ ] ::: 3988
NAME STRING % NAME ::: 3981
) } ) NEWLINE ::: 3975
. NAME [ - ::: 3975
NEWLINE ( NAME , ::: 3974
: ] ) NEWLINE ::: 3973
NEWLINE if NAME not ::: 3972
NAME * NAME * ::: 3970
NUMBER ) ] ) ::: 3970
NAME . NAME | ::: 3959
( ) for NAME ::: 3958
] ] NEWLINE NAME ::: 3956
NEWLINE if NAME < ::: 3951
NEWLINE from . import ::: 3946
% NAME , NAME ::: 3941
yield NAME NEWLINE DEDENT ::: 3940
NAME ( ) for ::: 3940
( NAME = { ::: 3938
} ) ) NEWLINE ::: 3938
= [ NAME [ ::: 3929
) NEWLINE continue NEWLINE ::: 3922
return NAME ( ) ::: 3921
. NAME } NEWLINE ::: 3921
) == STRING : ::: 3920
] ) NEWLINE def ::: 3915
[ NAME : NAME ::: 3914
NAME ( STRING in ::: 3907
if NAME < NUMBER ::: 3907
. NAME | NAME ::: 3901
= NUMBER NEWLINE def ::: 3899
STRING STRING % ( ::: 3886
. NAME = - ::: 3885
STRING , } NEWLINE ::: 3882
NAME , False ) ::: 3871
DEDENT if ( NAME ::: 3870
. NAME ) + ::: 3869
) == NAME . ::: 3855
[ NAME + NUMBER ::: 3854
. NAME } ) ::: 3853
( ) == STRING ::: 3852
NAME = STRING STRING ::: 3847
DEDENT NAME = NUMBER ::: 3843
) + STRING NEWLINE ::: 3841
= [ ( NAME ::: 3838
True ) , NAME ::: 3834
[ NAME ] : ::: 3833
NAME , STRING . ::: 3832
INDENT return ( NAME ::: 3831
== NAME NEWLINE DEDENT ::: 3830
NAME } NEWLINE DEDENT ::: 3830
is NAME : NEWLINE ::: 3830
, NUMBER : ( ::: 3826
> NAME : NEWLINE ::: 3813
NUMBER NEWLINE NAME [ ::: 3808
+ NAME + NAME ::: 3807
import NAME NEWLINE if ::: 3803
lambda NAME , NAME ::: 3794
( NAME = ( ::: 3790
INDENT return [ NAME ::: 3788
NAME + NAME + ::: 3786
NAME . NAME < ::: 3785
NAME : NAME , ::: 3779
) , NUMBER , ::: 3773
NAME * NAME NEWLINE ::: 3764
= NAME ) , ::: 3762
] = True NEWLINE ::: 3759
NAME ) if NAME ::: 3752
) NEWLINE assert ( ::: 3749
) NEWLINE DEDENT with ::: 3748
[ : NAME ] ::: 3748
* NAME + NAME ::: 3748
INDENT assert NAME . ::: 3738
NAME ) or NAME ::: 3738
NAME == NAME ) ::: 3737
] , NAME ( ::: 3736
NEWLINE INDENT return { ::: 3732
{ } , NAME ::: 3731
. NAME ( False ::: 3730
== NUMBER NEWLINE NAME ::: 3729
NEWLINE import NAME , ::: 3724
NAME = NUMBER * ::: 3715
== STRING and NAME ::: 3711
NAME + NAME * ::: 3704
( NAME - NUMBER ::: 3702
[ NAME [ NAME ::: 3700
) , NAME [ ::: 3691
DEDENT NAME ( STRING ::: 3680
= NAME + NUMBER ::: 3676
= STRING , ) ::: 3674
* NUMBER ) NEWLINE ::: 3674
, NAME , None ::: 3672
NAME + NAME ( ::: 3671
NAME ) : NAME ::: 3669
NAME ] , [ ::: 3668
NEWLINE DEDENT return STRING ::: 3659
return ( NAME , ::: 3657
[ STRING , NAME ::: 3651
[ : , NUMBER ::: 3650
NAME ) - NUMBER ::: 3644
NEWLINE assert not NAME ::: 3641
STRING NEWLINE @ NAME ::: 3638
None NEWLINE DEDENT if ::: 3627
assert STRING in NAME ::: 3621
NEWLINE INDENT NAME NAME ::: 3614
DEDENT return True NEWLINE ::: 3613
DEDENT DEDENT if not ::: 3612
. NAME , } ::: 3610
= NAME , ** ::: 3609
NUMBER + NUMBER ) ::: 3606
DEDENT DEDENT NAME ( ::: 3603
) NEWLINE del NAME ::: 3600
, ] ) NEWLINE ::: 3594
= [ { STRING ::: 3587
] . NAME = ::: 3582
and NAME : NEWLINE ::: 3582
NAME - NAME NEWLINE ::: 3580
( ) - NAME ::: 3579
STRING , [ NAME ::: 3577
, NAME ) and ::: 3567
return ( NAME . ::: 3564
INDENT NAME STRING % ::: 3564
: NEWLINE INDENT ( ::: 3561
STRING , True ) ::: 3560
STRING NEWLINE with NAME ::: 3559
] , STRING , ::: 3555
NAME = [ { ::: 3555
] ) NEWLINE assert ::: 3547
[ NUMBER ] : ::: 3542
: NAME , NAME ::: 3533
NAME != NUMBER : ::: 3532
NEWLINE INDENT ( NAME ::: 3528
] . NAME [ ::: 3514
: , NUMBER ] ::: 3513
( None ) NEWLINE ::: 3513
STRING ] = NUMBER ::: 3512
NEWLINE DEDENT raise NAME ::: 3509
STRING STRING , NAME ::: 3509
: NUMBER ] NEWLINE ::: 3505
NEWLINE return False NEWLINE ::: 3505
. NAME ( lambda ::: 3501
STRING , ] NEWLINE ::: 3492
NUMBER } ) NEWLINE ::: 3491
+= NAME ( NAME ::: 3490
NAME , ) , ::: 3489
/ NAME . NAME ::: 3487
NAME , { } ::: 3487
True NEWLINE DEDENT NAME ::: 3487
NEWLINE NAME ( NUMBER ::: 3480
{ } ) , ::: 3477
NUMBER * NAME . ::: 3476
NEWLINE while True : ::: 3474
DEDENT raise NAME ( ::: 3463
) and NAME ( ::: 3461
, [ NUMBER ] ::: 3459
NAME STRING % ( ::: 3458
) + STRING ) ::: 3457
DEDENT return False NEWLINE ::: 3456
- NUMBER : NEWLINE ::: 3454
as NAME NEWLINE NAME ::: 3447
from NAME import * ::: 3445
= None ) NEWLINE ::: 3441
STRING % NAME [ ::: 3441
DEDENT elif NAME [ ::: 3441
STRING , ( NAME ::: 3435
NAME += STRING % ::: 3435
NAME ( False ) ::: 3433
: NUMBER } NEWLINE ::: 3432
- NUMBER NEWLINE DEDENT ::: 3427
NAME ) / NAME ::: 3424
. NAME + NUMBER ::: 3423
None NEWLINE def NAME ::: 3415
: ( NUMBER , ::: 3411
NAME == STRING and ::: 3410
+ NAME [ NUMBER ::: 3410
+ STRING + STRING ::: 3407
if NAME [ NAME ::: 3403
= NAME ( { ::: 3401
NUMBER ) NEWLINE return ::: 3397
= NAME or NAME ::: 3387
>= NUMBER : NEWLINE ::: 3386
. NAME NEWLINE for ::: 3382
NAME * NAME + ::: 3372
DEDENT with NAME . ::: 3368
< NAME . NAME ::: 3359
[ - NUMBER , ::: 3358
= None NEWLINE def ::: 3357
) , { STRING ::: 3355
} NEWLINE NAME [ ::: 3347
) : NAME . ::: 3346
NAME = ( ) ::: 3329
, NAME , ) ::: 3326
- NAME ) NEWLINE ::: 3321
STRING STRING % NAME ::: 3315
: NAME } , ::: 3313
, NAME = - ::: 3303
return NAME [ NAME ::: 3302
) in NAME . ::: 3300
NAME [ NUMBER , ::: 3296
NUMBER , NUMBER : ::: 3290
] NEWLINE if not ::: 3280
NAME ) NEWLINE raise ::: 3279
= NUMBER NEWLINE if ::: 3274
) NEWLINE return STRING ::: 3272
- NAME NEWLINE NAME ::: 3267
INDENT raise NAME , ::: 3264
% ( NAME [ ::: 3261
} NEWLINE DEDENT NAME ::: 3261
INDENT ( NAME , ::: 3260
, NAME + NAME ::: 3256
= NAME = NAME ::: 3253
( STRING ) or ::: 3250
NUMBER ] == NAME ::: 3250
STRING NEWLINE DEDENT return ::: 3243
( ) == NAME ::: 3243
BOS NEWLINE NAME = ::: 3243
DEDENT return None NEWLINE ::: 3239
- NUMBER ) ) ::: 3235
: STRING } ] ::: 3230
NEWLINE NAME STRING % ::: 3224
STRING : [ NUMBER ::: 3223
, STRING + NAME ::: 3221
, [ ( STRING ::: 3219
{ STRING : ( ::: 3215
NAME = [ [ ::: 3214
INDENT yield NAME NEWLINE ::: 3211
NAME ( ) if ::: 3208
break NEWLINE DEDENT NAME ::: 3203
DEDENT DEDENT DEDENT else ::: 3198
assert NAME == NAME ::: 3197
NEWLINE INDENT raise NEWLINE ::: 3193
) NEWLINE return ( ::: 3193
STRING NEWLINE NAME STRING ::: 3188
] } ) NEWLINE ::: 3177
+ NUMBER NEWLINE DEDENT ::: 3171
NEWLINE assert STRING in ::: 3170
DEDENT NAME = ( ::: 3168
INDENT raise NEWLINE DEDENT ::: 3166
, NAME ( [ ::: 3164
NAME < NAME : ::: 3163
( NAME ( [ ::: 3162
) NEWLINE yield NAME ::: 3156
, NUMBER : NUMBER ::: 3156
{ NAME : NAME ::: 3155
NUMBER : NUMBER , ::: 3154
} NEWLINE DEDENT DEDENT ::: 3151
: NEWLINE INDENT while ::: 3150
NEWLINE DEDENT assert NAME ::: 3140
NAME ) , ) ::: 3139
( NAME ) as ::: 3133
STRING , ) ) ::: 3125
) , [ STRING ::: 3125
[ NUMBER ] * ::: 3122
NUMBER : ( STRING ::: 3119
: NUMBER ] ) ::: 3116
raise NAME , STRING ::: 3113
+= NAME NEWLINE DEDENT ::: 3110
NUMBER NEWLINE DEDENT return ::: 3109
NAME STRING NEWLINE DEDENT ::: 3106
DEDENT elif NAME in ::: 3103
NAME NEWLINE NAME += ::: 3096
STRING ) NEWLINE try ::: 3090
: [ NUMBER , ::: 3083
, STRING ) and ::: 3082
True ) ) NEWLINE ::: 3079
None , NAME . ::: 3078
= [ ] , ::: 3076
) ] = NAME ::: 3075
( NAME == NAME ::: 3070
] NEWLINE DEDENT EOS ::: 3068
. NAME += NAME ::: 3065
. NAME not in ::: 3059
{ } NEWLINE if ::: 3059
NUMBER ] ] NEWLINE ::: 3054
assert NAME [ NUMBER ::: 3051
) NEWLINE import NAME ::: 3050
None , None ) ::: 3049
* NAME , NAME ::: 3046
: NUMBER , NUMBER ::: 3043
( False ) NEWLINE ::: 3043
NAME is None or ::: 3042
elif NAME == NUMBER ::: 3040
STRING ) ) : ::: 3038
, STRING , ( ::: 3038
STRING : [ NAME ::: 3038
raise NEWLINE DEDENT DEDENT ::: 3034
NAME is NAME : ::: 3033
NAME . NAME not ::: 3032
[ STRING ] ( ::: 3018
NAME in ( NAME ::: 3017
STRING ] , NUMBER ::: 3016
: NAME [ NUMBER ::: 3016
assert not NAME . ::: 3014
NEWLINE return [ NAME ::: 3010
True NEWLINE DEDENT else ::: 3008
@ NAME NEWLINE @ ::: 3002
> NAME . NAME ::: 3001
( ) ] ) ::: 2999
= ( NAME ( ::: 2997
is NAME . NAME ::: 2995
STRING } , NAME ::: 2993
NUMBER ) NEWLINE def ::: 2990
NAME . NAME else ::: 2988
NUMBER NEWLINE DEDENT elif ::: 2987
DEDENT if NAME and ::: 2984
* NUMBER NEWLINE NAME ::: 2981
( NUMBER + NUMBER ::: 2979
) NEWLINE NAME NAME ::: 2977
) NEWLINE return True ::: 2976
, NAME = lambda ::: 2971
INDENT STRING NEWLINE from ::: 2969
False NEWLINE DEDENT if ::: 2968
STRING ) NEWLINE with ::: 2966
) , } NEWLINE ::: 2966
] NEWLINE try : ::: 2965
: NAME = NAME ::: 2960
NAME + NAME , ::: 2955
NAME / NUMBER ) ::: 2951
STRING , STRING % ::: 2945
NUMBER ] + NAME ::: 2942
STRING : ( NAME ::: 2942
, ] , NAME ::: 2940
. NAME ) and ::: 2937
] , [ ] ::: 2936
, STRING NEWLINE NAME ::: 2935
- NUMBER ] . ::: 2933
+ NUMBER NEWLINE NAME ::: 2929
( not NAME . ::: 2928
] } NEWLINE NAME ::: 2927
INDENT return STRING . ::: 2926
) [ - NUMBER ::: 2925
return [ ] NEWLINE ::: 2925
NEWLINE raise NAME NEWLINE ::: 2924
) } NEWLINE NAME ::: 2924
if NAME < NAME ::: 2920
if NAME != STRING ::: 2914
= NAME , ) ::: 2912
) , ] , ::: 2909
STRING ) ] , ::: 2906
) NEWLINE while NAME ::: 2899
if NAME : NAME ::: 2898
STRING , NAME NEWLINE ::: 2897
assert NAME [ STRING ::: 2896
, False ) , ::: 2895
NAME . NAME / ::: 2884
% ( NAME ) ::: 2884
INDENT del NAME . ::: 2883
( [ ( STRING ::: 2883
} ) : NEWLINE ::: 2882
) NEWLINE return False ::: 2879
** NAME . NAME ::: 2878
NAME = NAME / ::: 2878
( NAME ) is ::: 2874
NAME ) - NAME ::: 2871
else NAME . NAME ::: 2870
+= STRING NEWLINE DEDENT ::: 2869
NAME ] ) , ::: 2867
] == STRING NEWLINE ::: 2865
( [ [ NUMBER ::: 2863
DEDENT if NAME in ::: 2859
NAME : NAME + ::: 2858
, { } , ::: 2855
[ ] , STRING ::: 2850
] ) ) , ::: 2847
DEDENT NAME = None ::: 2842
. NAME and not ::: 2839
NAME == NAME ( ::: 2838
NAME ( NUMBER * ::: 2838
INDENT @ NAME NEWLINE ::: 2833
) ) ) , ::: 2823
= STRING ) . ::: 2818
NAME and NAME [ ::: 2817
STRING STRING . NAME ::: 2816
NAME NAME . NAME ::: 2815
} } ) NEWLINE ::: 2813
NEWLINE NAME = lambda ::: 2811
== NUMBER and NAME ::: 2809
NAME * NUMBER ) ::: 2805
, None , STRING ::: 2799
( ) if NAME ::: 2799
return NAME [ NUMBER ::: 2798
STRING ] = [ ::: 2797
STRING : { } ::: 2793
( ) + NAME ::: 2786
pass NEWLINE DEDENT else ::: 2782
STRING ] NEWLINE def ::: 2778
) ) ] NEWLINE ::: 2775
, - NUMBER ] ::: 2769
STRING , ] , ::: 2769
NAME - NUMBER ] ::: 2768
: [ ] , ::: 2768
: NAME ] NEWLINE ::: 2761
None ) ) NEWLINE ::: 2761
STRING , } , ::: 2758
( NAME ) and ::: 2758
, } NEWLINE DEDENT ::: 2750
NAME NEWLINE NAME STRING ::: 2747
) != NUMBER : ::: 2746
NEWLINE DEDENT from NAME ::: 2741
STRING NEWLINE NAME += ::: 2738
. NAME - NUMBER ::: 2738
in NAME [ NAME ::: 2738
if NAME > NAME ::: 2735
return NEWLINE DEDENT DEDENT ::: 2735
NAME . NAME >= ::: 2734
STRING ) or NAME ::: 2734
] NEWLINE NAME , ::: 2733
, [ NAME ( ::: 2732
) if NAME . ::: 2726
STRING + STRING + ::: 2724
None NEWLINE DEDENT return ::: 2715
( NAME ) < ::: 2713
STRING + NAME [ ::: 2712
+ NUMBER * NAME ::: 2711
[ STRING ] + ::: 2709
. NAME NEWLINE from ::: 2709
NAME > NAME : ::: 2708
( STRING , True ::: 2707
True ) NEWLINE def ::: 2706
NAME -= NUMBER NEWLINE ::: 2703
, None ) ) ::: 2699
is None or NAME ::: 2699
NAME in [ NAME ::: 2699
] ) NEWLINE for ::: 2698
DEDENT elif NAME is ::: 2694
in NAME [ NUMBER ::: 2694
True NEWLINE DEDENT if ::: 2693
: NEWLINE INDENT global ::: 2691
NEWLINE INDENT global NAME ::: 2691
= NAME ( lambda ::: 2690
( NUMBER ) ] ::: 2686
) and not NAME ::: 2684
NAME = yield NAME ::: 2681
] ) for NAME ::: 2680
NEWLINE return STRING % ::: 2680
, NAME ) == ::: 2679
NAME ) != NUMBER ::: 2677
as NAME NEWLINE DEDENT ::: 2676
, ] NEWLINE DEDENT ::: 2674
] NEWLINE DEDENT @ ::: 2667
NAME ) ) for ::: 2665
[ ( NAME . ::: 2663
STRING : ( NUMBER ::: 2663
None , NAME ) ::: 2662
% { STRING : ::: 2659
STRING ] == NAME ::: 2659
{ STRING : False ::: 2659
if NAME is NAME ::: 2659
, lambda NAME : ::: 2658
NAME and NAME : ::: 2657
( NUMBER ) . ::: 2657
( - NUMBER ) ::: 2655
] = ( NAME ::: 2654
while NAME . NAME ::: 2654
) NEWLINE ( NAME ::: 2650
STRING ] = True ::: 2650
STRING , NAME ] ::: 2646
NAME NEWLINE DEDENT for ::: 2644
[ STRING % NAME ::: 2642
) , None ) ::: 2639
( NAME ) * ::: 2634
] + NAME [ ::: 2634
NAME ) + NUMBER ::: 2631
NAME ] NEWLINE return ::: 2631
= ( ( STRING ::: 2628
, } , STRING ::: 2628
NUMBER ] for NAME ::: 2627
NAME ( ) as ::: 2625
( [ NAME [ ::: 2625
with NAME ( STRING ::: 2622
. NAME > NUMBER ::: 2621
= { NAME : ::: 2617
( STRING ) + ::: 2612
NEWLINE return NAME [ ::: 2609
) ) , ] ::: 2608
NEWLINE del NAME . ::: 2608
STRING : False } ::: 2607
. NAME is NAME ::: 2599
] ) , STRING ::: 2594
. NAME ) > ::: 2594
) , ) ) ::: 2589
[ NAME : ] ::: 2583
== STRING or NAME ::: 2576
NUMBER } NEWLINE NAME ::: 2576
= STRING NEWLINE class ::: 2575
NAME ] + NAME ::: 2572
( ) as NAME ::: 2561
/ NAME ( NAME ::: 2561
STRING ) == STRING ::: 2559
NAME == STRING ) ::: 2557
NUMBER , ) , ::: 2554
( ) NEWLINE with ::: 2554
NAME ) NEWLINE EOS ::: 2553
NUMBER ] * NAME ::: 2547
NAME [ NAME - ::: 2547
NAME , - NUMBER ::: 2546
[ : , NAME ::: 2539
[ NUMBER ] - ::: 2539
NAME ] for NAME ::: 2538
return [ NAME . ::: 2537
NEWLINE del NAME [ ::: 2535
elif NAME : NEWLINE ::: 2531
NUMBER , NAME [ ::: 2528
DEDENT elif NAME : ::: 2528
NUMBER ) NEWLINE for ::: 2525
STRING STRING ) , ::: 2520
= False ) , ::: 2520
NAME ) NEWLINE @ ::: 2515
, STRING , False ::: 2504
} ) , NAME ::: 2501
[ : ] NEWLINE ::: 2501
NAME : NAME [ ::: 2499
NAME , ( STRING ::: 2499
NAME ( ) } ::: 2498
INDENT return { STRING ::: 2494
} NEWLINE return NAME ::: 2489
) == NAME NEWLINE ::: 2488
) or NAME ( ::: 2488
= { } , ::: 2486
NEWLINE DEDENT return True ::: 2479
NEWLINE raise NAME . ::: 2476
. NAME != STRING ::: 2473
, NAME + STRING ::: 2470
NUMBER NEWLINE return NAME ::: 2469
None NEWLINE DEDENT else ::: 2467
- NUMBER * NAME ::: 2465
DEDENT elif not NAME ::: 2463
) NEWLINE assert not ::: 2461
= NUMBER NEWLINE while ::: 2454
NUMBER * NAME ) ::: 2449
NAME , ( NUMBER ::: 2449
: ( NAME , ::: 2448
and NAME [ NUMBER ::: 2445
STRING ] ] NEWLINE ::: 2445
= False NEWLINE if ::: 2442
( STRING STRING , ::: 2440
= False ) ) ::: 2439
] . NAME == ::: 2433
False ) , NAME ::: 2433
== NUMBER ) NEWLINE ::: 2432
, NAME , [ ::: 2429
NAME } , NAME ::: 2425
( [ ( NAME ::: 2425
. NAME , ** ::: 2416
in NAME and NAME ::: 2412
and not NAME : ::: 2410
NAME ) ( NAME ::: 2409
+ STRING . NAME ::: 2406
NAME ( NAME / ::: 2406
INDENT STRING NEWLINE assert ::: 2405
- NUMBER , STRING ::: 2402
, NUMBER : NAME ::: 2398
NUMBER ] == NUMBER ::: 2398
DEDENT with NAME ( ::: 2397
NAME , [ NUMBER ::: 2395
( ) , [ ::: 2395
= yield NAME . ::: 2394
NAME >= NUMBER : ::: 2390
and STRING in NAME ::: 2389
) NEWLINE DEDENT assert ::: 2388
( [ ] ) ::: 2385
== NAME ) NEWLINE ::: 2382
] == NAME . ::: 2375
assert NAME ( NUMBER ::: 2369
[ NAME - NUMBER ::: 2368
) ) , [ ::: 2368
NAME ] , STRING ::: 2363
( ) NEWLINE EOS ::: 2361
( ) NEWLINE class ::: 2358
STRING in NAME ) ::: 2353
False NEWLINE DEDENT return ::: 2352
[ NAME ] ] ::: 2352
] = { STRING ::: 2349
INDENT NAME [ NUMBER ::: 2348
NAME is not NAME ::: 2347
* NAME ) ) ::: 2343
NAME ) != NAME ::: 2340
) ) , ) ::: 2338
global NAME NEWLINE NAME ::: 2331
. NAME ) [ ::: 2330
NAME for NAME , ::: 2330
NUMBER ] ) : ::: 2327
NUMBER ] = NUMBER ::: 2325
] NEWLINE NAME += ::: 2323
NUMBER ) * NAME ::: 2318
: return NUMBER NEWLINE ::: 2314
NAME < NAME . ::: 2311
NUMBER : - NUMBER ::: 2310
] ] NEWLINE DEDENT ::: 2309
INDENT global NAME NEWLINE ::: 2309
None and NAME . ::: 2308
[ NAME ] + ::: 2307
= STRING NEWLINE for ::: 2304
. NAME ) for ::: 2303
NUMBER : NAME . ::: 2301
. NAME NEWLINE class ::: 2299
NAME ) < NUMBER ::: 2299
} ) , ( ::: 2298
return NAME ( * ::: 2297
= NAME ( * ::: 2296
) NEWLINE break NEWLINE ::: 2294
>> NAME . NAME ::: 2293
( [ ] , ::: 2292
) NEWLINE return [ ::: 2289
= STRING NEWLINE return ::: 2286
) ) , NUMBER ::: 2285
, NAME [ : ::: 2280
NAME == STRING or ::: 2280
NAME == NUMBER ) ::: 2278
NAME ) ] , ::: 2277
( NAME in NAME ::: 2274
NEWLINE NAME STRING , ::: 2274
STRING ] for NAME ::: 2271
( NAME ) if ::: 2271
< NAME ( NAME ::: 2270
NAME NEWLINE DEDENT try ::: 2269
) , [ ] ::: 2268
) * NAME . ::: 2266
[ ] , [ ::: 2264
- NAME , NAME ::: 2263
if not NAME and ::: 2258
[ NUMBER ] for ::: 2257
DEDENT NAME ( ) ::: 2250
[ STRING ] for ::: 2250
) * NAME ( ::: 2248
NUMBER ] - NAME ::: 2245
) , ] ) ::: 2241
NAME >> NAME . ::: 2241
] ) ) ) ::: 2240
NAME ) ] = ::: 2237
] = [ NAME ::: 2236
) , [ NAME ::: 2236
) ] , [ ::: 2235
INDENT STRING NEWLINE @ ::: 2234
= ( NAME [ ::: 2227
NEWLINE return NUMBER NEWLINE ::: 2223
False : NEWLINE INDENT ::: 2216
( NUMBER - NAME ::: 2212
NAME - NUMBER , ::: 2208
STRING : None } ::: 2208
NAME is NAME . ::: 2203
and NAME is not ::: 2200
NAME ] = NUMBER ::: 2199
= NUMBER * NAME ::: 2198
INDENT if NAME != ::: 2195
NEWLINE DEDENT elif not ::: 2195
INDENT STRING NEWLINE with ::: 2193
NUMBER ] ] , ::: 2191
STRING ] = { ::: 2187
) , STRING % ::: 2187
( STRING ) % ::: 2183
- NUMBER ) : ::: 2182
+= NAME NEWLINE NAME ::: 2180
, NAME NEWLINE def ::: 2177
= { } ) ::: 2176
) < NUMBER : ::: 2173
( NAME [ - ::: 2169
( ) ) . ::: 2168
STRING ] ) : ::: 2166
( ( NAME ( ::: 2162
NEWLINE yield NAME . ::: 2161
/ NUMBER ) NEWLINE ::: 2161
None NEWLINE for NAME ::: 2161
None , STRING ) ::: 2159
] - NAME [ ::: 2158
( NAME ) / ::: 2158
/ NUMBER NEWLINE NAME ::: 2155
NAME ( { NAME ::: 2155
, ( NUMBER + ::: 2154
, ) , ) ::: 2154
while NAME : NEWLINE ::: 2154
STRING : STRING % ::: 2152
NAME ) is NAME ::: 2150
: NAME ( ) ::: 2148
INDENT return [ ] ::: 2147
, ( NAME ( ::: 2146
NAME ] NEWLINE for ::: 2144
( ) + STRING ::: 2141
= { NAME . ::: 2140
del NAME [ STRING ::: 2139
DEDENT DEDENT DEDENT @ ::: 2131
NEWLINE for ( NAME ::: 2130
== STRING NEWLINE NAME ::: 2129
is not None NEWLINE ::: 2128
NAME * ( NAME ::: 2124
[ STRING % ( ::: 2123
STRING ) ) . ::: 2116
NEWLINE return None NEWLINE ::: 2114
) ) [ NUMBER ::: 2111
DEDENT return ( NAME ::: 2108
STRING , NAME : ::: 2100
, ) NEWLINE def ::: 2098
( NAME ) or ::: 2098
NEWLINE DEDENT return ( ::: 2098
( [ NUMBER ] ::: 2095
( * NAME . ::: 2093
STRING ] ( NAME ::: 2093
[ NAME ] == ::: 2091
/ NAME NEWLINE NAME ::: 2091
, ) NEWLINE EOS ::: 2089
<= NUMBER : NEWLINE ::: 2088
( ) == NUMBER ::: 2086
+= STRING % NAME ::: 2085
+= STRING NEWLINE NAME ::: 2082
NAME ) ) ] ::: 2079
] = [ ] ::: 2077
) - NAME . ::: 2076
NAME , NAME - ::: 2076
) - NAME ( ::: 2076
: NUMBER , } ::: 2075
, ) : NEWLINE ::: 2075
INDENT NAME STRING , ::: 2074
, NAME : STRING ::: 2074
) NEWLINE DEDENT raise ::: 2073
NEWLINE DEDENT return False ::: 2073
STRING ] } , ::: 2072
INDENT del NAME [ ::: 2072
] = None NEWLINE ::: 2070
] , ) NEWLINE ::: 2070
, } , NAME ::: 2065
( STRING ) and ::: 2063
NAME > NAME . ::: 2063
. NAME , False ::: 2063
= None NEWLINE for ::: 2062
return NAME ( [ ::: 2056
) ( NAME ) ::: 2054
) NEWLINE assert STRING ::: 2053
+ NAME [ NAME ::: 2051
, NAME ] = ::: 2050
BOS NEWLINE from . ::: 2050
NAME += STRING + ::: 2049
NUMBER ) [ NUMBER ::: 2039
NAME ) , ] ::: 2038
STRING ] NEWLINE for ::: 2038
= NAME NEWLINE for ::: 2036
False NEWLINE if NAME ::: 2035
NAME ) , [ ::: 2034
( None , None ::: 2033
NAME ( - NAME ::: 2028
DEDENT DEDENT DEDENT except ::: 2025
NEWLINE NAME [ : ::: 2025
NAME or NAME ( ::: 2023
) : pass NEWLINE ::: 2021
NUMBER } , STRING ::: 2020
DEDENT from NAME . ::: 2017
None and NAME is ::: 2014
) , ( ( ::: 2010
) - NUMBER ) ::: 2010
+= NUMBER NEWLINE if ::: 2009
% NAME , STRING ::: 2009
None ) , NAME ::: 2008
, STRING ] } ::: 2008
return NAME [ STRING ::: 2005
] ] , NAME ::: 2004
NAME * NAME ( ::: 2002
( NAME , True ::: 2000
NAME , } ) ::: 1999
, True ) , ::: 1998
not NAME and NAME ::: 1998
STRING NEWLINE DEDENT @ ::: 1996
if NAME != NUMBER ::: 1995
( NAME * NUMBER ::: 1995
and not NAME ( ::: 1994
) ] ) , ::: 1992
( ) NEWLINE while ::: 1992
if not ( NAME ::: 1991
STRING in NAME [ ::: 1990
NEWLINE return STRING . ::: 1988
. NAME , True ::: 1988
% NAME [ STRING ::: 1988
) ] ) ) ::: 1987
True NEWLINE DEDENT return ::: 1987
or NAME == STRING ::: 1984
DEDENT if NAME != ::: 1980
NAME - NUMBER NEWLINE ::: 1980
} ) . NAME ::: 1977
STRING ] } ) ::: 1975
NAME + ( NAME ::: 1974
] NEWLINE DEDENT class ::: 1973
NAME ( ) and ::: 1972
, } NEWLINE def ::: 1969
{ STRING : None ::: 1969
( ( NAME [ ::: 1969
NAME : return NUMBER ::: 1969
STRING , ** NAME ::: 1968
= NAME [ - ::: 1967
DEDENT DEDENT try : ::: 1962
NAME ( { } ::: 1960
NAME ) NEWLINE while ::: 1958
NUMBER NEWLINE while NAME ::: 1958
NAME , NUMBER : ::: 1957
STRING in NAME and ::: 1953
NEWLINE return { STRING ::: 1953
if NAME in ( ::: 1951
STRING NEWLINE return STRING ::: 1951
NAME ] = [ ::: 1951
+= STRING + NAME ::: 1950
( STRING + STRING ::: 1949
NAME or not NAME ::: 1948
NAME ( NAME == ::: 1948
) == NAME : ::: 1942
NUMBER ) ] , ::: 1942
NEWLINE DEDENT return None ::: 1942
import NAME NEWLINE return ::: 1941
( ) [ STRING ::: 1940
return NEWLINE DEDENT def ::: 1939
NEWLINE raise NEWLINE DEDENT ::: 1939
} ) NEWLINE return ::: 1937
) + NAME NEWLINE ::: 1934
: - NUMBER , ::: 1930
!= NAME ( NAME ::: 1928
[ NUMBER ] != ::: 1928
NAME , STRING + ::: 1926
NAME : NAME } ::: 1926
if ( not NAME ::: 1925
] , NUMBER , ::: 1925
= [ ] ) ::: 1925
) is not None ::: 1925
, ) ) , ::: 1925
if ( NAME ( ::: 1924
STRING ] } NEWLINE ::: 1924
( NAME , lambda ::: 1922
[ NAME ] for ::: 1921
+ STRING , STRING ::: 1921
) ) NEWLINE try ::: 1919
STRING STRING ) ) ::: 1918
and NAME [ STRING ::: 1915
NEWLINE NAME NAME NEWLINE ::: 1915
lambda : NAME . ::: 1915
) ] NEWLINE if ::: 1914
elif STRING in NAME ::: 1907
True NEWLINE DEDENT except ::: 1906
= NAME / NAME ::: 1906
) if NAME else ::: 1904
* NAME [ NUMBER ::: 1903
import NAME NEWLINE @ ::: 1901
NAME is None and ::: 1901
DEDENT elif STRING in ::: 1899
] = False NEWLINE ::: 1899
if not NAME or ::: 1897
NAME , False , ::: 1896
* NUMBER * NUMBER ::: 1893
NUMBER and NAME . ::: 1892
DEDENT DEDENT finally : ::: 1890
, NAME - NAME ::: 1890
NAME = NAME % ::: 1889
False NEWLINE def NAME ::: 1888
STRING % ( STRING ::: 1888
NAME : NAME ] ::: 1886
NAME ] = ( ::: 1885
INDENT class NAME : ::: 1882
: NAME + NUMBER ::: 1882
) } NEWLINE DEDENT ::: 1880
- NAME [ NUMBER ::: 1877
NAME [ ( NAME ::: 1876
- NUMBER ] [ ::: 1872
NEWLINE global NAME NEWLINE ::: 1870
) [ NUMBER : ::: 1870
. NAME : return ::: 1869
None , STRING , ::: 1869
[ : , : ::: 1868
, NAME * NAME ::: 1868
NEWLINE DEDENT elif STRING ::: 1866
= - NUMBER ) ::: 1864
) or ( NAME ::: 1863
>= NAME . NAME ::: 1861
= False NEWLINE def ::: 1859
- NAME * NAME ::: 1859
= [ NUMBER ] ::: 1859
( NAME , False ::: 1858
} , NAME . ::: 1856
STRING ) % NAME ::: 1856
: NUMBER ] , ::: 1851
True NEWLINE DEDENT elif ::: 1847
del NAME [ NAME ::: 1845
STRING + NAME , ::: 1843
[ NAME ( NUMBER ::: 1843
: , NAME ] ::: 1843
( NAME ) } ::: 1842
INDENT yield NAME . ::: 1841
True ) NEWLINE if ::: 1837
if NAME and not ::: 1836
NAME . NAME % ::: 1828
NAME ( NAME % ::: 1824
NEWLINE while NAME : ::: 1823
NAME ) : pass ::: 1822
+ NAME [ STRING ::: 1820
NAME : ] NEWLINE ::: 1819
in ( NAME , ::: 1818
] == NUMBER NEWLINE ::: 1817
) ; NEWLINE NAME ::: 1816
. NAME != NUMBER ::: 1811
or not NAME . ::: 1808
NEWLINE if NAME >= ::: 1806
NAME , } , ::: 1805
NEWLINE DEDENT import NAME ::: 1803
== None : NEWLINE ::: 1803
] NEWLINE DEDENT for ::: 1803
NAME == None : ::: 1802
NEWLINE NAME NAME . ::: 1800
) in NAME ( ::: 1799
% STRING . NAME ::: 1797
DEDENT NAME += NUMBER ::: 1797
( NAME / NUMBER ::: 1793
{ } , STRING ::: 1793
DEDENT return STRING . ::: 1790
NAME + NUMBER : ::: 1789
None , NAME , ::: 1787
INDENT if NAME and ::: 1784
& NAME . NAME ::: 1783
) + NUMBER NEWLINE ::: 1780
NAME ) / NUMBER ::: 1780
] += NUMBER NEWLINE ::: 1778
INDENT @ NAME . ::: 1778
= - NUMBER , ::: 1776
: NAME + NAME ::: 1776
[ NUMBER : - ::: 1776
DEDENT NAME += NAME ::: 1773
return [ NAME ( ::: 1772
False NEWLINE DEDENT else ::: 1772
= STRING NEWLINE import ::: 1771
STRING and NAME . ::: 1771
NAME * NAME , ::: 1770
) and ( NAME ::: 1768
) == NUMBER ) ::: 1768
( NUMBER , - ::: 1766
= False NEWLINE for ::: 1765
False ) ) NEWLINE ::: 1764
[ ] NEWLINE def ::: 1763
, NUMBER ) [ ::: 1761
assert ( NAME . ::: 1761
STRING : - NUMBER ::: 1761
} } , STRING ::: 1760
* NAME NEWLINE DEDENT ::: 1759
False NEWLINE for NAME ::: 1759
NAME + NAME ] ::: 1752
NUMBER } , { ::: 1747
) + NUMBER ) ::: 1745
. NAME NEWLINE try ::: 1745
( NAME for NAME ::: 1744
, NUMBER ) . ::: 1744
NAME , [ ( ::: 1743
, NAME - NUMBER ::: 1742
NAME if NAME else ::: 1741
: ] , NAME ::: 1740
NAME / NAME NEWLINE ::: 1740
NAME ) > NAME ::: 1739
STRING , [ ( ::: 1737
continue NEWLINE DEDENT DEDENT ::: 1736
while NAME < NAME ::: 1735
NAME ) } NEWLINE ::: 1734
= ( ) NEWLINE ::: 1733
, NAME , False ::: 1733
if NAME else NAME ::: 1729
NUMBER ] NEWLINE assert ::: 1728
in ( NAME . ::: 1728
is not None ) ::: 1727
[ - NUMBER : ::: 1727
NAME = NAME if ::: 1727
if not NAME [ ::: 1726
STRING % STRING . ::: 1724
] ) , NUMBER ::: 1723
as NAME NEWLINE class ::: 1723
- NAME ) ) ::: 1722
== NAME NEWLINE assert ::: 1718
INDENT NAME >> NAME ::: 1717
NEWLINE INDENT NAME >> ::: 1717
( NAME / NAME ::: 1717
. NAME * NUMBER ::: 1717
NAME : ( NAME ::: 1714
) in NAME : ::: 1714
, ( ( STRING ::: 1713
= True , ) ::: 1711
NAME < NAME ( ::: 1707
, lambda : NAME ::: 1707
NAME if NAME ( ::: 1706
> NUMBER and NAME ::: 1705
STRING STRING STRING % ::: 1703
NAME ) < NAME ::: 1701
NAME STRING + NAME ::: 1701
STRING in NAME NEWLINE ::: 1700
, ** NAME . ::: 1699
( STRING STRING . ::: 1698
= ( NAME + ::: 1695
if NAME else STRING ::: 1694
NAME NEWLINE with NAME ::: 1693
, [ - NUMBER ::: 1692
= NAME if NAME ::: 1692
STRING + STRING . ::: 1692
, ] , STRING ::: 1689
NEWLINE DEDENT NAME STRING ::: 1689
DEDENT if STRING not ::: 1688
NUMBER , NAME + ::: 1687
, NAME , { ::: 1686
) NEWLINE while True ::: 1685
. NAME < NAME ::: 1683
assert NAME ( STRING ::: 1683
[ [ STRING , ::: 1680
STRING ) , [ ::: 1674
STRING ) + NAME ::: 1674
NAME = { NUMBER ::: 1671
is None and NAME ::: 1670
. NAME ] . ::: 1669
NAME ] = { ::: 1666
[ ] ) : ::: 1664
NUMBER ] + STRING ::: 1664
= NAME ( None ::: 1663
STRING ] NEWLINE assert ::: 1663
NEWLINE while NAME < ::: 1662
DEDENT elif ( NAME ::: 1661
] NEWLINE class NAME ::: 1660
DEDENT DEDENT NAME [ ::: 1660
, NAME , True ::: 1660
: NAME ( NUMBER ::: 1656
NUMBER ] NEWLINE return ::: 1656
: ] : NEWLINE ::: 1655
NEWLINE if STRING not ::: 1655
) NEWLINE STRING NEWLINE ::: 1654
, NUMBER ] = ::: 1654
NEWLINE DEDENT DEDENT try ::: 1650
if NAME >= NUMBER ::: 1650
NAME ) NEWLINE continue ::: 1649
[ STRING , ] ::: 1648
NUMBER NEWLINE NAME ( ::: 1648
yield NAME ( NAME ::: 1646
DEDENT DEDENT except : ::: 1644
NEWLINE while NAME . ::: 1642
NAME / NAME ) ::: 1641
STRING ] = ( ::: 1640
NUMBER * NAME ( ::: 1640
!= None : NEWLINE ::: 1635
NAME = - NAME ::: 1634
NEWLINE DEDENT elif ( ::: 1632
% NAME ( ) ::: 1632
) NEWLINE raise NEWLINE ::: 1632
) NEWLINE return NUMBER ::: 1631
, NUMBER * NAME ::: 1630
, NAME ) or ::: 1629
NAME == NUMBER and ::: 1629
] != STRING : ::: 1629
. NAME in ( ::: 1628
- NUMBER : ] ::: 1627
] + NAME . ::: 1627
NAME <= NUMBER : ::: 1626
. NAME / NUMBER ::: 1626
) ) ] ) ::: 1624
NAME - NAME ( ::: 1623
= { NUMBER : ::: 1623
: True } ) ::: 1623
) , True ) ::: 1622
NAME - NAME , ::: 1621
NUMBER * NUMBER * ::: 1619
NUMBER + NAME . ::: 1619
: { } , ::: 1618
STRING : [ ( ::: 1617
NUMBER ) ) . ::: 1617
NUMBER ) + NAME ::: 1617
STRING , } ) ::: 1616
( ) NEWLINE @ ::: 1615
: NUMBER } } ::: 1614
NAME ) NEWLINE yield ::: 1611
) ] , STRING ::: 1610
] = { } ::: 1609
( ( NAME - ::: 1609
STRING ] ] ) ::: 1609
= NUMBER ) . ::: 1608
] ] = NAME ::: 1606
) ] NEWLINE for ::: 1605
INDENT return NAME , ::: 1603
, NAME , ( ::: 1603
DEDENT import NAME NEWLINE ::: 1603
True NEWLINE def NAME ::: 1602
) ) ) : ::: 1601
DEDENT if NAME > ::: 1600
STRING ) NEWLINE raise ::: 1598
NEWLINE assert NAME is ::: 1597
NAME ( ) != ::: 1594
: ] . NAME ::: 1594
NAME , STRING STRING ::: 1592
in NAME ) : ::: 1592
assert ( NAME ( ::: 1591
) != NAME ( ::: 1590
) ) == NAME ::: 1587
( [ NAME for ::: 1587
= [ STRING % ::: 1586
NAME NAME NEWLINE NAME ::: 1586
, NAME ) [ ::: 1586
NAME == - NUMBER ::: 1585
, STRING , True ::: 1581
** NAME ) ) ::: 1581
NAME , STRING ] ::: 1581
= True NEWLINE def ::: 1579
( NUMBER + NAME ::: 1579
, [ ( NUMBER ::: 1576
) / NUMBER NEWLINE ::: 1574
) , [ NUMBER ::: 1574
] NEWLINE del NAME ::: 1573
DEDENT return NAME [ ::: 1573
STRING ] ) . ::: 1572
) NEWLINE return None ::: 1571
False ) , ( ::: 1571
) - NUMBER NEWLINE ::: 1571
None or NAME . ::: 1570
@ NAME ( ) ::: 1570
( ) , ( ::: 1569
] ( NAME , ::: 1566
True ) . NAME ::: 1565
} ] NEWLINE NAME ::: 1565
, False ) : ::: 1564
( NAME ) ( ::: 1561
NAME += [ NAME ::: 1561
NUMBER , ( NUMBER ::: 1560
= STRING ) ] ::: 1560
= lambda NAME , ::: 1559
False ) NEWLINE if ::: 1557
return NUMBER NEWLINE if ::: 1555
( NAME ( ( ::: 1553
NAME ( NAME in ::: 1550
NUMBER NEWLINE NAME += ::: 1548
NAME % ( NAME ::: 1548
( STRING ) } ::: 1548
NAME , True , ::: 1546
( STRING ) as ::: 1542
NAME ) ) + ::: 1542
: NUMBER ] == ::: 1541
in NAME NEWLINE DEDENT ::: 1539
= ( ( NAME ::: 1538
@ NAME NEWLINE class ::: 1537
NAME , lambda : ::: 1536
NAME += NAME + ::: 1535
NAME ( ) is ::: 1534
yield NAME , NAME ::: 1534
NAME , NAME * ::: 1534
NAME != None : ::: 1531
* ( NAME - ::: 1528
. NAME = lambda ::: 1528
return NAME + NAME ::: 1527
NAME ) == STRING ::: 1527
-= NUMBER NEWLINE DEDENT ::: 1522
INDENT import NAME as ::: 1521
NAME = STRING if ::: 1520
: ] = NAME ::: 1520
) / NAME ( ::: 1520
DEDENT if NAME < ::: 1516
NUMBER * NUMBER ) ::: 1514
* NAME ** NUMBER ::: 1514
) * NUMBER NEWLINE ::: 1514
NUMBER ) , [ ::: 1513
, NUMBER ) == ::: 1511
) ) NEWLINE with ::: 1510
STRING ) , } ::: 1510
INDENT NAME NAME NEWLINE ::: 1508
NAME + NAME [ ::: 1506
: STRING % NAME ::: 1506
== STRING ) NEWLINE ::: 1504
. NAME ) as ::: 1503
, STRING ] ] ::: 1502
[ STRING ] is ::: 1501
) , NAME : ::: 1500
+ NUMBER : ] ::: 1499
NAME , : ] ::: 1499
not NAME [ STRING ::: 1499
DEDENT return NEWLINE DEDENT ::: 1499
. NAME ) or ::: 1497
+ NUMBER ) : ::: 1494
] = STRING . ::: 1494
) , STRING NEWLINE ::: 1491
or NAME : NEWLINE ::: 1490
[ NAME ( ) ::: 1490
) ) + STRING ::: 1489
STRING ] = False ::: 1488
if NAME >= NAME ::: 1487
as NAME , NAME ::: 1485
( NUMBER , ( ::: 1485
DEDENT DEDENT return None ::: 1485
( NAME ** NUMBER ::: 1483
NAME NEWLINE DEDENT from ::: 1481
] , [ - ::: 1479
. NAME > NAME ::: 1477
DEDENT DEDENT DEDENT elif ::: 1477
NEWLINE INDENT while NAME ::: 1476
[ STRING ] != ::: 1476
STRING NEWLINE if STRING ::: 1475
NAME STRING . NAME ::: 1474
NAME not in ( ::: 1473
STRING ) for NAME ::: 1472
NAME ] ) : ::: 1472
. NAME == ( ::: 1471
STRING } NEWLINE DEDENT ::: 1469
* NUMBER , NAME ::: 1469
<= NAME . NAME ::: 1468
( NAME , - ::: 1467
} ) NEWLINE if ::: 1465
NAME ) [ STRING ::: 1465
] ) ] NEWLINE ::: 1463
None NEWLINE assert NAME ::: 1462
pass NEWLINE DEDENT @ ::: 1461
, ( ( NUMBER ::: 1461
- NAME ) / ::: 1461
NAME ) ) == ::: 1460
. . NAME . ::: 1458
STRING or NAME == ::: 1457
INDENT if NAME < ::: 1456
NAME ** NUMBER ) ::: 1456
) ) == NUMBER ::: 1456
NEWLINE NAME = yield ::: 1456
not STRING in NAME ::: 1455
+ NUMBER , NUMBER ::: 1455
} ) NEWLINE assert ::: 1454
{ } ) : ::: 1454
) [ : NUMBER ::: 1453
NUMBER ] != STRING ::: 1450
] == NAME [ ::: 1448
) NEWLINE return { ::: 1448
= STRING STRING ) ::: 1447
) == NUMBER and ::: 1447
NEWLINE DEDENT DEDENT finally ::: 1446
= STRING if NAME ::: 1445
: { } } ::: 1444
) ] NEWLINE return ::: 1444
NEWLINE INDENT return not ::: 1444
STRING ] + NAME ::: 1442
- NUMBER ] == ::: 1441
STRING ) : ( ::: 1441
NAME ( not NAME ::: 1439
STRING STRING STRING , ::: 1439
DEDENT DEDENT return False ::: 1438
NAME ) NEWLINE del ::: 1438
NAME = lambda : ::: 1438
NAME ) and not ::: 1437
NAME or { } ::: 1437
: ( NAME . ::: 1436
NUMBER : ] , ::: 1434
NUMBER ] ) . ::: 1433
, } , } ::: 1433
in NAME NEWLINE assert ::: 1433
NAME NAME NEWLINE DEDENT ::: 1433
and ( NAME . ::: 1431
STRING + STRING ) ::: 1430
not NAME or NAME ::: 1428
STRING , STRING . ::: 1427
] == NAME : ::: 1427
= STRING NEWLINE EOS ::: 1426
[ NUMBER , - ::: 1425
, STRING : - ::: 1425
== STRING ) : ::: 1423
NAME / NUMBER NEWLINE ::: 1422
: , : , ::: 1422
DEDENT DEDENT DEDENT for ::: 1419
( ) } NEWLINE ::: 1418
+ NAME ) ) ::: 1415
NAME ( lambda : ::: 1415
[ ] ) ) ::: 1408
NAME else NAME . ::: 1408
[ NAME ] += ::: 1408
NAME . NAME -= ::: 1407
NEWLINE del NAME NEWLINE ::: 1407
NAME ) } ) ::: 1406
* NAME + NUMBER ::: 1404
INDENT NAME += [ ::: 1403
NAME == NAME [ ::: 1403
: [ ] } ::: 1402
None NEWLINE try : ::: 1401
] ) [ NUMBER ::: 1401
: NAME [ NAME ::: 1401
) ) NEWLINE continue ::: 1401
NEWLINE return STRING NEWLINE ::: 1400
: STRING . NAME ::: 1398
DEDENT if NAME not ::: 1397
+= STRING . NAME ::: 1397
) - NAME ) ::: 1396
DEDENT return STRING % ::: 1396
if ( NAME == ::: 1394
- NAME NEWLINE DEDENT ::: 1394
+ NUMBER ] ) ::: 1394
in [ NAME . ::: 1394
[ NAME , STRING ::: 1394
) * NAME NEWLINE ::: 1393
>= NAME : NEWLINE ::: 1392
if NAME == None ::: 1392
STRING NEWLINE DEDENT EOS ::: 1390
= ( NAME - ::: 1390
== - NUMBER : ::: 1389
NAME ) ) is ::: 1389
STRING , ] ) ::: 1388
/ NAME ) NEWLINE ::: 1387
NAME NEWLINE assert STRING ::: 1386
NEWLINE NAME ( [ ::: 1386
) * ( NAME ::: 1385
NAME and STRING in ::: 1384
( None , STRING ::: 1384
( NAME == NUMBER ::: 1383
elif NAME in NAME ::: 1381
: : - NUMBER ::: 1381
NAME : NAME = ::: 1378
== NAME [ STRING ::: 1378
= True ) . ::: 1378
NUMBER , NUMBER NEWLINE ::: 1377
* ( NAME + ::: 1377
NAME >= NAME . ::: 1375
STRING ] == NUMBER ::: 1375
NAME NEWLINE STRING NEWLINE ::: 1374
= True NEWLINE if ::: 1374
STRING , STRING STRING ::: 1373
= NAME ( ** ::: 1371
not NAME in NAME ::: 1370
( NUMBER ) == ::: 1369
} ) NEWLINE def ::: 1369
} , } NEWLINE ::: 1368
NAME ] = STRING ::: 1368
: True } , ::: 1367
NUMBER ) == NUMBER ::: 1367
* NUMBER NEWLINE DEDENT ::: 1366
NAME ) , None ::: 1365
) = NAME NEWLINE ::: 1365
) / NUMBER ) ::: 1364
STRING , ( ( ::: 1364
, STRING STRING ) ::: 1364
NAME NEWLINE if ( ::: 1363
) [ NAME ] ::: 1363
NAME , NUMBER ] ::: 1362
assert NAME is not ::: 1362
return ( NAME ( ::: 1359
with NAME ( ) ::: 1359
if NAME or NAME ::: 1358
STRING } } , ::: 1358
. NAME ) - ::: 1356
( NAME == STRING ::: 1355
STRING ) + STRING ::: 1355
NAME ( STRING * ::: 1355
NUMBER - NAME ) ::: 1354
is True : NEWLINE ::: 1354
NAME ( True , ::: 1353
STRING ) , { ::: 1353
in NAME ( ) ::: 1352
NAME ** NUMBER + ::: 1351
) } } NEWLINE ::: 1350
( NAME is not ::: 1350
] == NUMBER : ::: 1350
STRING NEWLINE from . ::: 1350
, ) , STRING ::: 1349
STRING % NAME ] ::: 1348
NAME is None NEWLINE ::: 1348
[ STRING . NAME ::: 1348
NAME ( ) or ::: 1345
STRING NEWLINE return [ ::: 1344
NEWLINE NAME >> NAME ::: 1344
INDENT STRING NEWLINE class ::: 1342
NUMBER * NAME + ::: 1342
NAME / NAME . ::: 1342
return { } NEWLINE ::: 1342
, NAME ) + ::: 1341
) ) NEWLINE raise ::: 1340
STRING ] = None ::: 1339
NAME += STRING . ::: 1337
( ) and NAME ::: 1336
and NAME in NAME ::: 1336
) , } ) ::: 1335
DEDENT NAME += STRING ::: 1335
break NEWLINE DEDENT if ::: 1334
elif NAME [ NUMBER ::: 1332
== NAME and NAME ::: 1331
) if NAME ( ::: 1331
None ) , ( ::: 1330
, STRING ) } ::: 1330
: [ ( STRING ::: 1330
. NAME ( not ::: 1328
NUMBER ) / NUMBER ::: 1328
NAME else STRING NEWLINE ::: 1327
== ( NUMBER , ::: 1323
NAME NEWLINE while NAME ::: 1323
STRING ) } ) ::: 1323
elif NAME [ STRING ::: 1323
STRING ) [ - ::: 1321
, ( ) ) ::: 1319
NUMBER : ] : ::: 1319
== NAME NEWLINE NAME ::: 1317
. NAME } , ::: 1317
= None NEWLINE try ::: 1317
NAME or [ ] ::: 1316
, ) , ] ::: 1316
INDENT import NAME . ::: 1315
[ : ] = ::: 1315
) ) + NAME ::: 1314
} ] ) NEWLINE ::: 1314
) NEWLINE from . ::: 1314
is False : NEWLINE ::: 1313
+= STRING % ( ::: 1311
DEDENT NAME = False ::: 1311
[ NUMBER ] in ::: 1311
+ NUMBER ) , ::: 1308
: NAME ] ) ::: 1308
DEDENT assert NAME . ::: 1308
NAME , lambda NAME ::: 1308
) , ** NAME ::: 1307
) / NAME . ::: 1307
[ NAME + NAME ::: 1307
NAME [ : : ::: 1306
DEDENT assert NAME ( ::: 1306
. NAME or STRING ::: 1305
NUMBER , NUMBER + ::: 1305
STRING ] , } ::: 1305
STRING , lambda NAME ::: 1305
. NAME ] [ ::: 1304
NAME ( ) in ::: 1302
NUMBER NEWLINE DEDENT class ::: 1301
NUMBER and NAME [ ::: 1301
) ; NEWLINE DEDENT ::: 1300
. NAME ] : ::: 1300
NEWLINE INDENT NAME -= ::: 1300
NAME = not NAME ::: 1299
) , { } ::: 1297
NAME NEWLINE break NEWLINE ::: 1295
False , ** NAME ::: 1293
is not None else ::: 1292
, None NEWLINE DEDENT ::: 1292
{ } ) ) ::: 1292
NUMBER ) ) : ::: 1290
DEDENT DEDENT raise NAME ::: 1290
NAME . NAME <= ::: 1290
None NEWLINE STRING NEWLINE ::: 1289
assert NAME == STRING ::: 1289
} ] , STRING ::: 1288
* NAME ) , ::: 1287
= None NEWLINE STRING ::: 1286
while NUMBER : NEWLINE ::: 1286
< ( NUMBER , ::: 1284
) + NAME ) ::: 1284
NAME ) * NUMBER ::: 1283
INDENT NAME = - ::: 1281
NAME is None ) ::: 1281
if not NAME in ::: 1279
} NEWLINE DEDENT else ::: 1276
= False , ** ::: 1276
, None ) : ::: 1276
) * NUMBER ) ::: 1274
[ STRING ] += ::: 1273
NAME , = NAME ::: 1272
NUMBER ] NEWLINE for ::: 1272
return NAME ( ( ::: 1271
STRING ] , ) ::: 1271
[ ] ) , ::: 1270
( ( NAME + ::: 1270
) - NAME NEWLINE ::: 1270
( NAME and NAME ::: 1268
] * NAME [ ::: 1267
} NEWLINE DEDENT if ::: 1267
] NEWLINE with NAME ::: 1264
( [ STRING % ::: 1263
is not NAME : ::: 1262
+ NUMBER ] NEWLINE ::: 1262
= NAME - NUMBER ::: 1261
STRING ] NEWLINE return ::: 1261
( NAME or NAME ::: 1258
] , } NEWLINE ::: 1258
] } , STRING ::: 1257
NAME ) , } ::: 1257
INDENT @ NAME ( ::: 1256
== NAME ( STRING ::: 1256
True ) NEWLINE return ::: 1255
NUMBER NEWLINE DEDENT @ ::: 1255
NUMBER , ) ) ::: 1255
] + STRING + ::: 1254
: [ NAME . ::: 1253
NAME ] == NAME ::: 1252
NAME * NUMBER NEWLINE ::: 1252
NAME else None NEWLINE ::: 1252
STRING ] + STRING ::: 1252
{ } NEWLINE def ::: 1252
import * NEWLINE NAME ::: 1251
INDENT if NAME > ::: 1251
, ( - NUMBER ::: 1249
NAME or NAME : ::: 1248
lambda : NAME ( ::: 1247
else STRING NEWLINE NAME ::: 1247
, False , False ::: 1245
INDENT if STRING not ::: 1245
} NEWLINE DEDENT @ ::: 1243
NEWLINE DEDENT return [ ::: 1242
and NAME [ NAME ::: 1241
* NUMBER ) ) ::: 1241
) . NAME == ::: 1240
NEWLINE INDENT from . ::: 1240
STRING } } NEWLINE ::: 1240
in NAME ) ) ::: 1239
. NAME < NUMBER ::: 1239
NAME + [ NAME ::: 1238
NAME and ( NAME ::: 1237
return STRING + NAME ::: 1237
NAME ] ) for ::: 1236
( NAME is None ::: 1235
NEWLINE DEDENT return NEWLINE ::: 1235
STRING in NAME ( ::: 1235
NAME >> NAME , ::: 1234
] , None ) ::: 1233
BOS NEWLINE class NAME ::: 1233
NUMBER * ( NAME ::: 1230
[ NUMBER , NAME ::: 1227
STRING ) : NAME ::: 1225
) , False ) ::: 1224
not NAME and not ::: 1224
STRING ] , { ::: 1221
: NAME } } ::: 1220
as NAME NEWLINE def ::: 1220
NAME } NEWLINE if ::: 1220
NEWLINE yield NAME NEWLINE ::: 1219
and NAME not in ::: 1219
NAME is None else ::: 1218
DEDENT DEDENT return True ::: 1218
= STRING STRING STRING ::: 1218
NAME += NAME [ ::: 1217
) ( ) NEWLINE ::: 1215
] = STRING % ::: 1214
] NEWLINE while NAME ::: 1214
from NAME import ( ::: 1212
NUMBER * NAME , ::: 1212
+ NUMBER ) * ::: 1212
NAME ( ) > ::: 1210
NUMBER ] [ NAME ::: 1209
NAME NEWLINE from ... ::: 1208
== NUMBER ) : ::: 1207
NEWLINE DEDENT STRING NEWLINE ::: 1207
) ) : NAME ::: 1205
True ) , ( ::: 1205
NAME ] ] NEWLINE ::: 1204
NAME and NAME == ::: 1204
) , None , ::: 1202
( { } ) ::: 1201
while NAME ( NAME ::: 1200
) , [ ( ::: 1200
[ NAME , : ::: 1200
not ( NAME . ::: 1199
INDENT NAME = lambda ::: 1199
] ] ) , ::: 1198
pass NEWLINE DEDENT EOS ::: 1196
elif NAME in ( ::: 1195
if not STRING in ::: 1195
= NUMBER * NUMBER ::: 1194
- NUMBER ] ] ::: 1193
NUMBER ) for NAME ::: 1192
= ( STRING ) ::: 1190
] ) == NUMBER ::: 1190
NAME ) ** NUMBER ::: 1190
NUMBER NEWLINE NAME , ::: 1190
: NAME = STRING ::: 1189
from . NAME . ::: 1189
INDENT STRING NEWLINE import ::: 1188
= STRING NEWLINE from ::: 1188
NUMBER + NUMBER , ::: 1187
( NAME ) >= ::: 1187
, NAME [ - ::: 1186
= STRING NEWLINE @ ::: 1185
STRING , NAME + ::: 1185
NAME , - NAME ::: 1179
NAME + STRING % ::: 1178
NEWLINE DEDENT DEDENT raise ::: 1178
, STRING STRING STRING ::: 1178
% NAME [ NUMBER ::: 1177
NAME = STRING * ::: 1177
[ STRING ] in ::: 1176
STRING ) } NEWLINE ::: 1176
NAME + ( STRING ::: 1175
} , NAME ) ::: 1174
] + STRING NEWLINE ::: 1172
NUMBER ] , ( ::: 1171
[ STRING , NUMBER ::: 1171
NUMBER ] + NUMBER ::: 1171
NAME ] * NAME ::: 1170
None NEWLINE DEDENT @ ::: 1170
[ : : - ::: 1169
, [ { STRING ::: 1168
for NAME , ( ::: 1168
] NEWLINE if STRING ::: 1167
) , NAME NEWLINE ::: 1167
. NAME : ( ::: 1166
NAME ( ) ; ::: 1166
NUMBER - NUMBER ) ::: 1165
] is not None ::: 1165
; NEWLINE NAME . ::: 1165
NAME : ( STRING ::: 1164
DEDENT from NAME import ::: 1164
NAME ) or ( ::: 1163
[ NAME ] * ::: 1162
NEWLINE DEDENT del NAME ::: 1161
) , STRING . ::: 1160
NAME ) NEWLINE import ::: 1159
- NAME [ NAME ::: 1159
STRING , - NUMBER ::: 1158
* ( NAME . ::: 1158
NUMBER for NAME in ::: 1158
: ] NEWLINE if ::: 1157
or STRING in NAME ::: 1156
NAME ( NAME or ::: 1155
import NAME NEWLINE EOS ::: 1155
} ) } } ::: 1154
. NAME , - ::: 1152
NAME == NAME and ::: 1152
NAME += [ STRING ::: 1151
STRING NEWLINE return ( ::: 1149
STRING : STRING . ::: 1149
INDENT return NAME + ::: 1148
NAME ( NAME for ::: 1148
NAME if NAME is ::: 1147
= [ [ NUMBER ::: 1147
/ NUMBER , NAME ::: 1147
( ) NEWLINE raise ::: 1146
] } NEWLINE DEDENT ::: 1146
NUMBER , ) NEWLINE ::: 1145
) = NAME ( ::: 1144
[ : NAME . ::: 1143
NAME ( NAME ** ::: 1142
* NAME [ NAME ::: 1140
( NAME % NAME ::: 1140
is None else NAME ::: 1140
False ) ) , ::: 1140
or { } NEWLINE ::: 1139
, NAME ) ( ::: 1137
NAME ) and ( ::: 1137
NUMBER * NAME * ::: 1137
( True , NAME ::: 1137
NAME + NUMBER * ::: 1136
) / NAME NEWLINE ::: 1136
. NAME NEWLINE @ ::: 1136
True NEWLINE assert NAME ::: 1136
] ) ] ) ::: 1135
INDENT NAME ( NUMBER ::: 1135
( { } , ::: 1134
+ STRING % NAME ::: 1134
if NAME in [ ::: 1133
] [ NAME . ::: 1133
{ NUMBER : STRING ::: 1133
STRING ) == NAME ::: 1133
return NAME in NAME ::: 1131
else NAME NEWLINE NAME ::: 1131
, True , NAME ::: 1131
NUMBER NEWLINE class NAME ::: 1130
NEWLINE NAME ( ( ::: 1129
. NAME >= NAME ::: 1129
NAME > NUMBER ) ::: 1128
STRING ) NEWLINE from ::: 1128
= STRING , ** ::: 1128
NEWLINE from ... NAME ::: 1127
- NAME ) * ::: 1126
NAME [ STRING % ::: 1126
pass NEWLINE DEDENT return ::: 1126
not in NAME ) ::: 1126
NUMBER ] ) ] ::: 1124
NAME - NAME * ::: 1122
class NAME ( ) ::: 1122
NAME not in [ ::: 1122
] = ( STRING ::: 1122
NEWLINE NAME += [ ::: 1120
STRING * NUMBER ) ::: 1119
, False , NAME ::: 1119
assert NAME ( [ ::: 1119
NUMBER * NAME ** ::: 1117
) / ( NAME ::: 1117
NUMBER , NAME - ::: 1116
= NUMBER , NUMBER ::: 1116
STRING if NAME . ::: 1115
True NEWLINE if NAME ::: 1114
( ) ) == ::: 1114
( NAME ) & ::: 1113
= [ ( NUMBER ::: 1113
( NAME ) in ::: 1113
} , STRING ) ::: 1113
{ } , { ::: 1113
NAME < ( NUMBER ::: 1112
; NEWLINE NAME = ::: 1112
return [ NAME for ::: 1112
STRING ) NEWLINE EOS ::: 1111
False NEWLINE assert NAME ::: 1111
( STRING ) is ::: 1110
= STRING + STRING ::: 1107
STRING , NUMBER ] ::: 1105
) . NAME = ::: 1105
( STRING , lambda ::: 1102
NAME NAME ( NAME ::: 1102
== [ STRING , ::: 1102
NEWLINE return NAME + ::: 1100
] , [ ( ::: 1098
and NAME is None ::: 1097
[ STRING + NAME ::: 1097
NAME ) : ] ::: 1096
NAME and NAME in ::: 1096
} NEWLINE NAME ( ::: 1094
STRING , STRING + ::: 1093
NEWLINE DEDENT return { ::: 1092
STRING STRING ) % ::: 1091
NAME >= NAME : ::: 1090
or [ ] NEWLINE ::: 1090
, NAME ( ( ::: 1089
] } , NAME ::: 1088
== { STRING : ::: 1087
( ) , { ::: 1087
= NUMBER NEWLINE return ::: 1087
[ NUMBER : NAME ::: 1087
, NAME ( { ::: 1085
pass NEWLINE DEDENT try ::: 1085
NAME / NUMBER , ::: 1084
NAME ) is not ::: 1083
DEDENT DEDENT if STRING ::: 1082
] ] , [ ::: 1081
+ NAME ( STRING ::: 1081
NUMBER + NUMBER * ::: 1080
NAME in NAME NEWLINE ::: 1080
NAME , NAME as ::: 1079
, NAME as NAME ::: 1079
. NAME == [ ::: 1079
NAME . NAME & ::: 1077
NAME is True : ::: 1077
or STRING NEWLINE NAME ::: 1077
NAME ( False , ::: 1075
] * NAME . ::: 1073
+ NAME NEWLINE if ::: 1072
NUMBER ] * NUMBER ::: 1071
NAME as NAME , ::: 1071
} NEWLINE class NAME ::: 1071
[ STRING ] * ::: 1069
- NUMBER ] + ::: 1069
NEWLINE INDENT while True ::: 1065
INDENT while True : ::: 1064
STRING } } ) ::: 1062
[ STRING ] if ::: 1061
if NAME != None ::: 1059
NUMBER , ( NAME ::: 1058
DEDENT NAME STRING NEWLINE ::: 1057
assert NAME == NUMBER ::: 1057
} , } , ::: 1055
NUMBER and NAME ( ::: 1055
} , ) NEWLINE ::: 1053
( lambda NAME , ::: 1052
STRING ] ] , ::: 1051
, NAME NEWLINE if ::: 1051
) is NAME : ::: 1051
NUMBER + NAME ) ::: 1051
is NAME ) NEWLINE ::: 1049
= STRING NEWLINE with ::: 1049
) > NUMBER and ::: 1048
<= NAME : NEWLINE ::: 1048
: NUMBER } ] ::: 1047
= NAME NEWLINE try ::: 1046
= True NEWLINE return ::: 1046
NAME ( NUMBER + ::: 1045
DEDENT return { STRING ::: 1045
NAME ( ( ( ::: 1044
NUMBER * NAME NEWLINE ::: 1044
, NUMBER + NUMBER ::: 1043
DEDENT return STRING NEWLINE ::: 1043
, STRING ) == ::: 1041
NAME NEWLINE del NAME ::: 1040
( NAME = lambda ::: 1040
or ( NAME . ::: 1039
) for ( NAME ::: 1039
assert NAME == [ ::: 1038
== NAME ( [ ::: 1038
( lambda : NAME ::: 1037
) : ] NEWLINE ::: 1035
. NAME / NAME ::: 1033
) : NAME += ::: 1033
True ) NEWLINE assert ::: 1033
NEWLINE DEDENT yield NAME ::: 1033
, ) NEWLINE from ::: 1032
- NUMBER ) ] ::: 1030
NAME ) [ : ::: 1030
% NAME for NAME ::: 1030
NEWLINE if not ( ::: 1029
] ( NAME ) ::: 1029
] ) + STRING ::: 1029
None , ) , ::: 1027
- NUMBER ] = ::: 1026
NAME NEWLINE NAME NAME ::: 1026
: ( ( NAME ::: 1024
[ NAME , NUMBER ::: 1023
NUMBER ] ) == ::: 1023
STRING if NAME else ::: 1023
STRING % { STRING ::: 1022
) ] : NEWLINE ::: 1021
* NEWLINE import NAME ::: 1021
pass NEWLINE class NAME ::: 1021
import * NEWLINE import ::: 1021
NAME NEWLINE if STRING ::: 1019
) ) NEWLINE @ ::: 1019
[ STRING ] and ::: 1019
STRING , STRING NEWLINE ::: 1019
in [ NAME , ::: 1019
STRING : lambda NAME ::: 1019
in [ NUMBER , ::: 1018
, NUMBER , [ ::: 1018
* NEWLINE NAME = ::: 1017
if NAME else None ::: 1017
[ ] NEWLINE while ::: 1017
: pass NEWLINE class ::: 1017
, NUMBER NEWLINE DEDENT ::: 1016
is None NEWLINE assert ::: 1016
) > NUMBER ) ::: 1015
NAME if NAME [ ::: 1011
NAME = NUMBER / ::: 1011
True ) NEWLINE @ ::: 1011
. NAME >= NUMBER ::: 1010
is False NEWLINE assert ::: 1010
NEWLINE while not NAME ::: 1010
== STRING , NAME ::: 1010
{ } ) . ::: 1009
or NAME [ NUMBER ::: 1009
INDENT yield NAME ( ::: 1009
. NAME ) if ::: 1008
, None , NUMBER ::: 1007
** NUMBER ) NEWLINE ::: 1006
INDENT return ( STRING ::: 1005
+ STRING ) ) ::: 1004
NAME or NAME == ::: 1003
NAME ) NEWLINE break ::: 1003
NUMBER ) == NAME ::: 1002
] } , { ::: 1002
if NAME ( ) ::: 1001
NAME ] ) . ::: 1000
( { NAME . ::: 999
) * NAME ) ::: 999
) : ( ( ::: 998
NAME or NAME NEWLINE ::: 997
, } , { ::: 996
True , ) , ::: 996
* NAME - NAME ::: 996
NAME ) / ( ::: 995
, None , ) ::: 995
NUMBER ] in NAME ::: 993
== NAME [ NUMBER ::: 993
is not None or ::: 993
= STRING NEWLINE try ::: 991
NAME } NEWLINE return ::: 990
. NAME ) * ::: 990
) ) as NAME ::: 990
not in ( STRING ::: 988
DEDENT return NUMBER NEWLINE ::: 987
from . . import ::: 987
NAME ) else NAME ::: 986
, [ ( NAME ::: 984
= ( STRING % ::: 983
} NEWLINE try : ::: 982
( NAME ( lambda ::: 982
in ( NUMBER , ::: 981
. NAME ) / ::: 981
NAME ) >= NUMBER ::: 981
NAME is False : ::: 980
if NAME [ - ::: 980
( STRING * NUMBER ::: 980
( { NAME : ::: 979
, : ] NEWLINE ::: 979
] [ NUMBER : ::: 979
) or not NAME ::: 979
= NAME or { ::: 978
DEDENT return [ NAME ::: 978
NEWLINE NAME STRING + ::: 978
global NAME NEWLINE if ::: 978
/ NUMBER ) ) ::: 977
, } NEWLINE if ::: 976
( ** NAME . ::: 975
) > NAME : ::: 975
and NAME == STRING ::: 975
STRING % NAME for ::: 975
. NAME + ( ::: 974
. . import NAME ::: 974
( ) ; NEWLINE ::: 974
, True , True ::: 973
if NAME <= NUMBER ::: 973
* NEWLINE from . ::: 973
< NUMBER or NAME ::: 973
== NAME ( NUMBER ::: 972
pass NEWLINE DEDENT if ::: 971
NEWLINE NAME -= NAME ::: 971
NEWLINE NAME NAME ( ::: 970
and NAME != NAME ::: 969
NAME ) ) [ ::: 969
( NAME < NAME ::: 969
] + NAME NEWLINE ::: 969
STRING ) ; NEWLINE ::: 968
) is None : ::: 968
. NAME in [ ::: 968
NAME ) & NAME ::: 967
NAME ( ) * ::: 967
NAME if not NAME ::: 966
NUMBER ) + NUMBER ::: 965
. NAME ) != ::: 964
NEWLINE INDENT assert ( ::: 964
NAME ) NEWLINE ( ::: 964
== NUMBER or NAME ::: 964
[ NAME ] ( ::: 964
) , ( - ::: 964
STRING ) if NAME ::: 963
not None or NAME ::: 963
STRING } ) ) ::: 962
NUMBER , STRING % ::: 962
NAME = [ None ::: 962
= NUMBER NEWLINE class ::: 962
True } ) NEWLINE ::: 960
= NAME * NUMBER ::: 959
NUMBER , [ NUMBER ::: 959
) NEWLINE for ( ::: 959
in NAME ] , ::: 958
, ( ) , ::: 958
INDENT return STRING + ::: 957
[ NUMBER ] is ::: 957
NAME } ) , ::: 956
NAME NEWLINE raise NAME ::: 955
: False , } ::: 955
NAME and NAME != ::: 955
) ) NEWLINE class ::: 954
if ( NAME is ::: 954
return [ NAME ] ::: 953
STRING NEWLINE global NAME ::: 953
- NUMBER ] : ::: 952
None , NUMBER ) ::: 952
STRING NEWLINE if ( ::: 952
NUMBER / NUMBER ) ::: 951
NAME == STRING , ::: 950
= ( NAME * ::: 950
/ NUMBER NEWLINE DEDENT ::: 948
. NAME ) } ::: 948
, ) + NAME ::: 948
NEWLINE INDENT return - ::: 948
, } } NEWLINE ::: 948
NEWLINE STRING NEWLINE def ::: 946
is True NEWLINE assert ::: 946
assert NAME in NAME ::: 946
and NAME == NAME ::: 945
NUMBER , STRING NEWLINE ::: 945
or NAME == NAME ::: 944
> NUMBER ) NEWLINE ::: 944
NAME * NAME - ::: 943
NUMBER * NUMBER NEWLINE ::: 942
DEDENT STRING NEWLINE def ::: 942
( NUMBER * NUMBER ::: 942
) + STRING , ::: 941
} } , { ::: 941
NUMBER ] ) + ::: 940
( ( ( NAME ::: 940
NAME ( { NUMBER ::: 940
NAME in NAME and ::: 938
] * NAME ( ::: 938
) != NAME . ::: 938
. NAME -= NUMBER ::: 937
assert not NAME ( ::: 937
] == STRING and ::: 937
, False ) ) ::: 937
None and NAME ( ::: 936
( ) [ NAME ::: 936
NEWLINE if NAME <= ::: 935
NAME NEWLINE DEDENT raise ::: 935
: NAME += NAME ::: 933
) . NAME [ ::: 932
( { NUMBER : ::: 930
NAME or STRING NEWLINE ::: 930
) ) NEWLINE EOS ::: 930
: return NAME ( ::: 929
NAME <= NAME . ::: 929
INDENT return not NAME ::: 929
pass NEWLINE DEDENT elif ::: 928
NAME % NAME ) ::: 928
+ NAME ) , ::: 926
NEWLINE INDENT yield ( ::: 926
INDENT yield NAME , ::: 926
, ) ) ) ::: 925
return - NUMBER NEWLINE ::: 924
NAME ( NAME is ::: 923
not None NEWLINE DEDENT ::: 923
+ NAME ] NEWLINE ::: 922
NEWLINE if ( not ::: 922
) NEWLINE NAME -= ::: 921
: NUMBER ] = ::: 921
= NAME NEWLINE break ::: 920
except ( NAME . ::: 920
+ ( STRING % ::: 919
) + ( NAME ::: 919
True ) , STRING ::: 918
NEWLINE DEDENT return NUMBER ::: 918
NAME } , STRING ::: 917
, ] NEWLINE EOS ::: 915
NUMBER ) == STRING ::: 914
INDENT STRING NEWLINE global ::: 914
yield ( NAME , ::: 914
NAME ) ( ) ::: 913
{ NUMBER : NUMBER ::: 913
, NUMBER , None ::: 912
if NAME == - ::: 912
, ( STRING STRING ::: 912
] , [ [ ::: 911
, True ) ) ::: 910
. NAME else STRING ::: 910
: lambda NAME : ::: 910
( ) ] , ::: 909
NAME % NAME . ::: 909
: True , } ::: 908
, STRING : lambda ::: 906
( STRING % STRING ::: 906
NUMBER ] - NUMBER ::: 906
( ) or NAME ::: 905
NAME / NAME ( ::: 905
: True } NEWLINE ::: 904
[ [ NUMBER ] ::: 904
] + [ NAME ::: 902
NUMBER << NUMBER ) ::: 902
in NAME and STRING ::: 902
) not in NAME ::: 902
) is None NEWLINE ::: 901
None ) , STRING ::: 901
NAME or STRING in ::: 901
) is True NEWLINE ::: 900
NUMBER ] = STRING ::: 900
, NUMBER ] : ::: 899
( ) , ) ::: 899
% NUMBER == NUMBER ::: 898
NUMBER ) NEWLINE try ::: 898
NAME ] - NAME ::: 896
NAME ) , { ::: 896
) != NAME : ::: 896
STRING } ] } ::: 895
DEDENT elif NAME and ::: 895
NAME is NAME ) ::: 894
None and not NAME ::: 893
STRING ) ) ] ::: 893
. NAME % NAME ::: 892
, NUMBER NEWLINE NAME ::: 891
( NUMBER << NUMBER ::: 890
NAME & NUMBER ) ::: 890
] ) ) : ::: 890
STRING ] ) == ::: 890
) ( NAME , ::: 890
NAME ) == ( ::: 890
== STRING : NAME ::: 890
NAME % NAME NEWLINE ::: 890
, lambda NAME , ::: 889
] [ - NUMBER ::: 888
[ STRING ] or ::: 888
[ ( NAME ( ::: 887
, NUMBER ) + ::: 887
. NAME is False ::: 887
STRING NEWLINE STRING NEWLINE ::: 886
NEWLINE while NAME ( ::: 886
, ) NEWLINE return ::: 886
% NAME ) ) ::: 886
NUMBER ] != NAME ::: 886
elif NAME is not ::: 884
) is False NEWLINE ::: 883
NAME , NUMBER * ::: 883
NEWLINE INDENT NAME |= ::: 882
) % { STRING ::: 882
, NUMBER ) } ::: 882
NAME > NUMBER and ::: 881
, } , NUMBER ::: 880
NAME ( ** { ::: 880
. NAME != None ::: 880
NEWLINE DEDENT while NAME ::: 880
NAME = NAME | ::: 878
STRING , * NAME ::: 878
{ } ) } ::: 878
: NUMBER , NAME ::: 878
. NAME ) < ::: 878
NAME ) * ( ::: 878
** NUMBER + NAME ::: 877
NUMBER NEWLINE try : ::: 877
NAME in [ NUMBER ::: 877
= lambda : NAME ::: 877
. NAME else NAME ::: 876
with NAME : NEWLINE ::: 876
and STRING not in ::: 876
return NAME [ : ::: 875
NUMBER : ] . ::: 874
None NEWLINE return NAME ::: 874
STRING ] NEWLINE class ::: 874
STRING , [ NUMBER ::: 874
NAME & NAME . ::: 874
} NEWLINE DEDENT class ::: 873
( STRING , - ::: 873
] , } , ::: 873
STRING NEWLINE NAME NAME ::: 872
** NUMBER - NUMBER ::: 871
else NAME ( NAME ::: 871
] ) NEWLINE EOS ::: 871
[ NUMBER ] / ::: 871
[ NAME ] - ::: 871
. NAME , * ::: 870
None , None NEWLINE ::: 869
( STRING not in ::: 869
STRING ] ) ] ::: 869
>= ( NUMBER , ::: 868
DEDENT DEDENT return STRING ::: 868
( False , NAME ::: 868
raise NEWLINE DEDENT NAME ::: 868
] not in NAME ::: 867
NAME == NAME , ::: 866
] ) NEWLINE @ ::: 865
( not NAME ) ::: 865
NAME else NAME NEWLINE ::: 865
NAME / ( NAME ::: 864
NAME * NAME [ ::: 864
INDENT NAME -= NUMBER ::: 863
NUMBER ] ] = ::: 863
NUMBER , } NEWLINE ::: 863
) , NAME ] ::: 863
NAME ) ; NEWLINE ::: 862
= NUMBER , ) ::: 862
, NUMBER ] } ::: 862
DEDENT DEDENT except ( ::: 862
** { STRING : ::: 861
, [ [ NUMBER ::: 861
NUMBER ) * NUMBER ::: 861
elif not NAME . ::: 861
] ) , [ ::: 861
= [ [ STRING ::: 861
NUMBER , NAME ] ::: 860
NEWLINE while NUMBER : ::: 859
) | NAME ( ::: 858
: None } NEWLINE ::: 857
False , False , ::: 857
) : STRING , ::: 857
in NAME for NAME ::: 857
NUMBER + NAME ( ::: 856
) & NAME . ::: 855
False NEWLINE DEDENT elif ::: 855
= NAME or [ ::: 855
STRING } ] NEWLINE ::: 855
STRING * NUMBER NEWLINE ::: 855
= None , ) ::: 855
: ] ) ) ::: 854
NUMBER , True ) ::: 854
INDENT return { } ::: 853
None , * NAME ::: 853
STRING STRING , STRING ::: 853
* NUMBER ) , ::: 852
False ) . NAME ::: 851
[ NAME + STRING ::: 851
= NAME NEWLINE class ::: 851
, NAME : ( ::: 851
( ) ) ] ::: 850
( ) > NUMBER ::: 850
, None , False ::: 850
NAME or STRING ) ::: 850
) + NAME [ ::: 850
= ( None , ::: 849
and NAME != STRING ::: 849
!= - NUMBER : ::: 848
. NAME is True ::: 848
NUMBER ) ) == ::: 848
NEWLINE if NAME or ::: 848
= None NEWLINE return ::: 847
from ... NAME import ::: 847
: NAME += NUMBER ::: 847
( STRING ) != ::: 845
NUMBER * NUMBER , ::: 845
BOS NEWLINE def NAME ::: 844
NAME ( ) ( ::: 843
NEWLINE else : NAME ::: 842
NAME ] == STRING ::: 842
>> NAME , STRING ::: 842
NAME ] ( NAME ::: 842
NUMBER ) , ) ::: 841
) NEWLINE DEDENT from ::: 841
is None ) NEWLINE ::: 840
: False } NEWLINE ::: 840
NAME ** NUMBER - ::: 839
NAME * NUMBER , ::: 838
NAME = NAME and ::: 837
INDENT NAME = yield ::: 836
* NAME ( NUMBER ::: 836
INDENT NAME NAME . ::: 836
** NUMBER + NUMBER ::: 835
NAME ] += NAME ::: 835
) ** NUMBER ) ::: 835
STRING } ] , ::: 835
NUMBER ) NEWLINE with ::: 835
, : , : ::: 835
DEDENT DEDENT with NAME ::: 835
( NUMBER ) + ::: 835
: [ NAME ( ::: 835
NAME and NAME is ::: 834
NAME == ( NUMBER ::: 834
else None NEWLINE NAME ::: 833
elif NAME is NAME ::: 832
, ) NEWLINE if ::: 832
NEWLINE assert NAME in ::: 832
NAME == STRING else ::: 831
None NEWLINE DEDENT elif ::: 831
= ( ( NUMBER ::: 830
in NAME NEWLINE NAME ::: 830
None ) NEWLINE return ::: 829
>= NUMBER and NAME ::: 829
NAME : { STRING ::: 828
: , : ] ::: 828
: STRING % ( ::: 828
NAME ] , NUMBER ::: 827
) < NAME : ::: 826
def NAME ( ** ::: 826
] ) + NAME ::: 825
, ( None , ::: 825
while not NAME . ::: 825
, ] , ) ::: 825
) >= NUMBER : ::: 824
!= STRING and NAME ::: 824
, NAME ) else ::: 824
- NUMBER ) * ::: 824
STRING ) [ : ::: 823
= True NEWLINE break ::: 823
] NEWLINE return STRING ::: 823
= NUMBER ) ] ::: 822
. NAME < ( ::: 822
] == STRING ) ::: 822
= ( ) , ::: 821
STRING ) % { ::: 820
] = [ STRING ::: 820
} NEWLINE with NAME ::: 820
STRING , [ [ ::: 819
STRING , False , ::: 819
NUMBER NEWLINE DEDENT except ::: 819
NUMBER ] if NAME ::: 818
True NEWLINE break NEWLINE ::: 818
return NEWLINE DEDENT for ::: 817
NUMBER NEWLINE if ( ::: 817
| NAME | NAME ::: 816
... NAME import NAME ::: 816
, ] NEWLINE def ::: 816
. NAME <= NAME ::: 816
STRING in NAME or ::: 815
NAME = ( None ::: 815
] NEWLINE if ( ::: 814
( NUMBER / NAME ::: 814
NUMBER ) ) ] ::: 812
lambda NAME : STRING ::: 812
] ) == NAME ::: 812
, NAME ) as ::: 811
= None , * ::: 811
+ [ NAME ] ::: 810
NAME | NAME | ::: 810
) and NAME [ ::: 809
== [ STRING ] ::: 809
DEDENT NAME = True ::: 808
NAME NEWLINE global NAME ::: 807
= NAME NEWLINE while ::: 807
NUMBER , NUMBER * ::: 807
NAME + [ STRING ::: 807
+ ( NAME . ::: 807
* NEWLINE class NAME ::: 806
] + NAME ( ::: 806
import * NEWLINE class ::: 806
= NAME % NAME ::: 805
: : NUMBER ] ::: 805
( NAME ( * ::: 805
= NAME + ( ::: 804
) > NUMBER NEWLINE ::: 804
( NAME ) <= ::: 804
not in NAME NEWLINE ::: 803
( NAME > NUMBER ::: 803
NAME : NAME += ::: 803
( ) [ : ::: 801
: False } , ::: 800
+= NUMBER NEWLINE return ::: 800
NAME ( ) < ::: 800
NUMBER : NAME ] ::: 799
/ NUMBER ) , ::: 799
NAME <= NAME : ::: 799
NUMBER ] NEWLINE try ::: 798
) , } , ::: 798
NAME + STRING ] ::: 798
NAME , ] NEWLINE ::: 798
NAME ] NEWLINE def ::: 798
NUMBER ) ] ] ::: 797
STRING ) NEWLINE import ::: 796
+ NAME ( NUMBER ::: 796
is None NEWLINE DEDENT ::: 795
) , - NUMBER ::: 794
NAME or NAME ) ::: 794
None , NAME ( ::: 794
STRING and NAME [ ::: 794
NAME ) [ NAME ::: 793
* NAME / NAME ::: 793
NAME else STRING ) ::: 793
NAME , ( ) ::: 792
not in NAME [ ::: 792
STRING } } } ::: 791
, NUMBER , True ::: 791
** NUMBER NEWLINE NAME ::: 791
- NAME ) , ::: 791
NAME or ( NAME ::: 791
None NEWLINE DEDENT try ::: 791
NUMBER : NAME , ::: 790
NAME } ) ) ::: 790
} , { } ::: 790
: NAME ] , ::: 790
NEWLINE NAME STRING . ::: 789
not NAME or not ::: 788
( ) ) [ ::: 788
( STRING * NAME ::: 788
NAME * NUMBER + ::: 787
) ] ] ) ::: 787
= False , ) ::: 787
== NUMBER , STRING ::: 787
+ STRING NEWLINE if ::: 787
} } } NEWLINE ::: 787
NAME < NAME ) ::: 786
NUMBER ** NUMBER ) ::: 786
, STRING ) [ ::: 786
None : NAME = ::: 786
NUMBER , None ) ::: 784
, NAME ] : ::: 784
= True NEWLINE for ::: 783
INDENT return [ STRING ::: 783
INDENT assert NAME is ::: 783
INDENT assert ( NAME ::: 783
[ NUMBER ] } ::: 782
] , ( NUMBER ::: 782
[ ( NAME [ ::: 781
) / NAME ) ::: 780
== [ NUMBER , ::: 780
NEWLINE INDENT assert not ::: 780
NUMBER , : ] ::: 780
in NAME or NAME ::: 780
True NEWLINE for NAME ::: 779
% ( NAME + ::: 779
= ( ) ) ::: 778
, None ) ] ::: 777
- NAME NEWLINE if ::: 777
NAME == [ STRING ::: 777
, NAME NEWLINE try ::: 777
| NAME ( NAME ::: 776
[ NUMBER , STRING ::: 776
NUMBER : NUMBER } ::: 776
: [ NAME ] ::: 776
-= NUMBER NEWLINE NAME ::: 775
, ( STRING % ::: 775
NAME < NUMBER ) ::: 775
[ ] ) . ::: 775
STRING ] NEWLINE del ::: 774
) : NAME = ::: 774
STRING ) , None ::: 774
: NAME ( [ ::: 774
NAME ( [ - ::: 773
STRING or NAME . ::: 772
* NUMBER + NAME ::: 772
NAME -= NAME NEWLINE ::: 771
if NAME [ : ::: 771
( STRING ) if ::: 771
= True , ** ::: 770
NAME < NUMBER or ::: 770
True , ** NAME ::: 770
False ) NEWLINE def ::: 769
NAME ] NEWLINE assert ::: 769
NAME ] ] ) ::: 769
, None , [ ::: 768
% ( STRING , ::: 767
NAME NEWLINE DEDENT import ::: 767
True , NAME . ::: 767
NUMBER ) / NAME ::: 766
( ) [ - ::: 766
( ) ] = ::: 766
assert STRING not in ::: 765
NUMBER * NAME [ ::: 765
) ) == STRING ::: 765
NUMBER } , NAME ::: 765
False ) , STRING ::: 764
. NAME [ ( ::: 764
} NEWLINE assert NAME ::: 764
{ NUMBER : NAME ::: 764
None , False ) ::: 763
NAME >> NUMBER ) ::: 763
NAME % NUMBER == ::: 762
NUMBER ) & NUMBER ::: 762
) == ( NAME ::: 762
INDENT while NAME . ::: 762
) NEWLINE DEDENT while ::: 762
not in [ STRING ::: 762
STRING STRING ) . ::: 761
return NEWLINE DEDENT try ::: 760
NUMBER , ** NAME ::: 760
in NAME or STRING ::: 760
~ NAME . NAME ::: 759
and NAME and NAME ::: 759
] += NAME NEWLINE ::: 758
} NEWLINE DEDENT return ::: 758
** NAME ) . ::: 758
NEWLINE STRING NEWLINE class ::: 757
+= NAME + ( ::: 757
) != STRING : ::: 757
and NAME [ - ::: 756
DEDENT elif NAME < ::: 755
% ( STRING . ::: 755
return NAME ( NUMBER ::: 755
elif not NAME ( ::: 755
NAME ] += NUMBER ::: 755
, : ] = ::: 754
NAME ) == [ ::: 754
NAME != STRING and ::: 754
NUMBER ] ) [ ::: 754
[ NUMBER ] < ::: 752
NAME == NUMBER , ::: 752
return not NAME . ::: 750
/ NAME NEWLINE DEDENT ::: 750
or STRING ) NEWLINE ::: 749
is None : NAME ::: 749
( STRING if NAME ::: 749
if NAME is True ::: 749
NAME } ) : ::: 748
% NAME NEWLINE if ::: 748
, NAME * NUMBER ::: 748
INDENT assert not NAME ::: 746
] . NAME : ::: 745
STRING , True , ::: 745
in NAME , NAME ::: 745
} ] } NEWLINE ::: 744
or NAME is None ::: 744
] * NAME NEWLINE ::: 744
} } , NAME ::: 744
True NEWLINE return NAME ::: 744
STRING ] in NAME ::: 743
lambda NAME : ( ::: 743
or not NAME ( ::: 743
. NAME + [ ::: 743
not in NAME and ::: 743
STRING ] and NAME ::: 742
= NAME / NUMBER ::: 741
or NAME in NAME ::: 741
NAME or STRING , ::: 741
. NAME ) ( ::: 741
NAME - ( NAME ::: 741
) ) * NUMBER ::: 740
DEDENT DEDENT NAME += ::: 740
) % ( NAME ::: 740
> NAME ( NAME ::: 739
STRING ) and not ::: 739
, ) NEWLINE class ::: 738
del NAME NEWLINE NAME ::: 738
( STRING ) for ::: 738
NEWLINE INDENT NAME NEWLINE ::: 738
return ( NUMBER , ::: 738
) , ( [ ::: 737
] in NAME : ::: 737
. NAME NEWLINE while ::: 736
NAME in NAME for ::: 735
NUMBER or NAME . ::: 735
NAME >= ( NUMBER ::: 735
False , STRING ) ::: 734
INDENT from . NAME ::: 734
( NAME & NUMBER ::: 733
NAME = NUMBER ; ::: 733
NAME and NAME and ::: 733
) ) > NUMBER ::: 732
in NAME [ : ::: 732
) ] NEWLINE def ::: 732
( ) NEWLINE del ::: 732
) ] . NAME ::: 731
, ) . NAME ::: 730
STRING , ) } ::: 730
] [ NAME [ ::: 730
NAME : ] ) ::: 729
NAME | NAME ) ::: 728
NUMBER , } , ::: 728
NEWLINE yield NAME ( ::: 727
) & ( NAME ::: 727
( ) in NAME ::: 727
elif NAME is None ::: 726
: NAME , NUMBER ::: 726
, False , None ::: 726
= False NEWLINE return ::: 726
NAME : NAME ) ::: 726
NAME ] = True ::: 725
NUMBER NUMBER ) NEWLINE ::: 725
STRING ) % ( ::: 724
/ ( NUMBER * ::: 724
, NAME ) * ::: 724
break NEWLINE DEDENT else ::: 724
( ) , } ::: 724
= STRING NEWLINE raise ::: 724
{ } } NEWLINE ::: 724
) ) * NAME ::: 723
continue NEWLINE DEDENT elif ::: 723
] , ( NAME ::: 722
] ] ) ) ::: 721
+= NAME [ NAME ::: 721
DEDENT raise NEWLINE DEDENT ::: 721
, [ [ ( ::: 720
+ NAME , STRING ::: 720
NAME and NAME not ::: 720
= STRING NEWLINE assert ::: 719
] * NUMBER NEWLINE ::: 719
STRING , } } ::: 719
, [ ] NEWLINE ::: 719
INDENT NAME STRING + ::: 719
and ( not NAME ::: 718
. NAME or not ::: 718
NUMBER ) , ] ::: 717
return [ NAME [ ::: 717
, ( NAME + ::: 716
and NAME == NUMBER ::: 716
NUMBER , None , ::: 716
* ( NAME ( ::: 716
, NUMBER , ( ::: 716
( [ - NUMBER ::: 715
NAME in ( NUMBER ::: 714
= NAME | NAME ::: 714
None , NUMBER , ::: 713
= STRING , STRING ::: 713
( NAME ( { ::: 713
INDENT return NAME in ::: 713
NUMBER , STRING ] ::: 713
} } NEWLINE DEDENT ::: 713
is not NAME . ::: 713
NAME ( NUMBER / ::: 712
NAME % { STRING ::: 712
NAME ] if NAME ::: 712
NEWLINE INDENT assert False ::: 712
* NAME ) . ::: 711
STRING NEWLINE return { ::: 711
DEDENT DEDENT if ( ::: 710
INDENT yield ( NAME ::: 710
else None NEWLINE DEDENT ::: 710
if NAME & NAME ::: 710
** NAME ) , ::: 710
] ) NEWLINE with ::: 709
continue NEWLINE DEDENT for ::: 709
. NAME ] + ::: 709
] * NUMBER ) ::: 708
, ( NAME [ ::: 708
if ( ( NAME ::: 707
: NAME ) NEWLINE ::: 707
) ) ) . ::: 707
; NEWLINE DEDENT else ::: 706
NAME = ( - ::: 706
) } , NAME ::: 706
NEWLINE NAME -= NUMBER ::: 705
) , ( ) ::: 705
NUMBER ] ) for ::: 705
return [ ( NAME ::: 705
NAME == NUMBER or ::: 704
NAME - NUMBER : ::: 704
( - NAME ) ::: 704
, False , True ::: 704
) > NAME . ::: 704
= False ) . ::: 704
STRING ) == NUMBER ::: 703
) ( NAME . ::: 703
STRING NEWLINE DEDENT try ::: 703
) ) if NAME ::: 702
NAME ( NUMBER - ::: 702
NUMBER - NAME . ::: 702
) NEWLINE DEDENT del ::: 701
) % NAME . ::: 701
STRING } , } ::: 701
<< NUMBER ) NEWLINE ::: 701
( NAME > NAME ::: 700
; NAME . NAME ::: 700
not in NAME ] ::: 699
+ NUMBER ) ] ::: 699
and STRING or STRING ::: 699
) == NUMBER , ::: 699
None , [ NAME ::: 698
INDENT if NAME >= ::: 698
NAME - NAME [ ::: 697
= NAME NEWLINE assert ::: 697
not None ) NEWLINE ::: 697
NAME : NUMBER , ::: 697
[ NAME ] != ::: 697
NAME NEWLINE assert not ::: 696
NUMBER ) : [ ::: 694
. NAME NEWLINE with ::: 694
, = NAME NEWLINE ::: 693
, STRING NEWLINE assert ::: 693
( NAME | NAME ::: 693
= STRING ) as ::: 692
, True , False ::: 692
DEDENT elif NAME > ::: 691
( ) NEWLINE from ::: 691
in STRING : NEWLINE ::: 691
( ) != NAME ::: 690
. NAME & NAME ::: 690
None : NAME . ::: 690
None or NAME ( ::: 689
NAME or NAME [ ::: 688
or NAME ( ) ::: 688
] ) > NUMBER ::: 688
NEWLINE DEDENT DEDENT with ::: 687
STRING ] ] = ::: 687
or NAME NEWLINE NAME ::: 686
[ NUMBER ] += ::: 686
( ) , None ::: 686
NAME + NAME - ::: 686
NAME } , { ::: 686
NAME : STRING } ::: 686
NAME else STRING , ::: 685
NUMBER - NUMBER * ::: 685
NAME ) for ( ::: 684
: [ NUMBER ] ::: 684
, [ NAME [ ::: 684
: return NAME NEWLINE ::: 684
NAME is NAME NEWLINE ::: 684
: STRING , ( ::: 684
NAME NEWLINE return ( ::: 684
] ) , ) ::: 682
( not NAME ( ::: 681
and NAME < NAME ::: 681
[ NUMBER ] > ::: 680
] , ( STRING ::: 679
( ( - NUMBER ::: 679
not None and not ::: 679
: None } ) ::: 679
* ( NUMBER - ::: 679
NAME += ( NAME ::: 679
NAME * NAME / ::: 679
= NAME = None ::: 678
== NAME [ NAME ::: 678
: NAME for NAME ::: 678
+ NAME + NUMBER ::: 678
DEDENT break NEWLINE DEDENT ::: 678
NAME , ) : ::: 678
False NEWLINE try : ::: 678
+ NUMBER NEWLINE if ::: 677
] = NAME + ::: 677
STRING ] is not ::: 677
INDENT NAME |= NAME ::: 676
if NAME <= NAME ::: 675
else STRING ) NEWLINE ::: 675
NAME * ( NUMBER ::: 675
: NUMBER ] . ::: 675
( NAME != NAME ::: 675
> NUMBER ) : ::: 675
) NEWLINE DEDENT yield ::: 674
) is NAME . ::: 674
not None : NAME ::: 674
+ [ STRING ] ::: 674
+ STRING % ( ::: 673
True , ) NEWLINE ::: 673
] NEWLINE NAME STRING ::: 673
, STRING ) or ::: 673
= NAME ) ] ::: 672
( ) } ) ::: 672
raise NAME ( NUMBER ::: 672
, ] NEWLINE for ::: 672
/ NUMBER , NUMBER ::: 671
NAME = NUMBER + ::: 671
] , ) , ::: 670
, [ ] ] ::: 670
NAME ) >= NAME ::: 669
global NAME , NAME ::: 669
] ) NEWLINE try ::: 668
= NUMBER , ** ::: 668
NAME NEWLINE ( NAME ::: 668
yield NAME NEWLINE NAME ::: 668
( NAME >> NUMBER ::: 667
elif NAME and NAME ::: 667
] is None : ::: 667
STRING ] if NAME ::: 667
, NUMBER + NAME ::: 666
STRING ] NEWLINE EOS ::: 666
if ( NAME [ ::: 666
= NUMBER NEWLINE assert ::: 666
) or STRING NEWLINE ::: 665
NUMBER * NAME / ::: 665
True NEWLINE NAME [ ::: 665
] in NAME . ::: 664
== NAME ) . ::: 664
STRING ] NEWLINE try ::: 663
INDENT if not ( ::: 663
) : NAME ( ::: 663
= [ None ] ::: 663
) ) / NAME ::: 663
None , ) : ::: 662
NUMBER ] not in ::: 661
. NAME == None ::: 661
) % NAME NEWLINE ::: 660
+= [ NAME . ::: 659
NAME ) ) * ::: 659
] ] . NAME ::: 659
, NUMBER * NUMBER ::: 659
NEWLINE DEDENT raise NEWLINE ::: 659
. NAME += STRING ::: 658
( [ ( NUMBER ::: 658
>= NAME ( NAME ::: 658
NAME != NAME ) ::: 657
== NUMBER , NAME ::: 657
INDENT return - NUMBER ::: 657
NUMBER : NAME ( ::: 656
NUMBER ] [ : ::: 656
= not NAME . ::: 655
raise NEWLINE DEDENT except ::: 655
) , NAME + ::: 654
= False NEWLINE try ::: 653
continue NEWLINE DEDENT else ::: 653
, STRING ) ; ::: 653
NAME ( STRING not ::: 652
. NAME ) is ::: 652
) ] NEWLINE assert ::: 652
. NAME and STRING ::: 651
NUMBER / NAME . ::: 650
* NAME - NUMBER ::: 649
NUMBER / NAME ) ::: 649
- NAME , NUMBER ::: 649
, STRING STRING , ::: 648
STRING ) } , ::: 648
{ STRING , STRING ::: 647
== True : NEWLINE ::: 647
( ) ) + ::: 647
|= NAME . NAME ::: 647
DEDENT if NAME >= ::: 646
STRING } ] ) ::: 646
] , ** NAME ::: 646
) ) NEWLINE yield ::: 644
) == [ NAME ::: 643
None or NAME is ::: 643
: False } ) ::: 643
NAME - NAME - ::: 643
DEDENT raise NAME . ::: 643
) if not NAME ::: 643
False ) NEWLINE return ::: 643
NEWLINE assert STRING not ::: 643
not NAME [ NUMBER ::: 643
] + NAME ) ::: 642
False NEWLINE NAME [ ::: 642
/ NAME , NAME ::: 642
} NEWLINE @ NAME ::: 642
NAME > NAME ) ::: 642
( ( STRING STRING ::: 642
= - NAME . ::: 641
[ NUMBER ] if ::: 640
NEWLINE STRING NEWLINE EOS ::: 640
, NUMBER NUMBER ) ::: 640
STRING NEWLINE DEDENT except ::: 640
} , ] NEWLINE ::: 639
NUMBER ) NEWLINE class ::: 639
) ) ] , ::: 639
) == [ STRING ::: 639
) [ : - ::: 639
NAME = NUMBER - ::: 639
: NUMBER ] + ::: 638
or not NAME : ::: 638
. NAME , ] ::: 638
NUMBER == NUMBER : ::: 638
DEDENT NAME STRING % ::: 638
= [ [ NAME ::: 638
True NEWLINE DEDENT @ ::: 638
: , NAME . ::: 637
[ NAME * NAME ::: 637
NAME ) ) / ::: 637
STRING and not NAME ::: 637
] - NAME . ::: 636
NAME |= NAME . ::: 636
DEDENT ( NAME , ::: 636
-= NAME . NAME ::: 635
. NAME else None ::: 635
@ NAME ( [ ::: 634
NAME STRING NEWLINE for ::: 634
NEWLINE DEDENT ( NAME ::: 632
NAME == ( NAME ::: 632
( ( NAME * ::: 632
, NUMBER : { ::: 631
( - NAME , ::: 631
== NAME or NAME ::: 630
NAME STRING NEWLINE return ::: 630
] ) , ] ::: 630
, } NEWLINE return ::: 629
= STRING * NUMBER ::: 629
) == STRING ) ::: 628
} , NUMBER : ::: 628
else NAME NEWLINE DEDENT ::: 627
NEWLINE INDENT yield STRING ::: 627
NAME if NAME not ::: 627
NAME ( [ { ::: 627
} for NAME in ::: 626
else : NAME = ::: 626
[ ] } NEWLINE ::: 626
STRING , ( ) ::: 625
) < NAME . ::: 625
+ NAME ** NUMBER ::: 625
, NUMBER , False ::: 625
NUMBER , { STRING ::: 625
} ) NEWLINE for ::: 625
NAME ( ( - ::: 625
NAME ] ) + ::: 624
NAME ) | NAME ::: 624
INDENT NAME ( [ ::: 624
( NAME * ( ::: 624
, NAME ) } ::: 624
NAME ) not in ::: 623
for NAME in STRING ::: 623
[ [ ( STRING ::: 623
) != - NUMBER ::: 623
+ NAME ) / ::: 623
True , True , ::: 622
return NEWLINE DEDENT else ::: 622
, : ] ) ::: 622
STRING ) ) == ::: 621
INDENT return ( NUMBER ::: 621
STRING STRING STRING . ::: 621
% NAME ] = ::: 621
STRING : STRING + ::: 620
, STRING ) + ::: 620
] == NAME ( ::: 619
NAME in NAME , ::: 619
NUMBER - NAME ( ::: 618
NUMBER ] ) * ::: 617
( ) ) for ::: 617
] != NAME . ::: 617
) if NAME is ::: 617
DEDENT DEDENT NAME STRING ::: 616
, } ) , ::: 616
( NAME ( - ::: 616
>> NUMBER ) & ::: 616
NUMBER : ( NUMBER ::: 616
( NUMBER , { ::: 615
( False , STRING ::: 614
[ NAME ] } ::: 614
[ NAME - NAME ::: 614
NAME NEWLINE return NEWLINE ::: 614
DEDENT DEDENT NAME , ::: 614
NAME != - NUMBER ::: 613
== [ ] NEWLINE ::: 613
, ) = NAME ::: 613
( NAME & NAME ::: 613
] == NAME NEWLINE ::: 612
NAME in NAME } ::: 612
+ NAME NEWLINE return ::: 611
STRING STRING NEWLINE NAME ::: 611
NEWLINE NAME , = ::: 610
( * NAME ( ::: 609
+ NUMBER ] = ::: 609
- NAME + NUMBER ::: 609
, None ) is ::: 609
} ) NEWLINE with ::: 608
: , NUMBER : ::: 608
] , } ) ::: 608
= NUMBER / NAME ::: 607
NAME , ) = ::: 607
( NUMBER ** NUMBER ::: 607
True ) NEWLINE for ::: 607
STRING , STRING } ::: 606
] ) * NAME ::: 606
NAME = NAME & ::: 606
] NEWLINE @ NAME ::: 606
] , None , ::: 606
) ) - NAME ::: 605
( None , NUMBER ::: 605
] , STRING % ::: 605
NAME += NUMBER + ::: 604
( ( STRING % ::: 604
global NAME NEWLINE global ::: 604
= NAME ) for ::: 604
None else NAME NEWLINE ::: 604
, NAME ) is ::: 603
NAME = NUMBER NAME ::: 603
NAME == { STRING ::: 603
None else NAME . ::: 603
) % NAME ) ::: 603
+= NUMBER + NAME ::: 602
/ NAME ) ) ::: 602
STRING ] [ : ::: 602
NAME ] + [ ::: 602
and NAME > NUMBER ::: 601
) - NUMBER , ::: 601
( [ { STRING ::: 600
= ( - NUMBER ::: 600
STRING in NAME else ::: 600
( STRING , ** ::: 599
STRING for NAME in ::: 599
NUMBER ] } ) ::: 599
not ( NAME == ::: 599
NUMBER ) - NUMBER ::: 598
NAME } } NEWLINE ::: 598
NAME == [ ] ::: 598
, } , ) ::: 598
== ( STRING , ::: 597
NAME ) <= NAME ::: 597
STRING : STRING STRING ::: 597
NAME NEWLINE DEDENT finally ::: 595
** NAME ( NAME ::: 595
( ) + NUMBER ::: 594
, STRING , lambda ::: 594
NAME NEWLINE continue NEWLINE ::: 593
+ [ NAME . ::: 593
DEDENT continue NEWLINE DEDENT ::: 593
) NEWLINE NAME >> ::: 592
True } , STRING ::: 592
, ) } ) ::: 592
NAME ) , True ::: 591
[ ] NEWLINE try ::: 590
NAME [ - NAME ::: 590
, - NAME . ::: 590
( NAME = - ::: 590
- NAME / NUMBER ::: 590
. NAME and ( ::: 589
] + STRING ) ::: 589
or NAME [ STRING ::: 589
, * NAME . ::: 589
NEWLINE yield NAME , ::: 589
NAME , ) + ::: 589
STRING ) NEWLINE ( ::: 589
NAME = [ - ::: 588
INDENT NAME += ( ::: 588
( NAME < NUMBER ::: 588
False , None , ::: 588
} NEWLINE DEDENT EOS ::: 588
STRING + STRING NEWLINE ::: 587
import * NEWLINE EOS ::: 587
, False , STRING ::: 587
: None } , ::: 587
STRING : NAME = ::: 587
NAME ) ) and ::: 587
) == NAME ) ::: 587
STRING ] , ( ::: 586
] != NAME : ::: 586
) NEWLINE DEDENT import ::: 585
) ) and NAME ::: 585
False , } , ::: 585
NUMBER ) + STRING ::: 585
import NAME NEWLINE STRING ::: 584
[ STRING ] > ::: 584
NUMBER * NAME - ::: 584
elif ( NAME . ::: 583
NAME ( * ( ::: 583
else STRING , NAME ::: 582
NAME ( * [ ::: 582
STRING ] != STRING ::: 582
NAME ( NAME < ::: 581
NAME - NAME + ::: 581
& NAME : NEWLINE ::: 581
NEWLINE NAME [ - ::: 581
= NAME [ ( ::: 581
NAME ** NUMBER NEWLINE ::: 581
in NAME if not ::: 581
) == - NUMBER ::: 580
STRING } NEWLINE def ::: 580
) if NAME [ ::: 580
= NAME and NAME ::: 580
( NAME % ( ::: 579
( ) - NUMBER ::: 579
, NUMBER ] . ::: 578
) ) is False ::: 578
[ NAME ] is ::: 577
NEWLINE NAME NEWLINE NAME ::: 577
+ ( NAME ( ::: 576
None NEWLINE NAME [ ::: 576
= NUMBER - NAME ::: 576
) , * NAME ::: 576
STRING + STRING , ::: 576
= NAME * ( ::: 575
== NAME ] NEWLINE ::: 575
NAME ) <= NUMBER ::: 575
STRING ] != NAME ::: 575
NUMBER } } , ::: 575
+= NAME + STRING ::: 574
STRING * ( NAME ::: 574
del NAME NEWLINE DEDENT ::: 573
NAME if NAME in ::: 573
[ STRING ] - ::: 572
STRING ] } } ::: 572
DEDENT DEDENT return ( ::: 571
NUMBER NEWLINE if not ::: 571
( NUMBER ) / ::: 571
== NAME ) : ::: 571
NAME == True : ::: 571
& NUMBER NEWLINE NAME ::: 571
STRING : { NAME ::: 570
NAME = NUMBER ** ::: 570
return NAME ( ** ::: 570
NAME % NAME ( ::: 570
) < NAME ( ::: 570
NEWLINE DEDENT break NEWLINE ::: 570
) is not NAME ::: 570
] , True ) ::: 570
, ) , NUMBER ::: 569
NEWLINE INDENT for ( ::: 569
+ STRING ) , ::: 569
] if NAME . ::: 569
= NAME ) [ ::: 569
, NAME ) if ::: 568
NEWLINE DEDENT NAME NAME ::: 568
NAME >= NUMBER and ::: 568
not None NEWLINE NAME ::: 568
STRING + NAME ] ::: 567
STRING ] or NAME ::: 567
False NEWLINE DEDENT except ::: 566
STRING ) or STRING ::: 566
, STRING ) for ::: 565
NAME ] = None ::: 565
NAME & NAME : ::: 565
return NAME + STRING ::: 565
, : , NAME ::: 565
: NAME = NUMBER ::: 565
NAME == NAME or ::: 565
) ) is True ::: 565
- NAME ) . ::: 565
, None ] NEWLINE ::: 564
NAME and STRING not ::: 564
- NUMBER NEWLINE if ::: 564
, ] ) , ::: 564
{ NAME : STRING ::: 563
. NAME >= ( ::: 563
| NAME ) NEWLINE ::: 563
NAME - NUMBER * ::: 563
is NAME NEWLINE DEDENT ::: 563
NAME = NAME == ::: 563
, NAME , - ::: 563
INDENT for ( NAME ::: 563
BOS NEWLINE try : ::: 562
] in ( STRING ::: 562
NUMBER ] = [ ::: 562
NAME ] ] = ::: 562
= [ - NUMBER ::: 562
, None ) or ::: 561
continue NEWLINE DEDENT try ::: 560
NUMBER / NUMBER , ::: 560
NUMBER NEWLINE while True ::: 560
DEDENT if not ( ::: 559
( ** NAME ( ::: 559
[ ] ] ) ::: 559
- NAME ( NUMBER ::: 559
] ) ] , ::: 558
elif NAME [ NAME ::: 558
/ ( NAME - ::: 557
not NAME [ NAME ::: 557
: NAME } ] ::: 557
> NUMBER NEWLINE DEDENT ::: 557
, NUMBER / NUMBER ::: 556
return NAME ( { ::: 556
DEDENT if ( not ::: 556
NAME NEWLINE yield NAME ::: 556
( - NAME . ::: 556
} } } , ::: 555
or STRING , NAME ::: 555
NAME NEWLINE return STRING ::: 555
) [ : , ::: 555
* NAME , NUMBER ::: 554
, NUMBER ) for ::: 554
NUMBER and NAME == ::: 554
if NAME % NUMBER ::: 554
) [ NAME . ::: 553
assert False , STRING ::: 552
] * ( NAME ::: 552
. import NAME , ::: 552
NUMBER NEWLINE DEDENT for ::: 552
) , STRING STRING ::: 552
] and NAME [ ::: 552
) : raise NAME ::: 551
) ) == [ ::: 551
NAME >= NAME ( ::: 550
= NAME NEWLINE @ ::: 550
: STRING + NAME ::: 550
NEWLINE if not STRING ::: 550
+ [ STRING , ::: 550
STRING ] * NAME ::: 549
+ NAME ) . ::: 548
not None else NAME ::: 548
) NEWLINE DEDENT STRING ::: 548
/ ( NAME + ::: 548
= NAME NEWLINE EOS ::: 548
, ) , { ::: 547
NAME [ NAME * ::: 547
NAME -= NAME . ::: 547
return not ( NAME ::: 547
NAME = NUMBER if ::: 547
INDENT NAME [ : ::: 546
NAME / NAME , ::: 546
INDENT NAME ( * ::: 546
STRING NEWLINE DEDENT for ::: 546
, NAME / NUMBER ::: 546
None ] NEWLINE NAME ::: 546
NAME ) + ( ::: 545
= NAME ( - ::: 544
== STRING and not ::: 544
( ) ( NAME ::: 544
assert NAME is None ::: 544
NUMBER , False ) ::: 544
, ] , } ::: 544
) | ( NAME ::: 543
else NUMBER NEWLINE NAME ::: 543
[ NUMBER ] or ::: 542
( ) NEWLINE yield ::: 542
NUMBER ) ** NUMBER ::: 542
STRING ) + NUMBER ::: 542
elif not NAME : ::: 542
, ] , [ ::: 542
( ) != STRING ::: 541
NEWLINE DEDENT DEDENT assert ::: 541
% NAME NEWLINE return ::: 541
in NAME : NAME ::: 541
** NUMBER ) ) ::: 541
NAME NEWLINE DEDENT assert ::: 541
* NUMBER , STRING ::: 541
NAME , NAME / ::: 540
, NAME : NUMBER ::: 540
NAME : NAME for ::: 540
( NUMBER - NUMBER ::: 540
= NAME + [ ::: 540
return NAME == NAME ::: 540
NUMBER ) - NAME ::: 540
) + NUMBER : ::: 539
& ( NAME . ::: 539
STRING ) ) as ::: 539
( ** { STRING ::: 539
] , NAME NEWLINE ::: 539
STRING NEWLINE return NEWLINE ::: 538
+ NAME - NUMBER ::: 538
) / ( NUMBER ::: 537
INDENT assert NAME == ::: 537
False NEWLINE return NAME ::: 536
] == NUMBER ) ::: 536
None NEWLINE DEDENT class ::: 536
] > NUMBER : ::: 536
NUMBER NEWLINE continue NEWLINE ::: 536
NUMBER ) * ( ::: 536
<< NUMBER NEWLINE NAME ::: 536
] ] , STRING ::: 536
NAME = ( [ ::: 536
True , False ) ::: 535
NEWLINE DEDENT continue NEWLINE ::: 535
. NAME NEWLINE del ::: 535
assert NAME ( ( ::: 535
NAME ( ) / ::: 535
NAME ) , ** ::: 534
** NUMBER , NAME ::: 534
( ) is None ::: 534
, NUMBER , ) ::: 534
= STRING NEWLINE STRING ::: 534
* NAME ) / ::: 534
) ) NEWLINE from ::: 534
return [ NAME , ::: 533
+ STRING ) : ::: 533
NUMBER and not NAME ::: 533
( NAME ( None ::: 533
True , False , ::: 532
not None ) : ::: 532
) . NAME : ::: 532
- NAME ) ** ::: 532
+ NAME ) * ::: 532
True } NEWLINE NAME ::: 532
+ NUMBER ] , ::: 532
STRING ] , None ::: 532
] ) / NAME ::: 531
STRING ) ( ) ::: 531
( NUMBER , None ::: 530
NUMBER / ( NAME ::: 529
& NUMBER ) NEWLINE ::: 529
+ NUMBER : NAME ::: 529
== False : NEWLINE ::: 529
NAME ** NUMBER , ::: 529
) + NUMBER * ::: 528
NAME ( NAME > ::: 528
] if NAME else ::: 527
NUMBER ] ) / ::: 527
NAME & NAME ) ::: 527
NEWLINE assert NAME NEWLINE ::: 527
+= NAME NEWLINE if ::: 527
NUMBER , NAME : ::: 526
* NAME ) + ::: 526
False ) NEWLINE assert ::: 526
= NAME = NUMBER ::: 526
- NAME - NAME ::: 526
DEDENT return NAME + ::: 525
DEDENT del NAME . ::: 524
True ) NEWLINE class ::: 524
. NAME , lambda ::: 524
) } ) , ::: 523
== NAME , NAME ::: 523
* NUMBER , NUMBER ::: 522
return NEWLINE DEDENT elif ::: 522
NUMBER ] } NEWLINE ::: 522
) , STRING ] ::: 521
NAME ] } NEWLINE ::: 521
= NUMBER NEWLINE try ::: 521
STRING ) NEWLINE while ::: 521
NUMBER ] / NUMBER ::: 521
INDENT STRING NEWLINE while ::: 520
] NEWLINE break NEWLINE ::: 520
] ) NEWLINE class ::: 520
return ( STRING , ::: 520
. NAME == True ::: 520
- NUMBER ) / ::: 520
] != NAME [ ::: 520
] + NAME , ::: 520
[ ] : NEWLINE ::: 519
= NAME or STRING ::: 519
/ ( NAME . ::: 519
= NUMBER if NAME ::: 519
NUMBER : NAME = ::: 519
NEWLINE return [ ] ::: 519
if NAME is False ::: 519
NAME += ( STRING ::: 519
in NAME } NEWLINE ::: 518
False NEWLINE DEDENT @ ::: 518
: ] NEWLINE return ::: 517
False , NAME . ::: 517
NAME ] NEWLINE try ::: 517
if NAME ( STRING ::: 516
INDENT NAME STRING . ::: 516
= True ) as ::: 516
return NAME * NAME ::: 516
= NAME ) as ::: 516
- NAME ** NUMBER ::: 516
] + NUMBER ) ::: 516
return NAME + NUMBER ::: 515
* NAME ) * ::: 515
, ) NEWLINE assert ::: 515
None NEWLINE if not ::: 515
} , ** NAME ::: 515
False , False ) ::: 515
True ) as NAME ::: 514
or STRING NEWLINE DEDENT ::: 513
NUMBER NEWLINE DEDENT EOS ::: 513
( * [ NAME ::: 513
( - NUMBER * ::: 513
( ) * NUMBER ::: 513
] * NAME ) ::: 512
+ NAME ] ) ::: 512
assert ( NAME [ ::: 512
* NUMBER + NUMBER ::: 512
not NAME NEWLINE DEDENT ::: 512
NAME == [ NAME ::: 512
None } ) NEWLINE ::: 510
: ] = [ ::: 510
( STRING ) > ::: 510
* NAME / NUMBER ::: 510
is not None , ::: 509
- NUMBER ) . ::: 509
NAME in [ ( ::: 509
and not NAME [ ::: 509
STRING ) is not ::: 508
* ( NAME [ ::: 508
NAME , None NEWLINE ::: 508
, STRING if NAME ::: 508
] NEWLINE import NAME ::: 507
} , NAME , ::: 507
None , { STRING ::: 507
while NAME > NUMBER ::: 507
NUMBER } ) , ::: 507
} NEWLINE NAME , ::: 506
NAME , NAME or ::: 506
+ NAME ] = ::: 506
STRING ] is None ::: 506
[ : , None ::: 506
True , NAME ) ::: 505
False , ) NEWLINE ::: 505
= NUMBER NAME NEWLINE ::: 505
- NAME - NUMBER ::: 505
[ NAME [ : ::: 503
NAME [ STRING + ::: 503
False , True , ::: 503
NAME ( NUMBER ** ::: 503
] == [ STRING ::: 503
, : , NUMBER ::: 503
) ( ) ) ::: 503
] ( ) NEWLINE ::: 502
NUMBER / NUMBER NEWLINE ::: 502
== ( NAME , ::: 502
in NAME ( STRING ::: 502
: None , } ::: 502
+ NAME ( ) ::: 502
return ( ( NAME ::: 501
: NAME ] + ::: 501
+ NAME ) ] ::: 501
) ) } NEWLINE ::: 501
NEWLINE try : NAME ::: 501
INDENT return not ( ::: 500
NEWLINE while NAME > ::: 500
NAME != NAME ( ::: 500
False , NAME ) ::: 500
NUMBER : STRING } ::: 500
STRING * NUMBER , ::: 500
] ) ) . ::: 500
DEDENT elif NAME != ::: 500
not in NAME or ::: 499
INDENT assert NAME [ ::: 498
[ NUMBER ] not ::: 498
= NUMBER * ( ::: 497
) & NUMBER ) ::: 497
None ) or NAME ::: 497
is not NAME NEWLINE ::: 496
import NAME NEWLINE for ::: 496
NAME [ ( STRING ::: 496
} NEWLINE DEDENT elif ::: 496
NUMBER , { } ::: 496
not NAME ( ) ::: 496
DEDENT NAME [ NUMBER ::: 496
( [ [ NAME ::: 496
NAME ] + STRING ::: 495
NUMBER : ] == ::: 495
assert NAME is NAME ::: 494
[ NUMBER * NAME ::: 494
NAME is False NEWLINE ::: 493
NEWLINE with NAME : ::: 493
DEDENT raise NAME NEWLINE ::: 493
NUMBER + NAME * ::: 493
NAME ) ) or ::: 493
assert NAME [ NAME ::: 492
NAME > NUMBER NEWLINE ::: 492
DEDENT del NAME NEWLINE ::: 492
) ] for NAME ::: 492
False , STRING NEWLINE ::: 492
STRING NEWLINE while NAME ::: 492
: [ NAME , ::: 492
NAME == NAME ] ::: 492
NEWLINE DEDENT DEDENT from ::: 491
NUMBER : { STRING ::: 491
[ None ] * ::: 490
, NAME / NAME ::: 490
: , None ] ::: 490
NAME , ( ( ::: 490
: ( ) , ::: 490
} ] } , ::: 490
or NAME ( STRING ::: 490
) ( * NAME ::: 489
( NAME not in ::: 489
[ [ - NUMBER ::: 489
) == ( STRING ::: 489
, NUMBER , ] ::: 489
NAME : NUMBER } ::: 489
NAME = NUMBER << ::: 488
NUMBER <= NAME <= ::: 488
+ ( NAME - ::: 487
DEDENT if NAME or ::: 487
False NEWLINE DEDENT for ::: 487
NAME : [ NAME ::: 487
) . NAME is ::: 486
[ NUMBER ] >= ::: 486
STRING NEWLINE return True ::: 486
] + NAME + ::: 486
NUMBER NAME NEWLINE NAME ::: 486
( NAME <= NAME ::: 486
NAME for ( NAME ::: 486
) NEWLINE pass NEWLINE ::: 486
- NAME [ STRING ::: 485
NAME and NAME > ::: 485
, NAME in ( ::: 485
- NUMBER + NUMBER ::: 485
NUMBER : ] ] ::: 485
( NUMBER ) * ::: 485
} , NUMBER ) ::: 484
] ) NEWLINE del ::: 484
( NAME is NAME ::: 483
, True , STRING ::: 483
, NUMBER , { ::: 483
NAME and NAME < ::: 483
) ) ) == ::: 483
NAME % NUMBER ) ::: 483
NUMBER + NAME ** ::: 482
, [ [ STRING ::: 482
NAME << NUMBER ) ::: 482
, - NAME ) ::: 482
NAME ) % NAME ::: 482
NAME , { NAME ::: 481
+ NAME ) : ::: 481
NAME in NAME or ::: 480
raise NAME , NAME ::: 480
NEWLINE elif NAME == ::: 479
NAME ) or not ::: 479
STRING STRING + NAME ::: 479
INDENT return [ ( ::: 478
STRING : NAME + ::: 478
None NEWLINE NAME ( ::: 478
NAME ) is None ::: 478
NUMBER , - NAME ::: 477
NUMBER ] < NUMBER ::: 477
+ NAME / NUMBER ::: 477
not NAME ) : ::: 477
] NEWLINE DEDENT try ::: 476
STRING ) != - ::: 476
NAME . NAME ** ::: 475
<= NAME ( NAME ::: 475
% NAME ) , ::: 475
NAME ] != NAME ::: 475
= STRING NEWLINE while ::: 474
NUMBER ] += NAME ::: 474
} NEWLINE if not ::: 474
STRING ] ( STRING ::: 473
, ( [ STRING ::: 473
NAME : return NAME ::: 473
True NEWLINE DEDENT class ::: 473
+= NAME ( STRING ::: 472
] NEWLINE for ( ::: 472
True , True ) ::: 472
[ NUMBER , : ::: 472
NUMBER ] , ) ::: 472
: ( STRING STRING ::: 471
assert NAME ( ) ::: 471
] - NUMBER ) ::: 471
. NAME or ( ::: 471
if ( NAME and ::: 471
, ( STRING + ::: 471
elif NAME in [ ::: 470
if ( NAME ) ::: 470
NAME ] ) == ::: 470
) } , { ::: 470
return ( NAME [ ::: 470
) : NAME , ::: 470
DEDENT while True : ::: 470
, ( NAME - ::: 470
STRING NEWLINE return None ::: 470
NAME ) , False ::: 469
STRING ) NEWLINE yield ::: 469
NUMBER ) : STRING ::: 469
( NAME or STRING ::: 469
or NAME == NUMBER ::: 469
. NAME -= NAME ::: 468
= None ) ) ::: 468
STRING ] ) for ::: 468
in [ STRING ] ::: 468
) / NUMBER , ::: 467
try : NAME = ::: 467
NAME : NAME NEWLINE ::: 467
, { NUMBER : ::: 467
STRING ) is None ::: 467
, = NAME . ::: 466
( ) is not ::: 466
DEDENT yield NAME NEWLINE ::: 466
( STRING , * ::: 466
not NAME ) NEWLINE ::: 466
STRING NEWLINE ( NAME ::: 465
= ( STRING + ::: 465
False NEWLINE DEDENT try ::: 465
: NAME ] = ::: 464
] ] NEWLINE if ::: 464
) ] ) ] ::: 464
NAME or NAME in ::: 464
] , False ) ::: 464
INDENT NAME NAME ( ::: 464
. NAME <= NUMBER ::: 463
] += NAME . ::: 463
NAME != NAME NEWLINE ::: 463
True , } , ::: 463
) > NAME ( ::: 462
assert False NEWLINE DEDENT ::: 462
+= [ STRING , ::: 462
: pass NEWLINE NAME ::: 462
DEDENT DEDENT assert NAME ::: 462
not in ( NAME ::: 461
STRING ] ) [ ::: 461
) NEWLINE while not ::: 461
STRING ] } ] ::: 461
[ [ NAME . ::: 461
return [ STRING , ::: 460
, ** NAME : ::: 460
NUMBER ) } , ::: 460
NUMBER } } NEWLINE ::: 460
NEWLINE while NAME is ::: 460
. NAME : ] ::: 460
) and STRING in ::: 460
True ) , ) ::: 460
None } NEWLINE NAME ::: 460
STRING ] += NUMBER ::: 459
[ NAME ( [ ::: 459
INDENT if ( not ::: 459
) ** NUMBER NEWLINE ::: 458
, : ] , ::: 458
) + NAME + ::: 458
STRING ) ] = ::: 457
STRING : [ [ ::: 457
NAME ) [ - ::: 457
[ : - NAME ::: 457
NAME else NUMBER NEWLINE ::: 457
, ( ( NAME ::: 456
NAME else NAME ( ::: 456
NEWLINE INDENT NAME *= ::: 455
( NAME % NUMBER ::: 455
( NAME if NAME ::: 455
NEWLINE NAME += ( ::: 455
= - NAME NEWLINE ::: 454
STRING } , ] ::: 454
) else NAME NEWLINE ::: 454
NAME ] ) ] ::: 454
STRING } NEWLINE if ::: 454
> NUMBER NEWLINE NAME ::: 453
( NUMBER / NUMBER ::: 453
if NAME and ( ::: 453
NEWLINE assert NAME != ::: 453
None ) NEWLINE def ::: 453
NAME ] } ) ::: 453
assert ( NAME == ::: 453
break NEWLINE DEDENT elif ::: 453
( ) , False ::: 453
= STRING in NAME ::: 452
INDENT assert False , ::: 452
+= NAME * NAME ::: 452
NUMBER NEWLINE with NAME ::: 452
is None NEWLINE NAME ::: 452
/ NUMBER + NAME ::: 451
( ) , True ::: 451
not ( NAME ( ::: 451
INDENT NAME [ - ::: 451
NUMBER << NUMBER NEWLINE ::: 451
) , ( { ::: 451
[ NAME ] if ::: 450
) ] + NAME ::: 450
STRING ] * NUMBER ::: 450
NUMBER ] [ - ::: 450
is None ) : ::: 450
+ NAME for NAME ::: 450
+ NUMBER ) / ::: 450
== - NUMBER NEWLINE ::: 450
INDENT NAME ( ( ::: 449
NAME <= NUMBER ) ::: 449
NAME <= NAME ) ::: 449
, NAME ] ] ::: 449
, NUMBER ** NUMBER ::: 449
NUMBER ] / NAME ::: 449
) ) is None ::: 448
NAME is True NEWLINE ::: 448
] , ) ) ::: 448
== STRING , STRING ::: 448
STRING ) == [ ::: 448
, { NAME : ::: 448
None ) . NAME ::: 447
] } ) , ::: 447
True , STRING ) ::: 447
( NAME ) else ::: 446
} , ) , ::: 446
+ STRING ) . ::: 446
: return NEWLINE NAME ::: 445
NAME >= NUMBER ) ::: 445
( ) : NAME ::: 445
] = - NUMBER ::: 445
STRING and NAME ( ::: 445
in ( None , ::: 445
* NAME NEWLINE if ::: 444
NAME NEWLINE DEDENT STRING ::: 444
DEDENT DEDENT DEDENT finally ::: 444
NAME , NAME % ::: 444
NAME ) NEWLINE STRING ::: 443
NAME ] NEWLINE del ::: 443
NAME += NAME * ::: 443
NAME and STRING or ::: 443
NAME = STRING in ::: 443
STRING ] += NAME ::: 442
else STRING NEWLINE DEDENT ::: 442
( None ) ) ::: 442
, NAME in [ ::: 441
) as NAME , ::: 441
- NUMBER - NUMBER ::: 441
** NUMBER * NAME ::: 441
in NAME , STRING ::: 441
NAME in ( ( ::: 441
: ( NAME ( ::: 440
} } } } ::: 440
DEDENT DEDENT from NAME ::: 440
and NAME > NAME ::: 440
) ) NEWLINE import ::: 440
, True ) : ::: 440
pass NEWLINE DEDENT except ::: 440
= None ) , ::: 439
) - NUMBER : ::: 439
] * NUMBER , ::: 439
: raise NAME ( ::: 439
NUMBER , NAME * ::: 439
) , ( None ::: 438
NAME != NAME and ::: 438
, ( { STRING ::: 438
or NAME > NAME ::: 438
: raise NAME . ::: 438
INDENT NAME NEWLINE DEDENT ::: 438
: ] , STRING ::: 437
== [ NAME . ::: 436
] ) ) ] ::: 436
) ) NEWLINE del ::: 436
break NEWLINE DEDENT except ::: 436
) - NUMBER ] ::: 435
assert NAME ( - ::: 435
STRING and NAME == ::: 435
= NUMBER << NUMBER ::: 435
== NAME , STRING ::: 435
} } } ) ::: 435
= NAME % ( ::: 435
NAME * NAME ** ::: 435
] } } NEWLINE ::: 434
( ) < NAME ::: 434
: NAME ] . ::: 434
+ [ NAME ( ::: 434
+= [ STRING ] ::: 434
NUMBER ] NEWLINE def ::: 433
INDENT NAME , = ::: 432
NEWLINE NAME [ ( ::: 432
: ( NAME + ::: 432
DEDENT for ( NAME ::: 431
, : NUMBER ] ::: 431
, ** { STRING ::: 431
== STRING else NAME ::: 431
NUMBER , NAME NEWLINE ::: 431
pass NEWLINE def NAME ::: 431
NEWLINE while ( NAME ::: 431
= ( NUMBER << ::: 430
, NAME ( None ::: 430
) + NAME * ::: 430
) else NAME . ::: 429
NUMBER + NUMBER ] ::: 429
None ) ) , ::: 429
= [ STRING . ::: 428
] [ : , ::: 428
: True } } ::: 428
) == [ NUMBER ::: 427
NAME . NAME // ::: 427
NUMBER } NEWLINE DEDENT ::: 427
NAME != STRING ) ::: 427
NAME * NUMBER * ::: 427
NUMBER , ] , ::: 427
NUMBER ] = ( ::: 426
+ ( NAME , ::: 426
NAME = NAME // ::: 426
, STRING STRING % ::: 426
NAME ] == NUMBER ::: 426
NUMBER NEWLINE STRING NEWLINE ::: 425
) and ( not ::: 425
] if STRING in ::: 425
NUMBER ) , - ::: 425
NUMBER ) , } ::: 425
. NAME ) >= ::: 425
= NUMBER + NAME ::: 425
( ( None , ::: 424
( NAME + ( ::: 424
NUMBER or NAME ( ::: 424
NUMBER ) } NEWLINE ::: 424
) == ( NUMBER ::: 424
NAME ) in ( ::: 424
STRING ] not in ::: 424
if NAME else NUMBER ::: 423
del NAME [ NUMBER ::: 423
NAME + STRING . ::: 423
[ NUMBER : : ::: 423
[ STRING ] not ::: 423
NUMBER : NAME + ::: 423
) ] = NUMBER ::: 423
= STRING STRING , ::: 422
) ) NEWLINE while ::: 422
NAME : NAME STRING ::: 422
( None ) , ::: 422
. NAME : [ ::: 422
if NAME and STRING ::: 422
. NAME == { ::: 421
[ STRING ] / ::: 421
NEWLINE NAME /= NAME ::: 421
STRING ] > NUMBER ::: 421
NUMBER ** NUMBER , ::: 420
] . NAME ] ::: 420
[ True , False ::: 420
, STRING + STRING ::: 420
STRING ) in NAME ::: 419
) & NUMBER NEWLINE ::: 419
NAME ) % NUMBER ::: 419
) % NAME ( ::: 419
NUMBER , } ) ::: 419
. NAME * ( ::: 418
elif NAME < NUMBER ::: 418
] + NUMBER NEWLINE ::: 418
) * NAME [ ::: 417
NUMBER NAME , NUMBER ::: 417
) NEWLINE assert NUMBER ::: 417
STRING ) [ STRING ::: 417
else [ ] NEWLINE ::: 417
: NEWLINE INDENT [ ::: 417
[ : NAME ( ::: 417
. NAME == - ::: 417
if ( STRING in ::: 416
= ( NAME == ::: 416
or ( NAME ( ::: 416
% NAME ] NEWLINE ::: 416
NUMBER NEWLINE NAME STRING ::: 416
NAME ] ) [ ::: 415
, STRING * NUMBER ::: 415
NEWLINE return NAME in ::: 415
NAME *= NAME NEWLINE ::: 415
( NAME >= NUMBER ::: 415
if NAME ] NEWLINE ::: 414
NUMBER ] > NUMBER ::: 414
NUMBER or NAME == ::: 414
, } , ] ::: 414
% NAME ) . ::: 414
NAME or NAME or ::: 414
) + NAME , ::: 413
NEWLINE if ( ( ::: 413
NEWLINE return [ ( ::: 412
NUMBER ] , - ::: 412
NAME = [ False ::: 412
] = NAME = ::: 412
) ) + NUMBER ::: 412
* NAME [ STRING ::: 412
= STRING ) [ ::: 411
INDENT return None , ::: 411
NUMBER or NAME > ::: 411
[ NUMBER for NAME ::: 411
== STRING ] NEWLINE ::: 411
) ) ) for ::: 411
. NAME : { ::: 411
= NAME NEWLINE STRING ::: 410
not NAME == NAME ::: 410
, NAME NEWLINE @ ::: 410
= STRING * NAME ::: 410
: lambda NAME , ::: 410
} , ] , ::: 410
) NEWLINE else : ::: 410
NAME ) & ( ::: 410
: { NUMBER : ::: 410
-= NAME NEWLINE NAME ::: 409
[ : NUMBER , ::: 409
NAME NEWLINE assert ( ::: 409
NAME , NUMBER NAME ::: 409
} , NUMBER , ::: 409
return [ STRING ] ::: 409
NUMBER : : NUMBER ::: 408
NAME NEWLINE DEDENT with ::: 408
NAME if NAME != ::: 408
and not ( NAME ::: 408
+ ( NAME * ::: 408
( ) and not ::: 407
NAME *= NUMBER NEWLINE ::: 407
NAME != NAME [ ::: 407
] if NAME ( ::: 407
} . NAME ( ::: 407
NAME in STRING : ::: 407
return None , None ::: 407
False } ) NEWLINE ::: 407
False } NEWLINE NAME ::: 407
] , NAME + ::: 407
] += NAME [ ::: 406
INDENT return STRING , ::: 406
} NEWLINE if STRING ::: 406
] , - NUMBER ::: 406
) NEWLINE NAME NEWLINE ::: 406
NUMBER ) + ( ::: 405
: NAME + STRING ::: 405
( NAME ) ** ::: 405
NAME if NAME == ::: 405
) [ : NAME ::: 405
NAME + NAME : ::: 405
: pass NEWLINE def ::: 405
< NAME ) NEWLINE ::: 405
DEDENT if not STRING ::: 404
NUMBER + ( NAME ::: 404
NUMBER ) ) [ ::: 404
) <= NUMBER : ::: 403
) + NUMBER , ::: 403
True NEWLINE NAME ( ::: 403
% NAME [ NAME ::: 403
( NAME >= NAME ::: 403
) ) / NUMBER ::: 403
if not NAME == ::: 403
( [ STRING . ::: 402
NAME ( ) >= ::: 402
) is NAME NEWLINE ::: 402
== NAME ) ) ::: 402
NAME == [ NUMBER ::: 401
[ : : NUMBER ::: 401
STRING ] - NAME ::: 401
. NAME == False ::: 401
< NAME and NAME ::: 401
) * NAME + ::: 400
] , ] NEWLINE ::: 400
< NUMBER ) NEWLINE ::: 400
NAME -= NAME ( ::: 399
// NUMBER NEWLINE NAME ::: 399
, NAME ( - ::: 398
} , NAME ( ::: 398
NEWLINE NAME = not ::: 398
NAME = NAME ** ::: 398
NUMBER ] += NUMBER ::: 398
) == { STRING ::: 398
( ) not in ::: 397
) if NAME in ::: 397
( NUMBER , [ ::: 397
NUMBER / ( NUMBER ::: 397
None ] * NAME ::: 397
: None ) NEWLINE ::: 397
INDENT NAME -= NAME ::: 397
NAME ( ) not ::: 396
STRING NEWLINE return NUMBER ::: 396
NAME |= NAME NEWLINE ::: 396
, NUMBER NAME , ::: 396
( * ( NAME ::: 396
= NAME NEWLINE ( ::: 396
[ NUMBER ] ( ::: 396
( NUMBER * ( ::: 396
or ( NAME == ::: 396
, { NAME . ::: 396
or NAME or NAME ::: 395
) > NUMBER else ::: 395
if NAME != - ::: 395
- NAME + NAME ::: 395
NAME ** NUMBER * ::: 395
+ NAME * NUMBER ::: 394
NEWLINE DEDENT while True ::: 394
} , [ ] ::: 394
NUMBER or NAME [ ::: 394
, ) , None ::: 394
del NAME [ : ::: 394
NAME NAME + STRING ::: 394
[ NAME ] in ::: 394
/ ( NAME * ::: 394
NUMBER ] : NAME ::: 394
NAME NEWLINE return [ ::: 394
] [ : NUMBER ::: 393
- ( NAME . ::: 393
NUMBER / NAME NEWLINE ::: 393
NAME ( NAME & ::: 393
STRING ] if STRING ::: 393
= NUMBER ; NAME ::: 393
[ [ NAME , ::: 393
) == [ ] ::: 393
) in NAME ] ::: 393
NUMBER ] ] ] ::: 393
NUMBER ] ) - ::: 393
* ( NAME * ::: 393
if NAME == True ::: 392
] if NAME [ ::: 392
NUMBER ] } , ::: 392
NUMBER } ] , ::: 392
!= NAME and NAME ::: 392
{ } NEWLINE try ::: 392
assert NAME != NAME ::: 391
) * ( NUMBER ::: 391
= None NEWLINE while ::: 391
not in NAME ( ::: 391
STRING * NAME ( ::: 391
= STRING STRING NEWLINE ::: 391
STRING NEWLINE return False ::: 391
) as ( NAME ::: 390
, STRING NEWLINE if ::: 390
True , False ] ::: 390
( NAME ) ; ::: 390
False ) NEWLINE for ::: 390
( ) NEWLINE import ::: 390
NUMBER + NAME , ::: 390
= NAME NEWLINE with ::: 390
<< NUMBER ) | ::: 390
, - NAME , ::: 390
STRING ] ) > ::: 390
DEDENT DEDENT STRING NEWLINE ::: 389
] + [ STRING ::: 389
) ) , } ::: 389
= ( STRING . ::: 389
( ) NEWLINE ( ::: 389
NUMBER ] in ( ::: 389
) , [ [ ::: 388
elif NAME > NUMBER ::: 388
( ) * NAME ::: 387
+= NAME [ STRING ::: 387
} ] } ) ::: 387
NUMBER ) ) * ::: 387
) in ( STRING ::: 387
) , lambda NAME ::: 387
: [ - NUMBER ::: 387
True NEWLINE try : ::: 386
, False ] ) ::: 386
NUMBER / NAME ( ::: 386
None ] ) NEWLINE ::: 386
) ( NAME ( ::: 386
] ] [ STRING ::: 386
NUMBER ] > NAME ::: 385
, ) , } ::: 385
return { NAME : ::: 385
, None , ( ::: 385
return NAME ( lambda ::: 385
} ] NEWLINE DEDENT ::: 385
) ) or NAME ::: 384
] != NUMBER : ::: 384
NAME and NAME ) ::: 384
lambda NAME : None ::: 384
NAME = { ( ::: 383
NAME * NAME : ::: 383
] ) if NAME ::: 383
; NEWLINE DEDENT def ::: 383
-= NUMBER NEWLINE if ::: 383
NAME else [ ] ::: 383
!= NUMBER or NAME ::: 383
NUMBER ) NEWLINE while ::: 383
DEDENT if NAME & ::: 383
while NAME is not ::: 382
False , True ) ::: 382
NAME NEWLINE return True ::: 382
NAME , ] ) ::: 382
INDENT yield NAME [ ::: 382
, STRING ] + ::: 382
- NAME ) + ::: 381
NAME is None , ::: 381
INDENT return NAME == ::: 381
INDENT assert NAME in ::: 381
STRING + STRING * ::: 381
* ( NUMBER + ::: 381
NUMBER * ( NUMBER ::: 380
False , STRING , ::: 380
( NAME ) not ::: 380
NUMBER ) ) + ::: 380
] or NAME [ ::: 380
, NAME NEWLINE assert ::: 379
- NUMBER ] != ::: 379
= True NEWLINE try ::: 379
} ) , ) ::: 379
) >= NAME . ::: 378
NAME ( ( ) ::: 378
NUMBER , NAME / ::: 378
NUMBER ] < NAME ::: 378
[ NUMBER ] and ::: 378
NAME ** NUMBER / ::: 378
INDENT global NAME , ::: 378
None NEWLINE if STRING ::: 378
True } ) , ::: 377
] < NUMBER : ::: 377
= NUMBER NEWLINE STRING ::: 377
NAME / ( NUMBER ::: 377
: continue NEWLINE NAME ::: 377
NAME ( ) else ::: 377
NAME == False : ::: 377
+= NAME [ NUMBER ::: 376
( NAME ) % ::: 376
None ) NEWLINE assert ::: 376
or NUMBER NEWLINE NAME ::: 376
. NAME ] } ::: 375
] = NAME * ::: 375
or { } ) ::: 375
, ** NAME ( ::: 375
] NEWLINE ( NAME ::: 375
or ( not NAME ::: 375
STRING , ) : ::: 375
STRING ] ] [ ::: 375
] } } , ::: 375
= NUMBER ) [ ::: 374
NAME < NAME and ::: 374
STRING ) : ] ::: 374
== NUMBER : return ::: 374
True , NAME , ::: 374
NUMBER } } ) ::: 374
] . NAME is ::: 374
( not NUMBER , ::: 374
STRING ] == [ ::: 373
NAME // NUMBER ) ::: 373
if ( NAME , ::: 373
- NUMBER NEWLINE assert ::: 373
) | NAME . ::: 373
, NAME , ] ::: 373
] , [ { ::: 373
NAME , [ [ ::: 373
, } ) ) ::: 373
NAME : return NEWLINE ::: 372
<= NAME <= NUMBER ::: 372
NEWLINE NAME *= NAME ::: 372
( * NAME [ ::: 372
[ ] , NUMBER ::: 372
] == NAME ) ::: 372
NAME , NEWLINE DEDENT ::: 372
, } NEWLINE class ::: 372
NEWLINE yield ( NAME ::: 371
] = STRING + ::: 371
[ : ] , ::: 371
) ) or ( ::: 371
) , NAME * ::: 371
: - NAME ( ::: 371
( NAME << NUMBER ::: 371
NUMBER ) if NAME ::: 370
NAME ) or STRING ::: 370
NAME + NAME / ::: 370
< NUMBER ) : ::: 370
NEWLINE INDENT [ NAME ::: 370
NAME - NAME ] ::: 370
DEDENT DEDENT elif not ::: 370
lambda * NAME : ::: 370
NUMBER + NUMBER NEWLINE ::: 370
STRING ] ) + ::: 370
NEWLINE if NAME % ::: 370
NEWLINE INDENT assert STRING ::: 369
, NUMBER ) * ::: 369
( NUMBER <= NAME ::: 368
: NUMBER , : ::: 368
+ NAME * ( ::: 368
) : ( ) ::: 368
) NEWLINE DEDENT ( ::: 368
, None ) == ::: 368
) & NAME ( ::: 368
NAME ) = ( ::: 368
, NAME ) ; ::: 368
) ] , None ::: 367
, { } NEWLINE ::: 367
as ( NAME , ::: 367
>> NAME , NAME ::: 367
return NAME if NAME ::: 367
NAME > NAME ( ::: 367
( NUMBER ) [ ::: 367
None , STRING NEWLINE ::: 367
NUMBER ) | ( ::: 367
NUMBER ] ] [ ::: 367
NUMBER ] and NAME ::: 367
] ) ) * ::: 367
NEWLINE return { } ::: 366
- NUMBER ) + ::: 366
and NAME < NUMBER ::: 366
if ( NAME != ::: 366
. NAME ] == ::: 366
, NUMBER ] * ::: 366
+ NAME [ : ::: 365
in NAME and not ::: 365
{ NAME : NUMBER ::: 365
@ NAME ( NUMBER ::: 365
NEWLINE NAME |= NAME ::: 365
return ( STRING % ::: 365
= ( NUMBER * ::: 364
NAME ) } , ::: 364
NAME * NUMBER / ::: 364
STRING in NAME , ::: 364
. NAME % ( ::: 364
STRING ) ) [ ::: 363
] NEWLINE from NAME ::: 363
NAME : STRING % ::: 363
. NAME = not ::: 362
NUMBER and NAME < ::: 362
NAME ( NAME != ::: 362
) ** NUMBER + ::: 362
and not NAME and ::: 362
] ) / NUMBER ::: 362
- NUMBER NEWLINE for ::: 362
assert NAME not in ::: 362
False ] ) NEWLINE ::: 361
] ) ) for ::: 361
STRING * NUMBER + ::: 361
{ STRING : - ::: 361
NUMBER - NUMBER , ::: 361
NAME NEWLINE NAME -= ::: 361
return ( False , ::: 360
. import NAME as ::: 360
, } } , ::: 360
NAME ] , None ::: 360
NAME & NUMBER NEWLINE ::: 360
STRING ) NEWLINE del ::: 360
) ] } NEWLINE ::: 359
assert NAME , STRING ::: 359
STRING NEWLINE while True ::: 359
INDENT return { NAME ::: 359
False , NAME , ::: 358
) in NAME ) ::: 358
) ) ) ] ::: 358
( STRING ) ; ::: 358
NAME ] [ : ::: 357
, ] NEWLINE if ::: 357
} ] , [ ::: 357
NAME } } ) ::: 357
[ None ] NEWLINE ::: 357
] / NAME [ ::: 357
] == STRING or ::: 357
None NEWLINE @ NAME ::: 357
NUMBER , NUMBER / ::: 357
* NUMBER / NAME ::: 356
NAME , ) . ::: 356
NUMBER ) : raise ::: 356
] == STRING , ::: 356
NAME ) ) if ::: 356
) ) ) + ::: 356
( True , False ::: 356
NAME } NEWLINE def ::: 356
{ NAME : { ::: 356
None or NAME == ::: 356
) NEWLINE elif NAME ::: 356
NUMBER ] , { ::: 356
] ) - NAME ::: 356
: pass NEWLINE DEDENT ::: 355
[ NAME , ] ::: 355
STRING and NAME != ::: 355
= None NEWLINE @ ::: 355
return NEWLINE DEDENT except ::: 355
) , NUMBER * ::: 355
) : [ STRING ::: 354
DEDENT NAME = lambda ::: 354
, NAME % NAME ::: 354
) + STRING % ::: 353
NUMBER ] is not ::: 353
or NAME > NUMBER ::: 353
, None , True ::: 352
( ) ) > ::: 352
NAME , [ { ::: 352
, ) NEWLINE for ::: 351
== NAME ( ( ::: 351
. NAME & NUMBER ::: 351
, None ] , ::: 351
NAME / NUMBER + ::: 351
!= STRING ) : ::: 351
NAME >= NUMBER NEWLINE ::: 351
NUMBER ) ] = ::: 350
} , } ) ::: 350
, } NEWLINE EOS ::: 350
INDENT STRING NEWLINE ( ::: 350
True ) NEWLINE with ::: 350
in NAME ) , ::: 350
DEDENT NAME += [ ::: 350
) NEWLINE [ NAME ::: 349
[ ] NEWLINE assert ::: 349
= True ) ] ::: 349
STRING NEWLINE NAME >> ::: 349
NAME STRING * NUMBER ::: 349
{ } , [ ::: 349
) in ( NAME ::: 349
elif ( NAME == ::: 349
] , NUMBER : ::: 349
STRING } } ] ::: 349
[ [ STRING ] ::: 348
) NEWLINE NAME /= ::: 348
NAME = NUMBER NUMBER ::: 347
+ NUMBER + NUMBER ::: 347
/ NAME ) * ::: 347
NAME : pass NEWLINE ::: 347
NEWLINE if NAME & ::: 347
) is None ) ::: 347
( ( NUMBER - ::: 347
. NAME ** NUMBER ::: 347
STRING ] NEWLINE with ::: 346
NAME >= NAME ) ::: 346
!= NAME [ NAME ::: 346
NAME != NUMBER ) ::: 346
NAME | NAME NEWLINE ::: 346
= None , None ::: 346
None , None ] ::: 345
] ) } NEWLINE ::: 345
not NAME : return ::: 345
/ ( NUMBER + ::: 345
/ NUMBER ) * ::: 345
None and NAME != ::: 345
: ] == STRING ::: 345
( ) > NAME ::: 344
assert NAME == { ::: 344
} ) ] ) ::: 344
+ NAME , NUMBER ::: 344
not NUMBER , STRING ::: 344
NUMBER if NAME . ::: 344
** NUMBER - NAME ::: 344
NAME + ( NUMBER ::: 343
return STRING in NAME ::: 343
NUMBER ] is None ::: 343
NAME or NAME is ::: 343
] ] NEWLINE for ::: 343
** NUMBER / NUMBER ::: 342
) } NEWLINE if ::: 342
- NAME : ] ::: 342
) NEWLINE yield ( ::: 342
STRING ) NEWLINE STRING ::: 342
not None , STRING ::: 342
False } , STRING ::: 342
) == NUMBER or ::: 342
if NAME else [ ::: 341
] NEWLINE return ( ::: 341
NUMBER NEWLINE return NUMBER ::: 341
} } ] NEWLINE ::: 341
!= NAME ) NEWLINE ::: 341
) < NUMBER ) ::: 341
] ) - NUMBER ::: 341
* NUMBER + STRING ::: 341
** NAME ( ) ::: 341
) NEWLINE except : ::: 341
( ** { NAME ::: 340
[ NAME ] / ::: 340
( ) == [ ::: 340
= lambda * NAME ::: 340
, NAME NEWLINE return ::: 340
NEWLINE return not NAME ::: 340
INDENT import NAME , ::: 340
NUMBER : { NUMBER ::: 339
NAME , NUMBER NEWLINE ::: 339
. NAME : NUMBER ::: 339
NEWLINE DEDENT for ( ::: 339
NAME += NUMBER * ::: 339
None , ( NUMBER ::: 339
!= NAME [ STRING ::: 339
+= NUMBER * NAME ::: 338
DEDENT return [ ] ::: 338
} ] } } ::: 338
) : NUMBER , ::: 338
NAME : raise NAME ::: 338
] and NAME . ::: 338
) } NEWLINE return ::: 338
import * NEWLINE DEDENT ::: 338
STRING } ) . ::: 338
is NAME : return ::: 337
: return STRING NEWLINE ::: 337
NUMBER <= NAME < ::: 337
. NAME ) = ::: 337
+ NAME - NAME ::: 337
NUMBER ) } ) ::: 337
- NAME ] NEWLINE ::: 337
STRING ] ( ) ::: 336
NAME ( not NUMBER ::: 336
NUMBER NEWLINE @ NAME ::: 336
) == NAME [ ::: 336
, NAME ** NUMBER ::: 336
NEWLINE return ( STRING ::: 336
STRING or NAME [ ::: 336
or NUMBER ) NEWLINE ::: 335
( None , { ::: 335
[ STRING ] < ::: 335
] [ NAME ( ::: 334
INDENT return NAME * ::: 334
NUMBER : [ NUMBER ::: 334
NAME == ( STRING ::: 334
] + STRING , ::: 334
) in NAME NEWLINE ::: 334
- NUMBER ) ** ::: 334
assert not NAME NEWLINE ::: 333
= [ NAME + ::: 333
( STRING ) else ::: 333
STRING % NAME } ::: 333
del NAME , NAME ::: 333
NAME ] + NUMBER ::: 333
or [ ] ) ::: 333
NUMBER ) / ( ::: 333
) : [ - ::: 333
, STRING , ** ::: 333
* ( ( NAME ::: 332
or NAME NEWLINE DEDENT ::: 332
) or NAME == ::: 332
NUMBER - NAME NEWLINE ::: 332
and NAME <= NAME ::: 332
NUMBER ] ] . ::: 332
. NAME NEWLINE EOS ::: 332
DEDENT del NAME [ ::: 331
NEWLINE DEDENT from . ::: 331
: ] ) : ::: 331
] ] : NEWLINE ::: 331
[ ] ) ] ::: 331
) NEWLINE global NAME ::: 331
NAME STRING , NEWLINE ::: 331
STRING ] , True ::: 330
NUMBER ) ) / ::: 330
{ } } ) ::: 330
( not NAME and ::: 330
lambda NAME : NUMBER ::: 330
} } NEWLINE def ::: 330
[ [ NAME ( ::: 330
False ) ) ) ::: 330
NEWLINE except NAME : ::: 329
and ( NAME ( ::: 329
STRING ) , True ::: 329
+ STRING NEWLINE return ::: 329
> NUMBER or NAME ::: 329
( ) } , ::: 329
) ) NEWLINE break ::: 329
* NAME : NAME ::: 329
NAME NAME , NAME ::: 329
= NUMBER ** NUMBER ::: 328
+ STRING ] = ::: 328
NUMBER ) NEWLINE EOS ::: 328
+= [ NAME ( ::: 328
INDENT return ( ( ::: 328
} , STRING , ::: 328
DEDENT if NAME <= ::: 328
not NAME ( STRING ::: 327
NUMBER ] , None ::: 327
NAME ( NAME >= ::: 327
None ) is None ::: 327
] ( NAME = ::: 327
( NAME + [ ::: 327
NAME % STRING NEWLINE ::: 327
: NUMBER * NAME ::: 327
] + ( NAME ::: 327
NEWLINE while NAME != ::: 327
** NAME : NAME ::: 327
[ ] } ) ::: 327
+= STRING NEWLINE return ::: 326
and ( NAME is ::: 326
NEWLINE DEDENT NAME -= ::: 326
None , } NEWLINE ::: 326
or STRING not in ::: 326
= NAME ( False ::: 326
NAME = lambda * ::: 326
] NEWLINE yield NAME ::: 325
) + [ NAME ::: 325
, NAME ] + ::: 325
+ NAME : NEWLINE ::: 325
NAME : None ) ::: 325
, STRING NEWLINE return ::: 325
NUMBER ) NEWLINE @ ::: 325
INDENT if NAME <= ::: 325
DEDENT yield NAME . ::: 325
STRING * NAME ) ::: 324
return NAME - NAME ::: 324
NEWLINE INDENT yield NEWLINE ::: 324
is NAME and NAME ::: 324
NAME == NUMBER else ::: 324
{ NUMBER : { ::: 324
, NEWLINE NAME = ::: 324
<= NAME <= NAME ::: 324
* NAME NEWLINE return ::: 324
) - ( NAME ::: 324
+ NUMBER + NAME ::: 324
) * NUMBER , ::: 324
-= NAME ( NAME ::: 323
. NAME or NUMBER ::: 323
NUMBER , ( STRING ::: 323
if NAME + NAME ::: 323
STRING NEWLINE assert not ::: 323
NUMBER ) or ( ::: 323
INDENT NAME NAME , ::: 323
True NEWLINE DEDENT EOS ::: 323
( NUMBER , True ::: 322
NEWLINE return STRING + ::: 322
* NAME [ : ::: 322
if not NAME else ::: 322
return NAME , None ::: 322
!= NUMBER and NAME ::: 322
+ NUMBER ] [ ::: 322
) or NAME NEWLINE ::: 322
== STRING else STRING ::: 322
None NEWLINE DEDENT except ::: 321
: ] NEWLINE for ::: 321
NAME or NUMBER NEWLINE ::: 321
STRING STRING STRING NEWLINE ::: 321
NAME ] , ) ::: 321
, NAME NEWLINE EOS ::: 321
assert STRING == NAME ::: 321
... NAME . NAME ::: 321
) ) [ : ::: 321
== NUMBER : NAME ::: 320
+= NUMBER NEWLINE continue ::: 320
if NAME ( [ ::: 320
[ False , True ::: 320
NAME ) ] . ::: 320
* NUMBER * NAME ::: 319
* NUMBER ) + ::: 319
STRING , NUMBER NUMBER ::: 319
] - NAME ) ::: 319
NUMBER ** NUMBER NEWLINE ::: 319
- NAME [ : ::: 319
) , NUMBER NEWLINE ::: 319
) NEWLINE NAME *= ::: 319
+ NUMBER ) % ::: 319
) and NAME : ::: 319
NUMBER NEWLINE DEDENT try ::: 319
= True ) == ::: 318
NUMBER ) and NAME ::: 318
[ NAME * NUMBER ::: 318
return ( STRING STRING ::: 318
DEDENT DEDENT return [ ::: 318
- NUMBER and NAME ::: 318
= NAME ** NUMBER ::: 318
or NAME ) NEWLINE ::: 318
( - NUMBER + ::: 318
) * NAME * ::: 318
raise NEWLINE DEDENT else ::: 318
NEWLINE NAME ( { ::: 318
or NAME [ NAME ::: 317
) and NAME == ::: 317
) * NAME , ::: 317
= ( NUMBER ) ::: 317
( ( NUMBER + ::: 317
( ( True , ::: 317
if ( NAME in ::: 317
in NAME ( [ ::: 317
None ) and ( ::: 317
] ) * NUMBER ::: 317
False , True ] ::: 316
} ) , ] ::: 316
STRING ] ) } ::: 316
NEWLINE return NAME == ::: 316
from ... NAME . ::: 316
( STRING ) in ::: 316
) [ : : ::: 316
: NAME NEWLINE NAME ::: 316
True } , { ::: 316
pass NEWLINE NAME = ::: 316
= NAME / ( ::: 315
NUMBER + NUMBER + ::: 315
NAME ) ( * ::: 315
NEWLINE DEDENT DEDENT STRING ::: 315
{ } , ** ::: 315
, ( NAME * ::: 315
] NEWLINE while True ::: 315
, NAME ] . ::: 315
None ] NEWLINE DEDENT ::: 315
STRING == NAME . ::: 315
None else NAME ( ::: 315
NAME < NAME NEWLINE ::: 314
, NAME , lambda ::: 314
not NAME : NAME ::: 314
. NAME += [ ::: 314
is not None ] ::: 314
NAME ] / NAME ::: 314
} ) ] NEWLINE ::: 314
( ( NAME ) ::: 314
/= NAME . NAME ::: 314
or NAME ) : ::: 314
while NAME and NAME ::: 314
NAME else None , ::: 314
NUMBER ) NEWLINE yield ::: 314
NAME > NUMBER else ::: 314
] : NAME [ ::: 314
( True , STRING ::: 313
NUMBER ) ) for ::: 313
) , STRING + ::: 313
[ STRING , [ ::: 313
None ) , NUMBER ::: 313
) NEWLINE DEDENT continue ::: 313
or ( NAME and ::: 312
( ( ) , ::: 312
) ) == ( ::: 312
( - NUMBER - ::: 312
assert NUMBER == NAME ::: 312
DEDENT elif NAME >= ::: 312
NAME == STRING ] ::: 312
DEDENT DEDENT DEDENT try ::: 312
, : NAME ] ::: 312
, } NEWLINE for ::: 311
, True , None ::: 311
NUMBER } , [ ::: 311
{ } , None ::: 311
= ( [ NAME ::: 311
] ) + NUMBER ::: 311
( STRING % { ::: 311
NAME ] * NUMBER ::: 310
raise NAME ( ( ::: 310
NAME } ] NEWLINE ::: 310
NAME ] in NAME ::: 310
not NAME NEWLINE if ::: 310
: NAME , : ::: 310
) : ] ) ::: 310
NEWLINE return NAME * ::: 309
True ) NEWLINE EOS ::: 309
NUMBER } ) ) ::: 309
not NAME NEWLINE NAME ::: 309
<= NAME < NAME ::: 309
] and not NAME ::: 309
[ NAME ] < ::: 309
. NAME // NUMBER ::: 309
NAME += [ ( ::: 309
NUMBER NEWLINE yield NAME ::: 309
) , - NAME ::: 309
False ) as NAME ::: 309
NAME = NAME is ::: 308
+ NUMBER : NEWLINE ::: 308
STRING , NEWLINE NAME ::: 308
STRING : ( [ ::: 308
NAME ) , - ::: 308
[ : ] ) ::: 307
DEDENT DEDENT elif ( ::: 307
: ] ] NEWLINE ::: 307
% NAME NEWLINE raise ::: 307
+= [ NAME ] ::: 307
NUMBER ) [ : ::: 307
NUMBER + NAME NEWLINE ::: 306
: - NUMBER } ::: 306
( ) NEWLINE break ::: 306
, NUMBER - NAME ::: 306
NAME . NAME |= ::: 306
. NAME ] ] ::: 306
STRING ) NEWLINE break ::: 306
NAME or NUMBER ) ::: 306
STRING if NAME == ::: 306
assert NAME >= NUMBER ::: 306
>= NUMBER ) NEWLINE ::: 306
NUMBER NAME ) NEWLINE ::: 305
NAME NEWLINE while True ::: 305
) == STRING and ::: 305
( STRING ) >= ::: 305
NAME , : , ::: 305
NAME ( ( True ::: 305
= ( NAME | ::: 304
NUMBER , True , ::: 304
} ] , NAME ::: 304
( None , ( ::: 304
= False ) as ::: 304
STRING ) or not ::: 304
if ( NAME < ::: 304
) in [ STRING ::: 304
NAME // NUMBER NEWLINE ::: 304
: ] = NUMBER ::: 304
NAME } NEWLINE for ::: 304
or NAME < NUMBER ::: 303
NAME NEWLINE else : ::: 303
STRING or STRING ) ::: 303
] , lambda NAME ::: 303
] / NUMBER ) ::: 303
True , STRING , ::: 303
NEWLINE return [ STRING ::: 303
True , NUMBER ) ::: 303
* NAME * ( ::: 303
= NAME % STRING ::: 303
[ ] NEWLINE with ::: 302
DEDENT DEDENT del NAME ::: 302
: { NAME : ::: 302
DEDENT DEDENT import NAME ::: 302
/ NUMBER - NAME ::: 302
not in [ NAME ::: 302
= STRING % { ::: 302
NAME , NAME and ::: 302
NUMBER if NAME else ::: 302
[ ( NAME + ::: 301
/ NAME ( NUMBER ::: 301
. NAME % NUMBER ::: 301
NAME + STRING STRING ::: 301
NAME ) ) - ::: 301
NAME = NAME : ::: 301
NAME : ] , ::: 301
: ] ) , ::: 301
NUMBER + NAME + ::: 301
( NUMBER ** NAME ::: 301
NUMBER ] ] + ::: 301
None ) ] NEWLINE ::: 301
if NAME - NAME ::: 301
NAME ; NAME . ::: 301
, NUMBER : [ ::: 300
, NAME ( * ::: 300
[ NAME for ( ::: 300
DEDENT NAME STRING , ::: 300
) ) - NUMBER ::: 300
NAME [ NAME == ::: 299
not in [ NUMBER ::: 299
} [ NAME ] ::: 299
!= NAME ) : ::: 299
( NAME // NUMBER ::: 299
( ( NUMBER * ::: 299
== STRING NEWLINE if ::: 299
& ~ NAME . ::: 299
/ NAME [ NAME ::: 299
= NAME = STRING ::: 299
elif NAME > NAME ::: 299
return NAME / NAME ::: 299
NAME ) in [ ::: 299
NAME , ( - ::: 299
, NAME or NAME ::: 299
** NUMBER NEWLINE DEDENT ::: 298
& NAME ( NAME ::: 298
else NAME ) NEWLINE ::: 298
STRING % ( ( ::: 298
& NUMBER : NEWLINE ::: 298
* NAME for NAME ::: 298
-= NAME NEWLINE DEDENT ::: 298
+ STRING * NUMBER ::: 298
NUMBER ) % NUMBER ::: 298
NAME ) if not ::: 297
[ STRING , { ::: 297
- NAME , - ::: 297
= False NEWLINE while ::: 297
+ NUMBER , STRING ::: 297
DEDENT NAME >> NAME ::: 297
NUMBER ] >= NUMBER ::: 297
, ) NEWLINE @ ::: 297
<< NAME . NAME ::: 297
NEWLINE ( NAME . ::: 297
+ NAME ) + ::: 296
INDENT yield NEWLINE DEDENT ::: 296
NAME % NAME , ::: 296
) , NUMBER ] ::: 296
STRING * NAME NEWLINE ::: 296
while not NAME : ::: 296
- NUMBER : NAME ::: 296
) ) } ) ::: 296
[ STRING ] else ::: 296
STRING ) >= NUMBER ::: 296
NEWLINE del ( NAME ::: 296
NUMBER ) : ( ::: 296
+ ( NAME [ ::: 295
= NUMBER ; NEWLINE ::: 295
None , True ) ::: 295
is NAME NEWLINE assert ::: 295
NUMBER ] + ( ::: 295
NAME ] NEWLINE while ::: 295
DEDENT assert NAME == ::: 295
[ - NAME : ::: 295
- NUMBER - NAME ::: 295
INDENT from . import ::: 295
> - NUMBER : ::: 295
True , ) ) ::: 295
NAME ) NEWLINE except ::: 294
NAME ) ] [ ::: 294
( ( STRING + ::: 294
( - NAME ( ::: 294
NEWLINE except : NAME ::: 294
] , NUMBER ] ::: 294
] + NUMBER * ::: 294
) if NAME not ::: 294
NAME , STRING if ::: 294
NEWLINE assert NUMBER == ::: 294
, STRING ) else ::: 294
NAME /= NAME . ::: 294
) < NUMBER NEWLINE ::: 293
. NAME |= NAME ::: 293
None or not NAME ::: 293
STRING NEWLINE assert ( ::: 293
] , STRING . ::: 293
[ NAME [ - ::: 293
< NAME NEWLINE DEDENT ::: 293
, NUMBER ] == ::: 293
NEWLINE assert [ NAME ::: 293
!= NAME [ NUMBER ::: 293
] , NAME ] ::: 292
) : { STRING ::: 292
STRING * NAME , ::: 292
== NUMBER ) ) ::: 292
NEWLINE STRING NEWLINE try ::: 292
, True ) ] ::: 292
] [ : ] ::: 292
, NAME | NAME ::: 292
) if NAME ] ::: 292
not None NEWLINE assert ::: 292
] ] + NAME ::: 292
( ) in ( ::: 292
] } ] } ::: 292
INDENT if NAME or ::: 292
. NAME NEWLINE raise ::: 291
return NUMBER NEWLINE return ::: 291
, True , NUMBER ::: 291
) : return NEWLINE ::: 291
NUMBER ) and ( ::: 291
NUMBER ) : NAME ::: 291
** NUMBER ) . ::: 291
NAME : continue NEWLINE ::: 291
NAME |= NAME ( ::: 291
= not NAME NEWLINE ::: 290
+ NUMBER ) + ::: 290
= { NAME [ ::: 290
NEWLINE INDENT return lambda ::: 290
NEWLINE INDENT while NUMBER ::: 290
STRING ] += STRING ::: 290
] NEWLINE STRING NEWLINE ::: 290
NEWLINE assert ( STRING ::: 290
None ) ] , ::: 289
, False ] , ::: 289
NUMBER , ) : ::: 289
: return False NEWLINE ::: 289
NEWLINE assert NAME , ::: 289
} , } } ::: 289
else None ) NEWLINE ::: 289
INDENT while NUMBER : ::: 289
STRING ) and ( ::: 289
] = [ NUMBER ::: 289
NUMBER == NAME . ::: 289
NAME ) ] + ::: 289
( not NAME or ::: 289
. NAME if not ::: 289
NAME : None , ::: 289
NAME ( NAME <= ::: 289
DEDENT DEDENT elif STRING ::: 288
** NUMBER , NUMBER ::: 288
[ NAME ] > ::: 288
} ) , { ::: 288
. NAME or [ ::: 288
] [ : NAME ::: 288
if NUMBER <= NAME ::: 288
= yield NAME ( ::: 288
NEWLINE assert STRING == ::: 287
NAME = NAME in ::: 287
] ] NEWLINE return ::: 287
> NAME ) NEWLINE ::: 287
) and NAME != ::: 287
= [ None , ::: 287
+= NAME NEWLINE return ::: 287
% ( STRING * ::: 287
STRING , [ { ::: 287
except : pass NEWLINE ::: 287
} , None ) ::: 287
NUMBER + NAME ] ::: 286
if ( NAME > ::: 286
] ) , { ::: 286
*= NAME . NAME ::: 286
; NAME = NAME ::: 286
NAME ( NAME | ::: 286
: NUMBER ] ] ::: 286
False NEWLINE if not ::: 286
, ] ) ) ::: 286
NUMBER , NUMBER ** ::: 286
] NEWLINE return [ ::: 286
, NAME ) != ::: 286
% NAME ( STRING ::: 286
None NEWLINE DEDENT for ::: 285
{ NAME ( NAME ::: 285
DEDENT import NAME . ::: 285
) NEWLINE if NUMBER ::: 285
% NUMBER NEWLINE NAME ::: 285
[ ] NEWLINE return ::: 285
] } } ) ::: 285
STRING ) , False ::: 284
) or ( not ::: 284
NAME ) + [ ::: 284
) & ~ NAME ::: 284
] ) == STRING ::: 284
% NUMBER ) NEWLINE ::: 284
and ( NAME [ ::: 284
, NAME and STRING ::: 284
NAME = ( { ::: 284
NAME in STRING , ::: 284
) } ) ) ::: 284
( ( NAME >> ::: 284
] in [ STRING ::: 284
NEWLINE NAME ( * ::: 284
STRING ) NEWLINE continue ::: 283
) NEWLINE while NUMBER ::: 283
( None , [ ::: 283
STRING ) : STRING ::: 283
assert ( not NAME ::: 283
. NAME } ] ::: 283
NEWLINE NAME STRING * ::: 283
[ [ [ NUMBER ::: 283
NAME = None if ::: 283
( ) != NUMBER ::: 283
NAME : break NEWLINE ::: 283
] ] [ NAME ::: 283
NAME ] ] , ::: 282
) else NAME ( ::: 282
*= NAME NEWLINE NAME ::: 282
NAME } for NAME ::: 282
== NUMBER and not ::: 282
^ NAME ( NAME ::: 282
[ : NAME , ::: 282
and not NAME ) ::: 282
+ NAME [ - ::: 282
- NUMBER , : ::: 282
and NAME >= NAME ::: 282
= NUMBER NEWLINE @ ::: 282
/ NUMBER + NUMBER ::: 282
NEWLINE DEDENT assert STRING ::: 282
, None , { ::: 282
= NAME : NAME ::: 281
) or STRING ) ::: 281
STRING % ( NUMBER ::: 281
NAME != None and ::: 281
False } , { ::: 281
STRING STRING , { ::: 281
NUMBER ) % NAME ::: 281
. NAME or None ::: 281
) = ( NAME ::: 281
) ) / ( ::: 281
STRING ) == ( ::: 280
) ) < NUMBER ::: 280
import NAME NEWLINE with ::: 280
is True NEWLINE DEDENT ::: 280
NUMBER ** ( NAME ::: 280
) is NAME ) ::: 280
] for NAME , ::: 280
if NAME == [ ::: 280
NAME ] is None ::: 280
return NUMBER * NAME ::: 280
or NAME < NAME ::: 280
NUMBER ] = True ::: 280
STRING ] NEWLINE import ::: 280
. NAME } } ::: 280
] or NAME . ::: 280
| NAME NEWLINE NAME ::: 280
* NAME ) ** ::: 280
== [ NAME ] ::: 279
) ) , { ::: 279
not None else None ::: 279
or NAME not in ::: 279
is False NEWLINE DEDENT ::: 279
raise NEWLINE DEDENT return ::: 279
: None , NAME ::: 279
False NEWLINE DEDENT class ::: 279
< NUMBER and NAME ::: 279
NUMBER - NAME ** ::: 279
NAME < NAME [ ::: 279
NEWLINE yield STRING NEWLINE ::: 279
: break NEWLINE NAME ::: 278
) ] + [ ::: 278
- NAME ( STRING ::: 278
True ) NEWLINE try ::: 278
+ STRING NEWLINE for ::: 278
] NEWLINE raise NAME ::: 278
{ } , ) ::: 278
, ( False , ::: 278
NAME or NAME , ::: 278
NAME != STRING ] ::: 278
NAME % NUMBER NEWLINE ::: 278
NAME ) and STRING ::: 278
not NAME is None ::: 278
NAME - NAME : ::: 278
!= STRING ] NEWLINE ::: 278
return NAME ( None ::: 278
is None or not ::: 278
INDENT with NAME : ::: 277
DEDENT NAME ( NUMBER ::: 277
= STRING ) } ::: 277
} } ] } ::: 277
pass NEWLINE NAME . ::: 277
[ NUMBER ] <= ::: 276
STRING , lambda : ::: 276
, None ] ) ::: 276
NAME else None ) ::: 276
= NAME - ( ::: 276
return ( ) NEWLINE ::: 276
} ) NEWLINE EOS ::: 276
return NEWLINE NAME = ::: 276
NAME , NUMBER NUMBER ::: 276
( ) / NUMBER ::: 275
None , NAME NEWLINE ::: 275
: return None NEWLINE ::: 275
NUMBER ] , ] ::: 275
<= NUMBER ) NEWLINE ::: 275
: STRING STRING , ::: 275
) else STRING NEWLINE ::: 275
= ( NAME & ::: 275
} NEWLINE DEDENT except ::: 275
< NAME ) : ::: 274
= { NAME ( ::: 274
, ) ] NEWLINE ::: 274
{ NAME [ STRING ::: 274
or NAME != NAME ::: 274
= NAME & NUMBER ::: 274
) == STRING , ::: 274
) if NAME != ::: 274
) ] ) . ::: 274
- ( NAME - ::: 274
== [ ] : ::: 274
NAME + NUMBER + ::: 274
NAME and STRING + ::: 274
True ) ] NEWLINE ::: 274
None ) is not ::: 273
NUMBER ) : NUMBER ::: 273
( ) ) - ::: 273
) = NAME [ ::: 273
] + NUMBER , ::: 273
/ NUMBER ) + ::: 273
NUMBER + NAME [ ::: 273
NAME != NUMBER and ::: 273
) if NAME == ::: 273
not None ) and ::: 273
NAME > NAME [ ::: 273
NAME ] is not ::: 272
, NUMBER : - ::: 272
) is False : ::: 272
, NAME ) - ::: 272
and STRING + NAME ::: 272
} ) NEWLINE try ::: 272
= ( NAME / ::: 272
NUMBER ) [ - ::: 272
) ( STRING ) ::: 272
+ STRING ] NEWLINE ::: 272
import NAME NEWLINE assert ::: 272
= STRING % STRING ::: 271
( NAME / ( ::: 271
[ None , None ::: 271
INDENT return - NAME ::: 271
False , False ] ::: 271
, True ] , ::: 271
= True ) [ ::: 271
- ( NAME + ::: 271
+ ( STRING , ::: 270
+ NUMBER ) . ::: 270
+ STRING , { ::: 270
in STRING , STRING ::: 270
else : NAME . ::: 270
elif NAME < NAME ::: 270
NUMBER * NAME ] ::: 270
NEWLINE NAME ( - ::: 270
== NUMBER NEWLINE if ::: 270
None } , STRING ::: 270
NUMBER - NAME [ ::: 270
NAME NEWLINE NAME >> ::: 269
== ( NAME ( ::: 269
STRING % NAME : ::: 269
NEWLINE return { NAME ::: 269
. NAME else NUMBER ::: 269
, NUMBER : ] ::: 269
NAME ] = False ::: 269
== STRING and STRING ::: 269
, False NEWLINE DEDENT ::: 269
True NEWLINE DEDENT for ::: 269
* ( NUMBER * ::: 269
+= STRING NEWLINE if ::: 268
else STRING , STRING ::: 268
= - NUMBER * ::: 268
NEWLINE while NAME and ::: 268
) * NUMBER + ::: 268
NEWLINE global NAME , ::: 268
% NAME ) : ::: 268
STRING , NAME * ::: 268
INDENT NAME [ ( ::: 268
NAME . NAME *= ::: 268
== ( NAME . ::: 268
, NUMBER NAME ) ::: 268
return NAME % NAME ::: 268
NUMBER ] + [ ::: 268
NAME ) is False ::: 267
{ ( STRING , ::: 267
= None if NAME ::: 267
NAME = True if ::: 267
or NAME >= NAME ::: 267
) NEWLINE NAME |= ::: 267
) and NAME is ::: 266
( True , ) ::: 266
** { NAME : ::: 266
if NAME < ( ::: 266
( ) in [ ::: 266
DEDENT DEDENT return NEWLINE ::: 266
not ( NAME and ::: 266
; NEWLINE DEDENT DEDENT ::: 266
. NAME ) in ::: 266
[ None ] ) ::: 266
== STRING ) ) ::: 266
NAME [ NUMBER * ::: 265
NUMBER ] or NAME ::: 265
, False ) ] ::: 265
NUMBER ] == ( ::: 265
NAME ] , ( ::: 265
] == NAME ] ::: 265
= True if NAME ::: 265
is NAME or NAME ::: 265
: ( None , ::: 265
NEWLINE return ( ( ::: 265
) >= NAME : ::: 264
NAME ) ** NAME ::: 264
None , ( NAME ::: 264
assert NAME > NUMBER ::: 264
{ NAME : ( ::: 264
NAME ] < NAME ::: 264
, STRING : NEWLINE ::: 264
None for NAME in ::: 264
or NAME is not ::: 264
( ) : return ::: 264
( ( ( STRING ::: 264
STRING ) else NAME ::: 264
NAME , STRING * ::: 263
STRING or STRING NEWLINE ::: 263
NAME [ ~ NAME ::: 263
NUMBER NEWLINE break NEWLINE ::: 263
NAME - NAME / ::: 263
, NAME = not ::: 263
) % NUMBER NEWLINE ::: 263
: NAME - NAME ::: 263
( ) < NUMBER ::: 263
] += STRING NEWLINE ::: 262
: raise NAME NEWLINE ::: 262
( [ [ STRING ::: 262
== NUMBER else NAME ::: 262
) not in ( ::: 262
STRING ] , False ::: 262
DEDENT from . NAME ::: 262
, NAME ) / ::: 261
+ ( NUMBER - ::: 261
NAME : NUMBER * ::: 261
. NAME , : ::: 261
yield STRING NEWLINE DEDENT ::: 261
[ ( None , ::: 261
- NUMBER or NAME ::: 261
NAME ) ] : ::: 261
[ ] , } ::: 261
STRING ) != STRING ::: 261
!= None and NAME ::: 261
NEWLINE return - NUMBER ::: 261
STRING } , ) ::: 261
) , NAME in ::: 261
!= NAME or NAME ::: 261
) // NUMBER NEWLINE ::: 261
NAME } } , ::: 261
is None , STRING ::: 261
= NAME ) ( ::: 261
return { NAME . ::: 260
) ] [ NUMBER ::: 260
NAME ) ) ( ::: 260
, NUMBER ] - ::: 260
) ^ NAME ( ::: 260
, NUMBER ) - ::: 260
None ) , ] ::: 260
NUMBER ** NUMBER - ::: 260
INDENT assert False NEWLINE ::: 260
) ] ) == ::: 260
NAME ) ) } ::: 260
/ NAME [ NUMBER ::: 260
STRING NEWLINE del NAME ::: 260
STRING + STRING % ::: 260
else STRING ) ) ::: 259
False NEWLINE NAME ( ::: 259
) <= NAME . ::: 259
DEDENT DEDENT return NUMBER ::: 259
( NAME or { ::: 259
= NUMBER NEWLINE with ::: 259
+ [ NAME , ::: 259
NAME > NUMBER , ::: 259
( ( ) ) ::: 259
STRING ) ) + ::: 259
NUMBER ] is NAME ::: 258
True , } NEWLINE ::: 258
] > NAME [ ::: 258
] NEWLINE DEDENT raise ::: 258
NAME ) & ~ ::: 258
* NAME ) for ::: 258
NUMBER NEWLINE NAME -= ::: 258
) if STRING in ::: 258
lambda * NAME , ::: 258
NEWLINE INDENT assert NUMBER ::: 258
NAME , NEWLINE NAME ::: 258
INDENT try : NAME ::: 258
} NEWLINE DEDENT for ::: 258
NEWLINE return NAME % ::: 257
NUMBER : ] + ::: 257
[ STRING , None ::: 257
) ) [ STRING ::: 257
NAME ( STRING if ::: 257
assert NAME NEWLINE NAME ::: 257
None , NAME [ ::: 257
as NAME NEWLINE try ::: 257
NAME : lambda NAME ::: 257
NAME [ ... , ::: 257
or STRING , ) ::: 257
[ NUMBER + NUMBER ::: 256
NUMBER , NUMBER - ::: 256
NEWLINE assert NAME > ::: 256
NAME if NAME ] ::: 256
NUMBER ] = - ::: 256
{ STRING % NAME ::: 256
= True NEWLINE @ ::: 256
STRING * NAME . ::: 256
True NEWLINE @ NAME ::: 256
) + [ STRING ::: 256
in [ NAME for ::: 256
% ( ( NAME ::: 255
NUMBER - NAME , ::: 255
* NAME / ( ::: 255
NAME *= NAME . ::: 255
, ) ) . ::: 255
None ) for NAME ::: 255
[ STRING ] >= ::: 255
; NAME = NUMBER ::: 255
NUMBER NEWLINE assert ( ::: 255
DEDENT NAME NAME NEWLINE ::: 255
STRING NEWLINE assert STRING ::: 255
] == STRING ] ::: 255
NUMBER : ( NAME ::: 255
else NUMBER ) NEWLINE ::: 254
( ) is NAME ::: 254
/ NAME NEWLINE if ::: 254
[ STRING , ( ::: 254
= NAME == NAME ::: 254
% ( NAME - ::: 254
NEWLINE DEDENT DEDENT del ::: 254
STRING ] NEWLINE from ::: 254
= NAME in NAME ::: 254
DEDENT NAME -= NUMBER ::: 254
= NUMBER / NUMBER ::: 254
NEWLINE if NAME + ::: 254
NUMBER , : NUMBER ::: 254
* NUMBER ** NUMBER ::: 254
NUMBER } ] NEWLINE ::: 254
. NAME ) & ::: 254
] < NAME [ ::: 253
] ( STRING , ::: 253
NAME < NUMBER NEWLINE ::: 253
STRING * NAME + ::: 253
STRING NEWLINE yield NAME ::: 253
+ [ NUMBER ] ::: 253
NAME / NUMBER - ::: 253
NAME ** NAME ) ::: 253
NEWLINE else : return ::: 253
STRING and NAME : ::: 253
None , STRING ] ::: 253
] NEWLINE NAME NAME ::: 253
] ) , } ::: 252
not NAME ( [ ::: 252
) << NUMBER ) ::: 252
- NAME : NEWLINE ::: 252
] ) ** NUMBER ::: 252
NUMBER , False , ::: 252
NAME : NAME * ::: 252
NAME . NAME ; ::: 252
*= NUMBER NEWLINE NAME ::: 251
and NAME ) : ::: 251
STRING ) > NUMBER ::: 251
NAME < NUMBER and ::: 251
None , : ] ::: 251
NUMBER ) ] : ::: 251
INDENT NAME *= NAME ::: 251
return lambda NAME : ::: 251
INDENT NAME NEWLINE NAME ::: 251
) NEWLINE assert False ::: 251
return ( NAME ) ::: 251
, NAME + [ ::: 251
INDENT return NUMBER , ::: 251
] ) } ) ::: 251
None ) ] ) ::: 251
None ) or ( ::: 251
// NAME . NAME ::: 250
> NUMBER , STRING ::: 250
) : return ( ::: 250
None ) ) ) ::: 250
DEDENT assert STRING in ::: 250
( NUMBER / ( ::: 250
else { } NEWLINE ::: 250
[ ] } , ::: 250
( [ NAME + ::: 250
DEDENT while NAME . ::: 250
or ( NAME is ::: 250
( NAME [ ( ::: 250
NUMBER ; NEWLINE NAME ::: 250
> NAME ) : ::: 250
NAME ) // NUMBER ::: 250
) , NUMBER NAME ::: 249
NAME > NAME NEWLINE ::: 249
) - NAME , ::: 249
STRING ) , ** ::: 249
= NAME & NAME ::: 249
) ] ] NEWLINE ::: 249
) NEWLINE DEDENT break ::: 249
} : NEWLINE INDENT ::: 249
] . NAME + ::: 249
) ) for ( ::: 249
True , None , ::: 249
, NUMBER / NAME ::: 249
, } } ) ::: 249
NUMBER , * NAME ::: 249
= True NEWLINE while ::: 248
True ) ) ) ::: 248
NUMBER ) , None ::: 248
NEWLINE assert NAME >= ::: 248
- NAME NEWLINE return ::: 248
** NUMBER + ( ::: 248
return NAME and NAME ::: 248
NUMBER ] ( NAME ::: 248
= NUMBER ) == ::: 248
NUMBER ; NAME = ::: 248
NUMBER , ) ] ::: 248
% NAME == NUMBER ::: 248
. NAME ) else ::: 248
, ( STRING ) ::: 248
return STRING % STRING ::: 248
DEDENT DEDENT return { ::: 248
else NAME NEWLINE if ::: 248
] * NUMBER + ::: 247
) ) NEWLINE ( ::: 247
( ) if not ::: 247
None ) NEWLINE for ::: 247
NAME ; NEWLINE DEDENT ::: 247
NEWLINE DEDENT NAME >> ::: 247
return ( None , ::: 247
NAME , } } ::: 247
elif NAME not in ::: 247
] . NAME != ::: 247
** NUMBER ) * ::: 247
) NEWLINE return - ::: 247
NAME ] ) * ::: 246
False ] , [ ::: 246
] = - NAME ::: 246
) ] ) : ::: 246
( STRING * ( ::: 246
STRING ) or ( ::: 246
DEDENT elif NAME not ::: 246
NUMBER NEWLINE assert STRING ::: 246
= STRING STRING % ::: 246
NUMBER and NAME > ::: 245
NUMBER ) << NUMBER ::: 245
= STRING ) == ::: 245
[ [ ] ] ::: 245
] } ] NEWLINE ::: 245
STRING ) | NAME ::: 245
|= NAME NEWLINE DEDENT ::: 245
in NAME else NAME ::: 245
= [ False ] ::: 245
** NAME ) for ::: 245
NAME ) , * ::: 245
if not NAME is ::: 245
return NEWLINE DEDENT return ::: 245
) : ( STRING ::: 245
NAME STRING NEWLINE if ::: 244
} ) NEWLINE @ ::: 244
False , NAME ( ::: 244
!= NAME NEWLINE DEDENT ::: 244
[ ] NEWLINE class ::: 244
NAME and ( not ::: 244
NAME == NUMBER ] ::: 244
= NUMBER NEWLINE EOS ::: 244
== NAME ( ) ::: 244
* [ NAME ( ::: 244
NEWLINE DEDENT DEDENT while ::: 244
, ) ] ) ::: 244
False , ) , ::: 244
, NEWLINE NAME . ::: 244
[ STRING ] <= ::: 244
, ) ) : ::: 244
NAME NEWLINE elif NAME ::: 244
NUMBER NAME , STRING ::: 244
] ; NEWLINE NAME ::: 244
] ] ] NEWLINE ::: 243
, ) for NAME ::: 243
STRING ) and STRING ::: 243
NAME << NAME . ::: 243
NAME ] == [ ::: 243
+ STRING for NAME ::: 243
NAME > - NUMBER ::: 243
) / NAME [ ::: 243
) or NAME [ ::: 243
STRING NEWLINE NAME NEWLINE ::: 243
INDENT if ( ( ::: 243
NEWLINE DEDENT NAME NEWLINE ::: 242
( ) , ** ::: 242
NAME & NAME NEWLINE ::: 242
NEWLINE DEDENT assert ( ::: 242
NEWLINE NAME NAME , ::: 242
* NUMBER ) . ::: 242
in NAME ( - ::: 242
NEWLINE STRING NEWLINE DEDENT ::: 242
NUMBER ] ) > ::: 242
NUMBER ] ** NUMBER ::: 242
NAME ) is True ::: 242
STRING ) : [ ::: 241
, NUMBER - NUMBER ::: 241
+ NAME or STRING ::: 241
) + STRING . ::: 241
= ( NAME or ::: 241
NEWLINE INDENT while not ::: 241
= NAME NEWLINE continue ::: 241
) == NAME and ::: 241
NUMBER NEWLINE DEDENT assert ::: 241
NUMBER ] * ( ::: 241
] NEWLINE assert STRING ::: 241
== STRING ) and ::: 241
True , True ] ::: 241
NEWLINE [ NAME . ::: 241
( [ [ - ::: 241
return NAME [ - ::: 241
: NAME STRING NEWLINE ::: 240
; NEWLINE if NAME ::: 240
) ) ** NUMBER ::: 240
STRING + NAME or ::: 240
. NAME ] * ::: 240
= NUMBER / ( ::: 240
STRING ) ) for ::: 240
True ] ) NEWLINE ::: 240
, { } ] ::: 240
: None } } ::: 240
NAME ( ~ NAME ::: 240
NAME and NAME <= ::: 240
, STRING STRING . ::: 240
NAME NEWLINE DEDENT while ::: 240
>= NUMBER NEWLINE NAME ::: 240
or None NEWLINE NAME ::: 240
DEDENT else : NAME ::: 239
+= STRING NEWLINE for ::: 239
NEWLINE assert NAME not ::: 239
NAME ] and NAME ::: 239
- NAME ) < ::: 239
= NAME , * ::: 239
!= NUMBER ) : ::: 239
= NAME ( True ::: 239
NUMBER and ( NAME ::: 239
if NAME + NUMBER ::: 239
NAME ) ] for ::: 239
NAME is NAME or ::: 239
NUMBER - NUMBER NEWLINE ::: 239
. NAME NEWLINE yield ::: 238
NEWLINE DEDENT DEDENT import ::: 238
, ) } NEWLINE ::: 238
None ) == STRING ::: 238
NAME != NAME or ::: 238
None NEWLINE with NAME ::: 238
] ] ] ) ::: 238
elif ( NAME ( ::: 238
( STRING ) < ::: 238
not ( NAME or ::: 238
: STRING % NUMBER ::: 238
( ) NEWLINE STRING ::: 238
STRING ] : NAME ::: 238
/ NUMBER * NAME ::: 237
* NAME ) ] ::: 237
) , NAME - ::: 237
) / NAME , ::: 237
INDENT NAME NAME + ::: 237
= [ NUMBER for ::: 237
STRING ] != NUMBER ::: 237
} , ] } ::: 237
} , ] ) ::: 237
NAME , NUMBER + ::: 237
NAME else NUMBER ) ::: 237
* NAME + ( ::: 237
NAME ) ) as ::: 237
STRING + ( STRING ::: 237
NUMBER ) or NAME ::: 237
DEDENT yield NAME , ::: 237
, STRING , * ::: 236
INDENT while not NAME ::: 236
** NUMBER ) / ::: 236
( ( NAME == ::: 236
continue NEWLINE NAME = ::: 236
** NUMBER ) , ::: 236
+ ( ( NAME ::: 236
NAME , ** { ::: 236
is None and not ::: 236
NAME // NUMBER , ::: 236
|= NAME ( NAME ::: 236
INDENT return False , ::: 236
NUMBER ) ; NEWLINE ::: 235
not in ( None ::: 235
STRING ) ] : ::: 235
) >= NUMBER and ::: 235
) ] , ) ::: 235
) ; NAME . ::: 235
True , NAME ( ::: 235
( ) == ( ::: 235
INDENT yield STRING NEWLINE ::: 235
- NUMBER ] in ::: 235
] -= NUMBER NEWLINE ::: 235
NEWLINE assert ( not ::: 235
return STRING + STRING ::: 235
assert NAME == ( ::: 235
) : return NUMBER ::: 235
NEWLINE DEDENT DEDENT yield ::: 235
: ] + NAME ::: 235
: NAME STRING , ::: 235
) > - NUMBER ::: 235
NAME : ( NUMBER ::: 235
: NAME ( ( ::: 235
None NEWLINE DEDENT EOS ::: 234
STRING , STRING * ::: 234
: NUMBER ] != ::: 234
!= NUMBER NEWLINE DEDENT ::: 234
None ) ) : ::: 234
] [ : - ::: 234
NEWLINE INDENT NAME << ::: 234
( ( ( NUMBER ::: 234
) . NAME ] ::: 234
STRING ] and not ::: 234
STRING : ( ( ::: 233
= [ [ ] ::: 233
, NAME : { ::: 233
NAME NEWLINE NAME NEWLINE ::: 233
, ( [ NUMBER ::: 233
* NUMBER ) : ::: 233
, : ] . ::: 233
and ( NAME == ::: 233
/ ( NAME ( ::: 233
DEDENT NAME = yield ::: 233
; NEWLINE DEDENT NAME ::: 233
* [ NAME . ::: 233
, NEWLINE DEDENT def ::: 232
) else None NEWLINE ::: 232
{ NAME : [ ::: 232
- NAME ) : ::: 232
assert NAME in ( ::: 232
, STRING , - ::: 232
= NAME // NUMBER ::: 232
: ] for NAME ::: 232
NAME in NAME + ::: 232
NUMBER , [ STRING ::: 232
None ) NEWLINE try ::: 232
NUMBER == NAME ( ::: 232
. NAME ) <= ::: 231
NAME & NUMBER : ::: 231
: ( - NUMBER ::: 231
NAME = NAME > ::: 231
: , : NAME ::: 231
STRING ) [ NAME ::: 231
) / NUMBER + ::: 231
STRING , NUMBER NEWLINE ::: 231
NUMBER or NAME >= ::: 231
STRING , NUMBER * ::: 231
{ } NEWLINE @ ::: 231
( NUMBER if NAME ::: 231
] == NUMBER and ::: 231
None and NAME == ::: 231
NAME ( ) & ::: 231
[ None , : ::: 231
NAME or NAME > ::: 230
STRING % NAME + ::: 230
DEDENT DEDENT yield NAME ::: 230
NAME and NAME >= ::: 230
) or None NEWLINE ::: 230
INDENT return NUMBER * ::: 230
INDENT assert STRING in ::: 230
else None , NAME ::: 230
raise NEWLINE DEDENT if ::: 229
} NEWLINE for ( ::: 229
{ STRING : lambda ::: 229
= [ STRING + ::: 229
not NAME ) or ::: 229
) > NUMBER , ::: 229
+ NUMBER NEWLINE return ::: 229
: NUMBER ] : ::: 229
) NEWLINE except NAME ::: 229
STRING % NUMBER , ::: 228
+ NAME + [ ::: 228
] ) and NAME ::: 228
: NAME - NUMBER ::: 228
- NUMBER ) == ::: 228
NUMBER ] >= NAME ::: 228
NAME or ( ) ::: 228
) ( NUMBER ) ::: 228
// NUMBER , NAME ::: 228
@ NAME ( { ::: 227
] } ) ) ::: 227
== [ NAME , ::: 227
or STRING NEWLINE if ::: 227
or NAME is NAME ::: 227
NUMBER - ( NAME ::: 227
NEWLINE INDENT NAME &= ::: 227
else NAME for NAME ::: 227
) NEWLINE assert [ ::: 227
NAME ) ) > ::: 227
False , } NEWLINE ::: 227
== NAME - NUMBER ::: 227
* NUMBER NEWLINE if ::: 227
] ) != NAME ::: 227
NUMBER ** NAME ) ::: 227
NAME <= NAME ( ::: 226
/ NUMBER NEWLINE if ::: 226
NAME ] NEWLINE break ::: 226
: , NAME : ::: 226
INDENT if NAME % ::: 226
STRING ] , ] ::: 226
NAME ] , } ::: 226
NUMBER } ] } ::: 226
in NAME ) or ::: 226
% NUMBER , STRING ::: 226
None ) , ) ::: 226
INDENT if not STRING ::: 226
NAME : STRING . ::: 226
in NAME ] : ::: 226
, NUMBER ) / ::: 225
] ) [ STRING ::: 225
as NAME NEWLINE if ::: 225
- NUMBER ] - ::: 225
NEWLINE [ NAME , ::: 225
( ) / NAME ::: 225
] >= NUMBER : ::: 225
or NAME , NAME ::: 225
< NAME [ NUMBER ::: 225
+= ( NAME . ::: 225
== STRING : return ::: 224
yield NAME [ NAME ::: 224
) ) , None ::: 224
in [ NAME [ ::: 224
raise NAME , ( ::: 224
) != NUMBER NEWLINE ::: 224
NAME or NAME != ::: 224
INDENT NAME = not ::: 224
, ] NEWLINE class ::: 223
* NAME NEWLINE for ::: 223
] or STRING NEWLINE ::: 223
NAME ( ( None ::: 223
DEDENT assert ( NAME ::: 223
) ; NAME ( ::: 223
NUMBER : return NAME ::: 223
is STRING : NEWLINE ::: 223
except : NAME = ::: 222
INDENT ( NAME . ::: 222
elif NAME != NAME ::: 222
is NAME NEWLINE NAME ::: 222
] ) is NAME ::: 222
) ) ; NEWLINE ::: 222
] , ] ) ::: 222
NAME [ STRING . ::: 222
None NEWLINE class NAME ::: 222
) , [ { ::: 222
] - NUMBER NEWLINE ::: 221
NAME , NUMBER / ::: 221
NAME /= NAME NEWLINE ::: 221
* NAME : ( ::: 221
STRING NEWLINE yield STRING ::: 221
else NUMBER NEWLINE DEDENT ::: 221
] ) NEWLINE raise ::: 221
NUMBER ] << NUMBER ::: 221
True } NEWLINE DEDENT ::: 221
) == [ ( ::: 221
} } ) ) ::: 221
in [ NUMBER ] ::: 221
: NAME = [ ::: 221
INDENT if NAME & ::: 221
NUMBER : ] = ::: 221
) or [ ] ::: 221
* NUMBER : NEWLINE ::: 221
None NEWLINE while NAME ::: 220
+ [ NAME [ ::: 220
return [ { STRING ::: 220
% NAME ) for ::: 220
if NAME == ( ::: 220
in NAME + NAME ::: 220
, - NAME [ ::: 220
+ NUMBER ] . ::: 220
( NUMBER ) } ::: 220
NAME or STRING not ::: 220
STRING ] ] . ::: 220
in NAME else STRING ::: 220
NUMBER ] != NUMBER ::: 220
NAME NEWLINE DEDENT yield ::: 219
<= NAME ) NEWLINE ::: 219
, None ) for ::: 219
import ( NAME as ::: 219
] ) ) + ::: 219
, STRING ) if ::: 219
> NUMBER : NAME ::: 219
} ) ) , ::: 219
except NAME : pass ::: 219
not NAME == STRING ::: 219
and NAME >= NUMBER ::: 219
( NAME as NAME ::: 219
try : NAME . ::: 219
NAME ] = - ::: 219
] } } } ::: 219
NEWLINE except : pass ::: 218
in [ ( STRING ::: 218
NEWLINE if ( STRING ::: 218
, [ True , ::: 218
[ : NAME + ::: 218
) , NEWLINE NAME ::: 218
) ) and ( ::: 218
: NAME * NAME ::: 218
STRING ] in ( ::: 218
] - NAME NEWLINE ::: 218
NUMBER ] NEWLINE with ::: 218
NUMBER ) == ( ::: 218
NEWLINE NAME NAME [ ::: 218
NAME ) ] } ::: 218
else NAME ( ) ::: 218
yield STRING NEWLINE yield ::: 217
def NAME ( ( ::: 217
return STRING , NAME ::: 217
( NAME != NUMBER ::: 217
NAME = ( lambda ::: 217
) ) in NAME ::: 217
NAME != None ) ::: 217
> NUMBER , NAME ::: 217
NAME [ [ NUMBER ::: 217
( NAME ) | ::: 217
return ( NAME + ::: 217
- NUMBER * ( ::: 217
INDENT return ( False ::: 217
: ( NAME [ ::: 217
or STRING , STRING ::: 217
STRING ] NEWLINE @ ::: 216
NAME , ) ] ::: 216
STRING NEWLINE return not ::: 216
NAME if STRING in ::: 216
, STRING } NEWLINE ::: 216
NEWLINE while NAME [ ::: 216
< NUMBER NEWLINE DEDENT ::: 216
. NAME ] ( ::: 216
, NAME or STRING ::: 216
] } ] , ::: 216
STRING , } ] ::: 215
* NAME ) - ::: 215
NAME [ None ] ::: 215
False NEWLINE break NEWLINE ::: 215
) ) ] = ::: 215
) <= NAME : ::: 215
NAME } ] ) ::: 215
NUMBER ) ) - ::: 215
] + NAME * ::: 215
: NAME , ( ::: 215
= False NEWLINE break ::: 215
[ NUMBER ] ** ::: 215
NUMBER else STRING NEWLINE ::: 215
NAME : None NEWLINE ::: 215
) , NEWLINE DEDENT ::: 215
] , STRING NEWLINE ::: 215
] = NAME , ::: 215
NAME is NAME and ::: 214
, - NUMBER : ::: 214
& NUMBER ) << ::: 214
] < NAME . ::: 214
is None : return ::: 214
) >= NUMBER ) ::: 214
NAME [ ( NUMBER ::: 214
| NAME ( STRING ::: 214
NAME == NAME - ::: 214
in [ NAME ( ::: 214
NUMBER ) <= NAME ::: 214
= { STRING , ::: 214
NAME . NAME >> ::: 214
) : NAME [ ::: 214
** ( NAME - ::: 214
) [ : ] ::: 213
INDENT return ( ) ::: 213
, ] : NEWLINE ::: 213
or STRING ) ) ::: 213
not in NAME , ::: 213
] = ( NUMBER ::: 213
assert NAME NEWLINE assert ::: 213
if STRING == NAME ::: 213
- ( NAME * ::: 213
* NAME ( - ::: 213
return NAME , STRING ::: 213
+ STRING * NAME ::: 213
STRING : ( - ::: 213
( NAME ** NAME ::: 213
if NAME : return ::: 213
NUMBER < NAME . ::: 213
NEWLINE INDENT if NUMBER ::: 213
( ) ) } ::: 213
True NEWLINE if not ::: 213
NUMBER else NUMBER NEWLINE ::: 213
NAME , : NAME ::: 213
) + ( STRING ::: 212
NUMBER : NUMBER : ::: 212
) + NUMBER ] ::: 212
, ) ] , ::: 212
NAME ) , NEWLINE ::: 212
) ) ( NAME ::: 212
= None ) . ::: 212
] ( NAME . ::: 212
NAME ] ( ) ::: 212
} NEWLINE STRING NEWLINE ::: 212
) } NEWLINE def ::: 212
) and NAME in ::: 212
== NAME [ - ::: 212
STRING , None ] ::: 212
NAME >= NUMBER , ::: 212
) in [ NAME ::: 211
: STRING + STRING ::: 211
> NAME [ NUMBER ::: 211
NAME ) ** ( ::: 211
{ NUMBER , NUMBER ::: 211
) ] * NAME ::: 211
STRING + NAME for ::: 211
INDENT from . . ::: 211
+ NUMBER * ( ::: 211
{ } } , ::: 211
STRING else STRING NEWLINE ::: 211
] NEWLINE except : ::: 211
STRING , ] } ::: 211
) or NAME in ::: 211
STRING ) == - ::: 211
return [ ( STRING ::: 211
, ] } NEWLINE ::: 211
] ) [ : ::: 210
STRING ] , ** ::: 210
NAME ; NEWLINE NAME ::: 210
lambda : None ) ::: 210
] = NUMBER * ::: 210
!= STRING or NAME ::: 210
NUMBER ) // NUMBER ::: 210
[ ] , None ::: 210
STRING + ( NAME ::: 210
, ( NUMBER - ::: 210
, NUMBER ] + ::: 210
NEWLINE elif NAME . ::: 210
* NAME ( ) ::: 210
= ( NAME ) ::: 210
] , NAME : ::: 210
: NAME NEWLINE DEDENT ::: 210
False ) , ] ::: 210
in ( STRING ) ::: 210
: raise NAME , ::: 209
INDENT return lambda NAME ::: 209
[ : ] : ::: 209
] NEWLINE DEDENT assert ::: 209
( NAME <= NUMBER ::: 209
( NAME and STRING ::: 209
None , ) NEWLINE ::: 209
NAME ( NAME if ::: 209
NEWLINE DEDENT pass NEWLINE ::: 209
: { NAME . ::: 209
NUMBER <= NAME . ::: 209
STRING ] in [ ::: 209
None NEWLINE DEDENT from ::: 209
, True ] ) ::: 208
STRING STRING % { ::: 208
) + ( NUMBER ::: 208
in NAME ) and ::: 208
* NUMBER - NUMBER ::: 208
NAME ] [ - ::: 208
/ NAME [ STRING ::: 208
+ NUMBER ] ] ::: 208
: False } } ::: 208
<< NUMBER ) ) ::: 208
and NAME in [ ::: 208
NEWLINE NAME NEWLINE DEDENT ::: 208
} , NAME : ::: 208
) * NAME ] ::: 208
NAME | NAME ( ::: 207
. NAME ( ~ ::: 207
( ) NEWLINE continue ::: 207
, None NEWLINE NAME ::: 207
, ) NEWLINE raise ::: 207
NAME ] ) / ::: 207
is None ) or ::: 207
NEWLINE NAME *= NUMBER ::: 207
( ( STRING ) ::: 207
= None NEWLINE class ::: 207
} ] , } ::: 207
) ] * NUMBER ::: 207
] NEWLINE assert ( ::: 207
, NAME : None ::: 207
: break NEWLINE DEDENT ::: 207
[ [ NAME ] ::: 207
DEDENT yield NAME ( ::: 207
NAME == NAME + ::: 206
NAME : [ STRING ::: 206
STRING } NEWLINE return ::: 206
NAME = [ True ::: 206
) : NUMBER } ::: 206
, - NUMBER * ::: 206
/ NUMBER ) - ::: 206
yield STRING % NAME ::: 206
- NUMBER NEWLINE while ::: 205
NAME else NAME ) ::: 205
) - NUMBER * ::: 205
NUMBER NUMBER , NUMBER ::: 205
if NAME & NUMBER ::: 205
elif not NAME and ::: 205
= NAME NEWLINE from ::: 205
NAME } , ) ::: 205
False ) NEWLINE class ::: 205
NAME NEWLINE DEDENT del ::: 205
, ( True , ::: 205
STRING ] / NAME ::: 205
NUMBER , NUMBER } ::: 205
] = NAME - ::: 205
NAME : - NAME ::: 205
[ NAME ] and ::: 205
: ] == NAME ::: 205
NUMBER ] NEWLINE del ::: 205
NAME > NUMBER ] ::: 205
] == NAME and ::: 204
NUMBER ) in NAME ::: 204
NAME + STRING : ::: 204
NAME != [ ] ::: 204
( - NAME * ::: 204
= NAME , NEWLINE ::: 204
not NAME ) and ::: 204
= STRING , * ::: 204
NUMBER ) NEWLINE del ::: 204
not NAME else NAME ::: 204
= NAME == STRING ::: 204
[ NUMBER : , ::: 204
( ) >= NAME ::: 204
= NAME ) == ::: 204
NAME == None ) ::: 204
STRING ) ] } ::: 204
NUMBER , NUMBER NUMBER ::: 204
assert NAME NEWLINE DEDENT ::: 203
, NAME if NAME ::: 203
return NAME NEWLINE NAME ::: 203
: NAME += STRING ::: 203
return not NAME == ::: 203
- NUMBER ] * ::: 203
lambda NAME : True ::: 203
* ( NUMBER / ::: 203
( ( NAME for ::: 203
del NAME [ - ::: 203
DEDENT global NAME NEWLINE ::: 203
NUMBER or NAME < ::: 203
NAME | NAME , ::: 203
. NAME += ( ::: 203
] NEWLINE DEDENT with ::: 203
NAME != NUMBER or ::: 203
) < NUMBER or ::: 203
STRING : ( { ::: 203
/ NAME ** NUMBER ::: 203
) <= NUMBER NEWLINE ::: 203
== NUMBER ) . ::: 203
> NUMBER else NAME ::: 202
pass NEWLINE DEDENT for ::: 202
> NAME [ NAME ::: 202
== [ NAME ( ::: 202
( False , False ::: 202
+= [ ( NAME ::: 202
in [ NAME ] ::: 202
] * NAME + ::: 202
== STRING ) . ::: 202
None , { } ::: 201
STRING ] ) / ::: 201
{ NUMBER : [ ::: 201
) , ( False ::: 201
STRING : NUMBER * ::: 201
NUMBER < NAME ( ::: 201
NUMBER else NAME . ::: 201
NAME , ( None ::: 201
NAME <= NAME NEWLINE ::: 201
] = [ ( ::: 201
DEDENT if ( ( ::: 201
<< NUMBER ) + ::: 201
NAME > NUMBER or ::: 201
= None NEWLINE with ::: 200
STRING ] [ - ::: 200
) ) != NUMBER ::: 200
: STRING STRING STRING ::: 200
= ( NAME and ::: 200
if ( NAME + ::: 200
= NAME % { ::: 200
NUMBER NEWLINE while NUMBER ::: 200
True ] , [ ::: 200
NAME if ( NAME ::: 200
NUMBER ] <= NAME ::: 200
, NAME : [ ::: 200
] ) == ( ::: 200
+= NAME ( NUMBER ::: 200
NAME ) NEWLINE else ::: 200
} , [ STRING ::: 200
] } NEWLINE if ::: 199
elif NAME >= NUMBER ::: 199
if NAME % NAME ::: 199
== NAME and not ::: 199
NAME , NUMBER - ::: 199
True NEWLINE while NAME ::: 199
False ) , ) ::: 199
NAME ( ( [ ::: 199
) ] , NUMBER ::: 199
) % NUMBER ) ::: 199
NAME // NAME NEWLINE ::: 199
, STRING NEWLINE for ::: 199
NAME [ STRING , ::: 198
. NAME ; NAME ::: 198
: [ ( NAME ::: 198
<= NAME and NAME ::: 198
as NAME ) NEWLINE ::: 198
NAME as NAME ) ::: 198
STRING ] + NUMBER ::: 198
STRING } ) : ::: 198
lambda NAME : [ ::: 198
NAME != NUMBER NEWLINE ::: 198
) : ] . ::: 198
NUMBER , STRING STRING ::: 198
= NAME % NUMBER ::: 198
) and NAME not ::: 198
+ NAME ] , ::: 198
DEDENT assert not NAME ::: 198
None } NEWLINE DEDENT ::: 197
] / NUMBER NEWLINE ::: 197
) >= NUMBER NEWLINE ::: 197
: ( { } ::: 197
None else None NEWLINE ::: 197
None NEWLINE NAME , ::: 197
del ( NAME [ ::: 197
else None NEWLINE if ::: 197
) NEWLINE while ( ::: 197
, NAME ( lambda ::: 197
: [ [ STRING ::: 197
// NUMBER ) NEWLINE ::: 197
* NAME ] NEWLINE ::: 197
None ] , NAME ::: 196
yield NAME ( STRING ::: 196
None , [ ] ::: 196
not None ] NEWLINE ::: 196
: [ NAME [ ::: 196
( NUMBER < NAME ::: 196
False , None ) ::: 196
NAME [ NAME % ::: 196
INDENT yield STRING % ::: 196
None , STRING % ::: 196
& NAME NEWLINE NAME ::: 196
: True } ] ::: 196
lambda : NAME ) ::: 196
STRING == NAME : ::: 196
] if NAME is ::: 196
[ ~ NAME ] ::: 196
NAME . NAME << ::: 196
NAME and not ( ::: 196
+ NUMBER , - ::: 196
NAME == True NEWLINE ::: 196
{ } NEWLINE return ::: 195
in NAME ( * ::: 195
} ) [ STRING ::: 195
: [ [ NUMBER ::: 195
not None else STRING ::: 195
[ NAME % NAME ::: 195
NUMBER ) : { ::: 195
NEWLINE return NAME if ::: 195
* NAME ) == ::: 195
: ] ] ) ::: 195
NAME : not NAME ::: 195
, : - NUMBER ::: 195
> NUMBER ] NEWLINE ::: 195
in [ ( NAME ::: 195
NUMBER } } } ::: 195
INDENT return NAME % ::: 195
, NUMBER , : ::: 195
( ) ) as ::: 195
) ] NEWLINE EOS ::: 195
in ( ( STRING ::: 195
) ] = ( ::: 195
INDENT while NAME ( ::: 195
} } NEWLINE if ::: 195
> NUMBER else STRING ::: 195
NAME is STRING : ::: 195
[ ] for NAME ::: 195
[ None , STRING ::: 194
None and NAME [ ::: 194
== ( STRING STRING ::: 194
STRING and NAME is ::: 194
NAME NAME , STRING ::: 194
NEWLINE while NAME <= ::: 194
- NUMBER / NAME ::: 194
NAME STRING : NAME ::: 194
[ True , True ::: 194
] - NUMBER , ::: 194
] = [ { ::: 194
NEWLINE return ( NUMBER ::: 194
STRING : NAME or ::: 194
and NAME != NUMBER ::: 194
) - NAME [ ::: 194
, STRING NEWLINE def ::: 193
+= NUMBER NEWLINE for ::: 193
INDENT pass NEWLINE NAME ::: 193
False NEWLINE DEDENT EOS ::: 193
or NAME NEWLINE if ::: 193
( NUMBER << NAME ::: 193
[ NUMBER ] << ::: 193
, NAME STRING : ::: 193
] . NAME - ::: 193
% STRING NEWLINE NAME ::: 193
NUMBER ] , } ::: 192
NUMBER else NAME NEWLINE ::: 192
NAME else NAME [ ::: 192
, [ None ] ::: 192
) is True : ::: 192
= NAME // NAME ::: 192
NUMBER , [ ] ::: 192
if NAME == False ::: 192
, True NEWLINE DEDENT ::: 192
NAME ) & NUMBER ::: 192
*= NAME NEWLINE DEDENT ::: 192
== [ ( STRING ::: 192
[ False , False ::: 192
NAME * NAME ] ::: 192
NAME - NUMBER - ::: 192
NAME /= NUMBER NEWLINE ::: 192
NEWLINE INDENT NAME /= ::: 192
: [ ( NUMBER ::: 192
NUMBER ) == [ ::: 192
NAME == None or ::: 192
NAME = STRING ; ::: 192
) NEWLINE del ( ::: 192
+ NAME ) % ::: 192
NAME NEWLINE NAME *= ::: 192
, NUMBER ) and ::: 192
STRING if NAME ( ::: 191
= True ) ( ::: 191
in NAME ] == ::: 191
DEDENT while NAME : ::: 191
= NUMBER + NUMBER ::: 191
NAME : NAME in ::: 191
= ( NUMBER - ::: 191
) >= NAME ( ::: 191
. NAME ) | ::: 191
NEWLINE NAME ( not ::: 191
NAME , not NAME ::: 191
< NAME [ NAME ::: 191
+ NUMBER ) for ::: 191
INDENT return STRING in ::: 190
: continue NEWLINE if ::: 190
NAME in ( None ::: 190
. NAME , NEWLINE ::: 190
False ) ] NEWLINE ::: 190
None , ( STRING ::: 190
STRING NEWLINE elif NAME ::: 190
< STRING : NEWLINE ::: 190
NEWLINE del NAME , ::: 190
elif NAME [ : ::: 190
None and ( NAME ::: 190
- NUMBER ] for ::: 190
( ( NAME & ::: 190
STRING in NAME ] ::: 190
) ) * ( ::: 190
NUMBER ] in STRING ::: 190
NAME ] > NAME ::: 189
% NAME ] ) ::: 189
. NAME NEWLINE break ::: 189
>= NAME and NAME ::: 189
{ } NEWLINE with ::: 189
DEDENT NAME = - ::: 189
yield ( NAME . ::: 189
STRING ) ) or ::: 189
NAME or NAME < ::: 189
= NAME ) | ::: 189
= NAME is not ::: 189
NAME // NAME . ::: 189
+ ( NAME + ::: 189
STRING ] or STRING ::: 189
= ( { STRING ::: 189
DEDENT raise NAME , ::: 189
. NAME [ [ ::: 189
, STRING * NAME ::: 189
] , - NAME ::: 189
( ) ) if ::: 188
STRING ] + [ ::: 188
del NAME NEWLINE del ::: 188
] [ NAME : ::: 188
, [ None , ::: 188
DEDENT NAME [ : ::: 188
STRING : NAME STRING ::: 188
] = { NAME ::: 188
False ) NEWLINE @ ::: 188
- NAME ) > ::: 188
NAME * NAME for ::: 188
[ ( - NUMBER ::: 188
NAME / NUMBER * ::: 188
NAME != NAME ] ::: 188
NUMBER , lambda NAME ::: 188
NUMBER , STRING . ::: 188
. NAME // NAME ::: 187
+ STRING , NUMBER ::: 187
, ] } , ::: 187
or None , NAME ::: 187
INDENT NAME << NAME ::: 187
) * NAME ** ::: 187
, NAME , : ::: 187
NAME == { } ::: 187
else STRING NEWLINE if ::: 187
NAME ) == { ::: 187
[ NAME == NUMBER ::: 187
not in ( NUMBER ::: 187
or ( NAME [ ::: 187
) <= NAME ( ::: 187
elif NAME and not ::: 187
True NEWLINE DEDENT try ::: 187
] << NUMBER ) ::: 187
True } , NAME ::: 186
] } NEWLINE def ::: 186
) : ( NAME ::: 186
return NUMBER , NAME ::: 186
[ [ ( NUMBER ::: 186
, None ) } ::: 186
NAME + NAME for ::: 186
STRING , ) ] ::: 186
== NUMBER NEWLINE return ::: 186
*= NUMBER NEWLINE DEDENT ::: 186
DEDENT return STRING + ::: 186
NAME % NAME == ::: 186
] / NAME . ::: 186
STRING : ( None ::: 186
) != NUMBER or ::: 186
] < NAME : ::: 186
] ) == [ ::: 186
+ NUMBER ] == ::: 186
NAME ( ) <= ::: 186
NEWLINE DEDENT global NAME ::: 186
) if ( NAME ::: 186
NAME } ) . ::: 186
NEWLINE assert False NEWLINE ::: 186
not NAME , STRING ::: 186
] > NUMBER ) ::: 186
} ) ) ) ::: 185
[ STRING ] % ::: 185
NUMBER and NAME != ::: 185
NUMBER and NAME : ::: 185
= ( NAME for ::: 185
NAME } , } ::: 185
( True ) ) ::: 185
> NAME and NAME ::: 185
import NAME ; NAME ::: 185
NAME NAME ( ) ::: 185
, NAME NEWLINE for ::: 185
else STRING NEWLINE return ::: 185
STRING : ( ) ::: 185
== None or NAME ::: 185
and NAME <= NUMBER ::: 185
NAME <= NAME [ ::: 185
, } } } ::: 185
NAME < - NUMBER ::: 185
in NAME ] + ::: 185
NUMBER * NUMBER ** ::: 185
False , STRING % ::: 185
) : return STRING ::: 184
( False , True ::: 184
( False ) ) ::: 184
- NUMBER : - ::: 184
, STRING ) ( ::: 184
or not NAME [ ::: 184
NUMBER ] NEWLINE while ::: 184
DEDENT NAME , = ::: 184
NAME ) ; NAME ::: 184
NAME == NAME else ::: 184
) == STRING or ::: 184
NEWLINE raise NAME , ::: 184
+= STRING + STRING ::: 184
return NEWLINE DEDENT @ ::: 184
+ NAME ( ( ::: 184
not None and ( ::: 184
STRING } NEWLINE class ::: 184
NUMBER , [ NAME ::: 184
= NAME or NUMBER ::: 184
NEWLINE return NAME / ::: 184
* NUMBER / NUMBER ::: 184
( ( not NAME ::: 184
return not NAME ( ::: 183
<= NAME , NAME ::: 183
None ) and NAME ::: 183
NUMBER , : , ::: 183
] ) NEWLINE yield ::: 183
NAME ] , ** ::: 183
, * NAME ( ::: 183
, NAME ] * ::: 183
{ } NEWLINE class ::: 183
, NAME ] } ::: 183
% NAME NEWLINE for ::: 183
- NAME / NAME ::: 183
= STRING ) ( ::: 183
NAME ] * ( ::: 183
== NUMBER * NAME ::: 183
assert NUMBER <= NAME ::: 183
NUMBER ) | NAME ::: 183
False , NAME NEWLINE ::: 183
( ) ; NAME ::: 183
NAME or None , ::: 182
if NAME or not ::: 182
. NAME % { ::: 182
) < NAME NEWLINE ::: 182
[ [ NAME [ ::: 182
STRING if NAME is ::: 182
NUMBER * NAME : ::: 182
) > NUMBER or ::: 182
NUMBER ] or STRING ::: 182
yield ( STRING , ::: 182
: , : NUMBER ::: 182
NAME ] } , ::: 182
) ) , True ::: 182
NUMBER / NUMBER + ::: 182
NEWLINE DEDENT assert not ::: 182
NAME ( NAME // ::: 182
NUMBER : raise NAME ::: 181
[ NUMBER + NAME ::: 181
STRING if NAME [ ::: 181
( ) + [ ::: 181
STRING ) ) } ::: 181
else : return NAME ::: 181
NAME ] ) > ::: 181
* NUMBER NEWLINE for ::: 181
= NAME NEWLINE del ::: 180
) , { NAME ::: 180
, ) * NUMBER ::: 180
) ] ] , ::: 180
in NAME if STRING ::: 180
+ NAME > NAME ::: 180
] != STRING and ::: 180
NAME ) ^ NAME ::: 180
== NAME for NAME ::: 180
DEDENT return None , ::: 180
: NAME } for ::: 180
[ ( STRING % ::: 180
) and not ( ::: 180
] * NAME , ::: 180
NAME ) NEWLINE pass ::: 180
NUMBER ) , { ::: 180
else NAME [ STRING ::: 180
NEWLINE NAME NAME + ::: 180
) ) [ NAME ::: 180
NAME ] - NUMBER ::: 180
, NAME ) < ::: 179
: NUMBER , ( ::: 179
while NAME <= NAME ::: 179
/ NAME ) , ::: 179
) , False , ::: 179
) != NUMBER ) ::: 179
NAME , NAME ** ::: 179
[ - NAME . ::: 179
NAME == False ) ::: 179
] [ NAME + ::: 179
STRING STRING , NUMBER ::: 179
NAME is not False ::: 179
STRING } NEWLINE assert ::: 179
DEDENT DEDENT while NAME ::: 179
NUMBER or ( NAME ::: 179
= ( lambda NAME ::: 179
= NAME ) } ::: 179
NEWLINE return STRING , ::: 179
] in STRING : ::: 179
False , NUMBER ) ::: 179
( STRING STRING + ::: 179
) * NAME / ::: 179
else False NEWLINE DEDENT ::: 179
STRING ] / NUMBER ::: 179
STRING ) else STRING ::: 179
// NAME NEWLINE NAME ::: 179
STRING ] < NAME ::: 179
STRING and STRING in ::: 178
) ; NEWLINE if ::: 178
[ NAME ] -= ::: 178
= STRING * ( ::: 178
< NUMBER NEWLINE assert ::: 178
) == NUMBER * ::: 178
NEWLINE STRING NEWLINE STRING ::: 178
( ( NAME / ::: 178
else None , STRING ::: 178
return NEWLINE DEDENT raise ::: 178
} ] } ] ::: 178
} ) for NAME ::: 178
NAME } ] , ::: 178
) ) + ( ::: 178
NAME in NAME else ::: 178
: - NAME ] ::: 178
] if NAME in ::: 178
] ) ) [ ::: 178
} ) NEWLINE class ::: 177
+ NAME ] [ ::: 177
= NAME NEWLINE raise ::: 177
% NAME + STRING ::: 177
or STRING ) , ::: 177
| ( NAME . ::: 177
: , NAME , ::: 177
, NAME // NUMBER ::: 177
+ NAME NEWLINE for ::: 177
in ( NAME ( ::: 177
- NAME ] ) ::: 177
DEDENT STRING NEWLINE NAME ::: 177
] } ] ) ::: 177
+= ( STRING % ::: 177
[ NAME == NAME ::: 177
, NUMBER NUMBER , ::: 177
NAME <= NAME <= ::: 177
and ( STRING in ::: 177
DEDENT DEDENT DEDENT raise ::: 177
DEDENT pass NEWLINE DEDENT ::: 177
in NAME ] for ::: 177
[ NUMBER ] & ::: 177
: NAME in NAME ::: 177
STRING ) < NUMBER ::: 177
] is None NEWLINE ::: 177
) in NAME [ ::: 177
= - NAME * ::: 176
= { ( STRING ::: 176
) == NUMBER else ::: 176
] ) > NAME ::: 176
, [ False , ::: 176
NAME + NAME > ::: 176
) , } } ::: 176
return NAME is not ::: 176
* NAME * NUMBER ::: 176
: NEWLINE INDENT NUMBER ::: 176
in STRING . NAME ::: 176
NAME ) else STRING ::: 176
else NAME [ NUMBER ::: 176
- NUMBER ] += ::: 176
NUMBER or not NAME ::: 176
( ( ( ( ::: 176
) ] [ NAME ::: 175
False ) NEWLINE try ::: 175
, * NAME [ ::: 175
) < NAME ) ::: 175
STRING STRING ) } ::: 175
, STRING ) is ::: 175
== { } NEWLINE ::: 175
and ( NAME or ::: 175
] NEWLINE return { ::: 175
) == NAME * ::: 175
True ) for NAME ::: 175
) or NUMBER NEWLINE ::: 175
+= [ STRING % ::: 175
( None , ) ::: 175
INDENT if ( STRING ::: 175
{ } , } ::: 175
False ) ) : ::: 175
NAME or None NEWLINE ::: 175
/ NAME * NAME ::: 175
. NAME / ( ::: 174
in NAME else None ::: 174
] ] ) . ::: 174
* ( NAME / ::: 174
- NUMBER * NUMBER ::: 174
NAME ) ] ] ::: 174
] NEWLINE continue NEWLINE ::: 174
< NAME or NAME ::: 174
[ NAME ( None ::: 174
INDENT if NAME + ::: 174
( NAME != STRING ::: 174
: NUMBER : NUMBER ::: 174
( NUMBER ) - ::: 174
, ) * NAME ::: 174
NAME ) ) < ::: 174
True if NAME . ::: 174
= ( [ STRING ::: 173
STRING else NAME . ::: 173
NAME ) , lambda ::: 173
- NUMBER + NAME ::: 173
% STRING ) NEWLINE ::: 173
in NAME or not ::: 173
] == ( NUMBER ::: 173
] = ( [ ::: 173
STRING ] = - ::: 173
] , STRING STRING ::: 173
!= NAME ] NEWLINE ::: 173
, NAME + ( ::: 172
= STRING STRING . ::: 172
} } ] , ::: 172
- ( NAME [ ::: 172
NAME NAME ( STRING ::: 172
== [ NUMBER ] ::: 172
: , - NUMBER ::: 172
: ] NEWLINE try ::: 172
return NAME == STRING ::: 172
in ( ( NAME ::: 172
+ NUMBER < NAME ::: 172
) : NAME } ::: 172
( NAME ) // ::: 172
in ( True , ::: 172
continue NEWLINE DEDENT yield ::: 172
NUMBER NEWLINE NAME NAME ::: 172
) ) ( ) ::: 172
NAME or NAME not ::: 172
. NAME NEWLINE STRING ::: 172
: , NUMBER , ::: 172
) ] , ( ::: 172
, NAME = yield ::: 172
] > NAME : ::: 172
] ) ) == ::: 171
( ) + ( ::: 171
/ ( NUMBER - ::: 171
!= NUMBER ) NEWLINE ::: 171
DEDENT NAME NAME . ::: 171
is NUMBER : NEWLINE ::: 171
NAME / NAME [ ::: 171
] ] NEWLINE assert ::: 171
, NUMBER NEWLINE for ::: 171
!= NAME NEWLINE assert ::: 171
NUMBER not in NAME ::: 171
DEDENT return { } ::: 171
INDENT return ( None ::: 171
NUMBER NEWLINE DEDENT while ::: 171
NUMBER / NAME , ::: 171
] ] for NAME ::: 171
+ STRING + ( ::: 170
NAME < NAME , ::: 170
NUMBER and NAME <= ::: 170
] ) ; NEWLINE ::: 170
NUMBER } ] ) ::: 170
NAME ( NAME not ::: 170
( ) ) / ::: 170
STRING } ) ] ::: 170
= NAME or ( ::: 170
NAME ** ( NAME ::: 170
NAME >> NUMBER NEWLINE ::: 170
) ) != NAME ::: 170
or None NEWLINE DEDENT ::: 170
) . NAME + ::: 170
) ] , } ::: 170
NAME % ( STRING ::: 170
>> NUMBER NEWLINE NAME ::: 169
NAME >= NAME and ::: 169
NAME = NAME ; ::: 169
* NAME NEWLINE assert ::: 169
STRING ] ) is ::: 169
NEWLINE return NAME and ::: 169
: ( STRING ) ::: 169
DEDENT return ( STRING ::: 169
) ] == NAME ::: 169
NEWLINE NAME ( None ::: 169
] , * NAME ::: 169
== True NEWLINE assert ::: 169
yield NAME [ NUMBER ::: 169
] NEWLINE return NEWLINE ::: 169
DEDENT NAME STRING . ::: 169
NAME = ~ NAME ::: 169
NUMBER ) ( NUMBER ::: 169
NAME else { } ::: 169
[ : , - ::: 169
+= NAME + NAME ::: 169
NAME ) - ( ::: 169
None and NAME in ::: 169
NEWLINE DEDENT if NUMBER ::: 169
return NEWLINE NAME . ::: 168
INDENT STRING NEWLINE yield ::: 168
<= NUMBER ) : ::: 168
/ NUMBER - NUMBER ::: 168
NUMBER NEWLINE if STRING ::: 168
+ ( NUMBER , ::: 168
NAME == [ ( ::: 168
* NAME , STRING ::: 168
NAME , { NUMBER ::: 168
True ) ] ) ::: 168
NEWLINE if NAME - ::: 168
= - NAME [ ::: 168
INDENT return NAME - ::: 168
= ( False , ::: 168
] ) ( NAME ::: 168
None if NAME . ::: 167
return NAME , [ ::: 167
] ) * ( ::: 167
= [ False , ::: 167
( NUMBER ** ( ::: 167
. NAME - ( ::: 167
= - NAME ( ::: 167
** ( - NUMBER ::: 167
] in NAME ) ::: 167
= not NAME ( ::: 167
, } ] , ::: 167
] not in ( ::: 167
NAME += STRING * ::: 167
DEDENT while NAME ( ::: 167
) + STRING STRING ::: 167
( NAME or [ ::: 166
None , - NUMBER ::: 166
== NAME * NAME ::: 166
. NAME : raise ::: 166
NAME >= NAME NEWLINE ::: 166
] ) NEWLINE while ::: 166
- NUMBER NEWLINE return ::: 166
] . NAME } ::: 166
, } ] NEWLINE ::: 166
>= NAME ) NEWLINE ::: 166
assert [ NAME ( ::: 166
- ( NAME ( ::: 166
] } NEWLINE for ::: 166
= NUMBER NUMBER NEWLINE ::: 166
True ) , ] ::: 166
NAME NAME NEWLINE return ::: 166
. NAME ] if ::: 165
) ] = STRING ::: 165
[ False ] NEWLINE ::: 165
( NAME % STRING ::: 165
( True , True ::: 165
STRING NEWLINE break NEWLINE ::: 165
= NAME = [ ::: 165
False ) NEWLINE with ::: 165
- NUMBER / NUMBER ::: 165
NAME < NAME or ::: 165
{ } ) ] ::: 165
) : continue NEWLINE ::: 165
NUMBER NEWLINE return ( ::: 165
] ] ] ] ::: 165
+ NUMBER / NAME ::: 165
[ : NAME - ::: 164
% STRING NEWLINE DEDENT ::: 164
NEWLINE assert NAME < ::: 164
- NUMBER : NUMBER ::: 164
( ) , * ::: 164
STRING ) ) and ::: 164
) [ NAME ( ::: 164
in NAME ( ( ::: 164
( ) ( ) ::: 164
[ ] ] NEWLINE ::: 164
, False , NUMBER ::: 164
NUMBER ] ) or ::: 164
& NAME ) NEWLINE ::: 164
] : NAME . ::: 164
, [ [ NAME ::: 164
NAME , NAME | ::: 164
] + [ ( ::: 164
NUMBER , STRING + ::: 164
( STRING ) * ::: 164
STRING } NEWLINE for ::: 164
/ NAME , NUMBER ::: 163
NAME ) NEWLINE elif ::: 163
NUMBER * ( ( ::: 163
if ( NAME not ::: 163
] ) as NAME ::: 163
NAME : ] . ::: 163
raise NAME ( { ::: 163
NEWLINE return NAME is ::: 163
NAME STRING , STRING ::: 163
+ NUMBER NEWLINE for ::: 163
{ NAME ( NUMBER ::: 163
STRING ) > - ::: 163
NAME ) ) in ::: 163
: NAME ] : ::: 163
True ) ( NAME ::: 163
STRING ) != NAME ::: 163
( ) : pass ::: 163
= ( ( None ::: 163
import ( NAME ) ::: 163
lambda NAME : not ::: 162
is None , NAME ::: 162
NUMBER ) NEWLINE STRING ::: 162
DEDENT NAME NAME ( ::: 162
is not NAME ) ::: 162
return ( NAME - ::: 162
[ - NAME ( ::: 162
) , ( True ::: 162
= False ) == ::: 162
NUMBER - NAME * ::: 162
STRING * ( NUMBER ::: 162
- NAME < NAME ::: 162
in NAME ( lambda ::: 162
) > NUMBER ] ::: 162
in [ None , ::: 162
NAME : NAME == ::: 161
- NUMBER NEWLINE def ::: 161
+ ( NUMBER * ::: 161
NAME [ None , ::: 161
NUMBER ) ** NAME ::: 161
False NEWLINE if STRING ::: 161
NUMBER ) < NAME ::: 161
] ) NEWLINE ( ::: 161
NUMBER : NAME } ::: 161
] / NAME NEWLINE ::: 161
) % NAME [ ::: 161
) ** ( NAME ::: 161
+ ( STRING if ::: 161
] ( STRING ) ::: 161
DEDENT if ( STRING ::: 161
- NUMBER ] if ::: 161
STRING ] == { ::: 161
NUMBER ] ) != ::: 161
return None , NAME ::: 161
STRING NEWLINE else : ::: 161
% NAME , NUMBER ::: 161
) ) < NAME ::: 161
( NAME ( ** ::: 161
( NAME % { ::: 161
] += NAME ( ::: 161
, } ] } ::: 161
NAME ( NUMBER NAME ::: 160
not None NEWLINE if ::: 160
yield NEWLINE DEDENT finally ::: 160
NAME [ NUMBER + ::: 160
NAME else False NEWLINE ::: 160
: ( ( STRING ::: 160
STRING NEWLINE for ( ::: 160
DEDENT from . import ::: 160
] ) NEWLINE break ::: 160
( ( NAME is ::: 160
* NAME + STRING ::: 160
pass NEWLINE DEDENT from ::: 160
!= [ ] : ::: 160
) or { } ::: 160
NAME + NUMBER < ::: 160
, } NEWLINE @ ::: 160
NUMBER } NEWLINE def ::: 160
] , STRING ] ::: 160
( NAME in [ ::: 160
] ] [ NUMBER ::: 160
STRING : STRING * ::: 160
NAME = NAME < ::: 160
+ STRING * ( ::: 159
is not False : ::: 159
NUMBER ) & ( ::: 159
or ( STRING in ::: 159
NUMBER } , ] ::: 159
if ( NAME - ::: 159
NAME ) ) ** ::: 159
) ] } ) ::: 159
NEWLINE INDENT yield NUMBER ::: 159
not False : NEWLINE ::: 159
NAME , ] , ::: 159
] [ NAME - ::: 159
NAME + STRING * ::: 159
= { STRING % ::: 159
( [ [ [ ::: 159
elif NAME != STRING ::: 159
( NUMBER ) for ::: 159
NAME = - ( ::: 159
DEDENT elif NAME <= ::: 159
NUMBER ] ) is ::: 158
/ NUMBER ] , ::: 158
, STRING } , ::: 158
NUMBER if NAME == ::: 158
return NAME * NUMBER ::: 158
NUMBER ] , : ::: 158
, ) ) ] ::: 158
NUMBER ) < NUMBER ::: 158
} , [ NUMBER ::: 158
% NAME : NAME ::: 158
( NUMBER , False ::: 158
NUMBER NEWLINE while ( ::: 158
@ NAME ( ( ::: 158
NAME = ( False ::: 158
* ( NAME ** ::: 158
NAME . async import ::: 158
NEWLINE return NAME - ::: 158
/ NAME + NUMBER ::: 158
NAME } } } ::: 158
/ NUMBER ) / ::: 158
True ) ] , ::: 158
NUMBER << NAME ) ::: 158
= ( True , ::: 158
and NAME ( ) ::: 158
STRING NEWLINE DEDENT raise ::: 158
) NEWLINE yield STRING ::: 157
NAME + NAME ** ::: 157
NAME != STRING or ::: 157
] == STRING else ::: 157
NAME : [ ] ::: 157
if NUMBER < NAME ::: 157
[ { } ] ::: 157
return NAME % ( ::: 157
NUMBER * NUMBER + ::: 157
] ] = ( ::: 157
/ ( NAME [ ::: 157
== NAME ) & ::: 157
== NUMBER NEWLINE for ::: 157
( [ STRING + ::: 157
, STRING ) in ::: 157
, - NAME ( ::: 157
STRING ) * NAME ::: 157
( ) , ] ::: 157
NAME } NEWLINE try ::: 156
) is NAME ( ::: 156
] == { STRING ::: 156
and ( NAME != ::: 156
NUMBER ) != NAME ::: 156
% ( NAME / ::: 156
= ( ( ( ::: 156
[ None , NAME ::: 156
NAME : { NAME ::: 156
STRING ) ] + ::: 156
) , True , ::: 156
= STRING ; NEWLINE ::: 156
/ NAME NEWLINE return ::: 156
INDENT NAME NAME [ ::: 156
NAME ) == - ::: 156
NUMBER ** NUMBER + ::: 156
STRING ) : NUMBER ::: 156
} ) [ NUMBER ::: 156
} NEWLINE DEDENT try ::: 156
NAME } ] } ::: 156
+ NAME NEWLINE try ::: 156
: NAME ] ] ::: 156
) ) , False ::: 155
) - NAME * ::: 155
NAME ) : ( ::: 155
NAME <= NAME , ::: 155
] , ( ) ::: 155
STRING if not NAME ::: 155
] ] , NUMBER ::: 155
STRING ] is True ::: 155
- NUMBER ) <= ::: 155
> NUMBER NEWLINE assert ::: 155
& NUMBER NEWLINE DEDENT ::: 155
STRING , NEWLINE DEDENT ::: 155
NAME % STRING , ::: 155
True } , } ::: 155
DEDENT assert NAME is ::: 155
} ) , NUMBER ::: 155
NAME % STRING ) ::: 155
: False } ] ::: 155
NUMBER ) NEWLINE ( ::: 155
NUMBER ] in [ ::: 155
None and NAME : ::: 155
if NAME > - ::: 155
] ) } , ::: 154
, lambda * NAME ::: 154
return ( True , ::: 154
* NAME ] ) ::: 154
= NAME ; NEWLINE ::: 154
: NUMBER * NUMBER ::: 154
NUMBER ] , True ::: 154
yield { STRING : ::: 154
NAME != STRING NEWLINE ::: 154
: None NEWLINE NAME ::: 154
, } [ NAME ::: 154
} , None , ::: 154
STRING ] - NUMBER ::: 154
not NAME [ - ::: 154
( NAME - ( ::: 154
False } NEWLINE def ::: 154
] and NAME ( ::: 154
NUMBER NEWLINE else : ::: 154
[ ( NAME - ::: 153
NAME ] ) - ::: 153
DEDENT DEDENT DEDENT with ::: 153
del ( NAME . ::: 153
, NEWLINE DEDENT NAME ::: 153
] - NAME ( ::: 153
* NAME ] , ::: 153
> NAME or NAME ::: 153
( ) ] . ::: 153
True ) [ NUMBER ::: 153
STRING or STRING , ::: 153
) NEWLINE yield NEWLINE ::: 153
, ] + NAME ::: 153
[ [ ] , ::: 153
] [ : : ::: 153
NUMBER != NUMBER : ::: 153
not NUMBER <= NAME ::: 153
NAME [ NAME < ::: 153
STRING ] > NAME ::: 153
= NAME NEWLINE yield ::: 153
, STRING STRING ] ::: 153
) ** NUMBER , ::: 153
NAME [ NAME > ::: 153
: not NAME . ::: 153
NUMBER ] ) } ::: 152
> NUMBER ) . ::: 152
( - NAME [ ::: 152
NAME = NAME >> ::: 152
) } NEWLINE for ::: 152
NAME ] > NUMBER ::: 152
INDENT return NAME is ::: 152
} } ) , ::: 152
* NEWLINE DEDENT except ::: 152
] != STRING ) ::: 152
. async import NAME ::: 152
yield STRING % ( ::: 152
/ NUMBER / NUMBER ::: 152
False NEWLINE with NAME ::: 152
, [ NAME + ::: 152
{ } } } ::: 152
+ ( STRING * ::: 152
+ STRING STRING STRING ::: 152
NAME NEWLINE assert NUMBER ::: 152
STRING } NEWLINE with ::: 151
in NAME NEWLINE if ::: 151
False , * NAME ::: 151
) or NUMBER ) ::: 151
{ NAME [ NUMBER ::: 151
. NAME >> NUMBER ::: 151
== NAME ) , ::: 151
NUMBER < NAME < ::: 151
< NAME [ STRING ::: 151
NAME ) else None ::: 151
NUMBER } NEWLINE assert ::: 151
NUMBER ] == [ ::: 151
<< NUMBER | NAME ::: 151
( NAME and not ::: 151
DEDENT if NAME + ::: 151
: ] , NUMBER ::: 151
continue NEWLINE DEDENT except ::: 151
] > NAME . ::: 150
* NUMBER NEWLINE def ::: 150
NUMBER ) NEWLINE raise ::: 150
+ [ ( NAME ::: 150
+ STRING STRING + ::: 150
. NAME ) ; ::: 150
. NAME NEWLINE ( ::: 150
raise NEWLINE DEDENT finally ::: 150
or NAME [ - ::: 150
NAME = ( not ::: 150
NAME ) ] * ::: 150
STRING ; NEWLINE NAME ::: 150
, NAME ) not ::: 150
NAME < NUMBER , ::: 150
True NEWLINE return NEWLINE ::: 150
+= ( STRING , ::: 150
NAME ( [ None ::: 150
NUMBER ) > NUMBER ::: 150
NAME >>= NUMBER NEWLINE ::: 150
& NUMBER ) ) ::: 150
NEWLINE while NAME >= ::: 150
assert not ( NAME ::: 149
NAME < STRING : ::: 149
> NUMBER else NUMBER ::: 149
) or ( STRING ::: 149
!= None ) : ::: 149
== STRING else False ::: 149
, NEWLINE DEDENT DEDENT ::: 149
> NAME NEWLINE DEDENT ::: 149
and NAME and not ::: 149
NEWLINE STRING NEWLINE if ::: 149
- NUMBER , ) ::: 149
] ) or NAME ::: 149
NAME } } ] ::: 149
, NUMBER ) if ::: 149
STRING } [ NAME ::: 149
STRING NEWLINE DEDENT assert ::: 149
> NUMBER and not ::: 149
NAME ] ) } ::: 149
> NUMBER ) ) ::: 149
( NAME or NUMBER ::: 148
: STRING if NAME ::: 148
STRING == NAME [ ::: 148
NUMBER ] & NUMBER ::: 148
. NAME *= NAME ::: 148
NAME ( [ True ::: 148
: STRING } [ ::: 148
not None and STRING ::: 148
NEWLINE if NUMBER <= ::: 148
) , ) + ::: 148
) not in [ ::: 148
) is NAME and ::: 148
( NUMBER ) if ::: 148
. NAME != True ::: 148
while NAME < NUMBER ::: 148
NAME ( - ( ::: 148
( - NAME + ::: 148
% ( STRING if ::: 148
NAME : { } ::: 148
) ) NEWLINE STRING ::: 148
NAME * NUMBER : ::: 147
) NEWLINE NAME &= ::: 147
) or NAME is ::: 147
and NAME or NAME ::: 147
+ NUMBER == NAME ::: 147
None ) , None ::: 147
* ( - NAME ::: 147
, } NEWLINE try ::: 147
] == - NUMBER ::: 147
STRING ] ) * ::: 147
) == NAME , ::: 147
( ) or STRING ::: 147
== STRING % NAME ::: 147
( STRING ) | ::: 147
NEWLINE DEDENT yield ( ::: 147
INDENT assert NAME NEWLINE ::: 147
STRING ) , lambda ::: 147
async import NAME NEWLINE ::: 147
if NAME else ( ::: 147
** ( NUMBER / ::: 147
NAME , [ - ::: 147
<= NAME [ NUMBER ::: 147
else False NEWLINE NAME ::: 147
= False NEWLINE with ::: 147
NEWLINE assert ( ( ::: 147
} [ NAME . ::: 147
and ( ( NAME ::: 147
STRING ] < NUMBER ::: 146
= ( not NAME ::: 146
is not NAME and ::: 146
NAME + STRING for ::: 146
== NUMBER else STRING ::: 146
NAME & ( NAME ::: 146
{ } ] , ::: 146
: NUMBER / NUMBER ::: 146
% ( NUMBER , ::: 146
STRING ] <= NUMBER ::: 146
** { NAME . ::: 146
) ) and not ::: 146
>= NUMBER , STRING ::: 146
, ) NEWLINE with ::: 146
return NAME , NUMBER ::: 146
- NUMBER ) // ::: 146
} ] ) , ::: 146
: , : - ::: 146
NAME ) != STRING ::: 146
NEWLINE NAME &= NAME ::: 146
) ) ) [ ::: 146
[ [ ] for ::: 145
DEDENT while NUMBER : ::: 145
: NUMBER ) NEWLINE ::: 145
} } , } ::: 145
( ) is True ::: 145
+= NUMBER NEWLINE try ::: 145
== [ ( NUMBER ::: 145
{ ( NUMBER , ::: 145
== NAME + NUMBER ::: 145
continue NEWLINE if NAME ::: 145
/ NUMBER , STRING ::: 145
% NUMBER : NEWLINE ::: 145
- NAME , STRING ::: 145
] ] = NUMBER ::: 145
NAME ) ( NUMBER ::: 145
% ( NAME * ::: 145
NUMBER == NUMBER NEWLINE ::: 145
) ] ) for ::: 145
== ( STRING ) ::: 145
NAME / NUMBER ] ::: 145
) ] ) + ::: 145
return not NAME NEWLINE ::: 145
, NUMBER NEWLINE yield ::: 145
* ( NUMBER ** ::: 145
if not ( NUMBER ::: 145
+ NUMBER ] - ::: 145
INDENT STRING NEWLINE STRING ::: 145
NUMBER else STRING ) ::: 145
is False NEWLINE NAME ::: 145
* NUMBER + [ ::: 145
else [ NAME ] ::: 145
STRING , ( None ::: 144
NUMBER ] NEWLINE except ::: 144
NAME , ) for ::: 144
, ( NUMBER * ::: 144
/= NAME NEWLINE NAME ::: 144
else : raise NAME ::: 144
] ) < NUMBER ::: 144
& ( NUMBER << ::: 144
is True NEWLINE NAME ::: 144
>= NUMBER NEWLINE DEDENT ::: 144
STRING NEWLINE DEDENT with ::: 144
== - NUMBER ) ::: 144
] ] ) ] ::: 144
+ STRING ) % ::: 144
= NUMBER ** NAME ::: 144
, NAME * ( ::: 144
lambda ( NAME , ::: 144
NEWLINE DEDENT NAME /= ::: 144
( ~ NAME . ::: 144
STRING STRING NEWLINE DEDENT ::: 143
None and NAME > ::: 143
DEDENT DEDENT from . ::: 143
NAME NEWLINE return { ::: 143
~ NAME ( NAME ::: 143
NAME NAME [ NUMBER ::: 143
NAME ] != STRING ::: 143
INDENT while NAME : ::: 143
NAME > NAME and ::: 143
NAME : STRING + ::: 143
NAME + ( ( ::: 143
STRING ] ) if ::: 143
NUMBER : ] != ::: 143
in NAME ] } ::: 143
( ) : ] ::: 143
] >= NAME [ ::: 143
( [ NAME * ::: 143
+ ( NAME / ::: 143
} , NAME [ ::: 143
: ] ) . ::: 143
** NUMBER NEWLINE assert ::: 143
not ( NUMBER <= ::: 143
NAME , async = ::: 143
if ( NAME or ::: 143
} ) ] , ::: 143
) == True NEWLINE ::: 142
* NAME : NEWLINE ::: 142
== NUMBER ] NEWLINE ::: 142
NAME ) ) != ::: 142
NEWLINE INDENT raise STRING ::: 142
) == - NAME ::: 142
NUMBER ) >> NUMBER ::: 142
= ( NAME << ::: 142
NAME ] , False ::: 142
assert NAME < NAME ::: 142
NUMBER ) as NAME ::: 142
] , [ False ::: 142
STRING , NUMBER / ::: 142
== STRING ) or ::: 142
False NEWLINE @ NAME ::: 142
[ None , NUMBER ::: 142
True NEWLINE continue NEWLINE ::: 142
NAME ] NEWLINE with ::: 142
) <= NUMBER ) ::: 142
NAME ) ] == ::: 142
: return True NEWLINE ::: 142
False NEWLINE while not ::: 142
) . NAME for ::: 141
) or STRING , ::: 141
/ NUMBER , - ::: 141
None , [ STRING ::: 141
False NEWLINE class NAME ::: 141
) == ( ( ::: 141
return [ STRING % ::: 141
NAME NEWLINE raise NEWLINE ::: 141
DEDENT return not NAME ::: 141
None : return NAME ::: 141
= False NEWLINE @ ::: 141
: ] - NAME ::: 141
// NUMBER NEWLINE DEDENT ::: 141
| NAME NEWLINE DEDENT ::: 141
= ( NUMBER + ::: 141
DEDENT while NAME < ::: 141
True ) ) : ::: 141
, NAME % ( ::: 141
STRING ) not in ::: 141
NAME = ( True ::: 141
, [ NAME for ::: 141
!= NUMBER : NAME ::: 141
= { None : ::: 141
( NUMBER ) ( ::: 141
] [ NUMBER , ::: 141
NUMBER } ) ] ::: 141
, STRING ) != ::: 141
NUMBER ] ; NEWLINE ::: 141
NUMBER , NAME ** ::: 141
NAME <= NUMBER NEWLINE ::: 141
if NUMBER : NEWLINE ::: 141
( ( NUMBER << ::: 140
) ] [ STRING ::: 140
STRING , NAME - ::: 140
, [ [ ] ::: 140
else STRING ) + ::: 140
DEDENT DEDENT NAME NAME ::: 140
DEDENT NAME -= NAME ::: 140
* NUMBER ) / ::: 140
NAME ] : NAME ::: 140
, - NUMBER + ::: 140
NUMBER , } } ::: 140
NAME ) == False ::: 140
- NAME NEWLINE for ::: 140
INDENT NAME *= NUMBER ::: 140
while NAME >= NUMBER ::: 140
NAME , None ] ::: 140
NAME = NAME != ::: 140
+ STRING NEWLINE try ::: 140
+ NAME NEWLINE assert ::: 140
from NAME . async ::: 140
NUMBER - NAME ] ::: 140
return NAME , ( ::: 140
, not NAME . ::: 140
NAME < NAME - ::: 140
) NEWLINE return not ::: 140
% ( NUMBER * ::: 140
% NUMBER NEWLINE DEDENT ::: 140
) ) > NAME ::: 140
NUMBER ] ] } ::: 140
= STRING NEWLINE elif ::: 140
return ( ( STRING ::: 140
, False ) and ::: 140
NUMBER } NEWLINE for ::: 140
<< NAME ) NEWLINE ::: 139
[ : : NAME ::: 139
NUMBER and NAME >= ::: 139
/ NUMBER ) ** ::: 139
) == False : ::: 139
NUMBER ; NAME . ::: 139
] and STRING in ::: 139
) ** NUMBER / ::: 139
NUMBER / NUMBER ] ::: 139
NAME NEWLINE return NUMBER ::: 139
( ) & NAME ::: 139
) or NAME : ::: 139
lambda : NAME NEWLINE ::: 139
} , { NAME ::: 139
} ) , } ::: 139
[ NAME / NAME ::: 139
NUMBER } , NUMBER ::: 139
- NAME > NAME ::: 139
NEWLINE DEDENT elif NUMBER ::: 139
NAME ; NAME = ::: 139
** NAME , NAME ::: 139
) ) | NAME ::: 139
} ] NEWLINE yield ::: 139
STRING ] ) as ::: 139
lambda NAME , * ::: 138
] , STRING + ::: 138
< NUMBER : NAME ::: 138
= ( NAME >> ::: 138
. NAME ] += ::: 138
NAME NAME [ STRING ::: 138
) : [ NUMBER ::: 138
] ) is not ::: 138
STRING , STRING if ::: 138
if NAME else { ::: 138
, : : - ::: 138
DEDENT STRING NEWLINE class ::: 138
+ NUMBER ) ** ::: 138
NAME = { None ::: 138
) & NUMBER ] ::: 138
) , ) . ::: 138
] , } } ::: 138
NAME * NUMBER ] ::: 138
) / NUMBER ] ::: 138
== NAME : NAME ::: 138
NEWLINE return STRING in ::: 138
NUMBER ) : ] ::: 138
True , None ) ::: 138
assert NAME [ - ::: 138
] } NEWLINE return ::: 138
@ NAME ( not ::: 138
, = NAME ( ::: 138
= - ( NAME ::: 138
] ) ] = ::: 138
NUMBER } ) . ::: 138
NAME ) | ( ::: 138
elif NAME is False ::: 138
NUMBER NUMBER NEWLINE NAME ::: 138
pass NEWLINE DEDENT raise ::: 138
return NEWLINE DEDENT with ::: 138
( NUMBER NAME , ::: 138
; NEWLINE NAME [ ::: 138
** NAME ( NUMBER ::: 138
NAME < ( NAME ::: 138
== NUMBER and STRING ::: 137
NAME ( NUMBER < ::: 137
] . NAME in ::: 137
= False ) ] ::: 137
NAME == NAME == ::: 137
] in NAME NEWLINE ::: 137
NUMBER ) == - ::: 137
[ ( ( NAME ::: 137
INDENT STRING NEWLINE del ::: 137
if NAME in STRING ::: 137
: NUMBER ] in ::: 137
( STRING ) - ::: 137
NAME ( [ False ::: 137
break NEWLINE DEDENT for ::: 137
NUMBER ] ) and ::: 137
NAME ) // NAME ::: 137
. NAME [ None ::: 137
) * NAME - ::: 137
NAME << NUMBER NEWLINE ::: 137
STRING ] ) != ::: 137
= NAME NEWLINE import ::: 137
assert ( NAME is ::: 137
( NAME / STRING ::: 137
False NEWLINE STRING NEWLINE ::: 136
] == [ NUMBER ::: 136
) + ( ( ::: 136
return STRING if NAME ::: 136
* NUMBER , [ ::: 136
assert NAME <= NAME ::: 136
!= STRING NEWLINE DEDENT ::: 136
<= NUMBER NEWLINE DEDENT ::: 136
INDENT [ NAME , ::: 136
] / NUMBER , ::: 136
; NEWLINE NAME , ::: 136
<= NAME < NUMBER ::: 136
+ NAME ) for ::: 136
STRING else NAME NEWLINE ::: 136
) * NUMBER / ::: 136
. NAME != ( ::: 136
) [ NAME : ::: 136
if NAME >= ( ::: 136
NAME != STRING else ::: 136
> NAME NEWLINE NAME ::: 136
= ( - NAME ::: 136
NAME : True , ::: 136
) } for NAME ::: 136
STRING ] ) - ::: 136
^ NAME . NAME ::: 136
, NAME % STRING ::: 136
[ NAME : , ::: 135
not NAME , NAME ::: 135
not NAME : break ::: 135
% NAME ] , ::: 135
NUMBER + NUMBER / ::: 135
. NAME ) % ::: 135
DEDENT return - NUMBER ::: 135
*= - NUMBER NEWLINE ::: 135
+ STRING NEWLINE def ::: 135
if False : NEWLINE ::: 135
) == ( [ ::: 135
NUMBER ) ] } ::: 135
: NAME ( { ::: 135
* NAME ( ( ::: 135
lambda NAME : { ::: 135
( ) ) != ::: 135
NAME == True ) ::: 135
, ) , [ ::: 135
) ) , - ::: 135
STRING ] >= NUMBER ::: 135
: : NAME ] ::: 135
NUMBER , ) * ::: 135
!= STRING ) NEWLINE ::: 135
; NEWLINE NAME ( ::: 135
} , [ ( ::: 135
) if NAME and ::: 135
STRING STRING , ( ::: 135
else NAME NEWLINE return ::: 134
[ ( ( STRING ::: 134
INDENT NAME /= NAME ::: 134
return True , NAME ::: 134
% STRING , NAME ::: 134
: STRING * NUMBER ::: 134
NAME , NAME <= ::: 134
) ** NUMBER * ::: 134
NAME ] , { ::: 134
) ** ( NUMBER ::: 134
and NAME in ( ::: 134
- NAME ( [ ::: 134
{ } , NUMBER ::: 134
NAME : ] : ::: 134
[ NAME ( * ::: 134
NAME << NAME ) ::: 134
NEWLINE NAME ( True ::: 134
break NEWLINE NAME = ::: 134
: NUMBER ] < ::: 134
STRING ] ] } ::: 134
NAME ] } } ::: 134
+ [ STRING % ::: 134
NEWLINE DEDENT yield STRING ::: 133
) * NUMBER * ::: 133
NAME ) or NUMBER ::: 133
] ) != NUMBER ::: 133
[ NUMBER , [ ::: 133
NUMBER : { } ::: 133
NEWLINE DEDENT return not ::: 133
] NEWLINE else : ::: 133
DEDENT yield ( NAME ::: 133
STRING : STRING if ::: 133
, STRING ] = ::: 133
return False , NAME ::: 133
[ NAME > NUMBER ::: 133
( NUMBER , lambda ::: 133
return NAME or NAME ::: 133
] , : ] ::: 133
] } , } ::: 133
STRING ] and STRING ::: 133
assert ( STRING , ::: 133
} , ( NUMBER ::: 133
= False NEWLINE STRING ::: 133
: NAME = None ::: 133
] < ( NUMBER ::: 133
return NAME NEWLINE if ::: 133
NAME , [ None ::: 133
NAME NEWLINE return False ::: 133
NEWLINE NAME ( ** ::: 132
NUMBER <= NAME ( ::: 132
= [ True , ::: 132
* NAME ) ( ::: 132
return - NAME . ::: 132
elif NAME [ - ::: 132
NAME ) ( STRING ::: 132
: NAME : NAME ::: 132
NAME : ] = ::: 132
, - NUMBER - ::: 132
== NUMBER ) and ::: 132
- NUMBER if NAME ::: 132
** NUMBER , STRING ::: 132
except ( NAME ) ::: 132
STRING STRING STRING + ::: 132
if not NUMBER <= ::: 132
NAME in ( True ::: 132
None ) NEWLINE with ::: 132
] ] = { ::: 132
NAME [ ... ] ::: 132
STRING ) ] . ::: 132
/ NAME + NAME ::: 132
: NAME [ : ::: 132
NUMBER / NAME ** ::: 132
NUMBER NEWLINE return NEWLINE ::: 132
None } , { ::: 132
and NAME NEWLINE DEDENT ::: 132
NUMBER NEWLINE del NAME ::: 132
NAME < NUMBER else ::: 132
( [ NAME in ::: 132
: None NEWLINE DEDENT ::: 132
pass NEWLINE DEDENT finally ::: 132
not ( NAME [ ::: 132
) ( NUMBER , ::: 132
NEWLINE INDENT raise ( ::: 131
: True ) NEWLINE ::: 131
, NUMBER ) ; ::: 131
import NAME NEWLINE raise ::: 131
>= NAME [ NUMBER ::: 131
, NAME NEWLINE STRING ::: 131
+ NAME == NAME ::: 131
NEWLINE assert ( NUMBER ::: 131
NUMBER , ] ) ::: 131
= [ ( ( ::: 131
, STRING ] and ::: 131
NAME ) NEWLINE [ ::: 131
[ { } , ::: 131
+ NAME ( [ ::: 131
NAME == ( ) ::: 131
] <= NUMBER ) ::: 131
: , NAME [ ::: 131
{ } ) [ ::: 131
/ NUMBER ** NUMBER ::: 131
] *= NAME NEWLINE ::: 131
NUMBER ] ) & ::: 131
] == ( STRING ::: 131
, NUMBER ) is ::: 131
NAME ) : NUMBER ::: 131
} } NEWLINE EOS ::: 131
[ ] NEWLINE @ ::: 131
yield NAME ( NUMBER ::: 131
) == STRING else ::: 131
while NAME in NAME ::: 131
NUMBER ) ) < ::: 131
NUMBER ) ** ( ::: 131
NAME * ( - ::: 131
NAME - NAME ** ::: 131
NAME , NAME if ::: 130
NUMBER ] < ( ::: 130
NAME NAME in NAME ::: 130
[ NAME ] or ::: 130
while NAME != NAME ::: 130
, lambda : None ::: 130
True } } NEWLINE ::: 130
] NEWLINE assert not ::: 130
= NAME and STRING ::: 130
( ) and STRING ::: 130
: NAME >> NAME ::: 130
: return ( NAME ::: 130
INDENT return [ { ::: 130
] ( NAME [ ::: 130
, ) NEWLINE try ::: 130
and NAME [ : ::: 130
: { NAME ( ::: 130
DEDENT NAME NEWLINE NAME ::: 130
NAME ] -= NAME ::: 130
= lambda : None ::: 130
not ( NAME in ::: 130
} } , ] ::: 130
NAME NEWLINE return None ::: 130
) >> NUMBER NEWLINE ::: 130
; NEWLINE for NAME ::: 130
lambda : NUMBER ) ::: 130
NUMBER - NAME / ::: 130
= ( NAME > ::: 130
None and NAME not ::: 129
: STRING STRING } ::: 129
} , [ NAME ::: 129
INDENT yield ( STRING ::: 129
if ( NAME >= ::: 129
- ( ( NAME ::: 129
INDENT NAME ( None ::: 129
- NUMBER : STRING ::: 129
NEWLINE NAME ( lambda ::: 129
NAME &= ~ NAME ::: 129
** NUMBER ) == ::: 129
STRING STRING ] , ::: 129
DEDENT return NAME == ::: 129
, NUMBER ] [ ::: 129
= True NEWLINE continue ::: 129
|= NAME NEWLINE NAME ::: 129
False ) ] ) ::: 129
. NAME ] for ::: 129
+ NUMBER NEWLINE assert ::: 129
NAME = None : ::: 129
) ] NEWLINE try ::: 129
* NAME : NUMBER ::: 129
NAME - NAME > ::: 129
= STRING , NEWLINE ::: 129
NUMBER NEWLINE NAME |= ::: 129
) ) ) is ::: 129
- NAME NEWLINE assert ::: 129
or STRING NEWLINE return ::: 129
, ] NEWLINE return ::: 129
!= ( NUMBER , ::: 129
with NAME as NAME ::: 128
] . NAME for ::: 128
( NAME // NAME ::: 128
STRING NEWLINE continue NEWLINE ::: 128
[ NAME ** NUMBER ::: 128
None else STRING NEWLINE ::: 128
] ) < NAME ::: 128
NUMBER ] += STRING ::: 128
NAME ) : STRING ::: 128
NAME in [ None ::: 128
!= NAME : return ::: 128
NAME / NAME * ::: 128
or STRING ) + ::: 128
, NAME ] += ::: 128
>= NAME NEWLINE DEDENT ::: 128
DEDENT import NAME as ::: 128
, } NEWLINE with ::: 128
NAME < NUMBER ] ::: 128
return STRING , NUMBER ::: 128
NAME if NAME > ::: 128
in NAME if ( ::: 128
) ) , ** ::: 128
NAME != True ) ::: 128
NAME and NAME NEWLINE ::: 128
: STRING ) NEWLINE ::: 128
<= NAME NEWLINE NAME ::: 128
, [ STRING % ::: 128
( ) ] + ::: 128
) ] = [ ::: 128
: NUMBER + NAME ::: 127
] , [ True ::: 127
) ] NEWLINE with ::: 127
NUMBER + NAME / ::: 127
] >= NUMBER and ::: 127
( ( - NAME ::: 127
NAME >= NAME [ ::: 127
[ NAME in NAME ::: 127
( None ) ] ::: 127
NAME > NAME or ::: 127
] == NUMBER , ::: 127
( ) ) and ::: 127
None NEWLINE if ( ::: 127
: ] , [ ::: 127
or STRING ) . ::: 127
NUMBER ) != NUMBER ::: 127
, [ NUMBER + ::: 127
while ( NAME . ::: 127
INDENT NAME ( { ::: 127
NUMBER , + NUMBER ::: 127
= True NEWLINE EOS ::: 127
, ( NAME ) ::: 127
( lambda : None ::: 127
NUMBER NEWLINE while not ::: 127
{ } . NAME ::: 127
] * ( NUMBER ::: 127
| NAME , NAME ::: 127
NUMBER ) ( NAME ::: 127
[ NUMBER ] // ::: 127
= NUMBER ) + ::: 127
: NUMBER NAME , ::: 127
NAME = NAME ^ ::: 127
) , ] : ::: 126
NUMBER ] ) < ::: 126
return ( NAME * ::: 126
NAME << NAME NEWLINE ::: 126
[ ] ] , ::: 126
) and ( STRING ::: 126
if ( NAME & ::: 126
NAME * NUMBER - ::: 126
NAME - NAME < ::: 126
/ NUMBER ) : ::: 126
+ NAME < NAME ::: 126
) ] NEWLINE class ::: 126
[ ] ) + ::: 126
: ( [ STRING ::: 126
lambda NAME : - ::: 126
: ] if NAME ::: 126
NAME ( NAME and ::: 126
] } for NAME ::: 126
return NUMBER , NUMBER ::: 126
] / NAME ( ::: 126
) ] if NAME ::: 126
) > NAME ) ::: 126
, NAME ] for ::: 126
None or NAME < ::: 126
NUMBER ) ^ NAME ::: 126
NAME [ [ STRING ::: 126
elif ( NAME [ ::: 126
>= NUMBER ) : ::: 126
] == NAME , ::: 126
< NUMBER NEWLINE NAME ::: 126
STRING ) } } ::: 126
NUMBER ) NEWLINE from ::: 126
assert True NEWLINE DEDENT ::: 126
( ) >= NUMBER ::: 126
( - NAME / ::: 126
if NAME ] ) ::: 126
is None ) and ::: 126
- NUMBER ** NUMBER ::: 126
( NUMBER in NAME ::: 126
. NAME / STRING ::: 126
NAME else ( NAME ::: 126
NAME STRING + STRING ::: 126
: pass NEWLINE try ::: 126
NAME if NAME < ::: 126
STRING ] else STRING ::: 126
NAME ( NUMBER in ::: 126
** NAME ) as ::: 125
not NAME or ( ::: 125
, NAME ] - ::: 125
: NAME * NUMBER ::: 125
NAME + NUMBER == ::: 125
NAME <= NAME and ::: 125
async . NAME ( ::: 125
NAME > ( NUMBER ::: 125
NAME and NAME or ::: 125
NUMBER : break NEWLINE ::: 125
as NAME NEWLINE return ::: 125
- NAME : NAME ::: 125
( STRING + ( ::: 125
+ - NUMBER * ::: 125
not NAME and ( ::: 125
STRING , NAME STRING ::: 125
* NAME , ( ::: 125
** NAME * NAME ::: 125
False } NEWLINE DEDENT ::: 125
NAME ( NUMBER <= ::: 125
or ( ) ) ::: 125
) else STRING ) ::: 125
: return NEWLINE if ::: 125
) else NAME for ::: 125
NEWLINE from ... . ::: 125
NAME NAME NEWLINE if ::: 125
} ] ) ) ::: 125
] } , ) ::: 125
; NAME ( NUMBER ::: 125
{ } NEWLINE while ::: 125
NEWLINE DEDENT while NUMBER ::: 125
) ; NAME = ::: 125
, ] NEWLINE import ::: 125
NAME &= NAME ( ::: 124
[ : ] . ::: 124
[ lambda NAME : ::: 124
NAME == False NEWLINE ::: 124
NUMBER NEWLINE for ( ::: 124
NEWLINE INDENT del ( ::: 124
= False , * ::: 124
] ) NEWLINE continue ::: 124
] NEWLINE assert [ ::: 124
True NEWLINE class NAME ::: 124
NAME ) : raise ::: 124
NAME : True ) ::: 124
NAME |= ( NAME ::: 124
) and STRING or ::: 124
NUMBER ] -= NAME ::: 124
STRING } ) [ ::: 124
NAME or ( STRING ::: 124
None ] * NUMBER ::: 124
) and STRING not ::: 124
NAME ] not in ::: 124
elif NAME ( STRING ::: 124
) // NUMBER ) ::: 124
INDENT del ( NAME ::: 124
False ) for NAME ::: 124
NUMBER , [ ( ::: 124
<= NUMBER or NAME ::: 124
] ) & NUMBER ::: 123
<= NUMBER and NAME ::: 123
NUMBER ] NEWLINE raise ::: 123
, - NAME * ::: 123
[ STRING ] & ::: 123
= [ NAME * ::: 123
NAME ] or NAME ::: 123
( not NAME , ::: 123
: return ( ( ::: 123
= NAME >> NUMBER ::: 123
% NUMBER != NUMBER ::: 123
) : None , ::: 123
DEDENT NAME NEWLINE DEDENT ::: 123
NUMBER ) ) } ::: 123
DEDENT return NAME * ::: 123
None ] , [ ::: 123
* NEWLINE NAME . ::: 123
] ) , None ::: 123
return - NAME ( ::: 123
NAME ) == True ::: 123
NAME + NAME < ::: 123
. NAME else [ ::: 123
pass NEWLINE DEDENT import ::: 123
NAME . NAME &= ::: 123
NUMBER == NUMBER ) ::: 123
<< NUMBER ) - ::: 123
NAME } , ( ::: 123
/ NUMBER NEWLINE return ::: 123
+= NUMBER NEWLINE yield ::: 123
NUMBER ] ] : ::: 123
( - NUMBER / ::: 123
- NAME ] , ::: 123
+ STRING ) == ::: 123
NAME NEWLINE for ( ::: 123
[ ] } } ::: 123
/= NAME ( NAME ::: 122
, NAME == NAME ::: 122
not NAME and STRING ::: 122
STRING or not NAME ::: 122
= NAME > NAME ::: 122
) ] , ] ::: 122
= True NEWLINE class ::: 122
+ STRING STRING ) ::: 122
STRING , ( [ ::: 122
] - NUMBER ] ::: 122
, None NEWLINE if ::: 122
<= NAME NEWLINE DEDENT ::: 122
NAME & NAME ( ::: 122
( ( STRING . ::: 122
) and NAME > ::: 122
or NUMBER NEWLINE DEDENT ::: 122
( ) ) or ::: 122
NAME ( ) | ::: 122
> NAME [ STRING ::: 122
== True NEWLINE DEDENT ::: 122
NUMBER ] ) if ::: 122
| ( NAME ( ::: 122
** NUMBER * ( ::: 122
NAME and STRING % ::: 122
( [ True , ::: 122
, ** NAME [ ::: 122
( ) ] [ ::: 122
NUMBER ] } } ::: 122
, NAME <= NAME ::: 122
NEWLINE NAME << NAME ::: 122
* ( NAME ) ::: 122
) | NAME NEWLINE ::: 122
return NAME ; NEWLINE ::: 121
STRING , ** { ::: 121
return ( STRING . ::: 121
NUMBER if NAME is ::: 121
NEWLINE assert False , ::: 121
and STRING % NAME ::: 121
] >= ( NUMBER ::: 121
* NAME ** NAME ::: 121
!= NUMBER NEWLINE NAME ::: 121
NAME & ~ NAME ::: 121
STRING : NUMBER NAME ::: 121
] NEWLINE NAME -= ::: 121
) , ) as ::: 121
% NAME ) + ::: 121
= ( STRING if ::: 121
. NAME : lambda ::: 121
NUMBER : ] for ::: 121
+ NUMBER * NUMBER ::: 121
assert NUMBER , STRING ::: 121
NEWLINE return NUMBER , ::: 121
] & NUMBER ) ::: 121
: NAME [ - ::: 121
( NAME and ( ::: 121
, None ] * ::: 121
NAME << NAME ( ::: 121
else None NEWLINE return ::: 121
<< NAME NEWLINE NAME ::: 121
DEDENT DEDENT break NEWLINE ::: 121
: ( False , ::: 120
* NUMBER ) ( ::: 120
] , ] , ::: 120
NUMBER NEWLINE return STRING ::: 120
STRING ] = lambda ::: 120
NUMBER ) , True ::: 120
- NUMBER } NEWLINE ::: 120
NUMBER * NUMBER : ::: 120
/ NAME ) . ::: 120
, ( ( ) ::: 120
while NAME [ NAME ::: 120
pass NEWLINE DEDENT with ::: 120
[ ] if NAME ::: 120
= ( NAME if ::: 120
NUMBER : ] if ::: 120
== NUMBER and ( ::: 120
[ ] , ** ::: 120
: , : : ::: 120
( lambda : NUMBER ::: 120
None if NAME is ::: 120
( ( [ NUMBER ::: 120
== ( NAME ) ::: 120
) or STRING in ::: 120
NUMBER ] , ** ::: 120
else STRING ) , ::: 120
( ) , - ::: 120
NAME ) NEWLINE global ::: 120
NAME is True and ::: 120
: NAME if NAME ::: 120
STRING : return NAME ::: 120
NEWLINE else : raise ::: 120
< NAME , NAME ::: 120
True NEWLINE with NAME ::: 120
NEWLINE return - NAME ::: 120
STRING : { NUMBER ::: 120
NAME ] ; NEWLINE ::: 120