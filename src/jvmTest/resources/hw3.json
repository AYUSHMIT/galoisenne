[
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let cur_state = let (x,y) = MazeGen.dims maze in (x-1, y-1, MazeGen.North) in  let step (x, y, dir) = match dir with | MazeGen.North -> (x, y-1, dir) | MazeGen.South -> (x, y+1, dir) | MazeGen.West -> (x-1, y, dir) | _ -> (x+1, y, dir) in  let rec walk_maze (x, y, dir_to_try) path fc = if x = 0 && y = 0 then path else let (right, forward, left) = MazeGen.dirs_to_check dir_to_try in  let fc2_left = fun () -> walk_maze (step (x, y, left)) (path@[left]) fc in  let fc2_forward_with_left = fun () -> walk_maze (step (x, y, forward)) (path@[forward]) fc2_left and fc2_forward_no_left = fun () -> walk_maze (step (x, y, forward)) (path@[forward]) fc in  let has_wall_r = MazeGen.has_wall maze (x, y, right) and has_wall_f = MazeGen.has_wall maze (x, y, forward) and has_wall_l = MazeGen.has_wall maze (x, y, left) in  match (has_wall_r, has_wall_f, has_wall_l) with | (false, false, false) -> walk_maze (step (x, y, right)) (path@[right]) fc2_forward_with_left | (false, false, true) -> walk_maze (step (x, y, right)) (path@[right]) fc2_forward_no_left | (false, true, false) -> walk_maze (step (x, y, right)) (path@[right]) fc2_left | (false, true, true) -> walk_maze (step (x, y, right)) (path@[right]) fc | (true, false, false) -> fc2_forward_with_left () | (true, false, true) -> fc2_forward_no_left () | (true, true, false) -> fc2_left () | _ -> fc () in  walk_maze cur_state [] (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let node n1 n2 = match n1,n2 with | (Nil,_) -> Nil | (_,Nil) -> Nil | (Cons (hd1,tl1), Cons (hd2,tl2)) -> Cons ((hd1,hd2), zip tl1 tl2) in fun () -> node (seq1 ()) (seq2 ()) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let node n = match n with | Nil -> Nil | Cons (hd, tl) -> if p hd then Nil else Cons (hd, keep_until p tl) in fun () -> node (seq ()) let to_list (seq : 'a seq) : 'a list = let rec build l s = match s () with | Nil -> l | Cons (hd, tl) -> build (l@[hd]) tl in build [] seq let range (start : int) (step : int) (stop : int) : int seq = let p a = if step >=0 then a >= stop else a <= stop in let f a = if a = 0 then start else start + step * (a) in keep_until p (map f nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let rec gcd a b = if a = 0 then b else gcd (b mod a) a  let add a b = let sum = let simplified_a = let factor = gcd a.num a.den in {num = a.num / factor; den = a.den / factor} and simplified_b = let factor = gcd b.num b.den in {num = b.num / factor; den = b.den / factor} in {num = simplified_a.num * simplified_b.den + simplified_b.num * simplified_a.den; den = simplified_a.den * simplified_b.den} in let factor = gcd sum.num sum.den in {num = sum.num / factor; den = sum.den / factor}  let mul a b = let simplified_a = let factor = gcd a.num a.den in {num = a.num / factor; den = a.den / factor} and simplified_b = let factor = gcd b.num b.den in {num = b.num / factor; den = b.den / factor} in let factor_1 = gcd simplified_a.num simplified_b.den and factor_2 = gcd simplified_b.num simplified_a.den in {num = (simplified_a.num / factor_1) * (simplified_b.num / factor_2) ; den = (simplified_a.den / factor_2) * (simplified_b.den / factor_1) ; }  let neg a = {num = 0-a.num ; den = a.den}  let inv a = if a.num = 0 then {num = 0; den = 1} else{num = a.den ; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = (a && not b) || (not a && b) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let find_next m s = (let (x, y, d) = s in match d with | MazeGen.North -> (x, (y - 1), d) | MazeGen.South -> (x, (y + 1), d) | MazeGen.East -> ((x + 1), y, d) | _ -> ((x - 1), y, d) )  in  let rec find_with_cont m c_s p_s sc fc = if MazeGen.has_wall m p_s then fc () else (match c_s with | (0, 0, _) -> let l = sc [] in List.rev l | (x, y, d) ->  let (r, f, l) = MazeGen.dirs_to_check d in    find_with_cont m (find_next m (x, y, r)) (x, y, r) (fun x -> sc (x @ [r])) (fun () -> find_with_cont m (find_next m (x, y, f)) (x, y, f) (fun x -> sc (x @ [f])) (fun () -> find_with_cont m (find_next m (x, y, l)) (x, y, l) (fun x -> sc (x @ [l])) fc))  ) in (let (w, h) = MazeGen.dims maze in find_with_cont maze ((w-1), (h-1), MazeGen.North) ((w-1), (h-1), MazeGen.North) (fun x -> x) (fun () -> []))  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil,_ -> empty | _, Nil -> empty | Cons (h1, t1), Cons (h2, t2) -> (fun () -> Cons ((h1, h2), (zip t1 t2))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (h, t) -> if (p h) then empty else (fun () -> Cons (h,  (keep_until p t))) let to_list (seq : 'a seq) : 'a list = let rec listf s = match s () with | Nil -> [] | Cons (h, t) -> h :: (listf t) in listf seq let range (start : int) (step : int) (stop : int) : int seq = if step == 0 then raise (Invalid_argument \"step cannot be 0\") else if start == stop then cons start empty else if (((start < stop) && (step < 0)) || ((start > stop) && (step > 0))) then raise (Invalid_argument \"infinit stream\") else ( let stepMulti = map (fun x -> start + x * step) nats in keep_until (fun x -> if (start < stop) && (x >= stop) then true else ((start > stop) && (x <= stop))) stepMulti) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  " module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1}  let one = {num = 1; den = 1}  let add t1 t2 = {num = (t1.num * t2.den + t2.num * t1.den); den = (t1.den * t2.den)}  let mul t1 t2 = {num = (t1.num * t2.num); den = (t1.den * t2.den)}  let neg t1 = {num = (zero.num - t1.num); den = t1.den }  let inv t1 = {num = t1.den; den = t1.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false  let one = true  let inv t1 = match t1 with | true -> true | _ -> false   let mul = (&&)  let neg t1 = t1  let add t1 t2 = (t1 || t2) && (not (t1 = t2))  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let starting_position state = let (x,y,_) = state in if (x=0&&y=0) then () in  let get_next state = let (x,y,direction) = state in match direction with | MazeGen.North -> (x,y-1,MazeGen.North) | MazeGen.South -> (x,y+1,MazeGen.South) | MazeGen.East -> (x+1,y,MazeGen.East) | MazeGen.West -> (x-1,y,MazeGen.West) in let rec exit_maze state sc fc = if starting_position state = () then () else let (x,y,dir) = state in let directions =  MazeGen.dirs_to_check dir in let (east,north,west) = directions in   if MazeGen.has_wall maze (x,y,east) = false then fc() else if MazeGen.has_wall maze (x,y,north) = false then fc() else if MazeGen.has_wall maze (x,y,west) = false then fc() else fc()  in [] *) raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with |Nil,_ |_,Nil -> fun() -> Nil | Cons(x,a),Cons(y,b) ->fun() -> Cons((x,y), zip a b) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun() -> Nil | Cons(x,a) -> if not (p x) then fun() -> Cons(x,keep_until p a) else fun () -> Nil   let to_list (seq : 'a seq) : 'a list =  let rec help seq = match seq() with | Nil ->[] | Cons(x,a) -> x::help a in help seq  let range (start : int) (step : int) (stop : int) : int seq = if step > 0 then keep_until (fun a -> a >= stop) (Seq.map (fun a -> a*step+start) nats) else keep_until (fun a -> a <= stop) (Seq.map (fun a -> a*step+start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num= 0;den= 1} let one = {num =1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let inv a = if a.den = 0 then raise DivideByZero else {num = a.den; den = a.num} let neg a  = if a.den = 0 then raise DivideByZero else {num = (-a.num); den = a.den} let mul a b = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = (a.num* b.num); den = a.den*b.den} let add a b = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = (a.num*b.den+ b.num*a.den); den = a.den*b.den} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one  = true let equal = (=) let add a b = match a,b with | true,true | false,false -> false | _,_ -> true let mul a b =  not (not a || not b) let neg a= a let inv a = a end ;; ",
  " let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let dirs_to_check_ls (dir: MazeGen.dir) : MazeGen.dir list = let (d1,d2,d3) = MazeGen.dirs_to_check dir in [d1 ; d2 ; d3] in let move state : MazeGen.state = match state with | (x,y,MazeGen.West) -> (x-1,y, MazeGen.West) | (x,y,MazeGen.North) -> (x,y-1, MazeGen.North) | (x,y,MazeGen.East) -> (x+1,y, MazeGen.East) | (x,y,MazeGen.South) -> (x,y+1, MazeGen.South) in let rec solve_maze_cont (x,y,d) dirs sc fc = if (x,y) = (0,0) then sc [] else match dirs with | [] -> fc () | hd::tl -> if MazeGen.has_wall maze (x,y,hd) then solve_maze_cont (x,y,d) tl sc fc else let sc' = (fun path -> sc (hd :: path)) in let fc' = (fun () -> solve_maze_cont (x,y,d) tl sc fc) in solve_maze_cont (move (x,y,hd)) (dirs_to_check_ls hd) sc' fc' in let (w, h) = MazeGen.dims maze in let dirs = dirs_to_check_ls MazeGen.North in let state = (w-1,h-1,MazeGen.North) in solve_maze_cont state dirs (fun path -> path) (fun () -> raise NotFound) ;; ",
  "let string_of_dir dir = match dir with | MazeGen.West -> \"W\" | MazeGen.North -> \"N\" | MazeGen.East -> \"E\" | MazeGen.South -> \"S\"  let string_of_path path = let list_of_strings = List.map string_of_dir path in let inner ls_str = match ls_str with | [] -> \"[]\" | hd::tl -> hd ^ (List.fold_left (fun res el -> res^\"; \"^el) \"\" tl) in \"[\"^(inner list_of_strings)^\"]\" let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (string_of_path path) ; print_string \"\\n\\n\" ; print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (),seq2 ()) with | (Nil, _) | (_, Nil) -> empty | (Cons(hd1,tl1), Cons(hd2,tl2)) -> let suspended_tail_zip = fun () -> (zip tl1 tl2) () in fun () -> Cons((hd1, hd2),suspended_tail_zip) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons(hd,_) when p hd -> empty | Cons(hd,tl) -> let suspended_keep_until = fun () -> (keep_until p tl) () in fun () -> Cons(hd,suspended_keep_until) let rec to_list (seq : 'a seq) : 'a list = match seq () with | Nil -> [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Step must be nonzero\") else let dir = step / (abs step) in if (stop-start) * dir < 0 then raise (Invalid_argument \"Step must go from start to stop\") else let numbseq = map (fun k -> k*step + start) nats in keep_until (fun k -> (k - stop)*dir >= 0) numbseq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0; den=1} let one = {num=1; den=1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let fix_sign a = if a.den>0 then a else {num = (-a.num); den = (-a.den)} let reduce a = if x < y then gcd y x else if y = 1 then 1 else if y = 0 then x else gcd y (x mod y) in let gcd = gcd (abs a.num) (abs a.den) in {num = a.num/gcd ; den = a.den/gcd }  let add a b = let vulgar = {num = a.num*b.den+b.num*a.den; den = a.den*b.den} in reduce (fix_sign vulgar) let mul a b = let vulgar = {num = a.num*b.num; den = a.den*b.den} in reduce (fix_sign vulgar)  let neg a = {num = (-a.num) ; den = a.den} let inv a = reduce (fix_sign {num = a.den ; den = a.num})  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=) let add a b = match a,b with | false,false | true,true -> false | _,_ -> true let mul a b = match a,b with | true,true -> true | _,_ -> false let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let nextstate states dir = let (a,b,c) = states in if c = North then (a,b-1,dir) else if c = East then (a+1,b,dir) else if c = South then (a,b+1,dir) else (a-1,b,dir) in let rec path (states : MazeGen.state) fc su = match states with | (0, 0, _) -> List.rev(List.tl(su North)) | (a, b, c) -> let (x,y,z) = dirs_to_check c in if not (has_wall maze (a,b,c)) then path (nextstate (a,b,c) x) (fun () -> path (nextstate(a,b,c) y) (fun () -> path (nextstate(a,b,c) z) fc (fun v -> v::(su c))) (fun v -> v::(su c))) (fun v -> v::(su c)) else fc () in let (m,n) = dims maze in path (m-1,n-1,North) (fun () -> path (m-1,n-1,West) (fun () -> raise NotFound) (fun v -> v::[])) (fun v -> v::[]) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(), seq2()) with |(a,_) when a = Nil -> (fun () -> Nil) |(_,b) when b = Nil -> (fun () -> Nil) |(a,b) -> let Cons (x,xs) = a in let Cons (y,ys) = b in (fun () -> Cons ((x,y), (zip xs ys)))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> (fun () -> Nil) | a -> let Cons(x,xs) = a in if (p x) then (fun () -> Nil) else (fun () -> Cons (x,(keep_until p xs))) let to_list (seq : 'a seq) : 'a list = let rec list seq acc = match seq() with | Nil -> List.rev(acc) | a -> let Cons(x,xs) = a in list xs (x::acc) in list seq [] let range (start : int) (step : int) (stop : int) : int seq = if start > stop && step > 0 || start < stop && step < 0 then raise (Invalid_argument \"Unable to reach to stop\") else if step = 0 then raise (Invalid_argument \"The step is 0\") else if start = stop then raise (Invalid_argument \"The start number is equals stop number\") else let x = map (fun v -> v*step) nats in let y = map (fun v -> v+start) x in if (((stop-start) mod step) = 0) then keep_until (fun v -> v=stop) y else if step > 0 then keep_until (fun v -> v>stop) y else keep_until (fun v -> v<stop) y end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0 ; den = 1} let one = {num = 1 ; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num*b.den+b.num*a.den; den = a.den*b.den} let mul a b = {num = a.num*b.num; den = a.den*b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = not (a = b) let mul a b = a && b let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1 (), seq2 ()  with |Cons(v,s),Cons(v2,s2) -> Cons((v,v2), zip s s2) |_ -> Nil   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq =   fun() -> match seq () with  |Cons(v,seq') -> if p v then Nil else Cons(v, keep_until p seq') |Nil -> Nil     let to_list (seq : 'a seq) : 'a list =    let rec aux seq= fun() -> match seq () with |Nil-> [] |Cons(v,s)-> v :: aux s () in aux seq()     let range (start : int) (step : int) (stop : int) : int seq =   raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let zero= {num=0 ; den=1} let one = {num=1 ; den=1}  let add= fun{num=n1;den=d1} {num=n2;den=d2}-> if d1!=d2 then {num=n1*d2 + n2*d1 ; den=d1*d2} else {num = n1+n2 ; den= d1 }     let mul= fun{num=n1;den=d1} {num=n2;den=d2} -> {num=n1*n2;den=d1*d2}  let neg= fun{num=n1;den=d1} -> {num= -1*n1 ; den= d1} let inv = fun {num=n1 ;den=d1} -> {num=d1 ; den=n1}     end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=)  let zero =  false let one = true  let add = fun (f)(f2)-> not(f=f2)   let mul = fun (f) (f2) -> if not f || not f2 then false else f=f2   let neg= fun f -> f   let inv = fun f -> not (not f)         end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in let inWidth = width - 1 in let inHeight = height - 1 in  let next_cell state = let (w, h, dir) = state in match dir with | (MazeGen.East) -> (w + 1, h) | (MazeGen.North) -> (w, h - 1) | (MazeGen.West) -> (w - 1, h) | (MazeGen.South) -> (w, h + 1) in  let rec helper state sc fc = let (w, h, cur_dir) = state in if (w = 0 && h = 0) then sc [] else if MazeGen.has_wall maze state then fc () else let (first_dir, second_dir, third_dir) = MazeGen.dirs_to_check cur_dir in let (w_next, h_next) = next_cell state in let sc1 = (fun r -> sc (cur_dir :: r)) in let fc2 = (fun () -> helper (w_next, h_next, third_dir) sc1 fc) in let fc1 = (fun () -> helper (w_next, h_next, second_dir) sc1 fc2) in helper (w_next, h_next, first_dir) sc1 fc1 in  let sc = (fun r -> r) in let fc2 = (fun () -> helper (inWidth, inHeight, MazeGen.West) sc (fun () -> [])) in let fc1 = (fun () -> helper (inWidth, inHeight, MazeGen.North) sc fc2) in helper (inWidth, inHeight, MazeGen.East) sc fc1 ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Seq.Nil, _ -> (fun () -> Seq.Nil) | _, Seq.Nil -> (fun () -> Seq.Nil) | Seq.Cons (v1, s1), Seq.Cons (v2, s2) -> ( fun () -> Seq.Cons ((v1, v2), zip s1 s2) ) ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Seq.Nil -> (fun () -> Seq.Nil) | Seq.Cons (v, s) -> if p v then (fun () -> Seq.Nil) else ( fun () -> Seq.Cons ((v), keep_until p s) ) ;; ",
  " let to_list (seq : 'a seq) : 'a list = Seq.fold_left (fun list el -> list @ [el]) [] seq ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if (step = 0 || (step < 0 && start < stop) || (step > 0 && stop < start)) then raise (Invalid_argument \"Invalid arguments. Either the step is 0, the step is decreasing but the start is smaller than the end, or the step is increasing but the start is bigger than the end\") else let map_seq = Seq.map (fun (el) -> start + step * el) nats in keep_until (fun (el) -> if step < 0 then el <= stop else el >= stop) map_seq ;; ",
  " end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add = fun x y -> let new_den = x.den * y.den in let new_numx = x.num * y.den in let new_numy = y.num * x.den in let res = {num = new_numx + new_numy ; den = new_den} in if res.num = 0 then zero else res  let mul = fun x y -> let res = {num = x.num * y.num; den = x.den * y.den} in if res.num = res.den then one else res  let neg = fun {num; den} -> {num = (-num); den = den} let inv = fun {num; den} -> {num = den; den = num} end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add = fun x y -> match x,y with | true, true -> zero | false, false -> zero | _ -> one  let mul = fun x y -> match x,y with | false, _ -> zero | _, false -> zero | _ -> one  let neg = fun x -> x let inv = fun x -> x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let help_st (s : MazeGen.state) (d : MazeGen.dir) : MazeGen.state = let (x, y, _) = s in if (d = MazeGen.North) then (x, y-1, MazeGen.North) else if (d = MazeGen.South) then (x, y+1, MazeGen.South) else if (d = MazeGen.West) then (x-1, y, MazeGen.West) else (x+1, y, MazeGen.East) in let opposite (d : MazeGen.dir) : MazeGen.dir = if (d = MazeGen.North) then MazeGen.South else if (d = MazeGen.South) then MazeGen.North else if (d = MazeGen.West) then MazeGen.East else MazeGen.West in let rec sm_helper maze s suc fai d : MazeGen.dir list = match s with |( 0, 0, _ ) -> suc [] |( x, y, z ) -> let (right, front, left) = MazeGen.dirs_to_check z in let (ifR, ifF, ifL) = ( (MazeGen.has_wall maze ( x, y, right)), (MazeGen.has_wall maze ( x, y, front)), (MazeGen.has_wall maze ( x, y, left)) ) in if not ifR then if right = opposite d then fai () else if ifF && ifL then sm_helper maze (help_st s right) (fun l -> suc (right :: l)) fai right else sm_helper maze (help_st s right) (fun l -> suc (right :: l)) (fun () -> sm_helper maze (x,y,left) suc fai d) right  else if not ifF then if front = opposite d then fai () else if ifL then sm_helper maze (help_st s front) (fun l -> suc (front :: l)) fai front else sm_helper maze (help_st s front) (fun l -> suc (front :: l)) (fun () -> sm_helper maze (x,y,left) suc fai d) front  else if  not ifL then if left = opposite d then fai () else sm_helper maze (help_st s left) (fun l -> suc (left :: l)) fai left else fai () in let (w,h) = MazeGen.dims maze in sm_helper maze (w-1, h-1, MazeGen.North) (fun r -> r) (fun () -> []) MazeGen.North ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons(h1,t1), Cons(h2,t2) -> (cons (h1,h2) (zip t1 t2)) () | Nil, _ -> empty () | _, Nil -> empty ()  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> empty () | Cons(h,t) -> if (p h) then empty () else Cons(h, keep_until p t) let to_list (seq : 'a seq) : 'a list = let rec help seq acc = match seq () with | Nil -> acc | Cons(h,t) -> help t (acc @ [h]) in help seq [] let range (start : int) (step : int) (stop : int) : int seq = if start = stop then empty else if step < 0 then if stop > start then raise (Invalid_argument \" while step < 0, stop > start\") else let f a = a + ((step-1) * a) + start in let s = Seq.map f nats in keep_until (fun n -> (n <= stop)) s else if step > 0 then if start > stop then raise (Invalid_argument \" while step > 0, stop < start\") else let f a = a + ((step-1) * a) + start in let s = Seq.map f nats in keep_until (fun n -> (n >= stop)) s else raise (Invalid_argument \"step is 0\")  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = (a.num * b.den + b.num * a.den); den = a.den * b.den} let mul a b = {num = (a.num * b.num); den = (a.den * b.den)} let neg a = {num = 0 - a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let first = ref 0 in let dim_maz = (dims maze) in let (dim_x,dim_y)=dim_maz in let helper_move (m_x,m_y) (m_d:dir) = if (m_d == North) then (m_x,(m_y - 1)) else if (m_d == South) then (m_x,(m_y + 1)) else if (m_d == East) then ((m_x + 1),m_y) else ((m_x - 1),m_y) in let rec helper ((c_x,c_y,c_d):state) cont fc : dir list = match (c_x,c_y,c_d) with | (0,0,_) -> cont | (_,_,_) -> if (has_wall maze (c_x,c_y,c_d)) then fc() else let (dir1,dir2,dir3) = (dirs_to_check c_d) in if (c_x == (dim_x-1) && c_y == (dim_y-1)) && !first == 0 then begin first := 1; let fc2 = fun () -> helper (c_x,c_y,dir3) (cont@[dir3]) fc in let fc1 = fun () -> helper (c_x,c_y,dir2) (cont@[dir2]) fc2 in helper (c_x,c_y,dir1) (cont@[dir1]) fc1 end else let (next_x,next_y) = helper_move (c_x,c_y) c_d in let fc2 = fun () -> helper (next_x,next_y,dir3) (cont@[dir3]) fc in let fc1 = fun () -> helper (next_x,next_y,dir2) (cont@[dir2]) fc2 in if (next_x == 0 && next_y == 0) then cont else helper (next_x,next_y,dir1) (cont@[dir1]) fc1 in helper (dim_x-1,dim_y-1,North) [] (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with | Cons(x,y),Cons(x2,y2) -> (fun () -> Cons((x,x2),(zip y y2))) | _,_ -> empty   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Cons(x,y) -> if (p x) then empty else (fun () -> Cons(x,(keep_until p y))) | Nil -> empty let to_list (seq : 'a seq) : 'a list = let acc = ref [] in let f = (fun x -> acc := (x::(!acc))) in if ((iter f seq) == ()) then List.rev !acc else List.rev !acc let range (start : int) (step : int) (stop : int) : int seq = let ls = ref [] in let rec helper1 s st sto : unit = if (st > 0) then begin ls := s::!ls; if ((s+st) < sto) then helper1 (s+st) st sto else () end else begin ls := s::!ls; (if ((s+st) > sto) then helper1 (s+st) st sto else ()) end in if (helper1 start step stop == ()) then map (List.nth (List.rev !ls)) (keep_until (fun l -> l >= (List.length !ls)) nats) else empty end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den =1} let one = {num=1; den=1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num=((a.num * b.den)+(b.num * a.den));den=(a.den * b.den)} let mul a b = {num=(a.num * b.num);den=(a.den * b.den)}  let neg a = {num=(a.num-(2 * a.num));den=a.den} let inv a = {num=a.den; den=a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add a b = match a,b with | true,true -> false | false,false -> false | _,_ -> true let mul a b = match a,b with | true,true -> true | _,_ -> false  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (wi, he) = MazeGen.dims maze in let next_cell width height dir = match dir with | MazeGen.East -> (width + 1, height) | MazeGen.North -> (width, height - 1) | MazeGen.South -> (width, height + 1) | MazeGen.West -> (width - 1, height) in let rec find_path maze (w, h) d fail success try_dir = match (w, h) with | (0, 0) -> success [] | _ -> let (d1, d2, d3) = MazeGen.dirs_to_check d in if not (MazeGen.has_wall maze (w, h, d1)) && try_dir = None then ( find_path maze (next_cell w h d1) d1 (fun () -> find_path maze (w, h) d fail success (Some d1)) (fun r -> success (d1 :: r)) None)  else if not (MazeGen.has_wall maze (w, h, d2)) && try_dir <> Some d2 && try_dir <> Some d3 then( find_path maze (next_cell w h d2) d2 (fun () -> find_path maze (w, h) d fail success (Some d2)) (fun r -> success (d2 :: r)) None)  else if not (MazeGen.has_wall maze (w, h, d3)) && try_dir <> Some d3 then find_path maze (next_cell w h d3) d3 (fun () -> find_path maze (w, h) d fail success (Some d3)) (fun r -> success (d3 :: r)) None else fail() in find_path maze (wi - 1, he - 1) MazeGen.North (fun () -> []) (fun l -> l) None  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1() with | Nil -> empty | Cons (x1, f1) -> match seq2() with | Nil -> empty | Cons (x2, f2) -> fun() -> Cons ((x1, x2), zip f1 f2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons (x, f) -> if p x then empty else fun() -> Cons (x, keep_until p f) let to_list (seq : 'a seq) : 'a list = fold_left (fun r b -> r @ [b]) [] seq let range (start : int) (step : int) (stop : int) : int seq = if (stop < start && step > 0) || (stop > start && step < 0) then raise (Invalid_argument \"Invalid input\") else if step = 0 then raise (Invalid_argument \"Invalid input\") else ( if start = stop then empty else let s1 = map (fun x -> x * step) nats in let s2 = map (fun x -> x + start) s1 in if stop > start then let s3 = filter (fun x -> x >= start) s2 in keep_until (fun x -> x >= stop) s3 else let s3 = filter (fun x -> x <= start) s2 in keep_until (fun x -> x <= stop) s3 ) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = a.num * (-1); den = a.den} let inv a = if a.num = 0 then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = if a && b then false else not((not a) && (not b)) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x, y) = MazeGen.dims maze in let (x, y) = (x-1, y-1) in let next s = let (x, y, d) = s in match d with | MazeGen.East -> (x+1, y, d) | MazeGen.South -> (x, y+1, d) | MazeGen.West -> (x-1, y, d) | MazeGen.North -> (x, y-1, d) in let rec helper m s p f = let (x, y, d) = s in if x = 0 && y = 0 then p() else let (d1, d2, d3) = MazeGen.dirs_to_check d in let b1 = MazeGen.has_wall m (x, y, d1) in let b2 = MazeGen.has_wall m (x, y, d2) in let b3 = MazeGen.has_wall m (x, y, d3) in match (b1, b2, b3) with | (true, true, true) -> f() | (false, true, true) -> helper m (next (x, y, d1)) (fun() -> p()@[d1]) f | (true, false, true) -> helper m (next (x, y, d2)) (fun() -> p()@[d2]) f | (true, true, false) -> helper m (next (x, y, d3)) (fun() -> p()@[d3]) f | (true, false, false) -> helper m (next (x, y, d2)) (fun() -> p()@[d2]) (fun() -> helper m (next (x, y, d3)) (fun() -> p()@[d3]) f) | (false, false, true) -> helper m (next (x, y, d1)) (fun() -> p()@[d1]) (fun() -> helper m (next (x, y, d2)) (fun() -> p()@[d2]) f) | (false, true, false) -> helper m (next (x, y, d1)) (fun() -> p()@[d1]) (fun() -> helper m (next (x, y, d3)) (fun() -> p()@[d3]) f) | (false, false, false) -> helper m (next (x, y, d1)) (fun() -> p()@[d1]) (fun() -> helper m (next (x, y, d2)) (fun() -> p()@[d2]) (fun() -> helper m (next (x, y, d3)) (fun() -> p()@[d3]) f)) in helper maze (x, y, MazeGen.North) (fun() -> []) (fun() ->  []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | (Nil, _) | (_, Nil) -> empty | (Cons(x1, xs1),Cons(x2, xs2)) -> fun () -> Cons((x1, x2), (zip xs1 xs2)) ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(x, xs) -> if p x then empty else (fun () -> Cons(x, (keep_until p xs))) let rec to_list (seq : 'a seq) : 'a list = match seq() with | Nil -> [] | Cons(x, xs) -> x::(to_list xs) let range (start : int) (step : int) (stop : int) : int seq = let seq = map (fun x -> start + step * x) nats in if step > 0 then keep_until (fun x -> x >= stop) seq else keep_until (fun x -> x <= stop) seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add = fun r1 r2 -> {num = r1.num*r2.den+r1.den*r2.num; den = r1.den*r2.den} let mul = fun r1 r2 -> {num = r1.num*r2.num; den = r1.den*r2.den} let neg = fun r -> {num= (-r.num); den = r.den} let inv = fun r -> {num = r.den; den = r.num} let equal = fun r1 r2 -> r1.num*r2.den == r1.den*r2.num end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = fun b1 b2 -> not (b1 == b2) let mul = fun b1 b2 -> match (b1, b2) with |(true, true) -> true |(true, false) -> false |(false, true) -> false |(false, false) -> false let neg = fun b -> b let inv = fun b -> b let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x,y) = MazeGen.dims maze in let move_state maze (x,y)  d = if not (MazeGen.has_wall maze (x, y, d)) then match d with | MazeGen.North -> [(x, y - 1, d)] | MazeGen.East -> [(x + 1, y, d)] | MazeGen.West -> [(x -1, y, d)] | MazeGen.South -> [(x, y + 1, d)] else [] in let rec solve_impl maze rs ss = if (List.length ss) == 0 then [] else let (x, y, d) = List.hd ss in if x = 0 && y = 0 then [rs] else let (d0,d1,d2) = MazeGen.dirs_to_check d in let ms0 = move_state maze (x, y) d0 in let ms1 = move_state maze (x, y) d1 in let ms2 = move_state maze (x, y) d2 in let ds0 = solve_impl maze (List.append rs [d0]) ms0 in let ds1 = solve_impl maze (List.append rs [d1])  ms1 in let ds2 = solve_impl maze (List.append rs [d2])  ms2 in let rs = (List.filter (fun x -> (List.length x) > 0) [ds0; ds1;ds2]) in if (List.length rs) > 0 then List.hd rs else [] in List.hd (solve_impl  maze [] [((x -1), (y - 1), MazeGen.North)]) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> let x = seq1() in let y = seq2() in match (x, y) with | (Nil, _) -> Nil | (_, Nil) -> Nil | (Cons(x1, x2), Cons(y1, y2))  -> Cons((x1, y1), (zip x2 y2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let x = seq() in match x with | Nil -> Seq.empty | Cons(x, y) -> if (p x) then Seq.empty else Seq.cons x  (keep_until p y) let to_list (seq : 'a seq) : 'a list = let rec to_list' seq = let v = seq() in match v with | Nil -> [] | Cons(x, y) -> List.cons x (to_list' y) in to_list' seq let range (start : int) (step : int) (stop : int) : int seq = keep_until (fun x -> if step > 0 then x >= stop else x <= stop) (Seq.map (fun x -> start + x*step) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let zero = {num = 0; den = 1} let one = {num = 1;den = 1} let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den*b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) let zero = false let one = true let add a b = not (b =  a) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(), seq2()) with | (Nil, _) -> (fun () -> Nil) | (_, Nil) -> (fun () -> Nil) | (Cons(x,xs), Cons(y,ys)) -> (fun () -> Cons((x,y), zip xs ys))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> (fun() -> Nil) | Cons(x,f) -> if p x then (fun () -> Nil) else (fun () -> Cons(x, keep_until p f)) let to_list (seq : 'a seq) : 'a list = let rec aux (seq : 'a seq) : 'a list = match seq() with | Nil -> [] | Cons(x,f) -> x::(aux f) in aux seq  let range (start : int) (step : int) (stop : int) : int seq = let helper_function x = start + (x * step) in let stop_condition x = if (step >= 0) then (x >= stop) else (x <= stop) in keep_until stop_condition (map helper_function nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1}  let one = {num = 1 ; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {den = a.den * b.den; num = (a.num * b.den) + (a.den * b.num)}  let mul a b = {den = a.den * b.den; num = a.num * b.num}  let neg a = {num = - a.num; den = a.den}  let inv a = {num = a.den ; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false  let one = true let equal = (=)  let add a b = not (equal a b)  let mul = (&&)  let neg a = a  let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let width, height = MazeGen.dims maze in let next_cell cur_state : (int * int * MazeGen.dir) = let x, y, cur_dir = cur_state in match cur_dir with | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.North -> (x, y-1, MazeGen.North) | MazeGen.East -> (x+1, y, MazeGen.East) | MazeGen.South -> (x, y+1, MazeGen.South) in let rec find_path cur_state success failure = if MazeGen.has_wall maze cur_state then failure() else match next_cell cur_state with | (0,0,direction) -> success [direction] | (x2,y2,direction) -> let right, front, left = (MazeGen.dirs_to_check direction) find_path (x2,y2,right) (fun r -> success (direction::r)) (fun () -> find_path (x2,y2,front) (fun r -> success (direction::r)) (fun () -> find_path (x2,y2,left) (fun r -> success (direction::r)) failure)) in let _,front,left = MazeGen.dirs_to_check MazeGen.North in find_path (width-1, height-1, front) (fun r->r) (fun () -> find_path (width-1,height-1,left) (fun r -> r) (fun () -> []))   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with |Nil,_ -> empty |_,Nil -> empty |Cons (hd1, tl1), Cons (hd2, tl2) -> fun() -> Cons((hd1,hd2), (zip tl1 tl2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> empty |Cons (hd, tl) -> if (p hd) then empty else fun () -> Cons (hd, keep_until p tl) let to_list (seq : 'a seq) : 'a list = let concat a b = a@[b] in match seq() with | Nil -> [] | Cons (hd, tl) -> fold_left concat [hd] tl let range (start : int) (step : int) (stop : int) : int seq = let seq = map (fun a -> step * a+start) nats in if start<=stop && step > 0 then keep_until (fun a -> a>=stop) seq else if start>stop && step < 0 then keep_until (fun a -> a<=stop) seq else if step = 0 then raise (Invalid_argument \"step cannot be 0\") else raise (Invalid_argument \"unreachable stop\")  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = 0-a.num; den = a.den} let inv a = if a.num=0 then raise DivideByZero else{num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = not ( equal a b ) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width,height) = MazeGen.dims maze in let next_cell (state: MazeGen.state) : MazeGen.state = let (x,y,dir) = state in match dir with |MazeGen.West -> (x-1,y,dir) |MazeGen.North -> (x, y-1,dir) |MazeGen.East -> (x+1, y,dir) |MazeGen.South -> (x, y+1,dir) in let rec solver (state: MazeGen.state) c_fail c_sucess= let (x,y,dir) = state in if (x,y) = (0,0) then c_sucess [] else if not (MazeGen.has_wall maze state)  then let (n_x,n_y,n_dir) = next_cell (x,y,dir) in let (right,forward,left) = MazeGen.dirs_to_check n_dir in solver (n_x,n_y,right)  (fun () -> solver (n_x,n_y,forward) (fun () -> solver (n_x,n_y,left) c_fail (fun l -> c_sucess (dir::l))) (fun l -> c_sucess (dir::l))) (fun l -> c_sucess (dir::l)) else c_fail ()  in solver (width-1,height-1, MazeGen.North)  ( fun () ->  solver (width - 1,height - 1,MazeGen.West) (fun () -> []) (fun l -> l) ) (fun l -> l)   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun f ->  match seq1 f, seq2 f with |Cons(x1,y1) , Cons(x2,y2) -> Cons((x1,x2),zip y1 y2) |_ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun f -> match seq f with |Cons(x,y) -> if p x then Nil else Cons(x, keep_until p y) |_ -> Nil let to_list (seq : 'a seq) : 'a list = let rec helper l s = match s () with |Cons(x,y) -> helper (l@[x]) y |_ -> l in helper [] seq let range (start : int) (step : int) (stop : int) : int seq = if (step<0 && start<stop) then raise (Invalid_argument \"stop needs to be less than start when step is negative\") else if (step>0 && stop<start) then raise (Invalid_argument \"stop needs to be greater than start when step is positive\") else if step>0 then map (fun x -> x+start) (filter (fun x -> x mod step = 0) (keep_until (fun x -> (x > stop-start-1)) nats)) else map (fun x -> (-1*x)+start) (filter (fun x -> x mod step = 0) (keep_until (fun x -> (x > start-stop-1)) nats))     end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0; den= 1} let one = {num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num= a.num * b.den + a.den * b.num ; den = a.den * b.den} let mul a b = {num = a.num * b.num ; den = a.den * b.den} let neg a = {num = -a.num ; den = a.den} let inv a ={num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = match a,b with |true,true -> false |false,false -> false |true,false -> true |false, true -> true let mul a b = match a,b with |true,true -> true |false,false -> false |true,false -> false |false, true -> false let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_cell (coord : int * int) (dir : MazeGen.dir) : MazeGen.state = let (x, y) = coord in match x, y, dir with | x, y, MazeGen.West -> (x-1, y, MazeGen.West) | x, y, MazeGen.North -> (x, y-1, MazeGen.North) | x, y, MazeGen.East -> (x+1, y, MazeGen.East) | x, y, MazeGen.South -> (x, y+1, MazeGen.South) in let rec solve (curr_coords : int * int) (dir : MazeGen.dir) sc fc = let (x, y) = curr_coords in let x', y', dir' = next_cell (x, y) dir in let right, straight, left = MazeGen.dirs_to_check dir in let blocked = MazeGen.has_wall maze (x, y, dir) in if (x, y) = (0, 0) then sc () else if blocked then fc () let goleft = (fun () -> solve (x', y') left (fun () -> sc() @ [dir']) fc) in let gostraight = (fun () -> solve (x', y') straight (fun () -> sc() @ [dir']) goleft) in solve (x', y') right (fun () -> sc() @ [dir']) gostraight in let sc = fun () -> [] in let fc = fun () -> solve (w-1, h-1) MazeGen.West sc (fun () -> raise NotFound) in solve (w-1, h-1) MazeGen.North sc fc ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | ((Cons (_, _), Nil) | (Nil, _)) -> fun () -> Nil | Cons (x, xf), Cons (y, yf) -> fun () -> Cons ((x, y), zip xf yf)   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (x, xf) -> if (p x) then empty else (fun () -> Cons (x, keep_until p xf))  let to_list (seq : 'a seq) : 'a list = let rec to_list' (seq' : 'a seq) acc = match seq' () with | Nil -> acc | Cons (x, xf) -> to_list' xf (acc @ [x]) in to_list' seq [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Error: Infinite sequence - step is 0\") else if (step < 0 && stop > start) || (step > 0 && stop < start) then raise (Invalid_argument \"Error: Infinite sequence - will never reach stop value\") else let f = fun n -> (n * step) + start in let p = fun n -> if step > 0 then n >= stop else n <= stop in keep_until p (map f nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let one = { num = 1; den = 1 }  let zero = { num = 0; den = 1 }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = let x = (a.num * b.den) + (a.den * b.num) in let y = a.den * b.den in let rec gcd a b = if b = 0 then (abs a) else (gcd b (a mod b)) in let d = gcd x y in { num = x / d; den = y / d }  let mul a b = let x = a.num * b.num in let y = a.den * b.den in let rec gcd a b = if b = 0 then (abs a) else (gcd b (a mod b)) in let d = gcd x y in { num = x / d; den = y / d }  let neg a = { num = -a.num; den = a.den }  let inv a = { num = a.den; den = a.num }  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let one = true  let zero = false  let equal = (=)  let add a b = if a = b then zero else one  let mul a b = if a = zero || b = zero then zero else one  let neg a = a  let inv a = a  end ;; ",
  "find_path (next_cell cur_state right) (fun e -> sc (right::e))  else if MazeGen.has_wall maze (x,y,front) = false then find_path (next_cell cur_state front) (fun e -> sc (front::e))  else if MazeGen.has_wall maze (x,y,left) = false then find_path (next_cell cur_state left) (fun e -> sc (left::e)) else raise NotFound *) in let (maze_width,maze_height) = MazeGen.dims maze in find_path (maze_width-1,maze_height-2, MazeGen.North) (fun l -> l)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "*) module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let (Cons (h1,t1)) = seq1 () in let (Cons (h2,t2)) = seq2 () in if t1 != empty & t2 != empty then append (return (h1,h2)) (zip t1 t2) else empty  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (a,b) = dims maze in let start_point : state = (a-1,b-1,North) in let second idk = let (c,d,e) = idk in if e = West then (c-1, d, e) else if e = North then (c,d-1, e) else if e = East then (c+1, d, e) else (c, d+1, e) in let helper idk = let (f,g,h) = idk in let (i,j,k) = dirs_to_check h in let result = ref[] in if not (has_wall maze (f,g,i)) then result := i :: !result; if not (has_wall maze (f,g,j)) then result := j :: !result; if not (has_wall maze (f,g,k)) then result := k :: !result; result in let starting = !(helper start_point) in let rec another_helper l dir fail success = match l with |(0,0,_)->success[] |(a,b,c)-> if dir = [] then fail () else let x::xs = dir in another_helper (second(a,b,x)) !(helper (second (a,b,x))) (fun () -> another_helper l xs fail success) (fun list -> success (x :: list)) in another_helper start_point starting (fun()->[]) (fun q->q)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun()-> match seq1(),seq2() with |_,Nil -> Nil |Nil,_ -> Nil |Cons(a,b),Cons(c,d) -> Cons((a,c), zip b d) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun()-> match seq() with |Nil->Nil |Cons(a,b)-> if p a then Nil else Cons(a, keep_until p b)  let to_list (seq : 'a seq) : 'a list = let rec recursive idk acc= match idk with |Nil -> acc | Cons(a,b) -> recursive (b()) (acc@[a]) in recursive (seq()) [] let range (start : int) (step : int) (stop : int) : int seq = if (step < 0 && start < stop) then raise (Invalid_argument \"start smaller than stop, causing the sequence decreasing infinitely.\") else if step = 0 then raise (Invalid_argument \"As step is 0, invalid.\") else if (step > 0 && start > stop) then raise (Invalid_argument \"start greater than stop,causing the sequence increasing infinitely.\") else let idk = map (fun l -> start + l * step) nats in keep_until (fun l -> if step <= 0 then (l <= stop) else (l >= stop)) idk end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one = {num = 1; den = 1} let zero = {num = 0; den = 1}  let inv (a:t) = if a.num = 0 then raise DivideByZero else if a.den = 0 then raise DivideByZero else {den = a.num; num = a.den}  let neg (a:t) = if a.den = 0 then raise DivideByZero else {den = a.den; num = a.num * (-1) }  let add (a:t) (b:t)= if a.den = 0||b.den = 0 then raise DivideByZero else if a.den = b.den then {den = a.den; num = (b.num + a.num)} else {den = (b.den * a.den); num = (b.den * a.num + b.num * a.den)}  let mul (a:t) (b:t)= if a.den = 0 || b.den =0 then raise DivideByZero else { den = (b.den)*(a.den); num = (b.num* a.num)}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let one = true let zero = false let inv (a:t) = a let neg (a:t) = a let add (a:t) (b:t) = (b && (not a))||((not b) && a) let mul (a:t) (b:t) = a && b let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let move (w, h, d) = match d with |MazeGen.North -> (w, h-1, d) |MazeGen.South -> (w, h+1, d) |MazeGen.West -> (w-1, h, d) |MazeGen.East -> (w+1, h, d) in let dim = MazeGen.dims maze in let rec help p s list cont = match s with | (0, 0, _) -> list [] | (w, h, d) -> let (r,f,l) = MazeGen.dirs_to_check d in match (p (w, h, r)), (p (w, h, f)), (p (w, h, l)) with |(true, true, true) -> cont () |(true, true, false) -> help p (move (w, h, l)) (fun c -> list (l::c)) cont |(true, false, true) -> help p (move (w, h, f)) (fun c -> list (f::c)) cont |(false, true, true) -> help p (move (w, h, r)) (fun c -> list (r::c)) cont |(false, false, true) -> help p (move (w, h, r)) (fun c -> list (r::c)) (fun () -> help p (move (w, h, f)) (fun c -> list (f::c)) cont) |(false, true, false) -> help p (move (w, h, r)) (fun c -> list (r::c)) (fun () -> help p (move (w, h, l)) (fun c -> list (l::c)) cont) |(true, false, false) -> help p (move (w, h, f)) (fun c -> list (f::c)) (fun () -> help p (move (w, h, l)) (fun c -> list (l::c)) cont) |(false, false, false) -> help p (move (w, h, r)) (fun c -> list (r::c)) (fun () -> help p (move (w, h, f)) (fun c -> list (f::c)) (fun () -> help p (move (w, h, l)) (fun c -> list (l::c)) cont)) in help (MazeGen.has_wall maze) (((fst)dim-1), ((snd)dim-1), North) ((fun c -> c)) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with |Nil, _ |_, Nil -> empty |Cons(x,xf), Cons(y,yf) -> fun () -> Cons((x,y), (zip xf yf)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Nil -> seq |Cons(x, xf) -> if (p x) then empty else fun () -> Cons(x, (keep_until p xf)) let to_list (seq : 'a seq) : 'a list = let rec help s list = match s () with |Nil -> list [] |Cons(x, xf) -> help xf (fun c -> list (x::c)) in help seq (fun c -> c) let range (start : int) (step : int) (stop : int) : int seq = let p a = (stop > start && a >= stop) || (stop < start && a <= stop) in let f a = start + a * step in if((stop >= start && step > 0) || (stop <= start && step < 0) ) then keep_until p (map f nats) else if (step = 0) then raise (Invalid_argument \"Step should not be zero\") else raise (Invalid_argument \"Infinite sequence, stop never reached\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = let reduce {num = x; den = y} = let rec gcd a b = if b = 0 then a else gcd b (a mod b) in let g = gcd x y in {num = x/g; den = y/g} in let a = reduce a in let b = reduce b in reduce {num = a.num * b.den + b.num * a.den ; den = a.den * b.den} let mul a b = let reduce {num = x; den = y} = let rec gcd a b = if b = 0 then a else gcd b (a mod b) in let g = gcd x y in {num = x/g; den = y/g} in let a = reduce a in let b = reduce b in reduce {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -a.num ; den = a.den} let inv a = if(a.num = 0) then raise (Invalid_argument \"Zero has no inverse\") else {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next x y dir = match dir with | MazeGen.East -> (x+1, y, dir) | MazeGen.North -> (x, y-1, dir) | MazeGen.West -> (x-1, y, dir) | MazeGen.South -> (x, y+1, dir) in let rec solve maze state sc fc = let y_pos = (fun (_,y,_) -> y) state in let x_pos = (fun (x,_,_) -> x) state in if y_pos = 0 && x_pos = 0 then sc [] else if MazeGen.has_wall maze state then fc () else let cur_dir = (fun (_,_,d) -> d) state in let checks = MazeGen.dirs_to_check cur_dir in let right = (fun (r,_,_) -> r) checks in let forward = (fun (_,f,_) -> f) checks in let left = (fun (_,_,l) -> l) checks in let (x, y, _) = next x_pos y_pos cur_dir in solve maze (x,y,right) (fun a -> sc (cur_dir::a)) ( fun () -> solve maze (x, y, forward) (fun a -> sc (cur_dir::a)) (fun () -> solve maze (x, y, left) (fun a -> (cur_dir::a)) (fc)) ) in let cur_pos = (fun (x,y) -> (x-1, y-1, MazeGen.North)) (MazeGen.dims maze) in solve maze cur_pos (fun a -> a) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let rec helper a b = fun () -> match a (), b () with | Seq.Cons (x,a'), Seq.Cons (y,b') -> Seq.Cons ((x,y), (helper a' b')) | _ -> Nil in helper seq1 seq2 let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let rec helper p a = fun () -> match a () with | Cons (x, a') -> if p x then Nil else (Cons (x, helper p a')) | _ -> Nil in helper p seq let to_list (seq : 'a seq) : 'a list = let rec helper a l = match a () with | Seq.Cons (x, a') -> (helper (a') (l@[x])) | _ -> l in helper seq [] let range (start : int) (step : int) (stop : int) : int seq = let n_seq = map (fun fx -> (fx * step)+start) nats in if step > 0 then keep_until (fun fx -> fx >= stop) n_seq else keep_until (fun fx -> fx <= stop) n_seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = if a.den = b.den then {num = a.num + b.num; den = a.den} else {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = if a.num < 0 && a.den < 0 then {num = a.num; den = (-a.den)} else if a.num > 0 && a.den < 0 then {num = a.num; den = (-a.den)} else if a.den > 0 then {num = (-a.num); den = a.den} else {num = a.num; den = a.den} let inv a = let n_num = a.den in let n_den = a.num in {num = n_num; den = n_den} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) let zero = false let one = true let add a b = if a && b then false else a <> b let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_step ((x, y, dir) : MazeGen.state) : MazeGen.state = match dir with |MazeGen.West -> (x-1, y, MazeGen.West) |MazeGen.North -> (x, y-1,MazeGen.North) |MazeGen.East -> (x+1, y,MazeGen.East) |_ -> (x, y+1, MazeGen.South) in let rec solve_maze' (maze: MazeGen.maze) ((x, y, dir): MazeGen.state) sCont fCont = let (dir1, dir2, dir3) = MazeGen.dirs_to_check dir in if MazeGen.has_wall maze (x, y, dir) then if (x, y) = (0, 0) then sCont [] else fCont() else let (x, y, _) = next_step(x, y, dir) in let fCont3 = fun() -> solve_maze' maze (x, y, dir3) (fun r -> sCont(dir3 :: r)) fCont in let fCont2 = fun () -> solve_maze' maze (x, y, dir2) (fun r -> sCont(dir2 :: r)) fCont3 in if (x, y) = (0, 0) then sCont[] else solve_maze' maze (x, y, dir1) (fun r -> sCont(dir1 :: r)) fCont2 in let (width, height) = MazeGen.dims maze in let fCont4 = fun() -> solve_maze' maze (width-1, height-1, MazeGen.West) (fun r -> MazeGen.West :: r) (fun () -> raise NotFound) in solve_maze' maze (width-1, height-1, MazeGen.North) (fun r -> MazeGen.North :: r) fCont4 ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "let print_rand_maze width height = let maze = MazeGen.random width height in print_string (MazeGen.string_of_maze maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with |Cons(x, xf),Cons(y, yf) -> (fun() -> Cons((x, y),(zip xf yf))) |_,_ -> fun() -> Nil ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Cons(x,xf) -> (if p x then keep_until p (fun() -> Nil) else fun() -> Cons(x,keep_until p xf)) |_ -> fun() -> Nil ;; ",
  " let to_list (seq : 'a seq) : 'a list = let rec to_list' (seq1 : 'a seq) cont = match seq1() with |Cons(x,xf) -> to_list' xf (fun r -> cont (x :: r)) |_ -> cont [] in to_list' seq (fun r -> r) ;; ",
  " let range (start : int) (step : int) (stop : int) : int seq = if (step < 0) && (stop > start) then raise (Invalid_argument \"Such inputs will result in an inifinite loop\") else if (step > 0) && (start > stop) then raise (Invalid_argument \"Such inputs will result in an inifinite loop\") else (if step < 0 then let seq2 = keep_until (fun r -> (start+(step*r)) <= (stop)) (nats) in Seq.map (fun r -> (start+(step*r))) seq2 else let seq2 = keep_until (fun r -> (start+(step*r)) >= (stop)) (nats) in Seq.map (fun r -> (start+(step*r))) seq2 ) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1}  let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = (a.num*b.den)+(b.num*a.den); den = a.den*b.den}  let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = (-a.num); den = a.den}  let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a  let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let next_state (x, y, d) = match d with | MazeGen.West -> (x - 1, y, d) | MazeGen.North -> (x, y - 1, d) | MazeGen.East -> (x + 1, y, d) | MazeGen.South -> (x, y + 1, d) in  let rec maze_helper (x, y, d) sc fc = if (x, y) = (0, 0) then sc [] else let (r, f, l) = MazeGen.dirs_to_check d in  let try_left () = if not (MazeGen.has_wall maze (x, y, l)) then maze_helper (next_state (x, y, l)) (fun t -> sc (l :: t)) (fun () -> fc ()) else fc () in  let try_front () = if not (MazeGen.has_wall maze (x, y, f)) then maze_helper (next_state (x, y, f)) (fun t -> sc (f :: t)) (fun () -> try_left ()) else try_left () in  let try_right () = if not (MazeGen.has_wall maze (x, y, r)) then maze_helper (next_state (x, y, r)) (fun t -> sc (r :: t)) (fun () -> try_front ()) else try_front () in  try_right ()  in let (w, h) = MazeGen.dims maze in maze_helper (w - 1, h - 1, MazeGen.North) (fun l -> l) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons (e1, seq1'), Cons (e2, seq2') -> Cons ((e1, e2), zip seq1' seq2') | _ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Cons (e, seq') -> if p e then Nil else Cons (e, keep_until p seq') | Nil -> Nil let to_list (seq : 'a seq) : 'a list = Seq.fold_left (fun cont e t -> cont (e :: t)) (fun l -> l) seq [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 || (step > 0 && start > stop) || (step < 0 && start < stop) then raise (Invalid_argument \"The range function would output an infinite sequence\") else keep_until (if step > 0 then ((<=) stop) else ((>=) stop)) (map (fun n -> start + n * step) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = { num = a.num * b.den + b.num * a.den ; den = a.den * b.den } let mul a b = { num = a.num * b.num ; den = a.den * b.den }  let neg a = { num = -a.num ; den = a.den } let inv a = { num = a.den ; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add = (<>) let mul = (&&)  let neg x = x let inv x = x  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec solve_maze_tr (maze: MazeGen.maze) (state: MazeGen.state) succ fail: MazeGen.dir list = let (x, y) = MazeGen.dims maze in let (e1, e2, _) = state in if (e1 = -1 || e1 = x) || (e2 = -1 || e2 = y) then fail () else if MazeGen.has_wall maze state then  fail () else match state with | (0, 0, dir) -> succ [] | (x, y, dir) -> let (e1, e2, e3) = MazeGen.dirs_to_check dir in let new_state = let open MazeGen in match dir with | North -> (x, y-1) | South -> (x, y+1) | West -> (x-1, y) | East -> (x+1, y) in let (xcor, ycor) = new_state in if(xcor = 0 && ycor = 0) then succ [] else let state_one = (xcor, ycor, e1) in let state_two = (xcor, ycor, e2) in let state_three = (xcor, ycor, e3) in solve_maze_tr maze (state_one) (fun x -> succ(e1 :: x)) (fun () -> solve_maze_tr maze (state_two) (fun y -> succ (e2 :: y)) (fun () -> solve_maze_tr maze (state_three) (fun z -> succ(e3 :: z)) fail)) in let open MazeGen in let (x, y) = dims maze in solve_maze_tr maze (x-1, y-1, North) (fun x -> North :: x) (fun () -> solve_maze_tr maze (x-1, y-1, West) (fun x -> West :: x) (fun () -> raise NotFound))  ;; ",
  "let test_maze maze = let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1(), seq2()) with | (Nil, _) -> Nil | (_, Nil) -> Nil | Cons(x, xs), Cons(hd, tl) -> Cons((x,hd), zip xs tl)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with | Nil -> Nil | Cons(x, xs) -> if p x then Nil else Cons(x, keep_until p xs) let to_list (seq : 'a seq) : 'a list = let rec to_list' my_seq list = fun () -> match my_seq() with | Nil -> list | Cons(x, xs) -> x :: (to_list' xs list ()) in to_list' seq [] ()  let range (start : int) (step : int) (stop : int) : int seq = if ((start > stop && step > 0) || (start < stop && step < 0)) then raise (Invalid_argument \"Choice of step value with given stop value leads to an infinite sequence\") else if (step = 0) then raise (Invalid_argument \"Choice of step cannot be zero\") else let open Seq in let my_seq = map (fun x -> if step > 0 then x + start else start - x) nats in let rec filter (seq: int seq) (num: int): int seq = fun () -> match seq() with | Nil -> Nil | Cons(x, xs) -> if x = num then Cons(x, filter xs (x + step)) else filter xs num () in let filtered = filter my_seq start in keep_until (fun x -> if stop > 0 then x >= stop else x <= stop) filtered  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if (a.den = b.den) then {num = a.num + b.num; den = a.den} else let first_val = a.num * b.den in let second_val = b.num * a.den in {num = first_val + second_val; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -(a.num); den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = if (a = zero && b = zero || a = one && b = one ) then zero else one let mul a b = if (a = one && b = one) then one else zero let neg a = if a = zero then zero else one let inv = neg end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let sq1 = seq1() in let sq2 = seq2() in match sq1 , sq2 with |Cons (a , b) , Cons (x, y) ->  fun() -> Cons ((a , x), (zip (b) (y)))  |Cons (a,b), Nil -> Seq.empty  |Nil, _ -> Seq.empty   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let sq = seq() in  match sq with |Cons (x,y) -> if (p x) then Seq.empty else fun () ->Cons ((x) ,(keep_until p y)) |Nil -> Seq.empty  let to_list (seq : 'a seq) : 'a list = let rec help (seq : 'a seq) : 'a list = match seq() with |Nil -> [] |Cons (a, b) -> a:: help b in help seq exception Invalid_argument of string  let range (start : int) (step : int) (stop : int) : int seq = if  (abs (stop-start) < abs(stop-(start+step))) || (step = 0) then raise (Invalid_argument \"invalid argument please verify them\") else let helper x =(x * step) + start in let tmp = Seq.map helper nats in keep_until (fun x -> let tmp = step in if (tmp > 0) then x >= stop else x <= stop) (tmp)   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add x y = if (x.den = 0 || y.den = 0) then raise DivideByZero else if (x.den = y.den) then {num = x.num + y.num ; den = x.den} else let tmpDen = x.den * y.den in let newXnum = x.num * y.den in let newYnum = y.num * x.den in {num = newXnum + newYnum ; den = tmpDen}  let mul x y = if (x.den = 0 || y.den = 0) then raise DivideByZero else {num = x.num * y.num ; den = x.den * y.den}  let neg x = { num = -x.num; den = x.den}  let inv x = { num = x.den; den = x.num}   end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one  = true let equal = (=)  let add x y = not (x=y)   let mul x y = match x,y with |false, false -> false |_, _ -> (x = y)  let neg x = x let inv x = x  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let next_cell (state: MazeGen.state) : MazeGen.state = let (coord_x, coord_y, direction) = state in if direction = West then (coord_x - 1, coord_y, direction) else if direction = North then (coord_x, coord_y - 1, direction) else if direction = East then (coord_x + 1, coord_y, direction) else (coord_x, coord_y + 1, direction) in  let rec solve_maze' (state: MazeGen.state) sc fc curr_path = let (curr_x, curr_y, dir) = state in let right, front, left = MazeGen.dirs_to_check dir in let state_toRight = (curr_x, curr_y, right) in let state_toFront = (curr_x, curr_y, front) in let state_toLeft = (curr_x, curr_y, left) in  if curr_x = 0 && curr_y = 0 then (sc curr_path @ [dir])  else if (MazeGen.has_wall maze state_toRight && MazeGen.has_wall maze state_toFront && MazeGen.has_wall maze state_toLeft) then fc ()  else if (MazeGen.has_wall maze state_toRight <> true) then let updated_state = next_cell state_toRight in let curr_path = curr_path @ [right] in let sc1 = fun r -> curr_path;r in let fc1 = fun () -> solve_maze' state_toFront (fun r -> let reversed_list = List.rev curr_path in let hd::tl = reversed_list in let updated_path = List.rev tl in tl @ [front]) fc curr_path in (solve_maze' updated_state sc1 fc1 curr_path)  else let updated_state = next_cell state_toFront in let curr_path = curr_path @ [front] in let sc2 = fun r -> curr_path; r in let fc2 = fun () -> solve_maze' state_toFront (fun r -> let reversed_list = List.rev curr_path in let hd::tl = reversed_list in let updated_path = List.rev tl in tl @ [left]) fc curr_path in (solve_maze' updated_state sc2 fc2 curr_path)  in let start_state = (0,0, North) in solve_maze' start_state (fun direction -> direction)  (fun () -> []) [] ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ -> (fun () -> Nil) | _, Nil -> (fun () -> Nil) | Cons (h1, s1), Cons (h2, s2) -> (fun () -> (Cons ((h1, h2), zip s1 s2))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons (hd, str) -> if p hd then fun () -> Nil else fun () -> Cons (hd, keep_until p str) let to_list (seq : 'a seq) : 'a list = let rec to_list' seq1 acc = match seq1 () with | Nil -> acc | Cons (hd, str) -> to_list' str (acc @ [hd]) in to_list' seq [] let range (start : int) (step : int) (stop : int) : int seq = let condition1 el = el mod step = 0 in if (start > stop && step > 0) || (start < stop && step < 0) || step = 0 || start = stop then raise (Invalid_argument \"Invalid arguments\") else let filtered_seq = filter condition1 nats in let Cons (first, _) = filtered_seq () in let shift_numb = start - first in let shifted_seq : int seq = map (fun el -> if step > 0 then el + shift_numb else -el + shift_numb) filtered_seq in keep_until (fun el -> if step > 0 then el >= stop else el <= stop) (shifted_seq)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero : t = {num = 0; den = 1} let one : t = {num = 1; den = 1}  let add a b = if a.den = b.den then let result = {num = a.num + b.num; den = a.den} in if result.num = result.den then one else result else let result = {num = (a.num * b.den) + (b.num * a.den); den = a.den * b.den} in if result.num = result.den then one else result  let mul a b = if a.num = 0 || b.num = 0 then zero else let result = {num = a.num * b.num; den = a.den * b.den} in if result.num = result.den then one else result  let neg number = {num = (-number.num); den = number.den}  let inv a = if a.num < 0 then {num = -a.den; den = a.num} else {num = a.den; den = a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let add = (<>)  let mul a b = not (not a || not b)  let neg a = a let inv a = a  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let getNext curr = let (x, y, direction) = curr in match direction with |MazeGen.West -> (x-1,y,MazeGen.North) |MazeGen.North -> (x,y-1,MazeGen.East) |MazeGen.East -> (x+1,y,MazeGen.South) |MazeGen.South -> (x,y+1,MazeGen.West) in let rec solveCont curr_cell ls sc fc = if MazeGen.has_wall maze curr_cell then fc() else match curr_cell with |(0,0,_) -> sc ls |(x,y,curr_dir) -> let (x_next,y_next,_) as nextcell = getNext curr_cell in let (_, front, left) = MazeGen.dirs_to_check curr_dir in let fc2 = fun () -> solveCont (x_next, y_next, front) ls sc fc in let fc1 = fun () -> solveCont (x_next, y_next, left) ls sc fc2 in solveCont nextcell (curr_dir::ls) sc fc1 in let (width,height) = MazeGen.dims maze in let initial_state = (width-1,height-1,MazeGen.North) in let sc = fun lst -> lst in let fc = fun () -> solveCont (width-1,height-1,MazeGen.West) [] sc (fun() -> raise NotFound) in solveCont initial_state [] sc fc  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with |Nil,_ -> fun() -> Nil |_,Nil -> fun() -> Nil |Cons(x1,y1),Cons(x2,y2) -> fun() -> Cons((x1,x2), zip y1 y2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> fun() -> Nil |Cons(a,b) -> if p a then fun()->Nil else fun() -> Cons(a, keep_until p b) let to_list (seq : 'a seq) : 'a list = let rec tolist seq l = match seq() with |Nil -> l |Cons(a,b) -> tolist b (l@[a]) in tolist seq []  let range (start : int) (step : int) (stop : int) : int seq = if ((start > stop)&&(step>0)) || ((stop > start)&&(step<0)) then raise (Invalid_argument \"stop is unreachable from start using given steps\" ) else let reached a = if step > 0 then (a >= stop) else (a <= stop) in let startat b = b+start in let stepping curr = (curr-start)*step+start in keep_until reached (map stepping (map (startat) nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if (a.num = 0 || b.num = 0) then {num = 0; den = 1} else {num = a.num*b.den + b.num*a.den; den = a.den*b.den} let mul a b = {num = a.num*b.num; den = a.den*b.den} let neg a = {num = -a.num; den = a.den} let inv a = if a.den != 0 then {num = a.den; den = a.num} else raise DivideByZero end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = let x = not a &&b in let y = a&&not b in x||y let mul a b = a&&b let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let go (x, y) = function | West  -> (x - 1, y) | East  -> (x + 1, y) | North -> (x, y - 1) | South -> (x, y + 1) in let shorten = function | [] -> [] | [a] -> [a] | West  :: East  :: xs | East  :: West  :: xs | South :: North :: xs | North :: South :: xs -> xs | xs -> xs in let rec maze_step (x, y) dir = if x = 0 && y = 0 then [] else let (r, f, l) = dirs_to_check dir  in let nx = List.find_opt (fun d -> not (has_wall maze  (x, y, d))) @@ [r;f;l] in match nx with | Some nextdir -> shorten (nextdir :: maze_step (go (x, y) nextdir) nextdir) | _ -> maze_step (x, y) l in let (width, height) = dims maze in maze_step (width - 1, height - 1) North   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | (Nil, _) -> empty | (_, Nil) -> empty | (Cons (x,xs), Cons (y,ys)) -> (fun () -> Cons((x, y), zip xs ys)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (x,_) when p x -> empty | Cons (x,xs) -> cons x (keep_until p xs) let to_list (seq : 'a seq) : 'a list = Seq.fold_left (fun lst x -> lst @ [x]) [] seq  let range (start : int) (step : int) (stop : int) : int seq = if (step <= 0 && stop > start) || (step >= 0 && stop < start) then raise (Invalid_argument \"infinite sequence\") else if (step <= 0 && start <= stop || step >= 0 && start >= stop) then empty else if step > 0 then keep_until (fun y -> y >= stop) (Seq.map (fun x -> start + x * step) nats) else keep_until (fun y -> y <= stop) (Seq.map (fun x -> start + x * step) nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "let rec gcd a = function | 0 -> a | b -> gcd b (a mod b)  let reduce {num = num; den = den; } = let gcdd = gcd num den in {num = num / gcdd; den = den / gcdd } module RationalField : (AlgField with type t = rational) = struct type t = rational   let zero = {num = 0; den = 1} let one  = {num = 1; den = 1} let add a b = reduce { num = a.num * b.den + b.num * a.den; den = a.den * b.den } let mul a b = reduce { num = a.num * b.num; den = a.den * b.den } let neg a = reduce { num = -a.num; den = a.den } let inv a = reduce { num = a.den; den = a.num } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = a && (not b) || b && (not a) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) end ;; ",
  "open MazeGen  ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = |_ -> match old with |(x,y,North) -> if ((y - 1) >= 0) then Some(x,y - 1,North) else None |(x,y,South) -> if ((y + 1) >= 0) then Some(x,y + 1 ,South) else None |(x,y,West) -> if ((x - 1) >= 0) then Some(x-1,y,West) else None  in let rec compute_out now success fail = match now with |Some(w,h,cd) -> let (r,s,l) = MazeGen.dirs_to_check cd in |None -> fail() in let (w,h) = MazeGen.dims maze in let a = w - 1 in let b = h - 1 in  raise NotImplemented   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with |Nil, _ -> empty |_, Nil -> empty |Cons(x,xs), Cons(y,ys) -> fun() -> Cons((x,y),zip xs ys) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Cons(hd,tl) -> if not (p hd) then (fun() -> Cons(hd, keep_until p tl)) else fun() -> Nil |Nil -> empty let to_list (seq : 'a seq) : 'a list= let rec to_list_helper sequence = match sequence() with |Nil -> [] |Cons(x,xs) -> x::to_list_helper xs in to_list_helper seq   let range (start : int) (step : int) (stop : int) : int seq = if (step > 0 && start > stop) || (step = 0) || (start < stop && step < 0) then raise (Invalid_argument \"Invalid Argument\") else if start = stop then empty else keep_until(fun m -> if step > 0 then (m >= stop) else (m <= stop)) (map (fun k -> step * k + start) nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add x y= {num = x.num * y.den + x.den * y.num; den = x.den * y.den} let mul x y ={num = x.num * y.num; den = x.den * y.den}   let neg x = {num = -x.num; den = x.den} let inv x = {num = x.den; den = x.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add x y = ((not x) && y || x && (not y)) let mul = (&&)  let neg x = x let inv x = x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let state_check (d : MazeGen.dir) state:(int*int) = let (x,y) = state in match d with | MazeGen.West -> (x-1,y) | MazeGen.East -> (x+1,y) | MazeGen.South -> (x,y+1) | MazeGen.North -> (x,y-1) in let rec maze_rec (s:(int*int)) d m sc fc  = match s with | (0,0) -> sc [] | (x,y) ->  print_string (string_of_int y); print_string (string_of_int x); if MazeGen.has_wall maze (x,y,d) then  fc () else let (d1,d2,d3) = MazeGen.dirs_to_check(d) in let newDir = state_check d (x,y) in let sc2 = fun r -> d::(sc r) in let fc2a = fun () -> maze_rec newDir d3 m sc2 fc in let fc2b = fun () -> maze_rec newDir d2 m sc2 fc2a in maze_rec newDir d1 m sc2 fc2b in let (h,w) = MazeGen.dims maze in List.rev (maze_rec (h-1,w-1) MazeGen.North maze (fun x-> x) (fun () -> (maze_rec (h-1,w-1) MazeGen.West maze (fun x-> x) (fun ()->[]))))  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1(),seq2() with | Nil,_ -> Nil | _,Nil -> Nil | Cons(a,b),Cons(c,d) -> Cons((a,c),zip b d);; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons(a,b) -> if p a then Nil else Cons(a,keep_until p b );; ",
  "let to_list (seq : 'a seq) : 'a list = fold_left (fun x y-> x @ [y]) [] seq;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if(step = 0) then raise (Invalid_argument \"Sequence will not converge\") else if(start < stop && step < 0) then raise (Invalid_argument \"Range approaches negative infinity\") else if(start > stop && step > 0) then raise (Invalid_argument \"Range approaches positive infinity\") else keep_until (fun x -> if step > 0 then x >= stop else x <= stop ) (map (fun x -> x* step + start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero:rational = {num=0;den=1} let one:rational = {num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num=((a.num*b.den)+(a.den*b.num));den=a.den*b.den};; ",
  "let mul a b =  {num=a.num*b.num;den=a.den*b.den};; ",
  "let neg a = {num=(-) 0 a.num ;den=a.den};; ",
  "let inv a = if a <> zero then {num=a.den;den=a.num} else a;; ",
  "end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add  = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (width, height) = dims maze in let moveStep ((x,y,_):state) (dirIns:dir) :state= match dirIns with | North -> (x,y-1,North) | South -> (x,y+1,South) | East ->(x+1,y,East) | West -> (x-1,y,West) in  let isReverse ((elem1, elem2) : dir*dir)  : bool = match (elem1, elem2) with | (North, South) -> true | (South,North) -> true | (West, East) -> true | (East, West) -> true | _ -> false in  let rec remove (dirList:dir list) (acc: dir list): dir list = match dirList with | [] -> acc | last :: [] -> acc @ [last] | elem1 :: elem2 :: tail -> if isReverse (elem1, elem2) then remove (acc @ tail) [] else remove (elem2 :: tail) (acc @ [elem1]) in   let rec moveForward (state:state) (cont:dir list -> dir list) : dir list = match state with | (0,0,_) -> cont [] | (x,y,dir) -> let (rg, stra, lf) = dirs_to_check dir in let (backDir, _, _) = dirs_to_check rg in if (has_wall maze (x,y,rg)) == false then moveForward (moveStep state rg) (fun acc -> cont (rg::acc)) else if (has_wall maze (x,y,stra)) == false then moveForward (moveStep state stra) (fun acc -> cont (stra::acc)) else if (has_wall maze (x,y,lf)) == false then moveForward (moveStep state lf) (fun acc -> cont (lf::acc)) moveForward (moveStep state backDir) (fun acc -> cont (backDir::acc)) in  let listOrg = moveForward(width-1,height-1,North) (fun f -> f) in remove listOrg [] ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () with | Nil -> (fun () -> Nil) | Cons(x1,xs1) -> match seq2 () with | Nil -> (fun () -> Nil) | Cons(x2,xs2) -> (fun () -> Cons( (x1, x2), zip xs1 xs2) )    let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons(x,xs) -> if p x then (fun () -> Nil) else (fun () -> Cons(x, keep_until p xs) )   let to_list (seq : 'a seq) : 'a list = let rec formList (ins : 'a seq) : 'a list = match ins () with | Nil -> [] | Cons(x,xs) -> x :: formList xs in formList seq    let range (start : int) (step : int) (stop : int) : int seq = let fn = map (fun x -> start + step*x) nats in let raiseError () =  raise (Invalid_argument \"infinite sequence\") in  if start<stop && step <= 0 then raiseError (); if start>stop && step >= 0 then raiseError ();  try if start == stop then fun () -> Nil else if step < 0 then keep_until (fun x-> x<=stop) fn else keep_until (fun x-> x>=stop) fn with _ -> raiseError () end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one =  {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = let n1 = a.num*b.den + b.num*a.den in let n2 = a.den*b.den in let rec gcd a b = if b = 0 then a else gcd b (a mod b) in let factor = gcd n1 n2 in {num = n1/factor; den = n2/factor}  let mul a b = let n1 = a.num*b.num in let n2 = a.den*b.den in let rec gcd a b = if b = 0 then a else gcd b (a mod b) in let factor = gcd n1 n2 in {num = n1/factor; den = n2/factor}  let neg a =  {num = -1 * a.num; den = a.den} let inv a =  {num = a.den; den = a.num} end module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one =  true  let equal = (=)  let add a b = if a && b then false else a || b  let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (length_x, length_y) = MazeGen.dims maze in let next_cell x_i y_i dir = match dir with | MazeGen.North -> (x_i, (y_i- 1 ), dir) | MazeGen.South -> (x_i, (y_i +1), dir) | MazeGen.West -> ((x_i-1), y_i, dir) | MazeGen.East -> ((x_i+1), y_i, dir) in let rec traverse (x, y, dir as state) f s = if x = 0 && y = 0 then s([]) else let (right, forward, left) = MazeGen.dirs_to_check dir in if not (MazeGen.has_wall maze state) then let (x_t, y_t , dir) = next_cell x y dir in (fun () -> traverse ( x_t, y_t, forward) (fun () -> traverse ( x_t, y_t, left) f (fun r -> s(dir::r)) ) (fun r -> s(dir::r))) (fun r-> s(dir::r)) else f () in traverse ((length_x - 1), (length_y -1), MazeGen.North) (fun () -> traverse ((length_x - 1), (length_y -1), MazeGen.West)  (fun () -> raise NotFound) (fun r -> r)) (fun r -> r)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1(), seq2() with | Cons (h, tf), Cons (h2, tf2) -> Cons((h,h2), zip tf tf2) | _ , _ ->  Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with |Cons (h, tf) -> if (p h) == false then Cons(h, keep_until p tf) else Nil | _ -> Nil  let to_list (seq : 'a seq) : 'a list = let rec traverse_list s = match s() with | Cons (h, tf) -> h::(traverse_list tf) | Nil -> [] in traverse_list seq  let range (start : int) (step : int) (stop : int) : int seq = if (start > stop) && (step > 0) then raise (Invalid_argument (\"invalid input for stop and start\")) else if start < stop && step < 0 then raise (Invalid_argument (\"invalid input\")) else if step == 0 then raise (Invalid_argument (\"step cant be 0\")) ;  if step > 0 then Seq.map (fun r -> r*step + start) (keep_until (fun nat -> (nat*step + start) >= stop) nats) else Seq.map (fun r -> r*step + start) (keep_until (fun nat -> (nat*step + start) <= stop) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num =0; den =1} let one = { num = 1; den =1} let add a b =  { num = (a.num*b.den + b.num*a.den); den = (a.den*b.den)} let  neg a =   { num = (a.num * -1); den = (a.den)} let inv a = {num = a.den; den = a.num} let mul a b = { num = (a.num * b.num); den = (a.den * b.den)}   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b =  (a && (b == false)) || (b && (a == false)) let  neg a =  a let inv a = a let mul a b = match a,b with | true, true -> true | _, _ -> false    let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let get_coords x y dir = match dir with | MazeGen.North -> (x,y-1,dir) | MazeGen.South -> (x,y+1,dir) | MazeGen.West -> (x-1,y,dir) | MazeGen.East -> (x+1,y,dir) in let rec solve s wall success failure = if wall then failure () else match s with |(0,0,_)-> success [] |(a,b,d)-> let (x,y,z) = MazeGen.dirs_to_check d in solve (get_coords a b x) (MazeGen.has_wall maze (a,b,x)) (fun r -> success (x::r)) (fun () -> solve (get_coords a b y) (MazeGen.has_wall maze (a,b,y)) (fun r -> success (y::r)) (fun () -> solve (get_coords a b z) (MazeGen.has_wall maze (a,b,z)) (fun r -> success (z::r)) failure))  in let (p,q) = MazeGen.dims maze in solve (p-1,q-1,MazeGen.North) false (fun r -> r)  (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (),seq2 ()) with | (Cons (a,b),Cons(c,d)) -> fun() -> Cons ( (a,c) ,zip b d ) | (Nil,_) -> fun() -> Nil | (_,Nil) -> fun() -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun()->Nil | Cons (a,b) -> if p a then fun() -> Nil else fun() -> Cons(a,keep_until p b)  let to_list (seq : 'a seq) : 'a list = let rec to_list_rec (seq : 'a seq) = match seq() with |Nil -> [] |Cons (a,b) -> a :: to_list_rec b in to_list_rec seq let range (start : int) (step : int) (stop : int) : int seq = let n = if stop>start then (stop-start)/step else (start-stop)/(-1*step) in if n<1 then raise (Invalid_argument \"Sorry your arguments are invalid\") else let n = if start+n*step=stop then n else n+1 in let pred a = a==n in let se = keep_until pred nats in let f a = start+(a*step) in Seq.map f se end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0;den=1} let one = {num=1;den=1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den   let add a b = if a.den==0 || b.den==0 then raise DivideByZero else {num=(a.num*b.den)+(a.den*b.num);den=a.den*b.den} let mul a b = if a.den==0 || b.den==0 then raise DivideByZero else {num=a.num*b.num;den=a.den*b.den}  let neg a = if a.den == 0 then raise DivideByZero else {num=a.num*(-1);den=a.den} let inv a = if a.num == 0 then raise DivideByZero else {num=a.den;den=a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = match (a,b) with |(false,false) -> false |(true,true) -> false |(_,_) -> true let mul a b = match (a,b) with |(true,true) -> true | (_,_) -> false  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (dimensions : int * int) = MazeGen.dims maze in let getX (x, _) = x - 1 in let getY (_, y) = y - 1 in let getFst (x, _, _) = x in let getSnd (_, y, _) = y in let getTrd (_, _, z) = z in let move (x, y, z) : (MazeGen.state) = match z with | MazeGen.North -> (x, y - 1, MazeGen.North) | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.South -> (x, y+1, MazeGen.South) | MazeGen.East -> (x+1, y, MazeGen.East) in let (coord : MazeGen.state) = (getX dimensions, getY dimensions, MazeGen.North) in let rec solve (cc : MazeGen.state) (ls : MazeGen.dir list) fail cont : MazeGen.dir list = match cc with | (0, 0, _) -> cont ls | (_, _, _) -> let check = MazeGen.dirs_to_check (getTrd cc) in let a = MazeGen.has_wall maze (getFst cc, getSnd cc, getFst check) in let b = MazeGen.has_wall maze (getFst cc, getSnd cc, getSnd check) in let c = MazeGen.has_wall maze (getFst cc, getSnd cc, getTrd check) in match a, b, c with | false, true, true -> solve (move (getFst cc, getSnd cc, getFst check)) ls fail (fun r -> cont ((getFst check)::r)); | true, false, true -> solve (move (getFst cc, getSnd cc, getSnd check)) ls fail (fun r -> cont ((getSnd check)::r)); | true, true, false -> solve (move (getFst cc, getSnd cc, getTrd check)) ls fail (fun r -> cont ((getTrd check)::r)); | false, false, true -> solve (move (getFst cc, getSnd cc, getFst check)) ls (fun () -> solve (move (getFst cc, getSnd cc, getSnd check)) ls fail (fun r -> cont ((getSnd check)::r))) (fun r -> cont ((getFst check)::r)); | true, false, false -> solve (move (getFst cc, getSnd cc, getSnd check)) ls (fun () -> solve (move (getFst cc, getSnd cc, getTrd check)) ls fail (fun r -> cont ((getTrd check)::r))) (fun r -> cont ((getSnd check)::r)); | false, true, false -> solve (move (getFst cc, getSnd cc, getFst check)) ls (fun () -> solve (move (getFst cc, getSnd cc, getTrd check)) ls fail (fun r -> cont ((getTrd check)::r))) (fun r -> cont ((getFst check)::r)); | false, false, false -> solve (move (getFst cc, getSnd cc, getFst check)) ls (fun () -> solve (move (getFst cc, getSnd cc, getSnd check)) ls (fun () -> solve (move (getFst cc, getSnd cc, getTrd check)) ls fail (fun r -> cont ((getTrd check)::r))) (fun r -> cont ((getSnd check)::r))) (fun r -> cont ((getFst check)::r)); | true, true, true -> fail () in solve coord [] (fun () -> []) (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, Nil -> empty | Cons(x, xs), Nil -> empty | Nil, Cons(y, ys) -> empty | Cons(x, xs), Cons(y, ys) -> (fun () -> Cons( (x, y), (zip xs ys))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(x, xs) -> if p x then empty else (fun () -> Cons(x, keep_until p xs)) let to_list (seq : 'a seq) : 'a list = let rec to_list' (seq' : 'a seq) : 'a list = match seq'() with | Nil -> [] | Cons(x, xs) -> x::(to_list' xs) in to_list' seq let range (start : int) (step : int) (stop : int) : int seq = let rec range' (start' : int) (step' : int) (stop' : int) (current : int) = if current >= stop' then empty else (fun () -> Cons(current, range' start' step' stop' (current + step'))) in let rec rangeN' (start' : int) (step' : int) (stop' : int) (current : int) = if current <= stop' then empty else (fun () -> Cons(current, rangeN' start' step' stop' (current + step'))) in if step > 0 then range' start step stop start else rangeN' start step stop start end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = ((a.num * b.den) + (b.num * a.den)); den = (a.den * b.den)} let mul a b = {num = (a.num * b.num); den = (a.den * b.den)} let inv a = {num = a.den; den = a.num} let neg a = {num = (-a.num); den = a.den} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = not (a = b) let mul a b = a && b let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let str1 = seq1 () in let str2 = seq2 () in match (str1, str2) with | Nil,_ | _, Nil -> empty | Cons(x, next_seq1), Cons(y, next_seq2) -> cons(x,y) (zip next_seq1 next_seq2) ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let str = seq () in match str with | Nil -> empty | Cons (x, seq) -> if (p x) then empty else append (return x) (keep_until p (seq)) let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let width, height = MazeGen.dims maze in  let rec solver maze cur_pos succeed fail = let (x, y, dir) = cur_pos in if x = 0 && y = 0 then List.rev succeed else let move (cur_pos : MazeGen.state) = let (x, y, dir) = cur_pos in match dir with | MazeGen.North -> (x, y-1, MazeGen.North) | MazeGen.South -> (x, y+1, MazeGen.South) | MazeGen.East -> (x+1, y, MazeGen.East) | MazeGen.West -> (x-1, y, MazeGen.West) in  let (right, forward, left) = MazeGen.dirs_to_check dir in let r_wall, f_wall, l_wall = (MazeGen.has_wall maze (x, y, right), MazeGen.has_wall maze (x, y, forward), MazeGen.has_wall maze (x, y, left)) in  match (r_wall, f_wall, l_wall) with | false, false, false -> solver maze (move (x, y, right)) (right::succeed) (fun () -> solver maze (move (x, y, forward)) (forward::succeed) (fun () -> solver maze (move (x, y, left)) (left::succeed) fail) ) | false, true, true -> solver maze (move (x, y, right)) (right::succeed) fail | true, false, true -> solver maze (move (x, y, forward)) (forward::succeed) fail | true, true, false -> solver maze (move (x, y, left)) (left::succeed) fail | false, false, true -> solver maze (move (x, y, right)) (right::succeed) (fun() -> solver maze (move (x, y, forward)) (forward::succeed) fail) | false, true, false -> solver maze (move (x, y, right)) (right::succeed) (fun() -> solver maze (move (x, y, left)) (left::succeed) fail) | true, false, false -> solver maze (move (x, y, forward)) (forward::succeed) (fun() -> solver maze (move (x, y, left)) (left::succeed) fail)  in solver maze (width-1, height-1, MazeGen.North) [] (fun () -> [])  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | ( Nil, Nil ) -> (fun() -> Nil) | ( Cons(_, _), Nil) -> (fun() -> Nil) | ( Nil, Cons(_, _) ) -> (fun() -> Nil) | ( Cons(a, b), Cons (c, d)) -> (fun() -> Cons((a, c), zip b d ))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> (fun() -> Nil) | Cons(a, b) -> if (p a) then (fun() -> Nil) else (fun() -> Cons(a, keep_until p b)) let to_list (seq : 'a seq) : 'a list = let rec helper seq acc = match seq() with | Nil -> acc | Cons(a, b) -> a :: (helper b acc) in helper seq [] let range (start : int) (step : int) (stop : int) : int seq = if ((step = 0) || (start < stop && step < 0) || (start > stop && step > 0)) then raise (Invalid_argument \"Diverging sequence is infinite :(\" ) else let nats_mapped = Seq.map (fun x -> (step*x)+start) nats in if (step > 0) then keep_until (fun x -> x >= stop) nats_mapped else keep_until (fun x -> x <= stop) nats_mapped   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one = {num = 1; den = 1} let equal a b = if a.den = 0 || b.den = 0 then raise DivideByZero else (a.num = b.num) && (a.den = b.den) let add a b = if a.den = 0 || b.den = 0 then raise DivideByZero else { num = (a.num * b.den) + (b.num * a.den) ; let mul a b = if a.den = 0 || b.den = 0 then raise DivideByZero else let neg a = if a.den = 0 then raise DivideByZero else let inv a = if a.den = 0 then raise DivideByZero else  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let add a b = match a, b with | false, false -> false | true, true -> false | _, _ -> true let mul = (&&) let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let oppositeDir (d:MazeGen.dir): MazeGen.dir = match d with |East -> West |West -> East |North -> South |South -> North in  let nextMove maze state : MazeGen.dir = let (x,y,facing) = state in let (a,b,c) = MazeGen.dirs_to_check facing in  if not (MazeGen.has_wall maze (x, y, a)) then a else if not (MazeGen.has_wall maze (x, y, b)) then b else if not (MazeGen.has_wall maze (x, y, c)) then c else oppositeDir facing in  let takeStep coords (d:MazeGen.dir): MazeGen.state = let (x, y) = coords in match d with |East -> (x+1, y, East) |West -> (x-1, y, West) |North -> (x, y-1, North) |South -> (x, y+1, South) in  let rec solve_maze' maze state cont: MazeGen.dir list = match state with |(0,0,_) -> cont [] |(a,b,c) -> let nextDir = nextMove maze state in let nextPosition = takeStep (a,b) nextDir in solve_maze' maze nextPosition (fun r -> match r with |hd::tl -> if (oppositeDir nextDir) = hd then (cont (tl)) else (cont (nextDir::r)) |_ -> (cont (nextDir::r))) in  let (w,h) = MazeGen.dims maze in solve_maze' maze (w-1,h-1,North) (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> let s1 = seq1 () in let s2 = seq2 () in match (s1, s2) with |(Seq.Cons (hd1,tl1), Seq.Cons (hd2,tl2)) -> Seq.Cons ((hd1, hd2), zip tl1 tl2) |_ -> Seq.Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with |Seq.Cons(hd, tl) -> if p hd then Seq.Nil else Seq.Cons (hd, keep_until p tl) |_ -> Seq.Nil let to_list (seq : 'a seq) : 'a list =  let rec to_list' (seq: 'a seq) (l : 'a list) cont: 'a list = let seq = seq () in match seq with |Seq.Cons (hd,tl) -> to_list' tl l (fun r -> cont (hd::r)) |_ -> cont l in to_list' seq [] (fun r -> r) let range (start : int) (step : int) (stop : int) : int seq =  let checkValidity (start : int) (step : int) (stop : int): bool = if (stop-start)*(step) > 0 then true else let ex = Invalid_argument \"Stop value will never be reached given the start and step values. Please check the sign of your inputs.\" in raise ex in  let limCheck (x: int): bool = if step >0 then x >= stop else x <= stop in  let intToEntry (index: int) : int = start + (index*step) in  let x = checkValidity start step stop in let infSeq = Seq.map intToEntry nats in keep_until limCheck infSeq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0; den=1} let one = {num=1; den=1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den <> 0 && b.den <> 0 then let num' = (a.num * b.den) + (b.num * a.den) in {num = num' ; den = (a.den*b.den)} else raise DivideByZero  let mul a b = if a.den <> 0 && b.den <> 0 then {num = (a.num * b.num) ; den = (a.den*b.den)} else raise DivideByZero  let neg a = if a.den <> 0 then {num = (a.num * (-1)) ; den = a.den} else raise DivideByZero  let inv a = if a.den <> 0 then {num = a.den ; den = a.num} else raise DivideByZero end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq   let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Cons(h1,t1), Cons(h2,t2) -> fun () -> Cons((h1,h2), zip t1 t2) | Nil, _ | _, Nil -> fun () -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Cons(h,t) -> if p h then fun() -> Nil else fun() -> Cons(h, keep_until p t) | Nil -> fun() -> Nil  let to_list (seq : 'a seq) : 'a list = let rec list seq l = match seq() with | Cons(h,t) -> h :: list t l | Nil -> l in list seq []    let range (start : int) (step : int) (stop : int) : int seq = let m = step in if m > 0 && start < stop then match nats() with | Nil -> fun() -> Nil | Cons(h, t) -> fun() -> let h = start in let x = map (fun step -> m * (step) + h) nats in match x() with | Nil -> Nil | Cons(h1,t1) -> Cons(h1, keep_until (fun h -> h >= stop) t1) else if m < 0 && start > stop then match nats() with | Nil -> fun() -> Nil | Cons(h2, t2) -> fun() -> let h2 = start in let x = map (fun step -> m * (step) + h2) nats in match x() with | Nil -> Nil | Cons(h3, t3) -> Cons(h3, keep_until (fun h3 -> h3 <= stop) t3) else if start == stop then let _ = nats () in fun () -> Nil else raise (Invalid_argument \"This will lead to an infinite loop.\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let add a b = {num = (a.num * b.den) + (a.den * b.num) ; den = (a.den * b.den)}  let mul a b = {num = (a.num * b.num); den = (a.den * b.den)} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add a b = match a,b with | false, false -> false | false, true -> true | true, false -> true | true, true -> false  let mul a b = match a,b with | false, _ -> false | _, false -> false | true, true -> true  let neg a = match a with | false -> false | true -> true  let inv a = match a with | false -> false | true -> true  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in  let move_towards (x, y, dir) : MazeGen.state = match dir with | MazeGen.West -> (x-1, y, dir) | MazeGen.East -> (x+1, y, dir) | MazeGen.North -> (x, y-1, dir) | MazeGen.South -> (x, y+1, dir) in  let rec next_step (x, y, dir) sc fc : MazeGen.dir list = let (r, f, l) = MazeGen.dirs_to_check dir in  if x = 0 && y = 0 then sc [] else if (MazeGen.has_wall maze (x, y, dir)) then fc () else let (nx, ny, _) = move_towards (x, y, dir) in  next_step (nx, ny, r) (fun d -> sc (r :: d)) (fun () -> next_step (nx, ny, f) (fun d -> sc (f :: d)) (fun () -> next_step (nx, ny, l) (fun d -> sc (l :: d)) fc ) )  in let (x, y, dir) = (width - 1, height - 1, MazeGen.North) in next_step (x, y, dir) (fun d -> d ) (fun () -> raise NotFound ) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ | _, Nil -> (fun () -> Nil) | (Cons (v1, s1)), (Cons (v2, s2)) -> (fun () -> Cons ((v1, v2), zip s1 s2) )  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (v, s) -> if p v then (fun () -> Nil) else (fun () -> Cons (v, keep_until p s) )  let to_list (seq : 'a seq) : 'a list = let rec make_list seq succ = match seq () with | Nil -> succ [] | Cons (v, s) -> make_list s (fun e -> succ (v :: e)) in make_list seq (fun e -> e) let range (start : int) (step : int) (stop : int) : int seq = if step = 0 || (start < stop && step < 0) || (start > stop && step > 0) then raise (Invalid_argument \"invalid argument! \")  else let rec repeat (x : 'a) : 'a seq = fun () -> Cons (x, repeat x) in let rec addStreams seq1 seq2 = let (Cons (v1, s1)), (Cons (v2, s2)) = seq1 (), seq2 () in (fun () -> Cons ((v1 + v2), addStreams s1 s2) ) in   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den = b.den then {num = a.num + b.num; den = a.den} else {num = (a.num * b.den + a.den * b.num); den = (a.den * b.den)} let mul a b = {num = (a.num * b.num); den = (a.den * b.den)} let neg a = {num = - a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero : t = false let one : t = true  let equal = (=)  let add (a:t) (b:t) : t = match a, b with | true, false | false, true -> true | true, true | false, false -> false  | false, _ | _, false -> false | true, true -> true  let neg (a:t) : t = match a with | true -> true | false -> false  let inv (a:t) : t = match a with | true -> true | false -> false end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_cell (n: MazeGen.state) : MazeGen.state = let (x, y, dir) = n in match dir with | MazeGen.West -> (x-1, y, dir) | MazeGen.East -> (x+1, y, dir) | MazeGen.North -> (x, y-1, dir) | MazeGen.South -> (x, y+1, dir) in  let mystate1 = let (x, y) = MazeGen.dims (maze) in ((x-1), (y-1), MazeGen.North) in  let rec solve_helper mystate sc fc = match mystate with |  (0, 0, _) -> List.rev sc |  (x, y, dir) -> let (rgt, fwd, lft) = MazeGen.dirs_to_check dir in  let fc_lft = fun () -> solve_helper (next_cell (x, y, lft)) (lft::sc) fc in  let fc_fwd_wall_left = fun () -> solve_helper (next_cell (x, y, fwd)) (fwd::sc) fc in let fc_fwd_no_wall_left = fun () -> solve_helper (next_cell (x, y, fwd)) (fwd::sc) fc_lft in  match (not (MazeGen.has_wall maze (x, y, rgt)), not (MazeGen.has_wall maze (x, y, fwd)), not (MazeGen.has_wall maze (x, y, lft))) with |(true, true, true) -> solve_helper (next_cell (x, y, rgt)) (rgt::sc) fc_fwd_no_wall_left |(true, true, false) -> solve_helper (next_cell (x, y, rgt)) (rgt::sc) fc_fwd_wall_left  |(true, false, true) -> solve_helper (next_cell (x, y, rgt)) (rgt::sc) fc_lft  |(true, false, false) -> solve_helper (next_cell (x, y, rgt)) (rgt::sc) fc  |(false, true, true) -> solve_helper (next_cell (x, y, fwd)) (fwd::sc) fc_lft  |(false, true, false) -> solve_helper (next_cell (x, y, fwd)) (fwd::sc) fc  |(false, false,true) ->  solve_helper (next_cell (x, y, lft)) (lft::sc) fc |(false, false, false) -> fc()     in solve_helper mystate1 [] (fun () -> raise NotFound)   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Seq.Nil, _ -> Seq.Nil | _ , Seq.Nil -> Seq.Nil | Seq.Cons (v1, s1), Seq.Cons (v2, s2) -> Seq.Cons ((v1, v2) ,  zip s1 s2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq () with | Seq.Nil -> Seq.Nil | Seq.Cons (v1, s1) -> if (p v1 ) then Seq.Nil else Seq.Cons (v1, keep_until p s1) let to_list (seq : 'a seq) : 'a list = let rec helper seq acc =  match seq () with | Seq.Nil -> List.rev acc | Seq.Cons (v1, s1) -> helper s1 (v1::acc) in helper seq [] let range (start : int) (step : int) (stop : int) : int seq =   if step = 0 then raise (Invalid_argument \"infinite loop\") else if (step > 0 && start > stop) || ( step < 0 && start < stop) then raise (Invalid_argument \"invalid start point\")  else   if step > 0 then keep_until (fun v -> v >= stop) (Seq.map (fun r -> start + r*step) nats) else keep_until (fun v -> v <= stop) (Seq.map (fun r -> start + r*step) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1}  let one  = {num = 1; den = 1}  let add = fun x y -> if x.den <> 0 && y.den <> 0 then if x.num * y.den + y.num * x.den = 0 then zero else  {num = x.num * y.den + y.num* x.den ; den = x.den * y.den} else raise DivideByZero    let mul = fun x y -> if x.den <> 0 && y.den <> 0 then if x.num * y.num = 0 then zero else if x.num * y.num = x.den * y.den then one else  {num = x.num * y.num ; den = x.den * y.den} else raise DivideByZero  let neg = fun x -> {num = - x.num; den = x.den}  let inv = fun x -> if x.num = 0 || x.den = 0 then raise DivideByZero else  {num = x.den ; den = x.num}       let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add = fun x y -> if x && y then false else not((not x) && (not y))  let mul = (&&) let neg = fun x -> x let inv = fun x -> x let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = not ( F.equal F.zero (F.add F.one (F.add F.one F.one )) || F.equal F.zero(F.add F.one F.one)) let onCurve = fun p q point -> let (x, y) = point in F.equal (F.mul y y) (F.add (F.mul x (F.mul x x)) (F.add (F.mul p x) q) ) end;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = | MazeGen.North -> (x, y - 1) | MazeGen.South -> (x, y + 1) | MazeGen.East  -> (x + 1, y) | MazeGen.West  -> (x - 1, y) in  let rec aux aList next succeed fail = match next with | (0,0,_) -> succeed [] | (x,y,z)  when MazeGen.has_wall maze (x,y,z) -> fail() | (x,y,z) ->  let (right, up, left) = MazeGen.dirs_to_check z in let (x',y') = move_up (x,y,z) in aux aList (x',y', right) (fun l -> succeed(z :: l)) ( fun() -> aux aList (x',y',up) (fun l -> succeed(z :: l)) ( fun() -> aux aList (x',y', left) (fun l -> succeed(z :: l)) fail ) ) in let (width, height) = MazeGen.dims maze in try aux [] (width-1,height-1,MazeGen.North) (fun x -> x) (fun () -> raise NotFound) with NotFound -> aux [] (width-1,height-1,MazeGen.West) (fun x -> x) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  " module Range : RangeSig = struct open Seq   let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1(), seq2() with | Nil, _ -> Nil | _, Nil -> Nil | Cons(h1,t1), Cons(h2,t2) -> Cons ((h1, h2),(zip t1 t2))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq() with | Nil -> Nil | Cons (h,t) -> if (p h) then Nil else Cons(h, keep_until p t )  let to_list (seq : 'a seq) : 'a list = let rec to_list_helper (aList: 'a list) (sequence : 'a seq) : 'a list= match sequence() with | Nil -> aList | Cons(h,t) -> to_list_helper (aList@[h]) t in to_list_helper [] seq  let range (start : int) (step : int) (stop : int) : int seq =  keep_until (fun y -> if step > 0 then y >= stop else y <= stop ) (map (fun x -> start + x  * step ) nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0;den=1} let one = {num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.den * b.num + a.num * b.den ; den = a.den * b.den} let mul a b = {num = a.num * b.num ; den = a.den * b.den} let neg a = {num = (-a.num); den = a.den} let inv a = {num = a.den; den = a.num}   end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = if a = b && a then false else a || b let mul = (&&) let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let nextcell state dir = let (x, y, _) = state in match dir with | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.North -> (x, y-1, MazeGen.North) | MazeGen.East -> (x+1, y, MazeGen.East) | MazeGen.South -> (x, y+1, MazeGen.South) in  let rec helper maze state sc fc = match state with | (0,0,_) -> sc [] | (x,y,dir) ->  let (right, front, left) = MazeGen.dirs_to_check dir in let rightcell = nextcell (x,y,dir) right in let frontcell = nextcell (x,y,dir) front in let leftcell = nextcell (x,y,dir) left in  let (norightwall, nofrontwall, noleftwall) = (not (MazeGen.has_wall maze (x,y,right)), not (MazeGen.has_wall maze (x,y,front)), not (MazeGen.has_wall maze (x,y,left))) in  match  (norightwall, nofrontwall, noleftwall)  with | (true, true, true) -> let fc1 = (fun () -> helper maze leftcell (fun r -> sc (left::r)) fc) in let fc2 = (fun () -> helper maze frontcell (fun r -> sc (front::r)) fc1) in helper maze rightcell (fun r -> sc (right::r)) fc2 | (true, true, false) -> let fc3 = (fun () -> helper maze frontcell (fun r -> sc (front::r)) fc) in helper maze rightcell (fun r -> sc (right::r)) fc3 | (true, false, true) -> let fc4 = (fun () -> helper maze leftcell (fun r -> sc (left::r)) fc) in helper maze rightcell (fun r -> sc (right::r)) fc4 | (true, false, false) -> helper maze rightcell (fun r -> sc (right::r)) fc | (false, true, true) -> let fc5 = (fun () -> helper maze leftcell (fun r -> sc (left::r)) fc) in helper maze frontcell (fun r -> sc (front::r)) fc5 | (false, true, false) -> helper maze frontcell (fun r -> sc (front::r)) fc | (false, false, true) -> helper maze leftcell (fun r -> sc (left::r)) fc | (false, false, false) -> fc () in  let (dimx, dimy) = MazeGen.dims maze in helper maze (dimx-1, dimy-1, MazeGen.North) (fun r -> r) (fun () -> [])   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze); ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | (Nil,_) | (_, Nil) -> empty | (Cons (h1, t1), Cons (h2, t2))  -> cons (h1, h2) (fun () -> zip t1 t2 ()) ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (head, tail) -> if p head then empty else cons head (keep_until p tail);; ",
  "let to_list (seq : 'a seq) : 'a list = fold_left (fun acc node -> acc @ [node]) [] seq let range (start : int) (step : int) (stop : int) : int seq = let nums = map (fun n -> start + n * step) nats in if stop > 0 then keep_until (fun n -> n >= stop) nums else keep_until (fun n -> n <= stop) nums ;; ",
  " end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num  = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.den * b.num + a.num * b.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = a.num * (-1); den = a.den} let inv a = { num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = ((not a) && b) || ((not b) && a) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "module EllipticCurves (F : AlgField) = struct type point = F.t * F.t let easyECs = let two = F.add F.one F.one in let three = F.add F.one two in (not (F.equal two F.zero)) && (not (F.equal three F.zero))  let onCurve p q point = let (x,y) = point in let y_sq = F.mul y y in let x_cub = F.mul x (F.mul x x) in let px = F.mul p x in F.equal y_sq (F.add x_cub (F.add px q))  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1()) with | Nil -> empty | Cons (x,y) -> ( match (seq2()) with | Nil -> empty | Cons (a,b) -> (fun () -> Cons((x,a), zip (y) (b)) ) ) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq()) with | Nil -> empty | Cons (x,y) -> ( if p x then empty else ( fun () -> Cons (x, keep_until p (y))) ) let to_list (seq : 'a seq) : 'a list = let rec create s = match s() with | Nil -> [] | Cons (x,y) -> x::create y in create seq let range (start : int) (step : int) (stop : int) : int seq = keep_until (fun x -> if step < 0 then (x <= stop) else (x >= stop)) (map (fun x -> start + ((x)*step)) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0 ; den = 1 } let one = { num = 1 ; den = 1 } let add a b = { num = (a.num * b.den) + (a.den * b.num) ; den = a.den * b.den} let mul a b = { num = (a.num * b.num) ; den = a.den * b.den} let neg a = {  num = a.num * (-1) ; den = a.den }  let inv a = { num = a.den ; den = if a.num = 0 then raise DivideByZero else a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let add a b = not ( a = b ) let mul a b = if a then (b) else false let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let getNextStateHelper state dir = let (x, y, _) = state in match dir with in  let (x0, y0) = MazeGen.dims maze in let initialState = ((x0-1), (y0-1), MazeGen.North) in  let rec mazeHelper maze state failCont successCont = let (x, y, dir) = state in let (right, front, left) = MazeGen.dirs_to_check dir in  let wallToRight = MazeGen.has_wall maze (x, y, right) in let wallInFront = MazeGen.has_wall maze (x, y, front) in let wallToLeft = MazeGen.has_wall maze (x, y, left) in  match (x, y) with | (0, 0) -> let _ = print_string (\"You're out!!\") in successCont [] | (_, _) -> let tryLeft = fun () -> ( if (wallToLeft) then let _ = print_string (\"Dead End\\n\") in failCont () else let nextState = getNextStateHelper state left in mazeHelper maze nextState failCont (fun l -> successCont(left::l)) ) in  let tryForward = fun () -> ( if (wallInFront) then tryLeft() else let nextState = getNextStateHelper state front in mazeHelper maze nextState tryLeft (fun l -> successCont(front::l)) ) in  if (wallToRight) then tryForward () else let nextState = getNextStateHelper state right in mazeHelper maze nextState tryForward (fun l -> successCont(right::l)) in mazeHelper maze initialState (fun () -> raise NotFound) (fun l -> l) ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq   let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons(hd1, tl1), Cons(hd2, tl2) -> fun () -> Cons((hd1, hd2), (zip tl1 tl2)) | _, _ -> fun () -> Nil   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons(hd, tl) -> if p hd then fun () -> Nil else fun () -> Cons(hd, keep_until p tl) let to_list (seq : 'a seq) : 'a list = let rec helper seq lst = match seq () with | Nil -> lst | Cons(hd, tl) -> hd::(helper tl lst) in helper seq []  let range (start : int) (step : int) (stop : int) : int seq = let f = fun x -> (start + (x * step)) in  let p = fun x -> let size = abs (stop - start) in (x > (size-1)/(abs step)) in  let seq = (keep_until p nats) in Seq.map f seq   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = ((a.num*b.den)+(b.num*a.den)); den = ((a.den*b.den))} let mul a b = {num = (a.num*b.num); den = (a.den*b.den)}  let neg a = {num = (-a.num); den = (a.den)} let inv a = {num = (a.den); den = (a.num)}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = if (a<>b<>true) then false else a || b  let mul = (&&)   end ;; ",
  "module EllipticCurves (F : AlgField) : sig  type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool  end = struct type point = F.t * F.t  let easyECs = let two = F.add (F.add F.one F.one) F.one in let three = F.add (F.add (F.add F.one F.one) F.one) F.one in not (F.equal (three) (F.zero)) && not (F.equal (two) (F.zero))  let onCurve p q point = let x = fst point in let y = snd point in  let y_square = F.mul y y in let x_cube = F.mul (F.mul x x) x in  let px = F.mul p x in  F.equal (y_square) (F.add (F.add x_cube px) (q)) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =   raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun()-> match (seq1(), seq2()) with |(Cons(n1,s1), Cons (n2, s2))-> Cons(((n1,n2), zip s1 s2)) |_-> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq  =  fun()-> match seq  ()with |Cons(a, s')->  if p a  then Nil else Cons(a, keep_until p s') |_->Nil   let to_list (seq : 'a seq) : 'a list = let rec list (s)= fun()-> match s () with |Cons(a, s')-> a::list s' () |_->[] in list seq ()  let range (start : int) (step : int) (stop : int) : int seq =   if ((start<stop) && step>0 || (start>stop) && step<0 ) then let f = fun a->start+step*a in let x = map f (nats) in let p= fun a-> if step<0 then a<=stop else a>=stop in keep_until (p) (x) else raise (Invalid_argument \"Cannot move to stop value with given starting value and step size\")    end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero:t = {num=0; den=1} let one ={num=1; den=1} let add = fun a b -> match a.den==b.den with | true-> {num=a.num+b.num; den=a.den} | false-> {num=a.num*b.den+b.num*a.den;den=a.den*b.den} let mul = fun a b-> {num=a.num*b.num; den=a.den*b.den} let neg = fun b-> {num = ~-(b.num) ;den=b.den} let inv = fun a -> {num=a.den; den=a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero:t=false let one:t=true let add=fun (a:t) (b:t)-> match a, b with |true,true->false |_,true->true |true,_->true |_,_->false let mul= fun (a:t) (b:t)-> a && b  let neg = fun (b:t)-> b let inv = fun (a:t)-> a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let a = (MazeGen.has_wall maz (x,y,r)) in let b = (MazeGen.has_wall maz (x,y,s)) in let c = (MazeGen.has_wall maz (x,y,l)) in (a,b,c)  in let update_state (x,y,d)  = match d with | MazeGen.North -> (x,y-1,d) | West -> (x-1,y,d) | South -> (x,y+1,d) | East -> (x+1,y,d) in let update_dir dir = match dir with | North -> South | West -> East | South -> North | East -> West  in  let rec next state sc fc = match state with | (0,0,_) -> sc [] | (x,y,direction) ->  let (r,s,l)= MazeGen.dirs_to_check direction in let (a) = MazeGen.has_wall maze state in if (a) then fc () else sc2 = next (updatestate state) sc@[direction] fc   in next (xa-1,ya-1,North) (fun x->x) (fun ()->[]) *) raise NotImplemented    ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with | Nil,_ -> Seq.empty | _,Nil -> Seq.empty | Cons(x,y),Cons(t,l) -> fun() -> (Cons((x,t), zip y l))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> Seq.empty | Cons(a,b) -> if (p a) then empty else fun () -> (Cons(a, keep_until p b)) let to_list (seq : 'a seq) : 'a list = let rec to_l seq = match seq() with |Nil->[] |Cons(a,b)-> a::(to_l b) in to_l seq  let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented       end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0; den=1} let one = {num=1; den=1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.num=0 then b else if b.num = 0 then a else {num = (a.num*b.den+b.num*a.den); den = (a.den*b.den)}  let mul a b = if a.num = 0 || b.num = 0 then zero else if a = {num=1; den=1} then b else if b = {num=1; den=1} then a else {num = (a.num*b.num); den = (a.den*b.den)}  let neg a = {num = -a.num; den = a.den}   let inv a = {num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = if not(a) then b else if not(b) then a else zero  let mul a b = if not(a) then false else b   let neg a = a  let inv = neg  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let change (x,y,d) = match d with | MazeGen.West -> (x-1,y,d) | MazeGen.North -> (x,y-1,d) | MazeGen.East -> (x+1,y,d) | MazeGen.South -> (x,y+1,d) in let rec next_state curr_s fc sc = let (x,y,z) = curr_s in let possibilities = MazeGen.dirs_to_check z in let (a,b,c) = possibilities in if (x = 0 && y = 0) then sc [] else match  (not (MazeGen.has_wall maze (x,y,a))) with | true -> next_state (change (x,y,a)) (fun () -> if (not (MazeGen.has_wall maze (x,y,b))) then next_state (change (x,y,b)) (fun () -> if (not (MazeGen.has_wall maze (x,y,c))) then next_state (change (x,y,c)) (fun () -> fc ()) (fun r -> sc (c::r)) else fc ()) (fun r -> sc (b::r)) else if (not (MazeGen.has_wall maze (x,y,c))) then next_state (change (x,y,c)) (fun () -> fc ()) (fun r -> sc (c::r)) else fc ()) (fun r -> sc (a::r)) | _ -> (if (not (MazeGen.has_wall maze (x,y,b))) then next_state (change (x,y,b)) (fun () -> if (not (MazeGen.has_wall maze (x,y,c))) then next_state (change (x,y,c)) (fun () -> fc ()) (fun r -> sc (c::r)) else fc ()) (fun r -> sc (b::r)) else if (not (MazeGen.has_wall maze (x,y,c))) then next_state (change (x,y,c)) (fun () -> fc ()) (fun r -> sc (c::r)) else fc ()) in  let m = MazeGen.dims maze in let (x,y) = m in let hori = x-1 in let vert = y-1 in let curr = hori,vert,MazeGen.West in   next_state curr (fun () -> []) (fun a -> a) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with | (Nil,_) -> Nil | (_,Nil) -> Nil | (Cons (a,b),Cons (c,d)) -> (Cons ((a,c),zip b d))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match (seq ()) with | Nil -> Nil | Cons (a,b) -> if p a then Nil else Cons(a,keep_until p b) let to_list (seq : 'a seq) : 'a list = let rec transform seq list = match (seq ()) with | Nil -> list | Cons (a,b) -> transform b (list @ (a::[])) in transform seq [] let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument \"Step must be non-zero\") else if (start>stop && step > 0 || start<stop && step < 0) then raise (Invalid_argument \"The step gives an infinite sequence\") else keep_until (fun x-> if stop>0 then x>=stop else x<=stop) (map (fun x -> (x * step)+start) nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num =1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = (a.num * b.den + b.num * a.den); den = (a.den * b.den)} let mul a b = {num = (a.num  * b.num); den = (a.den * b.den)} let neg a = {num = (0 - a.num);den = a.den} let inv a = {num = a.den; den = a.num}   end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let id x = x in let next tup  (a : MazeGen.dir) : (int * int) = let (x, y) = tup in match a with |MazeGen.North -> (x, y - 1) |MazeGen.South -> (x, y + 1) |MazeGen.East -> (x + 1, y) |MazeGen.West -> (x - 1, y) in let (x_start, y_start) = MazeGen.dims maze in let rec move state s_cont f_cont = let (x, y, dir) = state in match (x, y) with | (0, 0) -> s_cont [] | _ -> let (r, s, l) = MazeGen.dirs_to_check dir in if not (MazeGen.has_wall maze (x, y, r)) then let (new_x, new_y) = next (x, y) r in move (new_x, new_y, r) (fun t -> s_cont(r::t)) (fun() -> if not(MazeGen.has_wall maze (x, y, s)) then let (new_x, new_y) = next (x, y) s in move (new_x, new_y, s) (fun t -> s_cont(s::t)) (fun() -> if not(MazeGen.has_wall maze (x, y, l)) then let (new_x, new_y) = next (x, y) l in move (new_x, new_y, l) (fun t-> s_cont (l::t)) f_cont else else if not(MazeGen.has_wall maze (x, y, l)) then let (new_x, new_y) = next (x, y) l in move (new_x, new_y, l) (fun t-> s_cont(l::t)) f_cont else f_cont()) else if not (MazeGen.has_wall maze (x, y, s)) then let (new_x, new_y) = next (x, y) s in move (new_x, new_y, s) (fun t -> s_cont(s::t)) (fun() -> if not (MazeGen.has_wall maze (x, y, l)) then let (new_x, new_y) = next (x, y) l in move (new_x, new_y, l) (fun t -> s_cont(l::t)) (f_cont) else f_cont()) else if not (MazeGen.has_wall maze (x, y, l)) then let (new_x, new_y) = next (x, y) l in move(new_x, new_y, l) (fun t-> s_cont(l::t)) (f_cont) else f_cont() in move (x_start-1, y_start-1, MazeGen.North) id (fun() -> move (x_start-1, y_start-1, MazeGen.West) id (fun() -> raise NotFound))  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1(), seq2() with |Nil, _ -> Nil |_, Nil -> Nil |Cons(a, b), Cons(c, d) -> Cons ((a,c) , zip b d)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq() with |Nil -> Nil |Cons(a, b) -> if p a then Nil else Cons(a, keep_until p b) let to_list (seq : 'a seq) : 'a list = let rec eval b = match b with |Nil -> [] |Cons(a, c) -> a::(eval(c())) in eval(seq()) let range (start : int) (step : int) (stop : int) : int seq = if start < stop && step < 0 || start > stop && step > 0 then let a = \"Error: infinite\" in raise (Invalid_argument a) else if step = 0 then raise (Invalid_argument \"Cannot have 0 step\") else if step > 0 then (Seq.map(fun x -> x * step + start) nats) else keep_until (fun a -> a <= stop) (Seq.map(fun x -> x * step + start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero : t = let a = {num = 0; den = 1} in a let one : t = let a = {num = 1; den = 1} in a let equal (a : t) (b : t) : bool = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add (a : t) (b : t) : t = let x = ((a.num * b.den) + (b.num * a.den)) in let y = a.den * b.den in let r = {num = x; den = y} in r let mul (a : t) (b : t) : t = let x = a.num * b.num in let y = a.den * b.den in let r = {num = x; den = y} in r let neg (a : t) : t = let x = 0 - a.num in let r = {num = x; den = a.den} in r let inv (a : t) : t = let r = {num = a.den; den = a.num} in r end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero : t = false let one : t = true let equal (a : t) (b : t) : bool = if (a=b) then one else zero let add (a : t) (b : t) : t = if (a&&not(b))||(not(a)&&b) then one else zero let mul (a : t) (b : t) : t = if (a&&b) then one else zero let neg (a : t) : t = if a = one then one else zero let inv (a : t) : t = if a = one then one else zero   end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w,h) = MazeGen.dims maze in let nextCell (x, y, d)  = match d with | MazeGen.West -> (x-1, y, d) | MazeGen.East -> (x+1, y, d) | MazeGen.North -> (x, y-1, d) | MazeGen.South -> (x, y+1, d) in let rec aux maze (x,y,d) sc fc =  if  (MazeGen.has_wall maze (x,y,d)) then fc () else let (x1,y1,_) = nextCell (x,y,d) in if (x1=0 && y1 = 0) then sc [] else let (r,f,l) = MazeGen.dirs_to_check d in let fc3 = fun () -> aux maze  (x1, y1, l) (fun ls -> sc (l::ls)) fc in let fc2 = fun () -> aux maze (x1, y1, f) (fun ls -> sc (f::ls)) fc3 in aux maze (x1, y1, r) (fun ls -> sc (r::ls)) fc2 in let fc =  fun () -> raise NotFound in let fc1 = fun () -> aux maze  (w-1, h-1, MazeGen.West) (fun ls -> MazeGen.West::ls) fc in (aux maze (w-1, h-1, MazeGen.North) (fun ls -> MazeGen.North::ls ) fc1)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ -> fun () -> Nil | _, Nil -> fun () -> Nil | Cons(x,xs), Cons(y, ys) -> fun () -> Cons ((x, y), (zip (xs ) (ys ))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons(x, _)  when p x -> fun () -> Nil | Cons(x, xs) -> fun () -> Cons(x, keep_until p xs) let to_list (seq : 'a seq) : 'a list = fold_left (fun xs x -> xs @ [x]) [] seq let range (start : int) (step : int) (stop : int) : int seq = let seq = map (fun x -> start + (step * x)) nats in if step > 0 then if start > stop then raise (Invalid_argument \"Stop will never be reached\") else keep_until (fun x -> x >= stop) seq else if step < 0 then if start < stop then raise (Invalid_argument \"Stop will never be reached\") else keep_until (fun x -> x <= stop) seq else raise (Invalid_argument \"Can't have a step of 0\")   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ Range.to_list(range 10); Range.to_list(range ~start:5 10); Range.to_list(range ~step:2 20); Range.to_list(range ~start:(-3) ~step:(1) (28));   ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den=1} let one = {num = 1; den=1}  let add a b = { num = (a.num * b.den) + (b.num * a.den); den = a.den * b.den}  let inv a = if a.num = 0 then raise DivideByZero else {num = a.den; den = a.num} let mul a b = { num = (a.num * b.num); den = a.den * b.den} let neg a = {num = a.num * (-1); den = a.den}   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add a b = if a && b then false else a || b let mul = (&&) let inv a = a let neg a = a  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let step_helper (state : MazeGen.state) : MazeGen.state = let (x, y, dir) = state in match dir with | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.North -> (x, y - 1, MazeGen.North) | MazeGen.East -> (x + 1, y, MazeGen.East) | MazeGen.South -> (x, y + 1, MazeGen.South) in let rec aux maze state sc fc = let (x0, y0, _) = state in if (x0,y0) = (0, 0) then sc [] else if MazeGen.has_wall maze state then fc () else let newState = step_helper state in let (x1,y1, dir) = newState in let (r, s, l) = MazeGen.dirs_to_check dir in sc (aux maze (x1, y1, r) (fun sc -> r::sc) (fun () -> aux maze (x1, y1 ,s) (fun sc -> s::sc) (fun () -> aux maze (x1, y1, l) (fun sc -> l::sc) (fun () -> aux maze (x0, y0, l) sc fc )))) in let (x, y) = MazeGen.dims maze in let nextStep : MazeGen.state = (x - 1, y - 1, MazeGen.North) in  aux maze nextStep (fun sc -> MazeGen.North::sc) (fun () -> aux maze (x - 1, y - 1, MazeGen.West) (fun sc -> MazeGen.West::sc) (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "test_maze 3 3;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons(el1,xs1) , Cons(el2,xs2) -> fun () -> Cons((el1, el2),(zip xs1 xs2)) | _ -> fun () -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Cons(el, xs) -> if p el then fun () -> Nil else fun () -> Cons (el, keep_until p xs) |_ -> fun () -> Nil  let to_list (seq : 'a seq) : 'a list = let rec aux (seq : 'a seq) (sc : 'a list -> 'a list) : 'a list = match seq () with |Cons(el, xs) -> aux xs (fun x -> sc (el::x)) |_ -> sc [] in aux seq (fun x -> x) let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument \"Step is equal to 0 (constant sequence)\") else if ((start > stop) && (step > 0)) || ((start < stop) && (step < 0)) then raise (Invalid_argument \"Stop value can never be reached\") else let aux start step p = keep_until p (Seq.map (fun x -> start + (x * step)) nats) in if step > 0 then let p = fun x -> x >= stop in aux start step p else let p = fun x -> x <= stop in aux start step p end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + b.num * a.den; den = b.den * a.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = - a.num; den = a.den} let inv a = {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = not (a = b) let mul a b = (a, b) = (true, true) let neg a = a let inv = neg end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in let get_next (s : MazeGen.state) = let (x, y, dir) = s in match dir with | North -> (x, y-1, dir) | South -> (x, y+1, dir) | East -> (x+1, y, dir) | West -> (x-1, y, dir) in   let get_dir s = let (_, _, dir) = s in dir in  let start = MazeGen.dims maze in let (startx, starty) = start in  let rec navigate maze (s : MazeGen.state) succ fail =  match s with | (0, 0, _) -> succ [] | _ when MazeGen.has_wall maze s -> fail () | (_, _, dir) ->  let (newx, newy, newdir ) = get_next s in let (rt, fd, lf) = MazeGen.dirs_to_check dir in  navigate maze (newx, newy, rt) (fun l -> succ (dir::l)) (fun() -> navigate maze (newx, newy, fd) (fun l -> succ (dir::l)) (fun () -> navigate maze (newx, newy, lf) (fun l -> (succ (dir::l))) fail )) in navigate maze (width-1, height-1, MazeGen.North) (fun l -> l) (fun () -> navigate maze (startx-1, starty -1, MazeGen.West) (fun l -> l) (fun () -> [])) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1(), seq2()) with | (Cons (x, seq1'), Cons (y, seq2')) -> Cons ((x,y), zip seq1' seq2') | (Nil, _)  -> Nil | (_, Nil)  -> Nil ;; ",
  "   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with | Nil ->  Nil | Cons (v, seq') -> if not(p v) then Cons(v, keep_until p seq') else Nil  ;; ",
  "    let to_list (seq : 'a seq) : 'a list = let rec iterate l = match l() with | Nil -> [] | Cons (v, seq') -> (v :: (iterate seq')) in iterate seq ;; ",
  "      let range (start : int) (step : int) (stop : int) : int seq =  if stop > start && step <= 0 then raise (Invalid_argument \"This is an infinite sequence\") else if stop < start && step >= 0 then raise (Invalid_argument \"This is an infinite sequence\") else  if stop <= 0 then let stopfunc i = i <= stop in let inc i = (step * i) + start in keep_until (stopfunc) (Seq.map inc nats) else let stopfunc i = i >= stop in let inc i = (step * i) + start in keep_until (stopfunc) (Seq.map inc nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one  = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = b.num * a.den + b.den * a.num ; den = a.den * b.den } let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg x = {num = (-1) * x.num; den = x.den} let inv x = {num = x.den; den = x.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add (x : bool)  (y : bool) = match x, y with | false, false -> false | true, false -> true | false, true -> true | true, true -> false let mul (x : bool)  (y : bool) = match x, y with | true, true -> true | _, _ -> false let neg (x : bool) = match x with | true -> true | false -> false let inv (x : bool) = x   end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Nil, _ | _, Nil -> Nil | Cons (a, seq1'), Cons (b,  seq2') -> Cons ((a,b), (zip seq1' seq2'))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (a, seq') -> if p a then Nil else Cons (a, keep_until p seq') let to_list (seq : 'a seq) : 'a list = let rec list_helper s = match s () with | Nil -> [] | Cons (a, seq') -> a :: list_helper seq' in list_helper seq let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if a.den == 0 || b.den = 0 then raise DivideByZero else if a.den == b.den then {num = b.num + a.num; den = a.den} else {num = a.num*b.den + a.den*b.num; den= a.den*b.den}  let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = if a.den == 0 then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let mul a b = (a = b) && ((a)&&(b)) let add a b = not (a = b) let neg a = a let inv a = a  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let open MazeGen in  let next_cell state = let x_old, y_old, dir = state in match dir with | West -> (x_old - 1, y_old) | North -> (x_old, y_old - 1) | East -> (x_old + 1, y_old) | South -> (x_old, y_old + 1) in  let dirs_to_check_list dir = let dir1, dir2, dir3 = dirs_to_check dir in [dir1; dir2; dir3] in  let rec solve_maze_helper (x, y) dir_list succ fail =  if (x, y) = (0, 0) then List.rev (succ ())   else match dir_list with  if has_wall maze (x, y, dir) then  solve_maze_helper (x, y) dir_list' succ fail  else let next_cell_coords = next_cell (x, y, dir) in  solve_maze_helper next_cell_coords (dirs_to_check_list dir)  (fun () -> dir::(succ ()))  (fun () -> solve_maze_helper (x, y) dir_list' succ fail) in  let (width, height) = dims maze in  solve_maze_helper (width - 1, height - 1) (dirs_to_check_list North) (fun () -> []) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | Cons(h1, t1), Cons(h2, t2) -> fun () -> Cons((h1, h2), zip t1 t2) | _ -> fun () -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Cons(h, t) when not (p h) -> fun () -> Cons(h, keep_until p t) | _ -> fun () -> Nil let to_list (seq : 'a seq) : 'a list = let rec to_list_helper s l = match s () with | Nil -> l | Cons(h, s') -> h::(to_list_helper s' l) in to_list_helper seq [] let range (start : int) (step : int) (stop : int) : int seq =  if step = 0 then raise (Invalid_argument \"step cannot be 0\") else if (step < 0 && start < stop) then raise (Invalid_argument \"step cannot be negative if start < stop\") else if (step > 0 && start > stop) then raise (Invalid_argument \"step cannot be positive if start > stop\") else  let unending_seq = map (fun x -> start + (step * x)) nats in  let finished x = if step > 0 then in keep_until finished unending_seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let neg a = {num = (-a.num); den = a.den}  let inv a = {num = a.den; den = a.num}  let rec gcd a b = if b = 0 then a else gcd b (a mod b)  let reduce a = let divisor = gcd a.num a.den in { num = a.num / divisor; den = a.den / divisor; } *)  let add a b = let num' = (a.num * b.den) + (b.num * a.den) in let den' = a.den * b.den in {num = num'; den = den'}  let mul a b = let num' = a.num * b.num in let den' = a.den * b.den in {num = num'; den = den'}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  " exception Invalid_argument of string ;; ",
  " module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, Nil -> (fun () -> Nil) | Nil, Cons (h,t) -> (fun () -> Nil) | Cons (h,t), Nil -> (fun () -> Nil) | Cons (h1,t1), Cons (h2,t2) -> (fun () -> Cons ((h1,h2), zip t1 t2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (h,t) -> (fun () -> if p h then Nil else Cons (h, keep_until p t)) let to_list (seq : 'a seq) : 'a list = let rec to_list_helper (seq : 'a seq) = match seq () with | Nil -> [] | Cons (h,t) -> h::(to_list_helper t) in to_list_helper seq let range (start : int) (step : int) (stop : int) : int seq = if step > 0 then keep_until (fun v -> v >= stop) (Seq.map (fun n -> ((n * step) + start)) nats) else if step < 0 then keep_until (fun v -> v <= stop) (Seq.map (fun n -> ((n * step) + start)) nats) else raise (Invalid_argument \"Cannot compute range\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = ((a.num * b.den) + (a.den * b.num)); den = (a.den * b.den)} let mul a b = {num = (a.num * b.num); den = (a.den * b.den)}  let neg a = {num = (-1 * a.num); den = a.den} let inv a = {num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = (not a && b) || (a && not b) let mul = (&&)  let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = raise NotImplemented let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one={num=1 ; den=1} let zero={num=0 ; den=1} let add {num=n1 ; den=d1} {num=n2 ; den=d2} = {num= (n1*d2)+(n2*d1) ; den =d1 * d2} let neg {num=n ; den=d} = {num=(-n) ; den=d} let mul {num = n1 ; den = d1} {num = n2 ; den = d2} = {num = n1 * n2; den = d1 * d2} let inv {num = n ; den = d} = {num = d ; den = n} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let one=true let zero=false let add l m=(not l && m) || (l&& not m) let inv l= l let neg l=l let mul l m= l&&m let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (xPos,yPos) = MazeGen.dims maze in let (x_pos,y_pos) = (xPos-1, yPos-1) in let determine_next_cell state = match state with | (x,y,MazeGen.North) -> (x,y-1) | (x,y,MazeGen.South) -> (x,y+1) | (x,y,MazeGen.West) -> (x-1,y) | (x,y,MazeGen.East) -> (x+1,y) in let rec solve_maze_help maze (x,y,dir as state) succ fail  = let suc = fun r -> succ(dir::r) in match MazeGen.dirs_to_check dir, (x, y) with | ( _ , (0,0)) -> succ | ((right, straight, left), _) -> let (x',y') = determine_next_cell (x,y,dir) in let fc2 = fun()-> solve_maze_help maze (x', y', left) suc fail in let fc1 = fun()-> solve_maze_help maze (x', y', straight) suc fc2 in if not (MazeGen.has_wall maze (x, y, dir)) then solve_maze_help (maze) (x',y', right) (suc) (fc1) else (fail ()) in let failStart = fun () -> solve_maze_help maze (x_pos,y_pos,MazeGen.North) (fun r -> r) (fun () -> raise NotFound) in (solve_maze_help maze (x_pos,y_pos,MazeGen.West) (fun r -> r) (failStart))[] ;; ",
  "  let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Nil, _ -> (Nil) | _, Nil -> (Nil) | (Cons (x, f),(Cons (x', f'))) -> Cons ((x, x'),(zip  f  f'))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq () with | Nil -> Nil | (Cons (x, f)) -> if not (p x) then Cons(x,(keep_until p f)) else Nil let to_list (seq : 'a seq) : 'a list = match seq () with | Nil -> [] | sq1 -> List.rev(Seq.fold_left (fun x nxt -> nxt::x) ([]) (fun () -> sq1)) let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument (\"step is equal to 0\")) else if (start>stop && step>0 || start<stop && step<0) then raise (Invalid_argument (\"will never reach stop\")) else let seq' = (map (fun x -> x*step+start) nats) in let seq'' = if (step<0) then keep_until (fun (x) -> x<=stop)(seq') else keep_until (fun (x) -> x>=stop)(seq') in seq'' end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num*b.den+b.num*a.den ; den = a.den*b.den} let mul a b = {num = a.num * b.num; den = a.den*b.den} let neg a = {num=a.num*(-1); den=a.den} let inv a =  {num=a.den; den=a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add x y = if not x then (y)  else (not x || not y) let mul = (&&) let neg x = (x) let inv x = (x) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let get_next_cell (state : MazeGen.state) = let (x,y,dir) = state in match dir with | MazeGen.North -> (x, y - 1) | MazeGen.East -> (x + 1, y) | MazeGen.South -> (x, y + 1) | MazeGen.West -> (x - 1, y) in let rec solve_maze_rec s fl sc : MazeGen.dir list = match s with | (0,0,_) -> sc [] | (_,_,dir) -> if (MazeGen.has_wall maze s) then ( fl () ) else ( let (r, f, l) = MazeGen.dirs_to_check dir in let (x,y) = get_next_cell s in  solve_maze_rec (x,y,r) ( fun () -> solve_maze_rec (x,y,f) ( fun () -> solve_maze_rec (x,y,l) fl (fun lsc -> sc (f::lsc)) ) (fun fsc -> sc (f::fsc)) ) (fun rsc -> sc (f::rsc)) ) in let (w,h) = MazeGen.dims maze in  solve_maze_rec (w - 1,h - 1,MazeGen.North) ( fun () ->  solve_maze_rec (w - 1,h - 1,MazeGen.West) (fun () -> []) (fun sc -> sc) ) (fun sc -> sc) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons (x,xs), Cons (y, ys) -> Cons ((x,y), zip xs ys) | _ -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (x,xs) -> if (p x) then Nil else Cons (x, keep_until p xs)  let to_list (seq : 'a seq) : 'a list = let rec to_list_rec seq' = match seq' () with | Nil -> [] | Cons (x,xs) -> x::(to_list_rec xs) in to_list_rec seq  let range (start : int) (step : int) (stop : int) : int seq = let f x = start + step * x in let cond x = if (step > 0) then x >= stop else x <= stop in  if (step > 0 && start > stop) then invalid_arg \"start cannot be less than stop when step > 0\"; if (step < 0 && start < stop) then invalid_arg \"start cannot be greater than stop when step < 0\"; if (step = 0) then invalid_arg \"step cannot equal 0\";  keep_until cond (map f nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = { num = a.num * b.den + b.num * a.den; den = a.den * b.den } let mul a b = { num = a.num * b.num; den = a.den * b.den }  let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = (a && not b) || (not a && b) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t  let easyECs = let two = F.add F.one F.one in let three = F.add F.one two in not ( (F.equal two F.zero) || (F.equal three F.zero) ) ;; ",
  " let onCurve p q (x,y) = let x_cubed = F.mul x (F.mul x x) in let prod_p_x = F.mul p x in F.equal (F.mul y y) (F.add x_cubed (F.add prod_p_x q)) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (start_w, start_h) = MazeGen.dims maze in let next_state (width, height, direct) = let open MazeGen in match direct with |North -> (width, height-1, direct) |South -> (width, height +1, direct) |West ->(width -1 , height, direct) | East -> (width +1, height, direct)  in let rec traverse_maze (maze:MazeGen.maze ) (w,h, d) (fail:unit ->'a ) sc : MazeGen.dir list  = if (w,h ) =(0,0) then sc [] else let (r,f,l) = MazeGen.dirs_to_check d in let fail_l = fun () -> inner maze  (w,h,l) fail sc in let fail_f = fun () -> inner maze  (w,h,f) fail_l sc in inner maze (w,h,r) fail_f sc and inner maze (w,h, d) (fail:unit ->'a ) sc : MazeGen.dir list = if MazeGen.has_wall maze (w,h,d) then fail () else let new_state = next_state (w,h, d) in traverse_maze maze new_state fail (fun x -> sc (d::x ))  in traverse_maze maze (start_w-1, start_h-1, MazeGen.North)  (fun () -> []) (fun r  -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct exception Invalid_argument of string ;; ",
  "open Seq let  rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () , seq2 () with |Cons(a1, tail1), Cons(a2, tail2) ->  fun x ->  Cons((a1,a2), zip tail1 tail2 ) |Nil, _ -> empty |_, Nil -> empty  ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty |Cons(a,t) -> if p a then empty else fun x ->  Cons((a), keep_until p t) ;; ",
  "let  to_list (seq : 'a seq) : 'a list = fold_left (fun list el -> list @ [el]) [] seq ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq =  if step <0 && stop > start then raise (Invalid_argument \"step should be increasing\") else if step > 0 && stop < start then raise (Invalid_argument \"step should be decreasing\") else let ran =  map (fun x-> x*step +start) nats in if stop <= 0 && start >=0 then keep_until ((>=)stop) ran else keep_until ( (<=) stop) ran  ;; ",
  " end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num= 0; den=1} let one ={num= 1; den=1} let add a b = {num= a.num *b.den + b.num*a.den; den=a.den *b.den} let mul a b = {num= a.num * b.num; den= a.den*b.den} let neg a = {num= (-a.num); den=a.den} let inv a = {num= a.den; den=a.num}   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add  =  (<>) let mul  =   (&&) let neg a = a let inv a =  a let equal = (=) end ;; ",
  "exception Deadend let next_cell (x,y,dir) maze = let directions = MazeGen.dirs_to_check dir in let (d1,d2,d3) = directions in if (not (MazeGen.has_wall maze (x,y,d1))) then match d1 with |East -> (x+1, y, d1) |West -> (x-1, y, d1) |North -> (x, y-1, d1) |South -> (x, y+1, d1) else if (not (MazeGen.has_wall maze (x,y,d2))) then match d2 with |East -> (x+1, y, d2) |West -> (x-1, y, d2) |North -> (x, y-1, d2) |South -> (x, y+1, d2) else match d3 with |East -> (x+1, y, d3) |West -> (x-1, y, d3) |North -> (x, y-1, d3) |South -> (x, y+1, d3)  ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let s_list = [] in let s0 = MazeGen.dims maze in let (x1,y1) = s0 in let rec construct states s_list sc = match states with | (0,0,d) -> sc s_list | (x,y,d) -> construct (next_cell (x,y,d)) dirlist (fun (x,y,d) -> sc (d::dirlist)) in construct (x1-1,y1-1,North) s_list (fun r -> r) ;; ",
  " exception Deadend let next_cell (x,y,dir) maze : MazeGen.state = let (right,straight,left) = MazeGen.dirs_to_check dir in if MazeGen.has_wall maze (x,y,right) then if MazeGen.has_wall maze (x,y,straight) then if MazeGen.has_wall maze (x,y,left) then (x,y,dir) else match left with |East -> (x-1, y, left) |West -> (x-1, y, left) |North -> (x, y-1, left) |South -> (x, y+1, left) else match straight with |East -> (x-1, y, straight) |West -> (x-1, y, straight) |North -> (x, y-1, straight) |South -> (x, y+1, straight) else match right with |East -> (x-1, y, right) |West -> (x-1, y, right) |North -> (x, y-1, right) |South -> (x, y+1, right) ;; ",
  "let rec deadend maze state (list : MazeGen.dir list) : MazeGen.dir list = let (x,y,dir) = state in let (right,straight,left) = MazeGen.dirs_to_check dir in if MazeGen.has_wall maze (x,y,left) then let dirr::xs = list  in match dir with |East -> deadend maze (x-1, y, dir) xs |West -> deadend maze (x+1, y, dir) xs |North -> deadend maze (x, y+1, dir) xs |South -> deadend maze (x, y-1, dir) xs else list ;; ",
  "let rec turn maze (state :MazeGen.state) : (MazeGen.state) = let (x,y,dir) = state in let (right,straight,left) = MazeGen.dirs_to_check dir in if MazeGen.has_wall maze (x,y,left) then match dir with |East -> turn maze (x-1, y, dir) |West -> turn maze (x+1, y, dir) |North -> turn maze (x, y+1, dir) |South -> turn maze (x, y-1, dir) else match left with |East -> (x+1, y, left) |West -> (x-1, y, left) |North -> (x, y-1, left) |South -> (x, y+1, left) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x0,y0) = MazeGen.dims maze in let rec construct maze (state : MazeGen.state) list cont = let (x_0,y_0,d_0) = state in let (x_1,y_1,d_1) = (next_cell state maze) in if (x_0 = x_1) && (y_0 = y_1) then let (xx,yy,dd) =(turn maze (x_0,y_0,d_0)) in construct maze  (xx,yy,dd) (deadend maze (x_0,y_0,d_1) list) (fun list -> cont (dd :: list)) else match (x_1,y_1,d_1) with | (0,0,d1) -> cont list | (x, y, dir) -> construct maze (x,y,dir) list (fun list -> cont (dir :: list)) in construct maze (x0-1,y0-1,North) [] (fun r -> r)   let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Seq.Cons(hd1,tl1), Seq.Cons(hd2,tl2) -> fun () -> Seq.Cons ((hd1,hd2), zip tl1 tl2) | _ -> fun () -> Nil   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun() -> Nil | Seq.Cons(hd, tl) -> if (p hd) then Seq.empty else fun() -> Seq.Cons(hd, keep_until p tl)  let to_list (seq : 'a seq) : 'a list = let rec create sequence acc = match sequence() with | Nil -> acc | Seq.Cons(hd,tl) -> create tl (acc @ [hd]) in create seq []  let range (start : int) (step : int) (stop : int) : int seq = let seq1 = map ( ( * ) step ) nats in let seq2 = map ( ( + ) start ) seq1 in if step > 0 then keep_until ( ( <= ) stop ) seq2 else keep_until ( ( >= ) stop ) seq2     end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0 ; den = 1} let one = {num = 1 ; den = 1} let add t1 t2 = let ({ num = num1; den = den1 }, { num = num2; den = den2 }) = (t1, t2)  in { num = ((num1* den2) + (num2 * den1)) ; den = (den1 * den2)} let mul t1 t2 = let ({ num = num1; den = den1 }, { num = num2; den = den2 }) = (t1, t2)  in { num = (num1 * num2); den = (den1 * den2) } let neg t1 = let {num = num1 ; den= den1} = t1 in { num = -num1; den = den1} let inv t = let { num = num1 ; den = den1 } = t in if num1 = 0 then {num = 0; den = 1} else {num = den1; den = num1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add t1 t2 = match t1 with | false -> (match t2 with | false -> false | true -> true) | true -> (match t2 with | true -> false | false -> true)   let mul t1 t2 = match t1 with | false -> false | true -> match t2 with |true -> true |false -> false  let neg t = t let inv t = t let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1(), seq2() with |Nil, _ |_, Nil -> Nil |Cons(hd,tl), Cons(s,se) -> Cons((hd,s), zip tl se)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq() with |Nil -> Nil |Cons(hd, tl) -> if p hd then Nil else Cons(hd, keep_until p tl)  let to_list (seq : 'a seq) : 'a list = let rec lst seq' acc = match seq'() with |Nil -> acc |Cons (hd, tl) -> lst tl (acc@[hd]) in lst seq []  let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument \"error: step connot = 0.\") else if (step < 0 && start < stop) then raise (Invalid_argument \"error: this will go to - infinity.\") else if (step > 0 && start > stop) then raise (Invalid_argument \"error: this will go to + infinity.\") else let m = map (fun x -> x * step + start) nats in keep_until (fun x -> if (step > 0) then  (x >= stop) else (x <= stop)) m end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0; den=1} let one = {num=1; den=1} let add (x:t)(y:t) = if (x.den = 0 || y.den = 0) then raise DivideByZero else {num = (x.num * y.den + y.num * x.den); den = (x.den * y.den)}  let mul (x:t)(y:t) = if (x.den = 0 || y.den = 0) then raise DivideByZero else {num = (x.num * y.num); den = (x.den * y.den)}  let neg (x:t) = if (x.den = 0) then raise DivideByZero else {num = (-1) * x.num; den = x.den}  let inv (x:t) = if (x.num = 0 || x.den = 0) then raise DivideByZero else {num = x.den; den = x.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let add (x:t) (y:t) = (x&&(not y)) || ((not x) && y) let mul (x:t) (y:t) = x && y let neg (x:t) = x let inv (x:t) = x  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct  open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 ()),(seq2 ()) with | _, (Nil) -> (fun () -> Nil) | (Nil), _ -> (fun () -> Nil) | Cons (h1,t1), Cons (h2,t2) -> (fun () -> Cons ((h1,h2), (zip t1 t2)))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq ()) with | Nil -> (fun () -> Nil) | Cons (h,t) -> (fun () -> if p h then Nil else Cons (h, keep_until p t))  let to_list (seq : 'a seq) : 'a list = List.rev (Seq.fold_left (fun acc x -> x :: acc) [] seq)     let range (start : int) (step : int) (stop : int) : int seq =  raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational    let add {num = n1 ; den = d1} {num = n2 ; den = d2} = {num = n1 * d2 + n2 * d1 ; den = d1 * d2}  let mul {num = n1 ; den = d1} {num = n2 ; den = d2} = {num = n1 * n2 ; den = d1 * d2}  let neg {num = n ; den = d} = {num = (-n) ; den = d}  let inv {num = n ; den = d} = {num = d ; den = n}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool     end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t   let easyECs =     not (F.equal two F.zero) && not (F.equal three F.zero)  let onCurve p q (x,y) =    F.equal ysquare (F.add xcube (F.add px q))  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let stepDir (state: MazeGen.state) (dir: MazeGen.dir): MazeGen.state = let (x, y, _) = state in if (dir = MazeGen.North) then (x, y-1, dir) else if (dir = MazeGen.East) then (x+1, y, dir) else if (dir = MazeGen.South) then (x, y+1, dir) else (x-1, y, dir) in let rec solve_maze_rec (maze: MazeGen.maze) (currState: MazeGen.state) ((checkedR, checkedF, checkedL): (int * int * int)) (cont_succ: unit -> MazeGen.dir list) (cont_fail: unit -> MazeGen.dir list): MazeGen.dir list = let (x, y, facing) = currState in if x = 0 && y = 0 then cont_succ () else let (right, front, left) = MazeGen.dirs_to_check facing in if (not (MazeGen.has_wall (maze) (x, y, right))) && checkedR <> 1 then solve_maze_rec (maze) (stepDir currState right) (0, 0, 0) (fun () -> (cont_succ ()) @ [right]) (fun () -> solve_maze_rec (maze) (currState) (1, 0, 0) (cont_succ) (cont_fail)) else if (not (MazeGen.has_wall (maze) (x, y, front))) && checkedF <> 1 then solve_maze_rec (maze) (stepDir currState front) (0, 0, 0) (fun () -> (cont_succ ()) @ [front]) (fun () -> solve_maze_rec (maze) (currState) (1, 1, 0) (cont_succ) (cont_fail)) else if (not (MazeGen.has_wall (maze) (x, y, left))) && checkedL <> 1 then solve_maze_rec (maze) (stepDir currState left) (0, 0, 0) (fun () -> (cont_succ ()) @ [left]) (fun () -> solve_maze_rec (maze) (currState) (1, 1, 1) (cont_succ) (cont_fail)) else cont_fail () in let (width, height) = MazeGen.dims maze in solve_maze_rec (maze) (width-1, height-1, MazeGen.North) (0, 0, 0) (fun () -> []) (fun () -> [])   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ | _, Nil -> Seq.empty | Cons (x, a'), Cons(y, b') -> (fun() -> Cons((x, y), (zip a' b'))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> Seq.empty | Cons (x, a') -> if p x then (fun () -> Nil) else (fun () -> Cons (x, keep_until p a')) let to_list (seq : 'a seq) : 'a list =  let rec aux (seqn: 'a seq) (acc: 'a list) : 'a list = match seqn() with | Nil -> acc | Cons (x, a') -> aux a' (acc @ [x]) in aux seq [] let range (start : int) (step : int) (stop : int) : int seq = let f x = start + x * step in let p x = if step > 0 then x >= stop else x <= stop in let newSeq = Seq.map f nats in keep_until p newSeq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num= 0; den= 1} let one = {num= 1; den= 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num= a.num * b.den + a.den * b.num; den= a.den * b.den} let mul a b = {num= a.num * b.num; den= a.den * b.den}  let neg a = {num= 0-a.num; den= a.den} let inv a = {num= a.den; den= a.num} end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add a b = if a && b then false else (a && not b) || (not a && b) let mul = (&&)  let neg a = a  let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (x, y) = MazeGen.dims maze in let init : (int * int * MazeGen.dir) = (x-1, y-1, MazeGen.North) in  let next_tile (state : MazeGen.state) : MazeGen.state = let (x1, y1, d) = state in match d with | MazeGen.North -> (x1, y1-1, d) | MazeGen.East -> (x1+1, y1, d) | MazeGen.South -> (x1, y1+1, d) | MazeGen.West -> (x1-1, y1, d) in   let rec solve state fail succeed = let (w, h, d) = state in  match (w, h) with | (0, 0) -> succeed [] then fail () else let (r, c, l) = MazeGen.dirs_to_check d in let (w1, h1, d) = next_tile (w, h, d) in solve ((w1, h1, r)) (fun () -> solve ((w1, h1, c)) (fun () -> solve ((w1, h1, l)) fail (fun xs -> succeed (d :: xs))) (fun xs -> succeed (d :: xs))) (fun xs -> succeed (d :: xs)) in solve init (fun () -> solve (x-1, y-1, MazeGen.West) (fun () -> raise NotFound) (fun x -> x)) (fun x -> x)   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons (a, aseq), Cons (b, bseq) -> Cons ((a, b), (zip aseq bseq)) | _ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (a, aseq) -> match p a with | false -> Cons ( a , keep_until p aseq) | true -> Nil  let to_list (seq : 'a seq) : 'a list = let rec help (seq : 'a seq) (l : 'a list) : 'a list = match seq () with | Nil -> [] | Cons (a, aseq) -> a :: (help aseq l) in help seq []  let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument \"Zero Step\") else if ((stop-start)*step < 0) then raise (Invalid_argument \"Infinite seq\") else if (stop = start) then return start let add = map (fun n -> (n * step) + start) (nats) in if ((stop - start) > 0) then keep_until ( fun a -> a >= stop ) add else keep_until (fun a -> a <= stop) add  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0 ; den = 1} let one = ({num = 1; den = 1}) let mul a b = {num = (a.num * b.num) ; den = (a.den * b.den)} let add a b = { num = ((a.num * b.den) + (b.num * a.den)) ; den = (a.den * b.den)} let neg a = { num = (a.num * (-1)) ; den = (a.den)} let inv a = { num = (a.den) ; den = (a.num)}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let add a b = match (a, b) with | (true, true) -> false | (false, false) -> false | _ -> true  let mul a b = a && b  let neg a = a  let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = (MazeGen.dims maze) in let initialState = (width-1, height-1, MazeGen.North) and getNextState x y dir = ( match dir with | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.North -> (x, y-1, MazeGen.North) | MazeGen.East -> (x+1, y, MazeGen.East) | MazeGen.South -> (x, y+1, MazeGen.South) ) in let rec solveMazeHelper fc sc state maze = match state with | (0, 0, _) -> sc [] | (x, y, dir) -> let (right, straight, left) = MazeGen.dirs_to_check dir in if not (MazeGen.has_wall maze (x, y, right)) then solveMazeHelper (fun () -> if not (MazeGen.has_wall maze (x, y, straight)) then solveMazeHelper (fun () -> if not (MazeGen.has_wall maze (x, y, left)) then solveMazeHelper (fc) (fun step -> sc (left::step)) (getNextState x y left) maze else fc () ) (fun step -> sc (straight::step)) (getNextState x y straight) maze else if not (MazeGen.has_wall maze (x, y, left)) then solveMazeHelper (fc) (fun step -> sc (left::step)) (getNextState x y left) maze else fc () )  (fun step -> sc (right::step)) (getNextState x y right) maze  else if not (MazeGen.has_wall maze (x, y, straight)) then solveMazeHelper (fun () -> if not (MazeGen.has_wall maze (x, y, left)) then solveMazeHelper (fc) (fun step -> sc (left::step)) (getNextState x y left) maze else fc () ) (fun step -> sc (straight::step)) (getNextState x y straight) maze  else if not (MazeGen.has_wall maze (x, y, left)) then solveMazeHelper (fc) (fun step -> sc (left::step)) (getNextState x y left) maze  else fc () in solveMazeHelper (fun () -> []) (fun x -> x) initialState maze ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | (_, Nil) -> (fun () -> Nil) | (Nil, _) -> (fun () -> Nil) | (Cons (hd1, tl1), Cons (hd2, tl2)) -> (fun () -> Cons ((hd1, hd2), (zip tl1 tl2)))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> seq | Cons (hd, tl) -> if p hd then (fun () -> Nil) else (fun () -> Cons (hd, (keep_until p tl))) let to_list (seq : 'a seq) : 'a list = let rec aux seq ls = match seq () with | Nil -> ls | Cons (hd, tl) -> hd::(aux tl ls) in aux seq []  let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Step must not be 0\") else if (step > 0 && stop < start) then raise (Invalid_argument \"Stop must be >= start\") else if (step < 0 && stop > start) then raise (Invalid_argument \"Stop must be <= start\") else let seq = Seq.map (fun a -> a * step + start) nats and pred x = ((step > 0 && x >= stop) || (step < 0 && x <= stop)) in keep_until pred seq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = { num = (a.num * b.den + b.num * a.den); den = (a.den * b.den) } let mul a b = { num = (a.num * b.num); den = (a.den * b.den) }  let neg a = { num = (-1 * a.num); den = a.den } let inv a = { num = a.den; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a let inv a = (if a then one else zero) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec helper state sc fc = let next (x, y, dir) = match dir with |MazeGen.North -> (x,y-1) |MazeGen.South -> (x,y+1) |MazeGen.East ->  (x+1,y) |MazeGen.West ->  (x-1,y) in let (x,y,dir) = state in let (right,front,left) = MazeGen.dirs_to_check dir in if (x,y) = (0,0) then sc([]) else if not(MazeGen.has_wall maze state) then let (p,q) =  next state in helper (p,q, right) (fun(a) -> sc(dir::a)) (fun () -> helper (p,q, front) (fun(a) -> sc(dir::a)) (fun () -> helper (p,q,left) (fun(a) -> sc(dir::a)) fc)) else fc() in helper ((fst (MazeGen.dims maze)) - 1 , (snd (MazeGen.dims maze)) - 1 , MazeGen.North) (fun (x) -> x) (fun() -> helper ((fst (MazeGen.dims maze)) - 1 , (snd (MazeGen.dims maze)) - 1 , MazeGen.West) (fun (x) -> x)(fun() -> raise NotFound))  let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = (fun() -> match seq1() with |Nil -> Nil |Cons(x,xs) -> match seq2() with |Nil-> Nil |Cons(y,ys) -> Cons((x,y), zip xs ys))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = (fun() -> match seq() with |Nil -> Nil |Cons(x,xs) -> if not(p x) then Cons(x, keep_until p xs) else Nil) let to_list (seq : 'a seq) : 'a list = let rec helper seq acc = match seq() with |Nil -> acc |Cons(x,xs) -> helper xs (acc @ [x]) in helper seq [] let range (start : int) (step : int) (stop : int) : int seq = if step >= 0 then if (step = 0 || start > stop) then raise (Invalid_argument \"infinite\") else let range_helper x = x >= stop in let helper x = start + (step * x) in keep_until (range_helper) (Seq.map helper nats) else if start < stop then raise (Invalid_argument \"infinite\") else let range_helper x = x <= stop in let helper x = start + (step * x) in keep_until (range_helper) (Seq.map helper nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = a.num * b.den + b.num * a.den; den = a.den*b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = ((-1) * a.num); den = a.den} let inv a = if a.num = 0 then raise DivideByZero else {num = a.den; den = a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = (<>) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "open MazeGen let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let nextCell (s : MazeGen.state) : (int * int) = match s with | (x, y, West) -> (x-1, y) | (x, y, North) -> (x, y-1) | (x, y, East) -> (x+1, y) | (x, y, South) -> (x, y+1) in let rec findPath (x, y) dir sc fc = match (x, y, dir) with | (0, 0, _) -> List.rev ( match List.rev (sc ()) with | [] -> [] | _::t -> t )   | (x, y, dir) -> if MazeGen.has_wall maze (x, y, dir) then fc () else let next = nextCell (x, y, dir) in let (right, front, left) = MazeGen.dirs_to_check dir in findPath next right ( fun () -> sc () @ [right]) ( fun () -> findPath next front ( fun () -> sc () @ [front]) ( fun () -> findPath next left ( fun () -> sc () @ [left]) ( fun () -> fc () ) ) ) in let (width, height) = MazeGen.dims maze in findPath (width - 1, height - 1) North ( fun () -> [North]) ( fun () -> findPath (width - 1, height - 1) West ( fun () -> [West]) ( fun () -> raise NotFound ) )  let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ -> fun () -> Nil | _, Nil -> fun () -> Nil | Cons (s1, v1), Cons (s2, v2) -> fun () -> Cons ( (s1,s2) , zip v1 v2 )  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons (s1, _) when p s1 -> fun () -> Nil | Cons (s1, v1) -> fun () -> Cons (s1, keep_until p v1)  let to_list (seq : 'a seq) : 'a list = let rec auxToList (s : 'a seq) (acc : 'a list) : 'a list = match s () with | Nil -> acc | Cons (s, v) -> auxToList v (acc @ [s]) in auxToList seq [] let range (start : int) (step : int) (stop : int) : int seq = if (start < step && step < 0) then raise (Invalid_argument \"Error: Cannot have a negative step with start < step.\") else if (start > step && step > 0) then raise (Invalid_argument \"Error: Cannot have a positive step with start > step.\") else if step = 0 then raise (Invalid_argument \"Error: Cannot have a step of 0.\") else let stepNats = map (fun n -> step * n + start) nats in keep_until (fun n -> if step < 0 then n <= stop else n >= stop) stepNats end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = { num = a.num * b.den + b.num * a.den; den = a.den * b.den } let mul a b = { num = a.num * b.num; den = a.den * b.den } let neg a = { num = a.num * -1; den = a.den } let inv a = { num = a.den; den = a.num } end ;; ",
  "let mm x = match x with | MazeGen.North -> \"North\" | MazeGen.East -> \"East\" | MazeGen.West -> \"West\" | MazeGen.South -> \"South\";; ",
  "let rec mml l = match l with | [] -> \"\" | h::t -> (mm h) ^ \" -> \" ^ (mml t) let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec solve_maze_helper (mys: MazeGen.state) (sc) (fc): MazeGen.dir list = let (x, y, cur_dir) = mys in let pd = (print_string (\" Cur state is: \" ^(mm cur_dir) ^ \" x:\" ^ (string_of_int x) ^ \" y:\" ^ (string_of_int y) )) in if ( (x, y) = (0, 0) ) then match sc [cur_dir] with | [] -> [] | h::t -> t  else ( let new_st dir = match dir with | MazeGen.North -> (x, y - 1, dir) | MazeGen.East -> (x + 1, y, dir) | MazeGen.West -> (x - 1, y, dir) | MazeGen.South -> (x, y + 1, dir) in  let (right_dir, front_dir, left_dir) = MazeGen.dirs_to_check cur_dir in let abbr = MazeGen.has_wall maze in let sc2 = fun r -> sc (cur_dir::r) in let r_check = try abbr (x,y,right_dir) with Invalid_argument _ -> (print_string \"caught \\n\"; false) in let f_check = try abbr (x,y,cur_dir) with Invalid_argument _ -> (print_string \"caught \\n\"; false) in let l_check = try abbr (x,y,left_dir) with Invalid_argument _ -> (print_string \"caught \\n\"; false) in let r_st =  new_st right_dir in let f_st =  new_st front_dir in let l_st =  new_st left_dir in let check = (print_string (\"\\n The check is done ---------- result is:  \" ^ (string_of_bool r_check) ^\" | \"^ (string_of_bool f_check) ^\" | \"^ (string_of_bool l_check) ^ \"\\n\") ) in let pd = (print_string (\" Directions are: \" ^ (mm right_dir) ^ \" | \" ^ (mm front_dir) ^ \" | \" ^ (mm left_dir) ^ \"\\n\\n\" )) in match (r_check, f_check, l_check) with | (false, false, false) -> (try ( let fc3 = (fun () -> solve_maze_helper (l_st) (sc2) (fc)) in let fc2 = (fun () -> solve_maze_helper (f_st) (sc2 ) (fc3)) in solve_maze_helper (r_st) (sc2 ) (fc2)) with Failure _ -> fc ())   | (false, false, true)-> (try ( let fc2 = (fun () -> solve_maze_helper (f_st) (sc2 ) (fc)) in solve_maze_helper (r_st) (sc2 ) (fc2)) with Failure _ -> fc ())   | (false, true, false) -> (try ( let fc2 = (fun () -> solve_maze_helper (l_st) (sc2) (fc)) in solve_maze_helper (r_st) (sc2 ) (fc2) ) with Failure _ -> fc ())   | (false, true, true)-> (try ( solve_maze_helper (r_st) (sc2 ) (fc) ) with Failure _ -> fc () )   | (true, false, false) -> (try ( let fc3 = (fun () -> solve_maze_helper (l_st) (sc2) (fc)) in solve_maze_helper (f_st) (sc2 ) (fc3) ) with Failure _ -> fc () )   | (true, false, true)-> (try ( solve_maze_helper (f_st) (sc2) (fc) ) with Failure _ -> fc () )   | (true, true, false) -> (try ( solve_maze_helper (l_st) (sc2) (fc) ) with Failure _ -> fc () )   | (true, true, true)-> (let pd = (print_string (\" \\n\\n Rewinding from: \" ^(mm cur_dir) ^ \" x:\" ^ (string_of_int x) ^ \" y:\" ^ (string_of_int y) ^ \"\\n\\n\\n\" )) in fc () ) ) in let (width, height) = MazeGen.dims maze in solve_maze_helper (width - 1, height - 1, MazeGen.North) (fun x -> x) (fun x -> raise NotFound)  ;; ",
  "let maze_printer maze = let (w, h) = MazeGen.dims maze in let hw = MazeGen.has_wall maze in  let rec row_p i j = (match (j < w) && (i < (h - 1)) with | false -> () | true -> ( if hw (j, i, MazeGen.South) then print_string (\" H wall at: \" ^string_of_int j ^ \" \" ^string_of_int i); row_p i (j + 1)) ) in  let rec row_l i j = print_string \" \"; (match j < (w - 1) with | false -> () | true -> ( if hw (j, i, MazeGen.East) then print_string (\"V wall at: \" ^string_of_int j ^ \" \" ^string_of_int i); row_l i (j + 1)) ) in  let rec print_helper i = (match i < h with | false -> () | true -> print_string \"[\"; (row_l i 0); print_string \"]\"; print_string \"\\n\"; print_string \"[\"; (row_p i 0); print_string \"]\"; print_string \"\\n\"; print_helper (i + 1)); in print_string \"\\n\"; print_helper 0;; ",
  "let test_maze width height = let em = print_string \"hey0\" in let maze = MazeGen.random width height in let path = solve_maze maze in maze_printer maze; print_string (\"\\n\" ^ MazeGen.string_of_maze maze); print_string (\"\\n\" ^ mml path); print_string (\"\\n\" ^ MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (s1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (s1 (), seq2 ()) with | (Nil, _) -> Nil | (_, Nil) -> Nil | (Cons(value1, str1), Cons(value2, str2)) -> Cons ((value1, value2), zip str1 str2)  let rec keep_until (f: 'a -> bool) (s: 'a seq): 'a seq = let rec inner (s: 'a seq) (acc: 'a seq): 'a seq = match s () with | Nil -> acc | Cons(value, str) -> if f value then acc else ( fun ()->Cons (value, inner (str) acc) ) in  inner s (fun () -> Nil);; ",
  " let to_list (seq : 'a seq) : 'a list = let rec to_list_helper (seq : 'a seq) (cont: 'a list -> 'a list) : 'a list = match seq () with | Nil -> cont [] | Cons(v, str1) ->  to_list_helper str1 (fun r -> (cont r) @ [v])  in to_list_helper seq (fun x -> x);; ",
  " let range (start : int) (step : int) (stop : int) : int seq =  let range_helper fail = if step < 0 && start < stop then fail \"Decreasing, but the 'start' is already smaller than the 'stop'.\" else if step > 0 && start > stop then fail \"Increasing, but the 'start' is already greater than the 'stop'.\" else if step = 0 && start <> stop then fail \"The step is 0 and 'stop' is not equal to the 'start' which will result in an infinite loop\" in  let inner (): int seq = range_helper (fun r ->raise (Invalid_argument r)); if step < 0 then let fct = (fun x -> x <= stop) in keep_until fct (map (fun x -> start + (step * x)) nats)  else if step >= 0 then let fct = (fun x -> x >= stop) in keep_until fct (map (fun x -> start + (step * x)) nats)  else raise NotFound in  inner ()   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add x y = {num = x.num * y.den + y.num * x.den; den = x.den * y.den} let mul x y =  {num = x.num * y.num; den = x.den * y.den} let neg x = {num = -x.num; den = x.den} let inv x = let num_ph = x.num in {num = x.den; den = num_ph} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add x y = (x || y) && not (x && y) let mul = (&&) let neg x = x let inv x = x let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (dim_x, dim_y) = MazeGen.dims maze in  let next_cell (cur_state : MazeGen.state) : (int * int) = match cur_state with | (cur_x, cur_y, MazeGen.West) -> (cur_x-1, cur_y) | (cur_x, cur_y, MazeGen.East) -> (cur_x+1, cur_y) | (cur_x, cur_y, MazeGen.North) -> (cur_x, cur_y-1) | (cur_x, cur_y, MazeGen.South) -> (cur_x, cur_y+1) in  let rec solve_maze_cont cur_state failure success : MazeGen.dir list = match cur_state with | (0, 0, _) -> success [] | (_, _, cur_dir) -> if MazeGen.has_wall maze cur_state then failure () else let (right, forward, left) = MazeGen.dirs_to_check cur_dir in let (next_x, next_y) = (next_cell cur_state) in solve_maze_cont (next_x, next_y, right) (fun () -> solve_maze_cont (next_x, next_y, forward) (fun () -> solve_maze_cont (next_x, next_y, left) (fun () -> failure () ) (fun l -> success (cur_dir::l)) ) (fun l -> success (cur_dir::l)) ) (fun l -> success (cur_dir::l))   in solve_maze_cont (dim_x-1, dim_y-1, MazeGen.North) (fun () -> solve_maze_cont (dim_x-1, dim_y-1, MazeGen.West) (fun () -> raise NotFound) (fun dir -> dir)) (fun dir -> dir)   let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "open Seq let test : 'a seq = (fun () -> Cons (3, (fun () -> (Cons (2, (fun () -> Nil))))))  let test2 : 'a seq = (fun () -> Cons (\"a\", (fun () -> (Cons (\"b\", (fun () -> Nil)))))) ;; ",
  "let test3 : 'a seq = (fun () -> Cons (\"a\", fun () -> Nil)) ;; ",
  "let test4 : 'a seq = (fun () -> Nil) ;; ",
  "let test5 : 'a seq = (fun () -> Cons (\"a\", (fun () -> (Cons (\"b\", (fun () -> Cons (\"c\", fun () -> Nil))))))) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1() with | Nil -> (fun () -> Nil) | Cons (head1, tail1) -> begin match seq2() with | Nil -> (fun () -> Nil) | Cons (head2, tail2) -> (fun () -> Cons ((head1,head2), (fun () -> zip tail1 tail2 ())) ) end   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (head, tail) -> if p head then (fun () -> Nil) else (fun () -> Cons (head, (fun () -> keep_until p tail ())))  let to_list (seq : 'a seq) : 'a list = let rec to_list_acc (seq : 'a seq) (l : 'a list) : 'a list = match seq () with | Nil -> l | Cons (head, tail) -> to_list_acc tail (l@[head]) in to_list_acc seq [] let range (start : int) (step : int) (stop : int) : int seq = if step > 0 then ( let p i = (i>=stop) in keep_until p (map (fun x -> x * step + start) nats) ) else ( let p i = (i<=stop) in keep_until p (map (fun x -> x * step + start) nats) ) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let add (r1 : t) (r2 : t) : t = let ({ num = num1; den = den1 }, { num = num2; den = den2 }) = (r1, r2)  in {num = num1*den2 + num2*den1; den = den1*den2}  let mul (r1 : t) (r2 : t) : t = let ({ num = num1; den = den1 }, { num = num2; den = den2 }) = (r1, r2)  in {num = num1*num2; den = den1*den2}  let neg (r : t) : t = let { num = num1; den = den1 } = r  in {num = (-num1); den = den1}  let inv (r : t) : t = let { num = num1; den = den1 } = r  in {num = den1; den = num1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add b1 b2 = match b1,b2 with | true, true -> false | false, false -> false | true, false -> true | false, true -> true  let mul b1 b2 = match b1,b2 with | true, true -> true | false, false -> false | true, false -> false | false, true -> false  let neg b = b  let inv b = b let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let get_cor (x, y, dir) = (x, y) in let get_card (x, y, dir) = dir in let get_1 (a, b, c) = a in let get_2 (a, b, c) = b in let get_3 (a, b, c) = c in let (w, h) = MazeGen.dims maze in let cell_1 = (w-1, h-1, MazeGen.North) in  let next_cell state = match state with | (x, y, MazeGen.North) -> (x, y+1, get_1 (MazeGen.dirs_to_check MazeGen.North)) | (x, y, MazeGen.West) -> (x-1, y, get_1 (MazeGen.dirs_to_check MazeGen.West)) | (x, y, MazeGen.East) -> (x, y+1, get_1 (MazeGen.dirs_to_check MazeGen.East)) in  let rec solver state success = match state with | (0, 0, _ ) -> success [] | (_, _, _) -> [MazeGen.North; MazeGen.North; MazeGen.West] in  solver cell_1 (fun a -> a)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  " module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with |Nil, Nil -> Nil |Nil, _ -> Nil |_, Nil -> Nil |Cons(n1, n1t), Cons(n2, n2t) -> Cons ((n1, n2), (zip n1t n2t)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq ()with |Nil -> Nil |Cons(n1, n1t) -> if p n1 then keep_until p empty () else Cons(n1, keep_until p n1t) let to_list (seq : 'a seq) : 'a list = let rec to_list_helper seq = match seq () with |Nil -> [] |Cons (n1, n1t) -> n1::(to_list_helper n1t) in to_list_helper seq let range (start : int) (step : int) (stop : int) : int seq = if step = 0 || (start < stop && step < 0) || (stop = start) then raise (Invalid_argument \"Invalid Inputs\") else let p = fun a -> if (start > stop) then (a <= stop) else (a >= stop) in  let f = fun a -> start + (a+1)*step in let k_seq = fun() -> Cons(start, map f nats) in keep_until p k_seq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add x y = {num = (x.num * y.den + y.num * x.den); den = (x.den * y.den)} let mul x y = {num = x.num * y.num; den = x.den * y.den} let neg x = {num = x.num*(-1); den = x.den} let inv x = {num = x.den; den = x.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add x y = if not x && not y then false else not (x && y) let mul x y = if (not x && not y) then false else (x && y) let neg x = not (not x) let inv x = x let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let nextState (curState : MazeGen.state) (dir : MazeGen.dir) : MazeGen.state = let (curX, curY, _) = curState in match dir with in let rec solve (curState : MazeGen.state) (fc: unit -> MazeGen.dir list) (sc: MazeGen.dir -> MazeGen.dir list) = ( let (curX, curY, curDir):(int * int * MazeGen.dir) = curState in let (rRight, rFront, rLeft) = MazeGen.dirs_to_check curDir in let canGoRight = (not (MazeGen.has_wall maze (curX, curY, rRight))) in let canGoFront = (not (MazeGen.has_wall maze (curX, curY, rFront))) in let canGoLeft = (not (MazeGen.has_wall maze (curX, curY, rLeft))) in let isInDeadEnd = not canGoRight && not canGoFront && not canGoLeft in let addCurSc = fun a -> (sc curDir) @ [a] in  if curX = 0 && curY = 0 then ( ) else if isInDeadEnd then ( fc () ) else ( let rightFailed = fun () -> ( let frontFailed = fun () -> ( let stateLeft = nextState curState rLeft in if canGoLeft then ( solve stateLeft fc addCurSc ) else ( fc () ) ) in let stateFront = nextState curState rFront in if canGoFront then ( solve stateFront frontFailed addCurSc ) else ( frontFailed () ) ) in  let stateRight = nextState curState rRight in if canGoRight then ( solve stateRight rightFailed addCurSc ) else ( rightFailed () ) ) ) in let (x0, y0) = MazeGen.dims maze in let initState = (x0 - 1, y0 - 1, MazeGen.North) in let soln = solve initState (fun () -> raise NotFound) (fun a -> [a]) in match soln with | [] -> [] | x::xs -> xs ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () with | Seq.Nil -> (fun () -> Nil) | Seq.Cons (a, at) -> ( match seq2 () with | Seq.Nil -> (fun () -> Nil) | Seq.Cons (b, bt) -> ( let ab = (a, b) in ) )  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Seq.Nil -> (fun () -> Nil) | Seq.Cons (a, at) -> ( if p a then (fun () -> Nil) else fun () -> Cons (a, keep_until p at) ) let to_list (seq : 'a seq) : 'a list = let rec to_list_tr (seq : 'a seq) (acc : 'a list) : 'a list = match seq () with | Seq.Nil -> acc | Seq.Cons (a, at) -> ( to_list_tr at (acc @ [a]) ) in to_list_tr seq [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Step of 0 leads to infinite sequence.\") else if (start < stop && step < 0) || (start > stop && step > 0) then raise (Invalid_argument \"Stop will never be reached with given step.\") else ( let f = fun (a:int) : int -> ( ) in let steppedNats : int seq = map f nats in let createStopCheck = fun () -> ( if (step > 0) then fun a -> a >= stop else fun a -> a <= stop ) in let stopCheck = createStopCheck () in keep_until stopCheck steppedNats )  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let rec gcd (a:int) (b:int) = if b = 0 then (if a > 0 then a else -a) else gcd b (a mod b) let simplify (n:rational) : rational = let num = ref n.num in let den = ref n.den in if !den < 0 then ( den := -(!den); num := -(!num); ); let nGCD = gcd !num !den in {num = !num / nGCD; den = !den / nGCD}  let zero = {num = 0; den = 1} let one  = {num = 1; den = 1} let add = fun (a:t) (b:t) -> let fDen = a.den * b.den in let fNum = ( a.num * (b.den) ) + ( b.num * (a.den) ) in {num = fNum; den = fDen} let mul = fun (a:t) (b:t) -> {num = a.num * b.num; den = a.den * b.den} let neg = fun (a:t) -> {num = -a.num; den = a.den} let inv = fun (a:t) -> if a.num = 0 then zero else {num = a.den; den = a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = fun (a:bool) (b:bool) -> let mul = fun (a:bool) (b:bool) -> a && b let neg = fun (a:bool) -> a let inv = fun (a:bool) -> a let equal = (=) end ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = raise NotImplemented let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num =1; den =1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = (a.num*b.den) + (b.num*a.den); den = (a.den*b.den)} let mul a b = {num = a.num * b.num;den = a.den*b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den;den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal a b = match a,b with |true,true -> true |true, false -> false |false, false -> true |false, true -> false let add a b = match a,b with |true,true -> false |true, false -> true |false, false -> false |false, true -> true let mul a b = match a,b with |zero, _ -> zero |_, zero -> zero |one, b -> b |a, one -> a |true,true -> true |true, false -> false |false, false -> false |false, true -> false let neg a = match a with |zero -> zero |true -> false |false -> true let inv a = match a with |zero -> zero |one -> one |true -> false |false->true  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (wid, hei) = MazeGen.dims maze in let advance state = let (x, y, (z : MazeGen.dir)) = state in match z with | MazeGen.West -> (x-1, y, z) | MazeGen.North -> (x, y-1, z) | MazeGen.East -> (x+1, y, z) | MazeGen.South -> (x, y+1, z) in let dirs_to_list (x, y, z) = [ x ; y ; z ] in let rec sol_helper (maze : MazeGen.maze) (state : MazeGen.state) l c fc = match state with | (0, 0, _) -> c [] | (x, y, z) -> match l with | [] -> fc () | h::t -> if MazeGen.has_wall maze (x, y, h) == false then sol_helper maze (advance (x, y, h)) (dirs_to_list (MazeGen.dirs_to_check h)) (fun k -> c (h::k)) (fun () -> (sol_helper maze state t c fc)) else sol_helper maze state t c fc in sol_helper maze ((wid - 1), (hei - 1), MazeGen.North) (dirs_to_list (MazeGen.dirs_to_check MazeGen.North)) (fun k -> k) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Seq.Nil, _ -> Seq.empty | _, Nil -> Seq.empty | Cons(a1, t1), Cons(a2, t2) -> (fun () -> Seq.Cons((a1, a2), zip t1 t2))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> Seq.empty | Cons(a,tl) -> match p a with | false -> (fun () -> Seq.Cons(a, (keep_until p tl))) | true -> Seq.empty let to_list (seq : 'a seq) : 'a list = let rec helper seq c = match seq () with | Nil -> c [] | Cons(a,tl) -> helper tl (fun k -> c (a::k)) in helper seq (fun k -> k) let range (start : int) (step : int) (stop : int) : int seq = if step == 0 then raise (Invalid_argument\"Step cannot be zero\") else ( let inner_func number = start + (step * number) in keep_until (fun num -> (num >= stop && step > 0) || (num <= stop && step < 0)) (map (inner_func) nats) ) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = ({num = 0; den = 1}) let one = ({num = 1 ; den = 1})  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add t1 t2 = ({num = (t1.num * t2.den) + (t2.num * t1.den) ; den = (t1.den * t2.den)}) let mul a b = ({ num = a.num * b.num ; den = a.den * b.den})  let neg a = ({ num = (-a.num) ; den = a.den}) let inv a = ({ num = a.den ; den = a.num}) end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = if (a == true && b == true) then false else (a || b) let mul = ( && )  let neg a = a == true let inv a = a == true end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (w,h) = dims maze in let next_cell cur_state = let (x,y,d) = cur_state in if has_wall maze cur_state then (x,y) else match d with | North -> (x,y-1) | South -> (x,y+1) | East -> (x+1,y) | West -> (x-1,y) in let rec solve_cont cur_state succ fail = let (x,y,p) = cur_state in let (dR,dF,dL) = dirs_to_check p in if (x,y) = (0,0) then succ [] else if has_wall maze (x,y,dF) then fail () else let (x',y') = next_cell cur_state in solve_cont (x',y',dR) (fun r -> succ (dF::r)) (fun () -> solve_cont (x',y',dF) (fun r -> succ (dF::r)) (fun () -> solve_cont (x',y',dL) (fun r -> succ (dF::r)) fail )) in solve_cont (w-1,h-1,North) (fun r -> r) (fun () -> solve_cont (w-1,h-1, West) (fun r -> r) (fun () -> [])) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq exception Invalid_argument let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ -> fun () -> Nil | _, Nil -> fun () -> Nil | Cons(h1,t1), Cons(h2, t2) -> fun () -> Cons((h1,h2),zip t1 t2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons(h,t) -> if p h then fun () -> Nil else fun () -> Cons(h, keep_until p t) let to_list (seq : 'a seq) : 'a list = List.rev(fold_left (fun x y -> y::x) [] seq) let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise Invalid_argument else if step > 0 then if start > stop then raise Invalid_argument else keep_until (fun m -> m >= stop) (map (fun n -> start + step*n) nats) else if start < stop then raise Invalid_argument else keep_until (fun m -> m <= stop) (map (fun n -> start + step*n) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add r s = {num = r.num * s.den + r.den *s.num; den = r.den * s.den} let mul r s = {num = r.num * s.num; den = r.den * s.den} let neg s = {num = -s.num; den = s.den} let inv r = if (equal r zero) then zero else {num = r.den; den = r.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg x = x let inv x = x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (width, height) = MazeGen.dims maze in  let calc_position (position : MazeGen.state) (direction : MazeGen.dir) : MazeGen.state = let (x,y,dir) = position in  match dir with | MazeGen.West -> (x-1,y,direction) | MazeGen.North -> (x,y-1,direction) | MazeGen.East ->  (x+1,y,direction) | MazeGen.South -> (x,y+1,direction) in  let check_bounds (position : MazeGen.state) (x_max : int) (y_max : int) : bool = let (x,y,_) = position in  (x < 0) || (y < 0) || (x > (x_max-1)) || (y > (y_max-1)) in  let rec solve_maze_cont (maze : MazeGen.maze) (position : MazeGen.state) fc sc : MazeGen.dir list = match position with | (0,0,_) -> sc [] | (x,y,dir) ->  if( not (MazeGen.has_wall maze (x,y,dir)) && not (check_bounds (x,y,dir) width height)) then  let (right,front,left) = MazeGen.dirs_to_check dir in  solve_maze_cont maze (calc_position (x,y,dir) right) (fun () -> solve_maze_cont maze (calc_position (x,y,dir) front) (fun () -> solve_maze_cont maze (calc_position (x,y,dir) left) fc (fun el -> sc (dir::el))) (fun el -> sc (dir::el))) (fun el -> sc (dir::el)) else fc ()   in  solve_maze_cont maze (width-1,height-1,MazeGen.North) (fun () -> solve_maze_cont maze (width - 1, height - 1, MazeGen.West) (fun () -> raise NotFound) (fun l -> l) ) (fun l -> l) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with | (Nil,_) -> Nil | (_,Nil) -> Nil | (Cons (valA,a'), Cons (valB,b')) -> Cons ((valA,valB), zip a' b') ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (valA,a') -> if(p valA) then Nil else Cons(valA, keep_until p a') ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec to_list_rec (sequence : 'a seq) : 'a list= match sequence () with | Nil -> [] | Cons (valA, a') -> valA::(to_list_rec a') in to_list_rec seq ;; ",
  " let range (start : int) (step : int) (stop : int) : int seq =  if ((start > stop) && (step > 0)) then raise (Invalid_argument (\"Start cannot be greater than Stop with a positive Step\")) else if ((start < stop) && (step < 0)) then raise (Invalid_argument (\"Start cannot be less than Stop with a negative Step\")) else if (step == 0) then raise (Invalid_argument (\"Step cannot be 0\")) else  let check_stop (a : 'a) = if(step > 0) then a >= stop else a <= stop in  let transformedSeq = map (fun el -> (el*step)+start) nats in  keep_until check_stop transformedSeq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num=0 ; den=1 } let one = { num=1 ; den=1 }  let add a b = (if(a.den == b.den) then { num=(a.num+b.num); den=a.den } else { num=( (a.num*b.den)+(b.num*a.den) ); den=( a.den*b.den )} ) let mul a b = { num=(a.num*b.num); den=(a.den*b.den)}  let neg a = { num=(a.num*(-1)); den=a.den } let inv a = { num=a.den; den=a.num }   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add a b = ( if(a==b) then zero else one ) let mul = (&&)  let neg a = a let inv a = a  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in let (curState : MazeGen.state) = (width - 1, height - 1, MazeGen.North) in let next_cell (cs : MazeGen.state) : MazeGen.state = match cs with | (w, h, MazeGen.North) -> (w, h-1, MazeGen.North) | (w, h, MazeGen.South) -> (w, h+1, MazeGen.South) | (w, h, MazeGen.West) -> (w-1, h, MazeGen.West) | (w, h, MazeGen.East) -> (w+1, h, MazeGen.East) in let dirs_to_try (cs : MazeGen.state) : MazeGen.dir list = let output = ref [] in let (x, y, d) = cs in let (a, b, c) = MazeGen.dirs_to_check d in if not (MazeGen.has_wall maze (x, y, c)) then output := c::!output; if not (MazeGen.has_wall maze (x, y, b)) then output := b::!output; if not (MazeGen.has_wall maze (x, y, a)) then output := a::!output; !output in let rec solve (cs : MazeGen.state) dirs fc sc : MazeGen.dir list = match cs with | (x, y, d) -> match dirs with | [] -> fc () | z::zz -> let next_cs = (next_cell (x, y, z)) in solve next_cs (dirs_to_try next_cs) (fun () -> solve cs zz fc sc) (fun r -> sc (z::r)) in solve curState (dirs_to_try curState) (fun () -> []) (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () with | Nil -> (fun () -> Nil) | Cons (x, xt) -> (match seq2 () with | Nil -> (fun () -> Nil) | Cons (y, yt) -> (fun () -> Cons ((x, y), zip xt yt)) ) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (x, xt) -> if p x then (fun () -> Nil) else (fun () -> Cons (x, keep_until p xt)) let to_list (seq : 'a seq) : 'a list = let rec aux seqq = match seqq () with | Nil -> [] | Cons (x, xt) -> x::(aux xt) in aux seq let range (start : int) (step : int) (stop : int) : int seq = if (step > 0 && stop <= start) || (step < 0 && stop >= start) || (step = 0 && stop != start) then raise (Invalid_argument \"invalid inputs, will result in an infinite sequence\"); keep_until (fun x -> if step >= 0 then x >= stop else x <= stop) (map (fun x -> x * step + start) nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.den * b.num + b.den * a.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=) let add a b = not (a = b) let mul = (&&)  let neg a = a let inv a = a  end ;; ",
  "exception Invalid_argument of string ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let next_cell (curr_state:MazeGen.state)(dir:MazeGen.dir) :MazeGen.state = let (x,y,_) = curr_state in let open MazeGen in match dir with |North -> (x,y-1,dir) |South -> (x,y+1,dir) |East -> (x+1,y,dir) |West -> (x-1,y,dir) in  let (width,height) = MazeGen.dims maze in  let open MazeGen in  let rec maze_solver (m:MazeGen.maze) (current_state:MazeGen.state)  succ fail  =   let (x,y,d) = current_state in  if (x,y,d) = (0,0,d) then succ[] else  let (first_dir,second_dir,third_dir) = MazeGen.dirs_to_check d in  let no_wall m s = not (MazeGen.has_wall m s) in   let potential_directions = List.filter (no_wall maze) [(x,y,first_dir);(x,y,second_dir);(x,y,third_dir)] in  if  potential_directions = [] then fail ()  else  let valid_dirs_to_check = List.map (fun (_,_,c)-> c) potential_directions in  let get_dir = List.nth valid_dirs_to_check in  let length = List.length valid_dirs_to_check in     maze_solver m (next_cell (x,y,d) (get_dir 0)) (fun res -> succ (get_dir 0::res)) (fun () -> if length = 1 then fail() else maze_solver m (next_cell (x,y,d)  (get_dir 1)) (fun res -> succ (get_dir 1::res)) (fun () -> if length =2  then fail() else maze_solver m (next_cell (x,y,d)  (get_dir 2)) (fun res -> succ (get_dir 2::res)) fail ))     in maze_solver maze (width-1,height-1,North) (fun l -> l) (fun () -> raise NotImplemented)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1(), seq2() with | Nil, _ ->  Nil |_, Nil -> Nil | Cons(h1,t1), Cons(h2,t2)-> Cons((h1,h2), zip t1 t2) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with |Nil -> Nil |Cons(h,f) -> if p h then  Nil else Cons(h, keep_until p f)  let to_list (seq : 'a seq) : 'a list = let app list  v = list @ [v] in match seq() with |Nil -> [] |Cons (h, f) -> Seq.fold_left app [h] f let range (start : int) (step : int) (stop : int) : int seq = let next = start + step in if (abs (stop - next) >=  abs (stop - start)) then raise (Invalid_argument \"Error: Stepping AWAY from stop. Please adjust parameters\") else   let predicate x = if (step >0) then x>= stop else x<= stop in  let f var =  start  + (step * var) in keep_until predicate (map f nats)   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1}  let one = {num = 1; den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num*b.den + b.num*a.den;den = a.den *b.den} let mul a b = {num = a.num*b.num; den= a.den*b.den} let neg a = {num = -(a.num); den = a.den} let inv a = {num = a.den; den = a.num}    end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg a =  a let inv a =  a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let p = (fun d -> not (MazeGen.has_wall maze (x, y, d))) in let (d1, d2, d3) = (MazeGen.dirs_to_check dir) in let l = d1::d2::d3::[] in List.filter p l in let next_state (x, y, cur) next = match next with | MazeGen.West -> (x - 1, y, next) | MazeGen.North -> (x, y - 1, next) | MazeGen.East -> (x + 1, y, next) | MazeGen.South -> (x, y + 1, next) in let rec solver s d f dead = match s with | s -> match d with | h::t -> ( let next_s = (next_state s h) in let next_d = (next_dirs next_s) in let sf = ( fun l -> (f l) @ [h] ) in let ff = ( fun () -> ( solver s t f dead ) ) in solver next_s next_d sf ff ) in let (width, height) =  MazeGen.dims maze in in let d0 = next_dirs s0 in solver s0 d0 (fun l -> l) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze); path ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ | _, Nil -> fun () -> Nil | Cons (h1, t1), Cons (h2, t2) -> (fun () -> (Cons ( (h1, h2), zip t1 t2 ))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () ->  Nil | Cons (h, t) -> if p h then fun () -> Nil else fun () -> Cons (h, keep_until p t)  let rec to_list (seq : 'a seq) : 'a list = match seq () with | Nil -> [] | Cons (h, t) -> h::(to_list t) let range (start : int) (step : int) (stop : int) : int seq = let comp = if step < 0 then (<=) else (>=) in let s = map (fun i -> start + (step * i)) nats in keep_until (fun i -> comp i stop) s end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add x y = { num = x.num * y.den + y.num * x.den ; den = x.den * y.den } let mul x y = { num = x.num * y.num ; den = x.den * y.den }  let neg x = { num = -x.num ; den = x.den } let inv x = { num = x.den ; den = x.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add x y = if x = y then zero else one let mul x y = if (x = one) && (y = one) then one else zero  let neg x = x let inv x = x end ;; ",
  "let m = MazeGen.random 3 3;; ",
  "print_string (MazeGen.string_of_maze m);; ",
  "MazeGen.dims m;; ",
  "MazeGen.dirs_to_check MazeGen.South;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (a,b) = (MazeGen.dims maze) in let rec smaze state fcount sc fc = match state with | (0,0,_) -> sc [] | (x,y,dir)-> let (_,_,l) = MazeGen.dirs_to_check dir in if fcount > 2 then fc [] else if not(MazeGen.has_wall maze state) then let sc1 = (fun d -> sc d@[dir]) in let fc1 = (fun f -> smaze (x,y,l) (fcount+1) sc fc) in match dir with | MazeGen.North -> smaze (x,y-1,MazeGen.East) 0 sc1 fc1 | MazeGen.South -> smaze (x,y+1,MazeGen.West) 0 sc1 fc1 | MazeGen.East -> smaze (x+1,y,MazeGen.South) 0 sc1 fc1 | MazeGen.West -> smaze (x-1,y,MazeGen.North) 0 sc1 fc1 else in smaze (a-1,b-1,MazeGen.East) 0 (fun d -> d) (fun f -> f);; ",
  "  solve_maze m;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, Nil -> empty | Nil,_ | _,Nil -> empty | Cons (a, s1), Cons (b, s2) -> (fun () -> Cons ((a,b), (zip s1 s2))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (a, s) -> if (p a) then empty else (fun () -> Cons (a, (keep_until p s))) let to_list (seq : 'a seq) : 'a list = List.rev (fold_left (fun a b -> b::a) [] seq) let range (start : int) (step : int) (stop : int) : int seq = match start,stop with | start, stop when start > stop -> if step < 0 then keep_until (fun a -> (a <= stop))  (map (fun b -> (b * step) + start)  nats) else raise (Invalid_argument \"Stop is never met\") | start, stop when start < stop -> if step > 0 then keep_until (fun a -> (a >= stop))  (map (fun b -> (b * step) + start)  nats) else raise (Invalid_argument \"Stop is never met\") | _,_ -> keep_until (fun a -> (a >= stop))  (map (fun b -> (b * step) + start)  nats) end ;; ",
  "Range.to_list (Range.range 0 (-1) (-10));; ",
  "Range.to_list (Range.range 0 1 10);; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = { num = (a.num*b.den)+(b.num*a.den); den = a.den*b.den } let mul a b = { num = (a.num*b.num); den = (a.den*b.den) } let neg a = { num = (-a.num); den = a.den } let inv a = { num = a.den; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = match a,b with | true, true -> false | false, false -> false | _,_ -> true let mul a b = match a,b with | true, true -> true | _,_ -> false let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let dimensions = MazeGen.dims in let list2 = [MazeGen.North] in if (MazeGen.has_wall maze (1,1, MazeGen.North)) then list2 @ [MazeGen.North] else list2 @ [MazeGen.West] ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = raise NotImplemented let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let inv a = {num = a.den ; den = a.num} let neg a = { num = 0 - a.num ; den = a.den} let mul a b = { num = a.num * b.num ; den = a.den * b.den } let add a b = {num = (a.num * b.den) + (b.num * a.den) ; den = a.den * b.den} let zero = {num = 0 ; den = 1} let one = {num = 1 ; den = 1}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=)  let zero = false let one = true  let add a b = if a == true && b == true then false else (a && b) || (a || b)  let mul = (&&) let neg a = a || a let inv a = a || a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in let rec next_cell has_wall ((x, y, dir): MazeGen.state) dir_list= match x, y, dir with | 0, 0, dir -> dir_list() | _, _, dir -> if not (has_wall maze (x, y, dir)) then if dir <> North then (next_cell has_wall (x, y - 1, East) (fun()->dir_list()@[dir])) else if dir <> East then (next_cell has_wall (x + 1, y, dir) (fun()->dir_list()@[dir])) else if dir <> West then (next_cell has_wall (x - 1, y, East) (fun()->dir_list()@[dir])) else raise NotFound else let (right, forward, left) = MazeGen.dirs_to_check dir in if not (has_wall maze (x, y, right)) && not (has_wall maze (x, y, left)) then next_cell has_wall (x + 1, y, right) (fun() -> next_cell has_wall (x, y - 1, forward) (fun() -> next_cell has_wall (x + 1, y, left) dir_list)) else raise NotFound in next_cell MazeGen.has_wall ((width-1), (height-1), North) (fun() -> [North]) let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, Nil | Nil, _ | _, Nil -> empty | Cons (h1, t1), Cons (h2, t2) -> (fun() -> Cons ((h1, h2), zip t1 t2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun() -> Nil) | Cons (h, t) -> if not (p h) then (fun() -> Cons (h, keep_until p t)) else (fun() -> Nil)   let to_list (seq : 'a seq) : 'a list = let reverse_list = fold_left (fun x y -> y::x) [] seq in List.rev (reverse_list)  let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = if a && b then zero else if not a && not b then zero else if a || b then one else one let mul a b = if not a && not b then zero else if a && not b then zero else if not a && b then zero else one let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (ini_x, ini_y) = MazeGen.dims maze in  let g (a,b,c) = match (a,b,c) with | (a,b,MazeGen.North) -> (a, (b-1), MazeGen.North) | (a,b,MazeGen.West) -> ((a-1), b, MazeGen.West) | (a,b,MazeGen.South) -> (a, (b+1), MazeGen.South) | (a,b,MazeGen.East) -> ((a+1), b, MazeGen.East) in  let rec find (x, y, d) l fail = match (x, y, d) with | (0, 0, _) -> l | (x, y, d) -> let (a, b, c) = MazeGen.dirs_to_check d in let a1 = MazeGen.has_wall maze (x, y, a) in let b2 = MazeGen.has_wall maze (x, y, b) in let c3 = MazeGen.has_wall maze (x, y, c) in match (a1, b2, c3) with | (true,false,false) -> find (g (x,y,b)) (l@[b]) (fun () -> find (g (x,y,c)) (l@[c]) fail) | (true,true,false) -> find (g (x,y,c)) (l@[c]) fail | (true,false,true) -> find (g (x,y,b)) (l@[b]) fail | (false,true,true) -> find (g (x,y,a)) (l@[a]) fail | (false,true,false) -> find (g (x,y,a)) (l@[a]) (fun () -> find (g (x,y,c)) (l@[c]) fail) | (false,false,true) -> find (g (x,y,a)) (l@[a]) (fun () -> find (g (x,y,b)) (l@[b]) fail) | (true,true,true) -> fail () | (false,false,false) -> find (g (x,y,a)) (l@[a]) (fun () -> find (g (x,y,b)) (l@[b]) (fun () -> find (g (x,y,c)) (l@[c]) fail)) in find (ini_x - 1, ini_y - 1, MazeGen.North) [] (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct  open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | Nil, Nil -> fun () -> Nil | Nil, _ -> fun () -> Nil | _, Nil -> fun () -> Nil | Cons(x,xf),Cons(y,yf) -> fun () -> (Cons((x,y), zip xf yf))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons (x, xf) -> if (p x) then fun () -> Nil else fun () -> (Cons(x, keep_until p xf)) let to_list (seq : 'a seq) : 'a list = let rec ite s = match s () with | Nil -> [] | Cons(x, xf) -> x :: ite xf in ite seq  let range (start : int) (step : int) (stop : int) : int seq =  let g x = (x = stop) || ((x > stop) && (step > 0)) || ((x < stop) && (step < 0)) in  let f x = start + (step * x) in let n = map f nats in  let seq = fun () -> (let rec g x = match x () with | Nil -> Nil | Cons (x, xf) -> if (x = start) then Cons (x, xf) else g xf in g n) in  let wrong = ((stop > start) && (step <= 0)) || ((stop < start) && (step >= 0)) in  let ans = if wrong then raise (Invalid_argument (\"wrong inputs\")) else keep_until g seq in ans  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let zero = ({num = 0; den = 1}) let one = ({num = 1; den = 1}) let neg a = let diff = (0 - a.num) in if (equal a zero) then zero else ({num = diff; den = a.den}) let inv a = if (equal a zero) then zero else ({num = a.den; den = a.num})  let add a b = if (equal a (neg b)) || (equal b (neg a)) then zero else ({num = (a.num * b.den) + (b.num * a.den); den = (a.den * b.den)})  let mul a b = if (equal a zero) || (equal b zero) then zero else if (equal a (inv b)) || (equal b (inv a)) then one else ({num = (a.num * b.num); den = (a.den * b.den)})  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let neg a = a let inv a = a  let add a b = if (a && b) then false else (a || b) let mul = (&&) let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let where_to_go x y direction = match direction with | MazeGen.West -> (x-1, y) | MazeGen.North -> (x,y-1) | MazeGen.East -> (x+1, y) | MazeGen.South-> (x,y+1) in let rec solver x y dir fc sc = if (x = 0 && y = 0) then sc [] else let (right, up, left) = MazeGen.dirs_to_check dir in let fc3 = (fun () -> if not (MazeGen.has_wall maze (x, y, left)) then let (x', y') = where_to_go x y left in solver x' y' left fc ((@) (sc [left])) else fc ()) in let fc2 = (fun () -> if not (MazeGen.has_wall maze (x, y, up)) then let (x', y') = where_to_go x y up in solver x' y' up fc3 ((@) (sc [up])) else fc3 ()) in if not (MazeGen.has_wall maze (x, y, right)) then let (x', y') = where_to_go x y right in solver x' y' right fc2 ((@) (sc [right])) else fc2 () in let (x, y) = MazeGen.dims maze in solver (x-1) (y-1) MazeGen.North (fun () -> []) (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Seq.Cons(x, xs), Seq.Cons(y, ys)-> (fun () -> Seq.Cons((x,y),  zip (xs ) (ys))) |_, _ -> (fun () -> Seq.Nil)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Seq.Cons(x, xs) -> if (p x) then (fun() -> Seq.Nil) else (fun () -> Seq.Cons(x, keep_until p xs)) | _ -> (fun() -> Seq.Nil)  let to_list (seq : 'a seq) : 'a list = fold_left (fun l a -> l @ [a]) [] seq let range (start : int) (step : int) (stop : int) : int seq = if step > 0 && start > step then raise (Invalid_argument (\"step should be negative\")) else if step < 0 && start < step then raise (Invalid_argument(\"step should be positive\")) else if step = 0 then raise (Invalid_argument(\"step should not be 0\")) else keep_until (fun x -> if step>0 then (x >= stop) else (x <= stop) ) (map (fun y -> (start + (y * step))) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add (x:t) (y:t)= {num = (x.num * y.den) + (y.num * x.den); den = (x.den * y.den)} let mul (x:t) (y:t) = {num = (x.num * y.num); den = (x.den * y.den)} let neg (x:t) = {num = (-1) * x.num; den = x.den} let inv (x:t) = {num = x.den; den = x.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (!=) let mul = (&&) let neg (x:t)= x let inv (x:t)= x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let walk(curx:int) (cury:int) (walkdir: MazeGen.dir) = match walkdir with |MazeGen.North-> (curx,cury-1) |MazeGen.South-> (curx,cury+1) |MazeGen.East -> (curx+1,cury) |MazeGen.West -> (curx-1,cury) in  let (w,h)=MazeGen.dims maze in let rec transition (maze:MazeGen.maze) curx cury (walkdir: MazeGen.dir) sc fc=  if (curx,cury)=(0,0) then sc([]) else if MazeGen.has_wall maze (curx,cury,walkdir) then fc() else let (right,front,left)=MazeGen.dirs_to_check walkdir in let (newx,newy)=walk curx cury walkdir in let commonsc = fun r->sc(walkdir::r) in transition maze newx newy right commonsc ( fun ()-> transition maze newx newy front commonsc ( fun()->transition maze newx newy left commonsc fc ) ) in  let success = fun r->r in let fail = fun()-> transition maze (w-1) (h-1) MazeGen.West success (fun ()->[]) in  transition maze (w-1) (h-1) MazeGen.North success fail ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(), seq2()) with |(Cons(v1,s1),Cons(v2,s2)) -> fun() -> Cons((v1,v2), zip s1 s2) |(Nil,_) -> fun()->Nil |(_,Nil) -> fun()->Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> fun()->Nil |Cons(v,s) -> if p v then fun()->Nil else fun () -> Cons(v,keep_until p s) ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec f seq = match seq() with |Nil -> []; |Cons(v,s) -> v::f s in f seq let range (start : int) (step : int) (stop : int): int seq = match ((stop-start)*step<=0,step=0) with |(true,_)->raise (Invalid_argument \"check yo args\") |(_,true)->raise (Invalid_argument \"check yo args\") |_-> let extract start stop s  = let flip start stop s = if (stop-start)>=0 then s else Seq.map (( * ) (-1)) s in  let filter_fun1 =fun x-> (x>=start)&&(x<stop) in let filter_fun2 =fun x-> (x<=start)&&(x>stop) in let half_length=max (abs start) (abs stop) in let pos_half=keep_until (fun x->x>half_length) s in let neg_half=Seq.filter (fun x->not(x=0)) (Seq.map (fun x->x-half_length) pos_half) in let raw_range=Seq.append neg_half pos_half in let flipped_range = flip start stop raw_range in let multiple=Seq.filter (fun x->((x-start) mod step)=0) flipped_range in if step>0 then Seq.filter filter_fun1 multiple else Seq.filter filter_fun2 multiple in  extract start stop nats end ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0;den=1} let one ={num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num=(a.num*b.den+a.den*b.num);den=a.den*b.den} let mul a b = {num=a.num*b.num; den=a.den*b.den} let inv a   = {num=a.den;den=a.num} let neg a   = {num=(-1*a.num);den=a.den}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true   let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let result=ref [] in let width= let (a,b) = MazeGen.dims maze in a in let height =let (a,b) = MazeGen.dims maze in b in let finalwidth= width-1 in let finalheight= height-1 in let coor=ref (finalwidth,finalheight) in let dir = ref MazeGen.North in let f1 maze= let a =let (a,b) = !coor in a in let b =let (a,b) = !coor in b in let x= let (x,y,z)= MazeGen.dirs_to_check !dir in x in let y= let (x,y,z)= MazeGen.dirs_to_check !dir in y in let z= let (x,y,z)= MazeGen.dirs_to_check !dir in z in let f2 d = match d with |MazeGen.West-> (coor :=(a-1,b);result:=(!result@[d]);dir:=d) |MazeGen.North-> (coor :=(a,b-1);result:=(!result@[d]);dir:=d) |MazeGen.South-> (coor :=(a,b+1);result:=(!result@[d]); dir:=d) |MazeGen.East-> (coor :=(a+1,b);result:=(!result@[d]); dir:=d) in if MazeGen.has_wall maze (a,b,x) then if MazeGen.has_wall maze (a,b,y) then else f2 y else f2 x in let rec f3 maze = let a =let (a,_) = !coor in a in let b =let (_,b) = !coor in b in if a<=0 && b<=0  then !result else (f1 maze; f3 maze) in f3 maze ;; ",
  " *)     *) let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with |Cons(a,b),Cons(c,d)-> fun () -> Cons((a,c),zip b d) |_-> fun ()-> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Cons(x,y) when not (p x) -> fun ()-> Cons(x,fun () -> keep_until p y()) |_-> fun()-> Nil  let to_list (seq : 'a seq) : 'a list = let rec f seq1= match seq1() with |Nil-> [] |Cons(x,y)-> x::(f y) in f seq let range (start : int) (step : int) (stop : int) : int seq = if step>0 then keep_until (fun x->x>=stop) (Seq.map (fun x-> x*step+start) nats) else keep_until (fun x->x<=stop) (Seq.map (fun x-> x*step+start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational ) = struct type t = rational let zero  = let num=0 in let den=1 in {num;den} let one = let num=1 in let den=1 in {num;den} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = let num=a.num*b.den+b.num*a.den in let den=a.den*b.den in {num;den} let mul a b = let num=a.num*b.num in let den=a.den*b.den in {num;den} let neg a=  let den=a.den in let num = -a.num in {num;den} let inv a= if equal a zero then raise DivideByZero else let den=a.num in let num=a.den in {num;den} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero=false let one=true let equal = (=) let add a b = (if (a=b) then false else (a) || (b)) let mul = (&&) let neg a = not (not a) let inv a= not (not a) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let new_cell state dir= match (state, dir) with |((x,y,_), MazeGen.West) -> (x-1,y) |((x,y,_), MazeGen.North) -> (x,y-1) |((x,y,_), MazeGen.East) -> (x+1,y) |((x,y,_), MazeGen.South) -> (x,y+1) in let rec solve_maze_tr maze state succ fail = match state with |(0,0,dir) -> succ([]) |(x,y,dir) -> if MazeGen.has_wall maze state then fail() else let (x,y) = new_cell state dir in let (right, front, left) = MazeGen.dirs_to_check(dir) in solve_maze_tr maze (x,y,right) (fun l -> succ(dir::l)) ( fun() -> solve_maze_tr maze (x,y,front) (fun l -> succ(dir::l))( fun () -> solve_maze_tr maze (x,y,left) (fun l -> succ(dir::l)) fail ) )  in let (width, height) = MazeGen.dims maze in solve_maze_tr maze (width-1, height-1, MazeGen.North) (fun l -> l) ( fun () -> solve_maze_tr maze (width-1, height-1, MazeGen.West) (fun l -> l)(fun () -> []) ) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze); path ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() ->( let node1 = seq1() in let node2 = seq2() in match (node1, node2) with |(Nil,_) -> Nil |(_,Nil) -> Nil |(Cons(a, adlist),Cons(b, bdlist)) -> Cons((a,b), zip adlist bdlist) ) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () ->( let node = seq() in match node with |Nil -> Nil |Cons(a, adlist) -> if p a then Nil else Cons(a, keep_until p adlist) ) let to_list (seq : 'a seq) : 'a list = let rec to_list_tr seq acclist = match seq() with |Nil -> acclist |Cons(a, adlist) -> to_list_tr adlist (a::acclist) in List.rev(to_list_tr seq []) let range (start : int) (step : int) (stop : int) : int seq = let diverge = Invalid_argument \"The chosen step makes the sequence diverge from the final value\" in if (step = 0 || ((step<0)&&(start<stop)) || ((step>0)&&(start>stop))) then raise diverge else let cond =  if (step<0) then (fun n -> n <= stop) else (fun n -> n >= stop) in keep_until cond (map (fun a -> step*a+start) nats)    end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0; den=1} let one = {num=1; den=1} let add r1 r2 = {num=(r1.num*r2.den + r1.den*r2.num); den=(r1.den*r2.den)} let mul r1 r2 = {num=(r1.num*r2.num); den=(r1.den*r2.den)} let neg r = {num=(-r.num); den=r.den} let inv r = {num=r.den; den=r.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = (<>) let mul = (=) let neg b = b let inv b = b let equal = (=) end ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "*)  module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let force f = f () in let node1 = force seq1 in let node2 = force seq2 in match node1, node2 with | Cons(hd1, tl1) , Cons(hd2, tl2) -> (fun () -> Cons((hd1, hd2), zip tl1 tl2)) | _  -> fun () -> Nil   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let force f = f () in let node = force seq in match node with | Cons(hd, tl) -> if p hd then (fun () -> Nil) else (fun () -> Cons(hd, keep_until p tl)) | Nil -> fun () -> Nil let to_list (seq : 'a seq) : 'a list = let rec to_list' s l = let force f = f () in let node = force s in match node with | Nil -> l | Cons (hd, tl) -> hd :: to_list' tl l in to_list' seq []  exception Invalid_argument of string  let range (start : int) (step : int) (stop : int) : int seq = if (start < stop && step <= 0) || (start > stop && step >= 0) then raise (Invalid_argument \"The range is not feasible\") else let st = map (fun x -> x * step) nats in let seq = map ((+) start) st in let valid num = if start < stop then num >= stop else num <= stop in keep_until valid seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = ((a.num * b.den) + (b.num * a.den)) ; den = (a.den * b.den)} let mul a b = {num = (a.num * b.num) ; den = (a.den * b.den)}  let neg a = {num = (-1 * a.num) ; den = a.den} let inv a = {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = if (not a) && (not b) then false else not( a && b)  let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec helper maze curState sc fc = let (x , y , direction) = curState in if (x = 0 && y = 0) then sc [] else if MazeGen.has_wall maze curState then fc () else let nextState (x : int ) (y : int) ( nextDirection : MazeGen.dir ) : MazeGen.state = match nextDirection with |MazeGen.North -> (x , y-1, MazeGen.North) |MazeGen.South -> (x, y+1 , MazeGen.South) |MazeGen.East -> (x+1, y, MazeGen.East) |MazeGen.West -> (x-1 ,y , MazeGen.West) in let (x',y',dir) = nextState x y direction in let (dir1, dir2, dir3) = MazeGen.dirs_to_check dir in helper maze (x',y',dir1) (fun l -> sc (dir :: l)) (fun () -> helper maze (x', y', dir2) (fun l -> sc (dir :: l)) (fun () -> helper maze (x', y', dir3) (fun l -> sc (dir :: l)) fc ) ) in let ((xDim :int), (yDim :int)) = MazeGen.dims maze in helper maze (xDim-1, yDim-1 , MazeGen.North) (fun r -> r) ( fun () ->   helper maze (xDim-1, yDim-1 , MazeGen.West) (fun r -> r) ( fun () -> raise NotFound))         ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq =  fun () -> match seq1 () , seq2  () with |(_, Nil) -> Nil |(Nil, _) -> Nil |Cons (a , aseq), Cons (b, bseq) -> (Cons( (a, b) , zip aseq bseq)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with  |Nil -> Nil | Cons ( a , aseq) -> if not (p a)  then (Cons (a, keep_until p aseq)) else  Nil let to_list (seq : 'a seq) : 'a list = let rec toList seq    =  match seq () with  |Nil -> [] |Cons (a , aseq) ->  a:: (toList (aseq)) in toList seq let range (start : int) (step : int) (stop : int) : int seq =  if (step = 0 ) then raise ( Invalid_argument \"step can't be equal to 0 \" ) else if ((step = 0 )  ||  (start > stop && step > 0 ) || ( start < stop && step < 0)) then  raise ( Invalid_argument \"unreachable stop\" )   else  let shiftStart x = x + (start ) in  let shiftStep x =  if ( x = start ) then x else  (step -1  )* (x -start) + x in  let seqStart =  map shiftStart nats  in   let seqStep = map shiftStep seqStart  in  ( if step > 0 then  keep_until ( fun x -> x >= stop) (seqStep)  else  keep_until ( fun x -> x <= stop) (seqStep)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0 ; den = 1 } let one = { num = 1 ; den = 1 } let add a b = { num = (a.den * b.num) + (b.den * a.num) ; den = (a.den * b.den)}   let mul a b = { num = (a.num * b.num) ; den =  (a.den * b.den)}  let inv a = { num = a.den ; den = a.num  }  let neg a  = { num = (-1 * a.num) ; den = a.den }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false  let one = true  let add a b = if ( a  && b  ) then false else a || b  let mul =  (&&)  let neg a =  a  let inv a =  a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_cell cur_state = match cur_state with | (x,y, MazeGen.North) -> (x,y-1,MazeGen.North) | (x,y, MazeGen.South) ->(x,y+1,MazeGen.South) | (x,y, MazeGen.East) -> (x+1,y,MazeGen.East) | (x,y, MazeGen.West) -> (x-1,y,MazeGen.West) in let rec solve_maze_cont m s sc fc = match s with | (0,0,_) -> sc [] | (x,y,d) -> let (d1,d2,d3) = MazeGen.dirs_to_check d in match (MazeGen.has_wall m (x,y,d1), MazeGen.has_wall m (x,y,d2), MazeGen.has_wall m ((x,y,d3))) with | (false,false,false) -> solve_maze_cont m (next_cell (x,y,d1)) (fun el -> sc (d1::el)) (fun () -> solve_maze_cont m (next_cell (x,y,d2)) (fun el -> sc (d2::el)) (fun () -> solve_maze_cont m (next_cell (x,y,d3)) (fun el -> sc (d3::el)) fc)) | (false,false,_) -> solve_maze_cont m (next_cell (x,y,d1)) (fun el -> sc (d1::el)) (fun () -> solve_maze_cont m (next_cell (x,y,d2)) (fun el -> sc (d2::el)) fc) | (false,_,false) -> solve_maze_cont m (next_cell (x,y,d1)) (fun el -> sc (d1::el)) (fun () -> solve_maze_cont m (next_cell (x,y,d3)) (fun el -> sc (d3::el)) fc) | (false,_,_) -> solve_maze_cont m (next_cell (x,y,d1)) (fun el -> sc (d1::el)) fc | (_,false,false) -> solve_maze_cont m (next_cell (x,y,d2)) (fun el -> sc (d2::el)) (fun () -> solve_maze_cont m (next_cell (x,y,d3)) (fun el -> sc (d3::el)) fc) | (_,false,_) -> solve_maze_cont m (next_cell (x,y,d2)) (fun el -> sc (d2::el)) fc | (_,_,false) -> solve_maze_cont m (next_cell (x,y,d3)) (fun el -> sc (d3::el)) fc in let (s1, s2) = MazeGen.dims maze in solve_maze_cont maze (s1-1,s2-1,MazeGen.North) (fun l -> l) (fun () -> raise NotImplemented) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with | (Nil, _) -> Nil | (_,Nil) -> Nil | (Cons (v1, s1), Cons (v2, s2)) -> Cons ( (v1,v2), zip s1 s2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (a, s') -> if p a then Nil else Cons (a, keep_until p s') let to_list (seq : 'a seq) : 'a list = let seq_list = ref [] in iter (fun el -> seq_list := !seq_list @ [el]) seq; !seq_list  let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) || ((step < 0) && (start < stop)) || ((step > 0) && (start > stop)) then raise (Invalid_argument \"Infinite Range\") else if (step > 0) then filter (fun c -> ((c-start) mod step) = 0) (map (fun b -> b + start) (keep_until (fun a -> a > ((stop - start)-1)) nats)) else filter (fun c -> ((c-start) mod (abs step)) = 0) (map (fun b -> (-b) + start) (keep_until (fun a -> a > ((start - stop)-1)) nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = ((a.num * b.den) + (b.num * a.den)); den = a.den*b.den} let mul a b = {num = a.num*b.num ; den = a.den*b.den} let inv a = {num = a.den; den=a.num} let neg a = {num = -a.num; den = a.den} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = if equal a b then zero else one let mul a b = if (equal a zero) || (equal b zero) then zero else one let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with |(Nil, _) -> fun () -> Nil |(_, Nil) -> fun () -> Nil |(Cons(h1, t1), Cons(h2, t2)) -> fun () -> Cons((h1, h2), (zip t1 t2))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Nil -> fun () -> Nil |Cons(h, t) -> if p h then fun () -> Nil else fun () -> Cons(h, (keep_until p t)) let to_list (seq : 'a seq) : 'a list = let rec to_list' h = match h () with |Nil -> [] |Cons(h, t) -> h::(to_list' t) in to_list' seq let range (start : int) (step : int) (stop : int) : int seq = let seq = Seq.map (fun h -> (h*step)+start) nats in if start < 0 || step > 0 then let p = (fun h -> h >= stop) in keep_until p seq else let p = (fun h -> h <= stop) in keep_until p seq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0; den=1} let one = {num=1; den=1} let neg a = {num=(-a.num); den=a.den} let inv a = {num=a.den; den=a.num} let add a b = {num=((a.num * b.den) + (b.num*a.den)); den=(a.den*b.den)} let mul a b = {num=(a.num*b.num); den=(a.den*b.den)} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let neg a = a let inv a = a let add a b = if a && b then false else (a || b) let mul = (&&) let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec get_next_cell maze (state: MazeGen.state) : MazeGen.state= match state with |(x,y,North)-> (x, y-1,North) |(x,y,West)-> (x-1, y,West) |(x,y,East)-> (x+1, y,East) |(x,y,South)-> (x, y+1,South) in let rec help_solve_maze maze (l1 : MazeGen.dir list) (state: MazeGen.state)sc fc : MazeGen.dir list= match state with |(0,0,_)->sc l1 |(x,y,dir)-> let (first, second, third) = MazeGen.dirs_to_check dir in if (not (MazeGen.has_wall maze (x,y,first)))then (help_solve_maze (maze) (first :: l1) (get_next_cell maze (x,y,first)) sc (fun () -> help_solve_maze (maze) (second :: l1) (get_next_cell maze (x,y,second)) sc (fun ()-> help_solve_maze (maze) (third :: l1) (get_next_cell maze (x,y,third)) sc fc))) else if (not (MazeGen.has_wall maze (x,y,second)))then help_solve_maze (maze) (second :: l1) (get_next_cell maze (x,y,second)) sc (fun ()-> help_solve_maze (maze) (third :: l1) (get_next_cell maze (x,y,third)) sc fc) else if (not (MazeGen.has_wall maze (x,y,third)))then help_solve_maze (maze) (third :: l1) (get_next_cell maze (x,y,third)) sc fc else fc () in let state=(fst(MazeGen.dims maze)-1, snd(MazeGen.dims maze)-1, MazeGen.North) in help_solve_maze maze [] (state) (fun x-> x) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with |Nil, _ -> (fun() -> Nil) |_, Nil -> (fun() -> Nil) |Cons(x,f),Cons(y,g) -> (fun () -> Cons ((x,y),(zip (fun() -> f()) (fun()-> g())))) ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> (fun() -> Nil) |Cons (x,f) -> if (not(p x)) then (fun() -> Cons(x, fun() ->keep_until p f())) else fun() ->Nil   ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec help_to_list seq (l : 'a list) : 'a list = match seq() with |Nil -> [] |Cons (x,f) -> x::help_to_list (fun() -> f()) l in help_to_list seq [] ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if ((start>stop && step>0) || (start<stop && step<0) || (step ==0)) then raise (Invalid_argument \"This input will cause an infinite series\") else  let num_elms = if (abs ((stop - start) mod step)=0) then (abs ((stop - start)/step)-1) else (abs ((stop - start)/step)) in  let fxn1 (elm : int) : bool = (elm > num_elms)in let fxn2 (nat : int) : int= (nat * step) + start in map fxn2 naturals end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0 ; den=1} ;; ",
  "let one ={num=1 ; den=1} ;; ",
  "let add (v1: rational) (v2: rational) = if (v1 = zero) then v2 else if (v2 = zero) then v1 else {num=((v1.num * v2.den)+(v2.num * v1.den)) ; den=(v1.den * v2.den)} ;; ",
  " let mul(v1: rational) (v2: rational) = if (v1=zero || v2=zero) then zero else if (v1=one) then v2 else if (v2=one) then v1 else {num=(v1.num * v2.num) ; den=(v1.den * v2.den)} ;; ",
  "let neg v1 = {num=(-1 * v1.num); den=v1.den} let inv v1 = if (v1=zero) then raise DivideByZero else {num=v1.den ; den=v1.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero=false;; ",
  "let one=true;; ",
  "let add b1 b2 = match b1,b2 with | true , true -> false |true, false -> true |false,true -> true |false, false->false ;; ",
  "let mul b1 b2 = match b1, b2 with |true , true -> true |true, false -> false |false,true -> false |false, false->false ;; ",
  "let neg b = match b with |true -> true |false ->false ;; ",
  "let inv b = match b with |true -> true |false ->false ;; ",
  "let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = (not ((F.add F.one F.one) = F.zero)) && (not ((F.add (F.add F.one F.one) (F.add F.one F.zero)) = F.zero)) ;; ",
  "let onCurve f1 f2 p= let (x,y) = p in let left= (F.mul y y) in let right= (F.add (F.add (F.mul (F.mul x x) x) (F.mul f1 x)) f2) in F.equal left right ;; ",
  "end module Rational_EC = EllipticCurves(RationalField) module Boolean_EC = EllipticCurves(BooleanField) module Float_EC = EllipticCurves(FloatField)  ;;*) ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (width,height) = MazeGen.dims maze in let (curState:MazeGen.state)=(width-1,height-1,MazeGen.North) in let next_cell (cur: MazeGen.state): MazeGen.state = match cur with |(w,h,MazeGen.East)-> (w+1,h, MazeGen.East) |(w,h,MazeGen.North)-> (w,h-1,MazeGen.North) |(w,h,MazeGen.West)-> (w-1,h, MazeGen.West) |(w,h,MazeGen.South)-> (w,h+1, MazeGen.South) in let dir_to_go (cs: MazeGen.state) = let output = ref[] in let (x, y, d) = cs in let (a, b, c) = MazeGen.dirs_to_check d in if not (MazeGen.has_wall maze (x, y, c)) then output :=c::!output; if not (MazeGen.has_wall maze (x, y, b)) then output :=b::!output; if not (MazeGen.has_wall maze (x, y, a)) then output :=a::!output; output in let start_dir = !(dir_to_go curState) in let rec solve (cs: MazeGen.state) dirs fc sc: MazeGen.dir  list = match cs with |(0,0,d)-> sc [] |(x,y,d) as f -> if dirs = [] then fc () else let l :: ls = dirs in solve (next_cell (x,y,l)) !(dir_to_go (next_cell (x,y,l))) (fun () -> solve cs ls fc sc) (fun tail -> sc (l::tail)) in solve curState start_dir (fun () -> []) (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1(), seq2() with |Nil , _ -> Nil |_, Nil -> Nil |Cons(x,xs), Cons(y,ys) -> Cons((x,y),(zip xs ys))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(l,ls) -> if p l then empty else cons l (keep_until p ls) let to_list (seq : 'a seq) : 'a list = let rec list_ele s acc = match s with |Nil -> acc |Cons (l,ls) -> list_ele (ls()) (acc @ [l]) in list_ele (seq()) [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"nothing would be returned\") else if step < 0 && stop > start then raise (Invalid_argument \"If stop is greater than the start, then it will never stop\") else if step > 0 && stop < start then raise (Invalid_argument \"If stop is smaller than the start, then it will never stop\") else let a = fun x -> if step < 0 then x <= stop else x>= stop in let list = map (fun y -> start+ y * step ) nats in keep_until a list end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  " module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num=a.den*b.num+a.num*b.den;den=a.den*b.den} let mul a b = {num=a.num*b.num;den=a.den*b.den} let neg a = {num=(-a.num);den=a.den} let inv a = {num=a.den;den=a.num} let zero={num=0;den=1} let one={num=1;den=1}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = if a&&b then false else not ((a=zero)&&(b=zero)) let mul =(&&) let neg a = a let inv a = (a != zero) || a  let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = ((F.add F.one F.one) <> F.zero) && ((F.add (F.add F.one F.one) F.one) <> F.zero) let onCurve p q point = let (x,y) = point in F.equal (F.mul y y) (F.add (F.add (F.mul (F.mul x x) x) (F.mul p x)) q) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (start_x, start_y) = (let (x, y) = MazeGen.dims maze in (x-1, y-1)) in let next cur_s = match cur_s with | (a, b, MazeGen.West) -> (a-1, b, MazeGen.West) | (a, b, MazeGen.East) -> (a+1, b, MazeGen.East) | (a, b, MazeGen.North) -> (a, b-1, MazeGen.North) | (a, b, MazeGen.South) -> (a, b+1, MazeGen.South) in let rec find_tr cur_s sc fc = let (x, y, d) = cur_s in let (right, front, left) = MazeGen.dirs_to_check d in let check_r = MazeGen.has_wall maze (x, y, right) in let check_f = MazeGen.has_wall maze (x, y, front) in let check_l = MazeGen.has_wall maze (x, y, left) in if (x, y) = (0, 0) then sc [] else match check_r, check_f, check_l with | true, true, true -> fc () | true, true, false -> find_tr (next (x, y, left)) (fun s -> (sc s) @ [left]) fc | true, false, false -> find_tr (next (x, y, front)) (fun s -> (sc s) @ [front]) (fun () -> find_tr (next (x, y, left)) (fun s -> (sc s) @ [left]) fc) | true, false, true -> find_tr (next (x, y, front)) (fun s -> (sc s) @ [front]) fc | false, false,false -> find_tr (next (x, y, right)) (fun s -> (sc s) @ [right]) (fun () -> find_tr (next (x, y, front)) (fun s -> (sc s) @ [front]) (fun () -> find_tr (next (x, y, left)) (fun s -> (sc s) @ [left]) fc)) | fasle, false, true -> find_tr (next (x, y, right)) (fun s -> (sc s) @ [right]) (fun () -> find_tr (next (x, y, front)) (fun s -> (sc s) @ [front]) fc) | false, true, true -> find_tr (next (x, y, right)) (fun s -> (sc s) @ [right]) fc | false, true, false -> find_tr (next (x, y, right)) (fun s -> (sc s) @ [right]) (fun () -> find_tr (next (x, y, left)) (fun s -> (sc s) @ [left]) fc) in find_tr (start_x, start_y, MazeGen.North) (fun r -> r) (fun () -> []) module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons (x, res1), Cons(a, res2) -> (fun () -> Cons((x, a), zip res1 res2)) | _, _ -> empty let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (x, res) -> if p x then empty else (fun () -> Cons (x, keep_until p res)) let to_list (seq : 'a seq) : 'a list = let rec to_list' l acc = match l () with | Nil -> acc | Cons(x, res) -> to_list' res (acc @ [x]) in to_list' seq []   let range (start : int) (step : int) (stop : int) : int seq = if ((step = 0) || (start > stop && step > 0) || (start < stop) && step < 0) then raise NotFound else let f = fun r -> step * r + start in let range' = map f nats in keep_until (fun r -> if step > 0 then stop <= r else stop >= r) range' end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "   module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0 ; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add = fun a b -> if a.den <> 0 && b.den <> 0 then let x = a.den * b.den in let r1 = a.den * b.num in let r2 = a.num * b.den in {num = r1 + r2 ; den = x} else raise DivideByZero  let mul = fun a b -> if a.den <> 0 && b.den <> 0 then let x = a.den * b.den in let y = a.num * b.num in {num = y ; den = x} else raise DivideByZero  let neg = fun a -> if a.den <> 0 then {num = -a.num ; den = a.den} else raise DivideByZero  let inv = fun a -> if a.den <> 0 then {num = a.den ; den = a.num} else raise DivideByZero  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add a b = match a, b with | true, true -> false | false, false -> false | _, _ -> true  let mul = ( && )  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let get_dir (state:MazeGen.state):MazeGen.dir= let (_,_,cur_dir)=state in cur_dir in  let get_x (state:MazeGen.state):int= let (x,_,_)=state in x in  let get_y (state:MazeGen.state):int= let (_,y,_)=state in y in    let turn_right (state:MazeGen.state):MazeGen.state= let (x,y,cur_dir)=state in let(right_dir,_,_)=MazeGen.dirs_to_check cur_dir in (x,y,right_dir) in  let turn_left (state:MazeGen.state):MazeGen.state= let (x,y,cur_dir)=state in let(_,_,left_dir)=MazeGen.dirs_to_check cur_dir in (x,y,left_dir) in  let isReverse (state1:MazeGen.state)(state2:MazeGen.state):bool= (get_x state1=get_x state2)&&(get_y state1=get_y state2)&& ((get_dir (turn_left (turn_left state1)))=(get_dir state2))  in  let walk_ahead (state : MazeGen.state):MazeGen.state= let (x,y,cur_dir)=state in match cur_dir with |MazeGen.West->(x-1,y,cur_dir) |MazeGen.North->(x,y-1,cur_dir) |MazeGen.East->(x+1,y,cur_dir) |MazeGen.South->(x,y+1,cur_dir) in  let silly_walk (maze :MazeGen.maze) (state: MazeGen.state): MazeGen.state= if not( MazeGen.has_wall maze (turn_right state)) then walk_ahead (turn_right state) else if not( MazeGen.has_wall maze state) then walk_ahead state else if not( MazeGen.has_wall maze (turn_left state)) then walk_ahead (turn_left state) else walk_ahead (turn_left (turn_left state)) in   let rec doable (maze:MazeGen.maze)(initstate:MazeGen.state)(currstate:MazeGen.state):bool =if (isReverse initstate currstate) then false else match currstate with |(0,0,_)->true |_->doable maze initstate (silly_walk maze currstate) in  let doable2 maze initstate=doable maze initstate initstate  in  let clever_walk (maze :MazeGen.maze) (state: MazeGen.state): MazeGen.state= if (not( MazeGen.has_wall maze (turn_right state)))&& (doable2 maze (turn_right state) )then walk_ahead (turn_right state) else if (not( MazeGen.has_wall maze state))&&(doable2 maze state) then walk_ahead state else walk_ahead (turn_left state)  in  let rec solve_maze_tr (maze :MazeGen.maze) (state :MazeGen.state) (ls: MazeGen.dir list):MazeGen.dir list = match state with |(0,0,_)->ls |_->solve_maze_tr maze (clever_walk maze state) (ls@[get_dir (clever_walk maze state)]) in   let (width, height)=MazeGen.dims maze in solve_maze_tr maze (width-1, height-1, MazeGen.North) []  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(),seq2()) with |(_,Nil)->fun()->Nil |(Nil,_)->fun()->Nil |(Cons(x1,f1),Cons(x2,f2))-> fun ()-> Cons((x1,x2),fun ()-> (zip f1 f2) ())  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil->fun()->Nil |Cons(x,f)-> if p x then fun()->Nil else fun()->Cons(x,fun()->(keep_until p f) ())  let to_list (seq : 'a seq) : 'a list = let rec move (seq: 'a seq) (lst: 'a list) : 'a list= match seq() with |Nil-> lst |Cons(x,f)-> move (fun ()-> f()) (lst@[x]) in move seq [] let range (start : int) (step : int) (stop : int) : int seq =  if stop-start=0 then fun()->Cons(start,fun()->Nil) else if step=0 then raise (Invalid_argument \"The step is zero\") else if step*(stop-start)<0 then raise (Invalid_argument \"Infinite sequence\") else let rangeInf=Seq.map (fun x->x*step+start) nats in let isExceedStop x= if step>0 then x>=stop else x<=stop in keep_until isExceedStop rangeInf  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero={num=0;den=1} let one={num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b={num=a.num*b.den+a.den*b.num;den=a.den*b.den} let mul a b={num=a.num*b.num;den=a.den*b.den} let neg a={num=(-1)*a.num;den=a.den} let inv a=if a.den=0 then raise DivideByZero else {num=a.den;den=a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero=false let one=true let equal = (=) let add a b=match (a,b) with |(false,false)-> false |(false,true)-> true |(true,false)->true |(true,true)->false let mul =(&&) let neg a = a let inv a = not(a=zero) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let cell_calc x y direction = match direction with | MazeGen.North -> (x, y - 1, direction) | MazeGen.South -> (x, y + 1, direction) | MazeGen.West  -> (x - 1, y, direction) | MazeGen.East  -> (x + 1, y, direction) in let rec maze_solver state rslbool lst fail = match state with | (0, 0, _) -> List.rev lst | _ -> let ( boolR, boolS, boolL ) = rslbool in let ( width, height, dir ) = state in let ( right, straight, left ) = MazeGen.dirs_to_check dir in if ( boolR && not (MazeGen.has_wall maze (width, height, right))) then maze_solver (cell_calc width height right) (true, true, true) (right :: lst) ( fun () -> (maze_solver state (false, true, true) lst fail)) else if ( boolS && not (MazeGen.has_wall maze (width, height, straight))) then maze_solver (cell_calc width height straight) (true, true, true) (straight :: lst) ( fun () -> (maze_solver state (false, false, true) lst fail)) else if ( boolL && not (MazeGen.has_wall maze (width, height, left))) then maze_solver ( cell_calc width height left ) ( true, true, true ) (left :: lst) ( fun () -> (maze_solver state (false, false, false) lst fail)) else fail () in let maze_width, maze_height = MazeGen.dims maze in maze_solver (maze_width - 1, maze_height - 1, MazeGen.North) (true, true, true) [] (fun () -> raise NotFound) let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons (a, b), Cons(c, d) -> fun () -> Cons ( (a,c), zip b d) | Nil, _ -> fun () -> Nil | _, Nil -> fun () -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons (a, _) when p a -> fun () -> Nil | Cons (a, b) -> fun () -> Cons ( a, keep_until p b) let to_list (seq : 'a seq) : 'a list = List.rev (fold_left (fun a b -> b :: a) [] seq)  let range (start : int) (step : int) (stop : int) : int seq = if ( step = 0 || (start > stop && step > 0) || (start < stop && step < 0)) then raise (Invalid_argument \"Please input valid arguments for the function.\") else let temp_seq = map (fun b -> (start + (step * b)) ) nats in keep_until ( fun a -> if (stop < start) then a <= stop else a >= stop) temp_seq end ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "*) module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1; } let one  = { num = 1; den = 1; }  let equal a b = if a.den = 0 || b.den = 0 then raise DivideByZero else a.den * b.num = a.num * b.den  let add a b = if a.den = 0 || b.den = 0 then raise DivideByZero else { num = ( ( a.num * b.den ) + ( b.num * a.den ) ); den = (a.den * b.den); }  let mul a b = if a.den = 0 || b.den = 0 then raise DivideByZero else { num = a.num * b.num ; den = a.den * b.den ; }  let neg a = if a.den = 0 then raise DivideByZero else { num = (- a.num); den = ( a.den ); }  let inv a = if a.num = 0 then raise DivideByZero else { num = a.den ; den = a.num ; } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = ( ( not a) && b ) || ( a && (not b) )  let mul = (&&)  let neg a = a  let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_state (x, y, dir) = match (dir : MazeGen.dir) with | MazeGen.North -> (x    , y - 1, dir) | MazeGen.East  -> (x + 1, y    , dir) | MazeGen.South -> (x    , y + 1, dir) | MazeGen.West  -> (x - 1, y    , dir) in let rec aux succ ((x, y, d) as state) cont = match state with | (0, 0, _) -> succ [] | _ -> if MazeGen.has_wall maze state then cont () else let (x', y', _) = next_state state in let r, f, l = MazeGen.dirs_to_check d in aux (fun x -> succ (d::x) ) (x', y', r) (fun () -> aux (fun x -> succ (d::x) ) (x', y', f) (fun () -> aux (fun x -> succ (d::x) ) (x', y', l) cont )) in let (x, y) = MazeGen.dims maze in aux (fun x -> x) (x-1, y-1, MazeGen.North) (fun () -> aux (fun x -> x) (x-1, y-1, MazeGen.West) (fun () -> raise NotFound))  let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Nil, _ -> Nil | _, Nil -> Nil | Cons(h_s1, t_s1), Cons(h_s2, t_s2) -> Cons((h_s1, h_s2), (zip t_s1 t_s2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons(e, s) -> if p e then Nil else Cons(e, (keep_until p s)) let to_list (seq : 'a seq) : 'a list = let rec aux acc seq = match seq () with | Nil -> acc | Cons(el, seq) -> aux (el::acc) seq in aux [] seq |> List.rev let range (start : int) (step : int) (stop : int) : int seq = if ((step > 0) && (stop < start)) || ((step < 0) && (stop > start)) || (step = 0) then raise ( Invalid_argument(\"Sequence will never reach stop\") ) else let find_end = if step > 0 then fun n -> n >= stop else fun n -> n <= stop in let mapping n = start + (n * step) in nats |> map mapping |> keep_until find_end end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero : t = {num = 0; den = 1} let one : t = {num = 1; den = 1} let neg (x : t) : t = {num = -x.num; den = x.den} let add (x : t) (y : t) : t = let n = (x.num * y.den) + (y.num * x.den) in if n = 0 then zero else { num = n; den = (x.den * y.den) } let inv (x : t) : t = {num = x.den; den = x.num} let mul (x : t) (y : t) : t = if (x.num = 0) || (y.num = 0) then zero else let num = x.num * y.num in let den = x.den * y.den in if num = den then one else { num = num; den = den; } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero : t = false let one : t = true let neg x = x let add x y = (x || y) && not (x && y) let inv (x : t) : t = x let mul = (&&) let equal = (=) end ;; ",
  "let end_state(s : MazeGen.state) : bool = let (w, h, _) = s in w == 0 && h == 0 ;; ",
  "let next_state (s : MazeGen.state) : MazeGen.state = let (w, h, d) = s in match d with | MazeGen.North -> (w, h - 1, d) | MazeGen.South -> (w, h + 1, d) | MazeGen.West -> (w - 1, h, d) | MazeGen.East -> (w + 1, h, d) ;; ",
  "let print_state (s : MazeGen.state) = let (w, h, _) = s in print_string\"(\"; print_int w; print_string \",\"; print_int h; print_string \")\\n\"; ;; ",
  "let is_some (k : (MazeGen.dir list) option) : bool = match k with | Some(_) -> true | _ -> false ;; ",
  "let print_dir (d : MazeGen.dir ) = match d with | MazeGen.North ->  print_string \"N\" | MazeGen.South -> print_string \"S\" | MazeGen.West -> print_string \"W\" | MazeGen.East -> print_string \"E\" ;; ",
  "let rec solve_maze_helper (maze : MazeGen.maze) (s : MazeGen.state) : (MazeGen.dir list) option = print_state s; if end_state s then Some [] else let (w, h, d) = s in let (r, f, l) = MazeGen.dirs_to_check d in let r_result = if not (MazeGen.has_wall maze (w, h, r)) then match (solve_maze_helper maze (next_state (w, h, r)) ) with | Some(ds) -> Some(r::ds) | None -> None else None in let r_result = if is_some(r_result) then r_result else if not (MazeGen.has_wall maze (w, h, f)) then match (solve_maze_helper maze (next_state (w, h, f)) ) with | Some(ds) -> Some(f::ds) | None -> None else None in let r_result = if is_some(r_result) then r_result else if not (MazeGen.has_wall maze (w, h, l)) then match (solve_maze_helper maze (next_state (w, h, l)) ) with | Some(ds) -> Some(l::ds) | None -> None else None in r_result ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims(maze) in match solve_maze_helper maze (width - 1, height - 1, MazeGen.North) with | Some(ds) -> ds | _ -> [] ;; ",
  "let rec print_path (ds : MazeGen.dir list) = match ds with | [] -> () | d::l -> print_dir d ; print_string \", \" ; print_path l ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(), seq2()) with | (Nil, _) -> Seq.empty | (_, Nil) -> Seq.empty | (Cons (h1,t1), Cons (h2,t2)) -> fun () -> (Cons ((h1,h2), (zip t1 t2))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> Seq.empty | Cons (h1,t1) -> if p h1 then Seq.empty else fun () -> Cons (h1, keep_until p t1) let rec to_list (seq : 'a seq) : 'a list = match seq() with | Nil -> [] | Cons (h1,t1) -> h1 :: (to_list t1) let range (start : int) (step : int) (stop : int) : int seq = let ss = Seq.map (( * ) step) nats in let sss = Seq.map ((+) start) ss in let l = if step > 0 then (fun (c) -> c >= stop) else (fun (c) -> c <= stop) in keep_until l sss end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = not (a = b) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec walk state success fail = if MazeGen.has_wall maze state then fail () else let (last_x, last_y, current_dir) = state in let (x, y) = match current_dir with | MazeGen.West -> (last_x - 1, last_y) | MazeGen.East -> (last_x + 1, last_y) | MazeGen.North -> (last_x, last_y - 1) | MazeGen.South -> (last_x, last_y + 1) in let success acc = success (current_dir::acc) in if x = 0 && y = 0 then success [] else let (rhs, fwd, lhs) = MazeGen.dirs_to_check current_dir in let fail = fun () -> walk (x, y, lhs) success fail in let fail = fun () -> walk (x, y, fwd) success fail in walk (x, y, rhs) success fail in let (w, h) = MazeGen.dims maze in let success x = x in let fail = fun () -> [] in let fail = fun () -> walk (w - 1, h - 1, MazeGen.West) success fail in walk (w - 1, h - 1, MazeGen.North) success fail ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with | (Cons (x, xs), Cons (y, ys)) -> Cons ((x, y), zip xs ys) | _ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Cons (x, xs) when not (p x) -> Cons (x, keep_until p xs) | _ -> Nil let to_list (seq : 'a seq) : 'a list = let rec loop seq cont = match seq () with | Nil -> cont [] | Cons (x, xs) -> loop xs (fun acc -> cont (x::acc)) in loop seq (fun x -> x) let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Illegal step\") else if start < stop && step < 1 then raise (Invalid_argument \"Illegal infinite range\") else if start > stop && step > ~-1 then raise (Invalid_argument \"Illegal infinite range\") else nats |> map (fun x -> start + step * x) |> keep_until ((if start < stop then (<=) else (>=)) stop) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = { num = a.num * b.den + a.den * b.num ; den = a.den * b.den } let mul a b = { num = a.num * b.num; den = a.den * b.den }  let neg a = { num = -a.num; den = a.den } let inv a = { num = a.den; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&)  let neg x = x let inv x = x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let init = let (w, h) = MazeGen.dims maze in (w - 1, h - 1, MazeGen.North) in let init2 = let (w, h) = MazeGen.dims maze in (w - 1, h - 1, MazeGen.West) in let get_dir (state : MazeGen.state) = let (_, _, d) = state in d in let set_next_state (state : MazeGen.state) (d : MazeGen.dir) = let (x, y, _) = state in match d with | MazeGen.West -> (x - 1, y, MazeGen.West) | MazeGen.North -> (x, y - 1, MazeGen.North) | MazeGen.East -> (x + 1, y, MazeGen.East) | MazeGen.South -> (x, y + 1, MazeGen.South) in let set_dir (state : MazeGen.state) (d : MazeGen.dir) = let (x, y, _) = state in match d with | MazeGen.West -> (x, y, MazeGen.West) | MazeGen.North -> (x, y, MazeGen.North) | MazeGen.East -> (x, y, MazeGen.East) | MazeGen.South -> (x, y, MazeGen.South) in let rec solve_maze_tr maze (state : MazeGen.state) list sc fc = if MazeGen.has_wall maze state then fc () else let newState = set_next_state state (get_dir state) in let (a, b, c) = MazeGen.dirs_to_check (get_dir newState) in match newState with | (0, 0, _) -> sc list | _ -> solve_maze_tr maze (set_dir newState a) list (fun r -> sc (a::r)) (fun () -> solve_maze_tr maze (set_dir newState b) list (fun r -> sc (b::r)) (fun () -> solve_maze_tr maze (set_dir newState c) list (fun r -> sc (c::r)) fc) ) in let sc = (fun r -> (MazeGen.North)::r) in let fc = (fun () -> solve_maze_tr maze init2 [] (fun r -> (MazeGen.West)::r) (fun () -> [])) in solve_maze_tr maze init [] sc fc ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | (Nil, _) -> fun () -> Nil | (_, Nil) -> fun () -> Nil | (Cons (x, xs), Cons (y, ys)) -> fun () -> Cons ((x, y), (zip xs ys)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq ()) with | Nil -> fun () -> Nil | Cons (x, xs) -> if p x then fun () -> Nil else fun () -> Cons (x, keep_until p xs) let to_list (seq : 'a seq) : 'a list = let rec to_list_aux seq = match (seq ()) with | Nil -> [] | Cons (x, xs) -> x::(to_list_aux xs) in to_list_aux seq exception Invalid_argument of string ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if step > 0 then if start > stop then raise (Invalid_argument \"Permanently increasing, step should be negative.\") else let mapNats = map (fun x -> start + x * step) nats in keep_until (fun x -> x >= stop) mapNats else if step < 0 then if stop > start then raise (Invalid_argument \"Permanently decreasing, step should be positive.\") else let mapNats = map (fun x -> start + x * step) nats in keep_until (fun x -> x <= stop) mapNats else raise (Invalid_argument \"Never increments, step cannot be 0.\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational ;; ",
  "let zero = {num = 0; den = 1} ;; ",
  "let one = {num = 1; den = 1} ;; ",
  "let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den ;; ",
  "let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} ;; ",
  "let mul a b = {num = a.num * b.num; den = a.den * b.den} ;; ",
  "let neg a = {num = 0 - a.num; den = a.den} ;; ",
  "let inv a = {num = a.den; den = a.num} ;; ",
  "end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool ;; ",
  "let zero = false ;; ",
  "let one = true ;; ",
  "let equal = (=) ;; ",
  "let add = (<>) ;; ",
  "let mul = (&&) ;; ",
  "let neg = fun b -> b ;; ",
  "let inv = fun b -> b ;; ",
  "end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t ;; ",
  "let easyECs = not (F.equal (F.add (F.add F.zero F.one) F.one) F.zero) && not (F.equal (F.add (F.add (F.add F.zero F.one) F.one) F.one) F.zero) ;; ",
  " let onCurve p q (x, y) = F.equal (F.add (F.add (F.mul (F.mul x x) x) (F.mul p x)) q) (F.mul y y) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x_init,y_init) = MazeGen.dims maze in let current_state = (x_init-1,y_init-1,MazeGen.North) in let next_move state = match state with | (x, y, MazeGen.North) -> (x, y - 1, MazeGen.North) | (x, y, MazeGen.South) -> (x, y + 1, MazeGen.South) | (x, y, MazeGen.East) -> (x + 1, y, MazeGen.East) | (x, y, MazeGen.West) -> (x - 1, y, MazeGen.West) in  let rec dir_list maze state sc fc = let (current_x, current_y, current_direction) = state in let (right, front, left) = MazeGen.dirs_to_check current_direction in let right_wall = MazeGen.has_wall maze (current_x, current_y, right) in let front_wall = MazeGen.has_wall maze (current_x, current_y, front) in let left_wall = MazeGen.has_wall maze (current_x, current_y, left) in let (right_check, front_check, left_check) = (right_wall, front_wall, left_wall) in  match state with |(0,0,_) -> sc [] |(current_x, current_y, current_direction) -> if (not right_check && front_check && left_check) then dir_list maze (next_move (current_x, current_y, right)) (fun next -> sc(right::next)) fc else if (not right_check && not front_check && left_check) then dir_list maze (next_move (current_x, current_y, right)) (fun next -> sc(right::next)) (fun () -> dir_list maze (next_move (current_x, current_y, front)) (fun next -> sc(front::next)) fc) else if (not right_check && front_check && not left_check) then dir_list maze (next_move (current_x, current_y, right)) (fun next -> sc(right::next)) (fun () -> dir_list maze (next_move (current_x, current_y, left)) (fun next -> sc(left::next)) fc) else if (right_check && not front_check && left_check) then dir_list maze (next_move (current_x, current_y, front)) (fun next -> sc(front::next)) fc else if (right_check && not front_check && not left_check) then dir_list maze (next_move (current_x, current_y, front)) (fun next -> sc(front::next)) (fun () -> dir_list maze (next_move (current_x, current_y, left)) (fun next -> sc(left::next)) fc) else if (right_check && front_check && not left_check) then dir_list maze (next_move (current_x, current_y, left)) (fun next -> sc(left::next)) fc else if (not right_check && not front_check && not left_check) then dir_list maze (next_move (current_x, current_y, right)) (fun next -> sc(right::next)) (fun () -> dir_list maze (next_move (current_x, current_y, front)) (fun next -> sc(front::next)) (fun () -> dir_list maze (next_move (current_x, current_y, left)) (fun next -> sc(left::next)) fc)) else fc () in  dir_list maze current_state (fun r -> r) (fun () -> [])  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(),seq2()) with | (Nil,_) -> empty | (_,Nil) -> empty | (Cons(h1,t1),Cons(h2,t2)) -> (fun() -> cons (h1,h2) (zip (t1) (t2)) () )  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(h,tl) -> if p h then empty else cons h (keep_until p tl) let to_list (seq : 'a seq) : 'a list = fold_left (fun (l:'a list) (node:'a) -> l @ [node]) [] seq let range (start : int) (step : int) (stop : int) : int seq = let traverse start_pts num = if (start_pts >= 0) then num else start_pts + num in  let input_verification start_pts next_pts = if((next_pts - start_pts) mod step <> 0) then None else Some(next_pts) in  if(start >= stop) then let cur_save = keep_until (fun num -> num >= (-stop)) (map(traverse (-start) ) nats) in let next_save = map (~-) (filter_map (input_verification (-start) ) cur_save) in try next_save with Invalid_argument \"THIS IS INFINITE SEQ!\" -> empty else let cur_save = keep_until (fun num -> num >= stop) (map(traverse start) nats) in let next_save = filter_map (input_verification start) cur_save in try next_save with Invalid_argument \"THIS IS INFINITE SEQ!\" -> empty   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one = {num = 1; den = 1} ;; ",
  "let zero = {num = 0; den = 1};; ",
  "let add r1 r2 = if (r1.den = r2.den) then {num = r1.num + r2.num;den = r2.den} else {num = r1.num * r2.den + r2.num * r1.den; den = r1.den * r2.den};; ",
  "let mul r1 r2 = {num = r1.num * r2.num ; den = r1.den * r2.den};; ",
  "let neg r1 = {num = (-r1.num); den = r1.den};; ",
  "let inv r1 = {num = r1.den ; den = r1.num};; ",
  " let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let one = true ;; ",
  "let zero = false ;; ",
  "let add =  (<>) ;; ",
  "let mul =  (&&) ;; ",
  "let inv b1 = b1 ;; ",
  "let neg b1 = b1 ;; ",
  "let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = let two = F.add F.one F.one in let three = F.add two F.one in (not (F.equal F.zero two)) && (not (F.equal F.zero three));; ",
  " let onCurve p q pts = let (x, y) = pts in let x_third = F.mul (F.mul x x) x in let y_square = F.mul y y in let p_times_x = F.mul p x in let equation_val = F.add (F.add x_third p_times_x) q in F.equal y_square equation_val ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (width, height) = MazeGen.dims maze in let start = (width - 1, height - 1) in  let next_cell (x, y, direction) = match direction with | MazeGen.West -> (x - 1, y) | MazeGen.North -> (x, y - 1) | MazeGen.South -> (x, y + 1) | MazeGen.East -> (x + 1, y) in  let dir_list dir = let (dir1, dir2, dir3) = MazeGen.dirs_to_check dir in [dir1; dir2; dir3] in  let rec solve maze (x_pos, y_pos) directions_list success fail = if (x_pos, y_pos) = (0, 0) then success [] else  match directions_list with | [] -> fail () | direction :: tl -> if MazeGen.has_wall maze (x_pos, y_pos, direction) then solve maze (x_pos, y_pos) tl success fail else let fail2 = fun () -> solve maze (x_pos, y_pos) tl success fail in let success2 = fun path -> success (direction :: path) in solve maze (next_cell (x_pos, y_pos, direction)) (dir_list direction) success2 fail2  in  solve maze start (dir_list MazeGen.North) (fun path -> path) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2()) with | (Cons (s1, s1_tl), Cons (s2, s2_tl)) -> fun () -> Cons ((s1, s2), zip s1_tl s2_tl) | _ -> empty let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq ()) with | Cons (s, s_tail) -> if p s then empty else fun () -> Cons(s, keep_until p s_tail) | _ -> empty let to_list (seq : 'a seq) : 'a list = let rec toList sequence = match sequence () with | Nil -> [] | Cons (s, s_tail) -> s :: toList s_tail in toList seq let range (start : int) (step : int) (stop : int) : int seq = if start * step > stop * step || step = 0 then raise (Invalid_argument \"Infinite sequence\") else keep_until (fun x -> x * step >= stop * step) (map (fun x -> step * x + start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den}  let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -a.num; den = a.den}  let inv a = if a <> zero then {num = a.den; den = a.num} else zero end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add = (<>)  let mul = (&&)  let neg a = a  let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w,h) = (MazeGen.dims maze) in  let move (curr : MazeGen.state) : MazeGen.state = let (x,y,dir) = curr in match (x,y,dir) with |(_,_,MazeGen.North) -> (x, y-1,dir) |(_,_,MazeGen.South) -> (x, y+1,dir) |(_,_,MazeGen.East) -> (x+1, y, dir) |(_,_,MazeGen.West) -> (x-1, y, dir)  in  let rec solve_maze_cont (curr : MazeGen.state) sc fc : MazeGen.dir list = match curr with | (_,_,dir)-> if MazeGen.has_wall maze curr then fc () else let (x',y',_) = move curr in let (r,s,l) = MazeGen.dirs_to_check dir in solve_maze_cont ((x',y',s)) (fun d -> sc (dir::(d))) (fun () -> (solve_maze_cont ((x',y',l)) (fun d -> sc (dir::(d))) fc)) in solve_maze_cont (x',y',r) sc1 fc1  in solve_maze_cont(w - 1, h- 1, MazeGen.North) (fun k -> k ) (fun () -> solve_maze_cont(w - 1, h - 1, MazeGen.West) (fun k -> k ) (fun () ->raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 () with | Nil -> Seq.empty() | Cons (v, seq1') -> match seq2 () with |Nil -> Seq.empty() |Cons (w, seq2') -> Cons ((v,w), zip seq1' seq2')  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (a, seq') -> if not(p a) then Cons (a, keep_until p seq') else Seq.empty() let to_list (seq : 'a seq) : 'a list = let rec to_list_tr (seq : 'a seq) acc = match seq () with | Nil -> acc | Cons (a, seq') -> (to_list_tr seq' (acc @ [a])) in to_list_tr (seq : 'a seq) [] let range (start : int) (step : int) (stop : int) : int seq = if (stop-start)*step > 0 then let seq1 = Seq.map (fun x -> start + (step * (x))) nats in if (step < 0) then keep_until (fun y -> (y <= stop)) seq1 else keep_until (fun y -> (y >= stop)) seq1 else raise (Invalid_argument \"Invalid_arguments\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one = {num = 1;den= 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + b.num * a.den; den = (a.den * b.den)} let mul a b = {num=(a.num * b.num); den=(a.den * b.den)} let neg a = {num=(-a.num) ; den=a.den} let inv a = {num =a.den; den=a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = match (a,b) with |(false,false) -> false |(true,true) -> false |(_,_) -> true let mul a b = match (a,b) with |(true,true) -> true |(_,_) -> false let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x,y) = MazeGen.dims maze in let determine_cell (x, y, dir) = match dir with | MazeGen.North -> (x, y-1) | MazeGen.East -> (x+1, y) | MazeGen.South -> (x, y+1) | MazeGen.West -> (x-1, y) in let rec solve_maze_rec ((x,y,dir) as state) fc sc = if MazeGen.has_wall maze state then fc () else let (right, front, left) = MazeGen.dirs_to_check dir in match determine_cell state with | (0, 0) -> sc () | (newX, newY) -> solve_maze_rec (newX, newY, right) (fun () -> solve_maze_rec (newX, newY, front) (fun () -> solve_maze_rec (newX, newY, left) fc (fun () -> sc() @ [left])) (fun () -> sc() @ [front])) (fun () -> sc() @ [right]) in solve_maze_rec (x-1, y-1, MazeGen.East) (fun () -> solve_maze_rec (x-1, y-1, MazeGen.North) (fun () -> solve_maze_rec (x-1, y-1, MazeGen.West) (fun () -> raise NotFound) (fun () -> [MazeGen.West])) (fun () -> [MazeGen.North])) (fun () -> [MazeGen.East]) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze); path ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons(x,xs), Cons(y,ys) -> (fun () -> Cons((x,y), zip xs ys)) | Nil, _ -> empty | _, Nil -> empty let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Cons(x,xs) -> if p x then (fun () -> Nil) else (fun () -> Cons(x, keep_until p xs)) | _ -> empty let to_list (seq : 'a seq) : 'a list = let rec to_list_rec seq ls = match seq () with | Nil -> ls | Cons(x, xs) -> to_list_rec xs (ls @ [x]) in to_list_rec seq [] let range (start : int) (step : int) (stop : int) : int seq = if ((start <= stop && step < 0) || (step = 0) || (start >= stop && step > 0)) then (raise (Invalid_argument (\"Invalid Arguments\"))) else match start < stop with | true -> let s = map (fun x -> start + (x*step)) nats in let s2 = keep_until (fun x -> x >= stop) s in s2 | false -> let s = map (fun x -> start + (x*step)) nats in let s2 = keep_until (fun x -> x <= stop) s in s2 end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = a.num * b.den + b.num * a.den; den = a.den * b.den}  let mul a b = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = a.num * b.num; den = a.den * b.den}  let neg a = if a.den = 0 then raise DivideByZero else {num = (-1) * a.num; den = a.den}  let inv a = if a.num = 0 then raise DivideByZero else {num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=) let add a b = (a || b) && (not a || not b) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let next_cell curx cury dir = match dir with | West -> (curx - 1, cury) | North -> (curx, cury - 1) | East -> (curx + 1, cury) | South -> (curx, cury + 1) in let rec solve_maze_cont cur m l sc fc = match cur with | (0, 0, dir) -> sc dir l | (curx, cury, dir) -> if has_wall m cur then fc () else let (dir1, dir2, dir3) =  dirs_to_check dir in let (nextx, nexty) = next_cell curx cury dir in let sc1 = sc in let fc2 = fun () -> solve_maze_cont (nextx, nexty, dir3) m l sc1 fc in let fc1 = fun () -> solve_maze_cont (nextx, nexty, dir2) m l sc1 fc2 in solve_maze_cont (nextx, nexty, dir1) m (dir :: l) sc1 fc1 in let (x,y) = dims maze in solve_maze_cont (x - 1, y - 1, North) maze [] (fun r l -> r :: l) (fun () -> raise NotFound)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 () , seq2 () with | Nil, Nil -> Nil | Nil, _ -> Nil | _, Nil -> Nil | Cons(h1, t1), Cons(h2, t2) -> Cons((h1, h2), zip (fun () -> t1()) (fun () -> t2() )) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq() with | Nil -> seq() | Cons(h, t) -> if p h then empty() else Cons(h, fun() -> keep_until p t()) let to_list (seq : 'a seq) : 'a list = let rec to_list_helper s = match s() with | Nil -> [] | Cons(h, t) -> h :: to_list_helper t in to_list_helper seq let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Cannot step by 0\" ) else if (stop > start && step < 0) || (stop < start && step > 0) then raise (Invalid_argument \"Stop is unreachable\" ) else let absvalue x = if x >= 0 then x else (-1) * x in let y = (absvalue start) + (absvalue stop) in let s = (absvalue step) in let p r = match y mod s with | 0 -> (r = y/s) | _ -> (r = y/s + 1) in let newseq = keep_until p nats in let f z = z * step + start in map f newseq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add x y = { num = (x.num * y.den) + (y.num * x.den); den = (x.den * y.den) } let mul x y = { num = (x.num * y.num); den = (x.den * y.den) } let neg x = { num = x.num * -1; den = x.den } let inv x = { num = x.den; den = x.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add x y = match x, y with | true, true -> false | true, _ -> true | _, true -> true | _, _ -> false let mul x y = match x, y with | false, _ -> false | _, false -> false | _, _ -> true let neg x = x let inv x = x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let get1st (a, _, _) = a in let get2nd (_, a, _) = a in  let dirsToCheckArray dir = begin let (dir1, dir2, dir3) = MazeGen.dirs_to_check dir in [dir1; dir2; dir3] end in  let dimensions = MazeGen.dims maze in let firstLocation = ((fst dimensions - 1), (snd dimensions - 1), MazeGen.North) in  let nextLocation (currLocation: MazeGen.state) (direction : MazeGen.dir) : MazeGen.state = match direction with | MazeGen.North -> (get1st currLocation, (get2nd currLocation) - 1, MazeGen.North) | MazeGen.East -> ((get1st currLocation) + 1, get2nd currLocation, MazeGen.East) | MazeGen.South -> (get1st currLocation, (get2nd currLocation) + 1, MazeGen.South) | MazeGen.West -> ((get1st currLocation) - 1, get2nd currLocation, MazeGen.West) in  let rec solveMaze (currMaze : MazeGen.maze) (currLoc : MazeGen.state) dirsToCheck fc sc = if (currLoc = (0, 0, MazeGen.North) || currLoc = (0, 0, MazeGen.West)) then sc [] else match dirsToCheck with | [] -> fc () | dir :: dirs_remaining -> begin  let boolHasWall = MazeGen.has_wall currMaze (get1st currLoc, get2nd currLoc, dir) in match boolHasWall with | true -> solveMaze currMaze currLoc dirs_remaining fc sc | false -> let nextLoc = nextLocation currLoc dir in let fc2 = fun () -> solveMaze currMaze currLoc dirs_remaining fc sc in let sc2 = fun p -> sc (dir :: p) in solveMaze currMaze nextLoc (dirsToCheckArray dir) fc2 sc2  end in  let dirList = solveMaze maze firstLocation (dirsToCheckArray MazeGen.North) (fun () -> raise NotFound) (fun p -> p) in dirList ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | (Cons (a, seq1_tail), Cons (b, seq2_tail)) -> fun () -> Cons ((a, b), zip seq1_tail seq2_tail) | _ -> (fun () -> Nil) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun() -> Nil | Cons (a, seq_tail) -> if p a then fun() -> Nil else fun () -> Cons(a, keep_until p seq_tail) let to_list (seq : 'a seq) : 'a list = let rec makeList seq = match seq () with | Nil -> [] | Cons (a, seq_tail) -> a :: makeList seq_tail in makeList seq let range (start : int) (step : int) (stop : int) : int seq = let makeList start step stop = if (start * step > stop * step || step = 0) then raise (Invalid_argument \"Outputs an infinite sequence.\") else keep_until (fun num -> num * step >= stop * step) (Seq.map (fun num -> step * num + start) nats) in makeList start step stop end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  " module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (width,height) = MazeGen.dims maze in  let go_next_cell (state : MazeGen.state) = let (x,y,currdir) = state in match currdir with |MazeGen.North -> (x,y-1) |MazeGen.South -> (x,y+1) |MazeGen.East  -> (x+1,y) |MazeGen.West  -> (x-1,y) in  let rec helper (maze: MazeGen.maze) (state: MazeGen.state) sc fc =  match state with |(0,0,_) -> sc []; |(x,y,direction) ->  let (right,straight,left) = MazeGen.dirs_to_check direction in if (MazeGen.has_wall maze state) then (fc ()) else ( let (xpos,ypos) = go_next_cell(state) in  helper maze (xpos, ypos, right) (fun r -> sc (direction :: r)) (fun () -> helper maze (xpos, ypos,straight) (fun r -> sc (direction :: r)) (fun () -> helper maze (xpos, ypos,left) (fun r -> sc (direction :: r)) fc )) ) in helper maze (width - 1, height - 1, MazeGen.North) (fun r -> r) (fun () -> helper maze (width - 1, height - 1, MazeGen.West) (fun r -> r)  (fun () -> raise NotFound) ) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let a = seq1() in match a with |Nil -> fun() -> Nil |Cons (h,t) -> let b = seq2() in match b with |Nil ->  fun() -> Nil |Cons(x,xs) -> fun ()->(Cons((h,x), zip t xs)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let a = seq() in match a with |Nil -> fun() -> Nil |Cons (h,t) -> if (p (h) ) then fun() -> Nil else fun() -> (Cons(h,keep_until p t)) let to_list (seq : 'a seq) : 'a list =  let rec helper seq = let a = seq() in match a with |Nil -> [] |Cons(h,t) -> h::helper t in helper seq  let range (start : int) (step : int) (stop : int) : int seq =  if (step = 0) then raise (Invalid_argument \"Step is Zero\") else if (stop > start && step < 0) then raise (Invalid_argument \"STEP1\") else if (start > stop && step > 0) then raise (Invalid_argument \"STEP2\") else ( let predicate (num : int) = if(step > 0) then num >= stop else num <= stop in  let map_func (a:int) = (a*step) + start in keep_until predicate (map map_func nats)  )   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1}  let one = {num = 1; den =1}  let add a b = if (a.den = b.den) then {num = a.num + b.num; den = a.den} else {num = (a.num * b.den) + (a.den  * b.num) ; den = (a.den * b.den)}  let neg a = {num = a.num * (-1) ; den = a.den} let inv a = {num = a.den ; den = a.num }  let mul a b  = {num = (a.num * b.num) ; den = (a.den * b.den)}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let mul a b = match a,b with |true,true -> true |false,_ -> false |_,false -> false  let add a b = match a,b with |true,true -> false |false,true -> true |true,false -> true |false,false -> false  let inv a = match a with |true -> true |false -> false  let neg a = match a with |true -> true |false -> false   let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list= let (width, height) = MazeGen.dims maze in let init_state = (width-1, height-1, MazeGen.North) in  let get_next_states (state : MazeGen.state) : MazeGen.state * MazeGen.state * MazeGen.state= match state with | (x, y, MazeGen.West) -> let (r, s, l) = MazeGen.dirs_to_check MazeGen.West in let right_state = (x-1, y, r) in let straight_state = (x-1, y, s) in let left_state = (x-1, y, l) in (right_state, straight_state, left_state) | (x, y, MazeGen.North) -> let (r, s, l) = MazeGen.dirs_to_check MazeGen.North in let right_state = (x, y-1, r) in let straight_state = (x, y-1, s) in let left_state = (x, y-1, l) in (right_state, straight_state, left_state) | (x, y, MazeGen.East) -> let (r, s, l) = MazeGen.dirs_to_check MazeGen.East in let right_state = (x+1, y, r) in let straight_state = (x+1, y, s) in let left_state = (x+1, y, l) in (right_state, straight_state, left_state) | (x, y, MazeGen.South) -> let (r, s, l) = MazeGen.dirs_to_check MazeGen.South in let right_state = (x, y+1, r) in let straight_state = (x, y+1, s) in let left_state = (x, y+1, l) in (right_state, straight_state, left_state) in  let rec solve (state : MazeGen.state) sc fc : MazeGen.dir list = match state with | (0, 0, _) ->  if MazeGen.has_wall maze state then fc () else let (right_state, straight_state, left_state) = get_next_states state in let (_, _, right) = right_state in let (_, _, straight) = straight_state in let (_, _, left) = left_state in  let sc_right = fun () -> right::sc () in let sc_straight = fun () -> straight::sc () in let sc_left = fun () -> left::sc () in   let fc_right = fun () -> solve straight_state sc_straight (fun () -> solve left_state sc_left (fc)) in solve right_state sc_right fc_right in  let reversed = solve init_state (fun () -> [MazeGen.North]) (fun () -> solve (width-1, height-1, MazeGen.West) (fun () -> [MazeGen.West]) (fun () -> raise NotFound)) in let _::t = reversed in let rev = List.rev t in rev ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | _, Nil -> fun () -> Nil | Nil, _ -> fun () -> Nil | Cons (h1, t1), Cons(h2, t2) -> fun () -> Cons ((h1,h2), zip t1 t2) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons (h, t) -> if p h then fun () -> Nil else fun () -> Cons (h, keep_until p t) let to_list (seq : 'a seq) : 'a list = let rec to_list_helper seq : 'a list = match seq () with | Nil -> [] | Cons(h, t) -> h::to_list_helper t in to_list_helper seq let range (start : int) (step : int) (stop : int) : int seq = match step with | 0 -> invalid_arg \"Step cannot be 0\" | _ -> if start = stop then fun () -> Nil else if start > stop && step > 0 then invalid_arg \"Step must be positive given these bounds\" else if start < stop && step < 0 then invalid_arg \"Step must be negative given these bounds\" else let step_function (n : int) : int = start + (step * n) in let p_function (n : int) : bool = if start >= stop then n <= stop else n >= stop in let mapped = map step_function nats in keep_until p_function mapped  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0 ; den = 1} let one = {num = 1 ; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = (a.num * b.den) + (b.num * a.den); den = a.den * b.den} let mul a b = {num = a.num * b.num ; den = a.den * b.den} let neg a = {num = 0 - a.num ; den = a.den} let inv a = {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | (Cons (h1,t1),Cons (h2,t2)) -> fun () -> Cons ((h1, h2), (zip t1 t2)) | _, _ -> fun() -> Seq.Nil ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Cons (h, t) -> if p h then fun () -> Nil else cons h (keep_until p t) | _ -> fun () -> Seq.Nil ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec tolist seq = match (seq ()) with | Nil -> [] | Cons(h,t) -> h::(tolist t) in tolist seq ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = let stop_func x = if start<stop then x>=stop else x<=stop in  if (( start-stop>=0 && step>0) || (start-stop<=0 && step<0)) then raise (Invalid_argument \"infinite\") else keep_until (stop_func) (unfold (fun x -> Some (x, x+step)) start)  ;; ",
  "end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = (a.num*b.den)+(b.num*a.den); den = a.den*b.den} let mul a b = {num = (a.num*b.num); den = a.den*b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) let zero = false let one = true let add a b = (not a && b) || (a && not b) let mul a b = (a && b) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let next_cell (x,y,direction) d = match d with | East -> (x+1,y, East) | West -> (x-1, y, West) | South -> (x, y+1, South) | North -> (x,y-1, North) in let (width, length) = dims maze in let rec solve state fail succeed = match state with |(0,0,_) -> succeed [] |(x, y, d) -> let cont = fail in let (right, front, left) = dirs_to_check d in match (has_wall maze (x,y,right)) with | false -> let cont = fun() -> solve (next_cell state right) cont (fun a -> succeed (right::a)) in ( match (has_wall maze (x,y,front)) with | true -> if (not (has_wall maze (x,y,left))) then let cont = fun() -> solve (next_cell state left) cont (fun a -> succeed (left::a)) in cont () else cont () | false -> let cont = fun() -> solve (next_cell state front ) cont (fun a -> succeed (front::a)) in if (not (has_wall maze (x,y, left))) then let cont = fun() -> solve (next_cell state left) cont (fun a -> succeed (left::a)) in cont () else cont ()  ) | true -> ( if (not (has_wall maze (x,y,front))) then let cont = fun() -> solve (next_cell state front ) cont (fun a -> succeed (front::a)) in if (not (has_wall maze (x,y,left))) then let cont = fun() -> solve (next_cell state left) cont (fun a -> succeed (left::a)) in cont() else cont () else if (not (has_wall maze (x,y,left))) then let cont = fun() -> solve (next_cell state left ) cont (fun a -> succeed (left::a)) in cont() else cont() let cont = fun() -> solve (next_cell state left) cont (fun a -> succeed (left::a)) in cont() | true -> cont () else if (not (has_wall maze (x,y,left))) then let cont = fun() -> solve (next_cell state left ) cont (fun a -> succeed (left::a)) in cont() else cont() *) )  in solve (width-1,length-1,North) (fun() -> []) (fun x -> x)   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct  open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | (_, Nil) -> fun() -> Nil | Cons(element1, sequence1), Cons(element2 , sequence2) -> fun() -> Cons((element1, element2), zip sequence1 sequence2) | (Nil, _) -> fun() -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons(element, sequence) -> match p element with | false -> fun() -> Cons (element, keep_until p sequence) | true -> fun() -> Nil let to_list (seq : 'a seq) : 'a list = let rec list seq a = match seq () with | Cons (element, sequence) -> list sequence (element::a) | Nil -> List.rev a in list seq [] let range (start : int) (step : int) (stop : int) : int seq = match (start < stop) with | true -> if (step > 0) then keep_until (fun x -> x >= stop) (map (fun x -> start + x * step) nats) else raise (Invalid_argument (\"Infinite Sequence\")) | false -> if (step < 0) then keep_until (fun x -> x <= stop) (map (fun x -> start + x * step) nats) else raise (Invalid_argument (\"Infinite Sequence\")) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = ({den=1; num=0})  let one = ({den=1; num=1})  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let inv h = { den = h.num; num = h.den}  let add x y = let snum = x.num * y.den + y.num * x.den in let sden = x.den * y.den in {den = sden; num = snum}  let neg i27 = {den = i27.den; num = -i27.num}  let mul y z = let pden = y.den * z.den in let pnum = y.num * z.num in { den = pden ;num = pnum}   end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=) let inv z=z let neg z=z  let add h i = match (h, i) with | (true, true) -> false | (true, false) -> true | (false, true) -> true | (false, false) -> false  let mul yc h = match (yc, h) with | (true, true) -> true | _ -> false   end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec update_list list = let rec update_list_helper list acc = match list with | x :: MazeGen.North :: MazeGen.South :: r -> update_list_helper (x :: r) acc | x :: MazeGen.South :: MazeGen.North :: r -> update_list_helper (x :: r) acc | x :: MazeGen.West :: MazeGen.East :: r -> update_list_helper (x :: r) acc | x :: MazeGen.East :: MazeGen.West :: r -> update_list_helper (x :: r) acc | MazeGen.North :: MazeGen.South :: r -> update_list_helper (r) acc | MazeGen.South :: MazeGen.North :: r -> update_list_helper (r) acc | MazeGen.West :: MazeGen.East :: r -> update_list_helper (r) acc | MazeGen.East :: MazeGen.West :: r -> update_list_helper (r) acc | x :: xs -> update_list_helper (xs) (acc @ [x]) | [] -> acc in let l = update_list_helper list [] in if l = list then l else update_list l in let update_position (x,y) dir = match dir with | MazeGen.North -> (x, y-1, dir) | MazeGen.South -> (x, y+1, dir) | MazeGen.East -> (x+1, y, dir) | MazeGen.West -> (x-1, y, dir) in let rec find_next_dir (maze : MazeGen.maze) (state : MazeGen.state) c : MazeGen.dir list = let (x,y,card_dir) = state in match (x,y) with | (0,0) -> c [] | (x',y') -> let (right, forward, left) = MazeGen.dirs_to_check card_dir in if MazeGen.has_wall maze (x',y', right) then if MazeGen.has_wall maze (x',y', forward) then if MazeGen.has_wall maze (x',y', left) then match card_dir with | MazeGen.North -> find_next_dir maze (update_position (x',y') MazeGen.South) (fun r -> c (MazeGen.South :: r)) | MazeGen.South -> find_next_dir maze (update_position (x',y') MazeGen.North) (fun r -> c (MazeGen.North :: r)) | MazeGen.East -> find_next_dir maze (update_position (x',y') MazeGen.West) (fun r -> c (MazeGen.West :: r)) | MazeGen.West -> find_next_dir maze (update_position (x',y') MazeGen.East) (fun r -> c (MazeGen.East :: r)) else find_next_dir maze (update_position (x',y') left) (fun r -> c (left :: r)) else find_next_dir maze (update_position (x',y') forward) (fun r -> c (forward :: r)) else find_next_dir maze (update_position (x',y') right) (fun r -> c (right :: r))  in let (x,y) = MazeGen.dims maze in let dir = find_next_dir maze (x-1,y-1,MazeGen.North) (fun r -> r ) in update_list dir  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with | (Seq.Cons(a,b),Seq.Cons(c,d)) -> Seq.Cons( (a,c), zip b d) | (Nil,Seq.Cons(c,d)) -> Nil | (Seq.Cons(a,b),Nil) -> Nil | (Nil, Nil) -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Seq.Cons(a,b) -> if p a then Nil else Seq.Cons(a, keep_until p b) let to_list (seq : 'a seq) : 'a list = let rec to_list_helper seq = match seq () with | Nil -> [] |Seq.Cons(a,b) -> a :: (to_list_helper b) in to_list_helper seq  let range (start : int) (step : int) (stop : int) : int seq = let f = if step > 0 then (fun a -> a >= stop) else (fun a -> a <= stop) in let new_seq = Seq.map (fun a -> a * step + start) nats in let list = keep_until f new_seq in try to_list list; list with Stack_overflow -> print_string(\"Infinite Sequence\"); Seq.empty end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0;den = 1}  let one = {num = 1; den = 1}  let add x y = { num = (y.den*x.num + y.num*x.den) ; den = x.den*y.den}  let mul x y = {num = x.num*y.num ; den = x.den*y.den}  let neg x = {num = -x.num ; den = x.den}  let inv x = { num = x.den ; den = x.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false  let one = true  let add = (<>)  let mul = (&&)  let neg x = x  let inv x = x let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let dir1 (x,_,_) = x in let dir2 (_,x,_) = x in let dir3 (_,_,x) = x in let next_state (state : MazeGen.state) = match state with |(x,y,MazeGen.North) -> (x,y-1,MazeGen.North) |(x,y,MazeGen.South) -> (x,y+1,MazeGen.South) |(x,y,MazeGen.East) -> (x+1,y,MazeGen.East) |(x,y,MazeGen.West) -> (x-1,y,MazeGen.West) in let rec solve_maze_cont curstate maze succ fail = match curstate with |(0,0,_) -> succ [] |(_,_,_) when MazeGen.has_wall maze curstate -> fail () |(_,_,dir) -> let get_next_cell = next_state curstate in let get_dirs = MazeGen.dirs_to_check (dir3 get_next_cell) in let fail2 () = solve_maze_cont ((dir1 get_next_cell), (dir2 get_next_cell), (dir3 get_dirs)) maze (fun r -> succ (dir::r)) fail in let fail1 () = solve_maze_cont ((dir1 get_next_cell), (dir2 get_next_cell), (dir2 get_dirs)) maze (fun r -> succ (dir::r)) fail2 in solve_maze_cont ((dir1 get_next_cell), (dir2 get_next_cell), (dir1 get_dirs)) maze (fun r -> succ (dir::r)) fail1 in let start_x (w,_) = w - 1 in let start_y (_,h) = h - 1 in let check_init = (start_x (MazeGen.dims maze), start_y (MazeGen.dims maze), MazeGen.North) in let final1 () = solve_maze_cont (dir1 check_init, dir2 check_init, MazeGen.West) maze (fun r -> r) (fun () -> []) in solve_maze_cont check_init maze (fun r -> r) final1 ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 ()), (seq2 ()) with | Nil,_ | _,Nil -> fun() -> Nil | Cons(e1,rest1), Cons(e2,rest2) -> fun() -> Cons((e1,e2), (zip rest1 rest2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Nil -> fun () -> Nil |Cons(e,rest) -> if p e then fun () -> Nil else fun () -> Cons(e,keep_until p rest) let to_list (seq : 'a seq) : 'a list = let rec produce_list seq acc = match seq () with | Nil -> acc | Cons(e, rest) -> produce_list rest (e::acc) in List.rev (produce_list seq [])  let range (start : int) (step : int) (stop : int) : int seq = let negative_inf =  start < stop && step < 0 in let positive_inf = start > stop && step > 0 in if negative_inf || positive_inf then raise (Invalid_argument \"Infinity Sequence\") else let start_seq = map (fun e -> step * e + start) nats in let p elem = if step > 0 then elem >= stop else elem <= stop in keep_until p start_seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  " module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den <> 0 && b.den <> 0 then {num = a.den * b.num + a.num * b.den; den = a.den * b.den} else raise DivideByZero  let mul a b = if a.den <> 0 && b.den <> 0 then {num = a.num*b.num; den = a.den * b.den} else raise DivideByZero  let neg a = if a.den <> 0 then {num = (-1) * a.num; den = a.den} else raise DivideByZero  let inv a = if a.den <> 0 then {num = a.den; den = a.num} else raise DivideByZero end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b =  not (equal a b) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs =  not (F.equal (F.add F.one F.one) F.zero) && not (F.equal (F.add (F.add F.one F.one) F.one) F.zero) let onCurve p q (x,y) = F.equal (F.mul y y) (F.add (F.add (F.mul (F.mul x x) x) (F.mul p x)) q) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (a, b) = MazeGen.dims maze in let move (w : int) (h : int) (d : MazeGen.dir)= match d with | MazeGen.North -> (w, h-1) | MazeGen.South -> (w, h+1) | MazeGen.East -> (w+1, h) | MazeGen.West -> (w-1, h) in let rec solve (position : (int * int)) dir fail succ = match position with | 0, 0 -> succ [] | w, h when MazeGen.has_wall maze (w, h, dir) -> fail () | w, h -> let (right, front, left) = MazeGen.dirs_to_check dir in let (x', y') = move w h dir in let fc2 = (fun () -> solve (x', y') left (fun () -> fail ()) (fun x -> succ (dir :: x)) ) in let fc1 = (fun () -> solve (x', y') front fc2 (fun x -> succ (dir :: x))) in solve (x', y') right fc1 (fun x -> succ (dir :: x)) in solve (a-1, b-1) MazeGen.North (fun () -> solve (a-1, b-1) MazeGen.West (fun () -> raise NotFound) (fun x -> x)) (fun x -> x) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons(a, aseq), Cons(b, bseq) -> Cons((a, b), zip aseq bseq) | _ -> Nil ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Cons (a, aseq) when not (p a) -> Cons(a, keep_until p aseq) | _ -> Nil ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec take_element s acc = match s () with | Nil -> acc | Cons (a, aseq) -> take_element aseq (acc @ [a]) in take_element seq [] ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Step is 0 so stop will never to reached. Forever looping.\") else if stop - start = 0 then empty else match (stop - start) > 0 , step > 0 with | false, true -> raise (Invalid_argument \"Stop is less than start but step is positive. Forever looping.\") | true, false -> raise (Invalid_argument \"Stop is greated than start but step is negative. Forever looping.\") | _ -> if step > 0 then begin let s1 = map (fun x -> x + start) nats in let s2 = Seq.filter (fun x -> ((x - start) mod step) = 0) s1 in keep_until (fun x -> x >= stop) s2 end else begin let s1 = map (fun x -> x + start) (map (fun x -> x * (-1)) nats) in let s2 = Seq.filter (fun x -> ((x - start) mod step) = 0) s1 in keep_until (fun x -> x <= stop) s2 end end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = { num = a.num * b.den + b.num * a.den ; den = a.den * b.den }  let mul a b = { num = a.num * b.num ; den = a.den * b.den }  let neg a = { num = (-1) * a.num ; den = a.den }  let inv a = match a.num with | 0 -> raise DivideByZero | _ -> { num = a.den ; den = a.num }  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add (a : bool) (b : bool) = match a, b with | true, true -> false | false, true -> true | true, false -> true | false, false -> false  let mul (a : bool) (b : bool) = match a, b with | true, true -> true | _ -> false  let neg (a : bool) = a  let inv (a : bool) = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (wedth, height) = dims maze in  let proceed ((x, y, _): state) direction: state= match direction with |West ->(x-1,y,West) |North -> (x,y-1,North) |East ->(x+1,y,East) |South -> (x,y+1,South) in  let turnAround direction = match direction with | West -> East | North -> South | East -> West | South -> North in  let rec solve_maze' (s1:state) (cont:dir list -> dir list) : dir list = match s1 with | (0,0,_) -> cont [] |(x,y,d1)-> let (r,f,l) = dirs_to_check d1 in if not (has_wall maze (x, y, r)) then solve_maze' (proceed s1 r) (fun acc -> cont (r::acc)) else if not (has_wall maze (x, y, f)) then solve_maze' (proceed s1 f) (fun acc -> cont (f::acc)) else if not (has_wall maze (x, y, l)) then solve_maze' (proceed s1 l) (fun acc -> cont (l::acc)) else solve_maze' (proceed s1 (turnAround f)) (fun acc -> cont ((turnAround f)::acc)) in  let rec cleanOpposite (dir_list:dir list) (acc: dir list): dir list = match dir_list with | [] -> acc | t :: [] -> acc @ [t] | d1 :: d2 :: tail -> if turnAround d2 = d1 then cleanOpposite (acc @ tail) [] else cleanOpposite  (d2 :: tail) (acc @ [d1]) in   let list = solve_maze' (wedth-1, height-1, North) (fun l ->l) in cleanOpposite list [] ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (),seq2 () with |Nil,_-> fun() -> Nil; |_, Nil -> fun () -> Nil; |Cons(x,xs),Cons(y,ys) -> fun () -> Cons ((x,y),zip xs ys) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> (fun() -> Nil) |Cons(x, xs) -> if p x then (fun()-> Nil) else (fun () -> Cons(x, keep_until p xs))  let to_list (seq : 'a seq) : 'a list = let rec to_list' seq cont = match seq() with | Nil -> cont [] | Cons(x,xs)-> to_list' xs (fun l -> cont (x::l)) in to_list' seq (fun l -> l)  let range (start : int) (step : int) (stop : int) : int seq = let l1 = map (fun x -> x*step + start) nats in try if start = stop then fun()-> Nil else if step <0 then keep_until (fun x-> x<= stop) l1 else  keep_until (fun x-> x>= stop) l1 with _ -> raise (Invalid_argument \"The output is an infinite sequence\")  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num =0; den = 1} let one = {num = 1; den =1 } let add x y = let n1 = x.num * y.den + y.num * x.den in let d1 = x.den * y.den in match n1, d1 with | 0,_ -> zero | x,y when x = y -> one | x,y -> {num = x ; den = y}  let mul x y = let n1 = x.num * y.num in let d1 = x.den * y.den in match n1,d1 with | 0,_ -> zero | x,y when x=y -> one | x,y -> {num = x ; den = y}  let neg a =  {num = -1 * a.num; den = a.den} let inv a =  {num = a.den; den = a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add x y= match x ,y with | false , false -> false | true , true -> false | true , false -> true | false, true -> true let equal = (=) let mul = (&&) let neg x =  x let inv x =  x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =   let open MazeGen in    let move_towards v = match v with |(x,y,East) -> (x + 1, y) |(x,y,West) -> (x - 1, y) |(x,y,North) ->(x, y - 1) |(x,y,South) ->(x, y + 1)  in  let string_dir d = match d with |East -> \"East\" |West -> \"West\" |North -> \"North\" |South -> \"South\"   in  let print_state t = let (a,b, v) = t in \"(\" ^ string_of_int a ^ \",\" ^ string_of_int b ^ \")\" ^ \"FACING: \" ^ string_dir v  in  let rev_dir v = match v with |East -> West |West -> East |North -> South |South -> North  in    let rec maze_helper maze dirlist (state:MazeGen.state) check cont =  let (x,y,v) = state in  if (x,y) = (0,0) then let void = () in Some dirlist  else let (a,b,c) = dirs_to_check v in let rec cont_1 = fun () ->  if check = c then let revdir = rev_dir b in  None  else if check = a then  maze_helper maze dirlist state b cont_1  else  maze_helper maze dirlist state c cont_1 in if not (has_wall maze (x,y,check)) then let newdir = check in let (j,k) = move_towards (x,y,newdir) in let newstate = (j,k,newdir) in let newlist = dirlist @ [newdir] in let (one,_,_) = dirs_to_check newdir in let return = maze_helper maze newlist newstate one cont_1 in match return with |None -> cont_1() |(Some dir) -> Some dir  else let void = () in cont_1()    in let (width, height) = dims maze in let (Some dirlist) = maze_helper maze [] (width - 1,height - 1,North) East (fun()->None) in dirlist         ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let open MazeGen in let path = [] in print_string (MazeGen.string_of_maze ~path maze ^ \"\\n\"); let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq   let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq =  let force = fun f -> f()  in   let rec helper seq1 seq2 = let a = force seq1 in let b = force seq2 in  match a,b with |Cons(hd1,tl1) , Cons(hd2,tl2) -> fun () -> Cons( (hd1,hd2) , helper tl1 tl2 ) |_ -> fun () -> Nil  in  helper seq1 seq2   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq =  let force = fun f -> f()  in  let a = force seq in  match a with |Nil -> fun () -> Nil |Cons(hd,tl) when p hd -> fun () ->Nil |Cons(hd,tl) -> fun () -> Cons(hd, keep_until p tl)    let to_list (seq : 'a seq) : 'a list =  let force = fun f -> f()  in   let rec helper seq list =  let a = force seq in  match a with |Cons(hd,tl) -> let newlist = list @ [hd] in helper tl newlist |Nil ->  list  in  helper seq []   let range (start : int) (step : int) (stop : int) : int seq =  if (start < stop && step < 0) then invalid_arg \"step var should be > 0\"  else if (start > stop && step > 0) then invalid_arg \"step var should be < 0\"  else  let force = fun f -> f()  in  let ustop x = x = stop in    let rec z_int from : 'a seq = if (from >= 0 && step > 0) then nats else if stop > 0 then fun () -> Cons(from, z_int (from + 1)) else fun () -> Cons(from, z_int (from - 1))  in  let r_seq = z_int start in   let finseq = keep_until ustop r_seq in  let helper x =  if (x = start) then Some x  else if ( ( (x - start) mod step )= 0 ) then Some x  else None  in  let tmplist = Seq.map helper finseq in  let rec aux seq = let a = force seq in  match a with |Cons(hd,tl) when not (hd = None) -> let (Some int) = hd in Cons(int, fun () -> aux tl) |Cons(hd,tl) -> aux tl |Nil -> Nil  in fun () -> aux tmplist      end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField: (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let add x y = {num = (x.num * y.den) + (y.num * x.den); den = x.den * y.den} let mul x y = {num = x.num * y.num; den = x.den * y.den}  let neg x = {num = (-x.num);den = x.den} let inv x = {num = x.den; den = x.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add = (!=) let mul x y = (x = y) && (x) && (y)  let neg x = x let inv x = x  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let leftify d = match d with | North -> West | West -> South | South -> East | East -> North in let rightmost d = let (rm, _, _) = dirs_to_check d in rm in let next (x, y, d) = let (x, y) = match d with | North -> (x, y-1) | West -> (x-1, y) | South -> (x, y+1) | East -> (x+1, y) in (x, y, rightmost d) in  let rec checkpath (x, y, d) backdir upc instructions = let new_upc = fun () -> checkpath (x, y, leftify d) (backdir) upc instructions in if (x, y) = (0, 0) then instructions [] else if d = backdir then upc () else begin if has_wall maze (x, y, d) then new_upc () else checkpath (next (x, y, d)) (leftify (leftify d)) (new_upc) (fun l -> instructions (d::l)) end in let (x, y) = dims maze in checkpath (x-1, y-1, North) South (fun () -> raise NotFound) (fun l -> l) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () with | Nil -> empty | Cons (hd1, tl1) -> match seq2 () with | Nil -> empty | Cons (hd2, tl2) -> (fun () -> Cons ((hd1, hd2), zip tl1 tl2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (hd, tl) -> if p hd then empty else (fun () -> Cons (hd, keep_until p tl)) let to_list (seq : 'a seq) : 'a list = fold_left (fun a b -> a @ [b]) [] seq let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"step of zero leads to infinite recursion\") else if (step < 0 && stop > start) || (step > 0 && stop < start) then raise (Invalid_argument \"step should go in the direction of start -> stop, stop cannot ever be passed with the current step and start\") else let compare = (if step < 0 then (<=) else (>=)) in keep_until (fun b -> compare b stop) (map (fun a -> start + (a * step)) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = (a.num * b.den) + (a.den * b.num); den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = 0 - a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = not (a = b) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let move_cell (x, y) dir = match dir with | MazeGen.East -> (x+1, y, MazeGen.East) | MazeGen.North -> (x, y-1, MazeGen.North) | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.South -> (x, y+1, MazeGen.South) in let rec move_next sc fl (x, y, dir) = if x = 0 && y = 0 then sc [] else let (right, front, left) = MazeGen.dirs_to_check dir in let left_check () = if not (MazeGen.has_wall maze (x, y, left)) then match dir with | MazeGen.East -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.North) | MazeGen.North -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.West) | MazeGen.West -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.South) | MazeGen.South -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.East) else fl () in let front_and_left_check () = if not (MazeGen.has_wall maze (x, y, front)) then match dir with | MazeGen.East -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.East) | MazeGen.North -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.North) | MazeGen.West -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.West) | MazeGen.South -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.South) else if not (MazeGen.has_wall maze (x, y, left)) then match dir with | MazeGen.East -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.North) | MazeGen.North -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.West) | MazeGen.West -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.South) | MazeGen.South -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.East) else fl () in if not (MazeGen.has_wall maze (x, y, right)) then match dir with | MazeGen.East -> move_next (fun prev_list -> sc (right::prev_list)) (fun () -> front_and_left_check ()) (move_cell (x, y) MazeGen.South) | MazeGen.North -> move_next (fun prev_list -> sc (right::prev_list)) (fun () -> front_and_left_check ()) (move_cell (x, y) MazeGen.East) | MazeGen.West -> move_next (fun prev_list -> sc (right::prev_list)) (fun () -> front_and_left_check ()) (move_cell (x, y) MazeGen.North) | MazeGen.South -> move_next (fun prev_list -> sc (right::prev_list)) (fun () -> front_and_left_check ()) (move_cell (x, y) MazeGen.West) else if not (MazeGen.has_wall maze (x, y, front)) then match dir with | MazeGen.East -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.East) | MazeGen.North -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.North) | MazeGen.West -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.West) | MazeGen.South -> move_next (fun prev_list -> sc (front::prev_list)) (fun () -> left_check ()) (move_cell (x, y) MazeGen.South) else if not (MazeGen.has_wall maze (x, y, left)) then match dir with | MazeGen.East -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.North) | MazeGen.North -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.West) | MazeGen.West -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.South) | MazeGen.South -> move_next (fun prev_list -> sc (left::prev_list)) fl (move_cell (x, y) MazeGen.East) else fl () in let (width, height) = MazeGen.dims maze in move_next (fun l -> l) (fun () -> raise NotFound) (width-1, height-1, MazeGen.North) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 ()), (seq2 ()) with | Nil, Nil -> (fun () -> Nil) | Cons(a, sr1), Nil -> (fun () -> Nil) | Nil, Cons(b, sr) -> (fun () -> Nil) | Cons(a, sr1), Cons(b, sr2) -> (fun () -> Cons((a,b),  zip sr1 sr2)) ;; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq ()) with | Nil -> (fun () -> Nil) | Cons(a, str) -> if p a then (fun () -> Nil) else (fun () -> Cons(a, keep_until p str)) ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec to_list_tl seq acc = match (seq ()) with | Nil -> acc | Cons(a, str) -> to_list_tl str (acc @ [a]) in to_list_tl seq [] ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if (stop > start) && (step < 0) || (stop < start) && (step > 0) || step = 0 || start = stop then raise (Invalid_argument \"infinite sequence\") else if start < stop then keep_until (fun x -> x >= stop) (map (fun x -> start + (x * step)) nats) else keep_until (fun x -> x <= stop) (map (fun x -> start + (x * step)) nats) ; end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den = b.den then {num = (a.num + b.num) ; den = (a.den)} else {num = (a.num * b.den) + (b.num * a.den); den = (a.den * b.den)}  let mul a b = {num = (a.num * b.num); den = (a.den * b.den)}  let neg a = {num = (0 - a.num); den = a.den}  let inv a = {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add a b = match a, b with | false, false -> false | true, false | false, true -> true | true, true -> false  let mul a b = match a, b with | false, false -> false | true, false | false, true -> false | true, true -> true  let neg a = a  let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (x, y) = dims maze in let next s = let (o, p, q) = s in if q = North then (o, p-1, q) else if q = West then (o-1, p, q) else if q = East then (o+1, p, q) else (o, p+1, q) in let helper_dir s = let out = ref [] in let (q, w, r) = s in let (a, b, c) = dirs_to_check r in if not (has_wall maze (q, w, c)) then out := c :: !out; if not (has_wall maze (q, w, b)) then out := b :: !out; if not (has_wall maze (q, w, a)) then out := a :: !out; out in let step_for_start = !(helper_dir start) in let rec helper i dir_l fail succeed = match i with | (0, 0, _) -> succeed [] | (q, w, r) -> if dir_l = [] then fail () else let l::ls = dir_l in helper (next (q, w, l)) !(helper_dir (next (q, w, l))) (fun () -> helper i ls fail succeed) (fun lis -> succeed (l :: lis)) in helper start step_for_start (fun () -> raise NotFound) (fun e -> e) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1(), seq2() with | Nil, _ -> Nil | _, Nil -> Nil | Cons(x, xs), Cons(y, ys) -> Cons((x, y), (zip xs ys)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(x, xs) -> if p x then empty else cons x (keep_until p xs) let to_list (seq : 'a seq) : 'a list = let rec list_r s acc = match s with | Nil -> acc | Cons(x, xs) -> list_r (xs()) (x :: acc) in List.rev (list_r (seq()) []) let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"If step is 0, nothing will be returned.\") else if step > 0 && stop < start then raise (Invalid_argument \"Stop is less than start, this will never stop\") else if step < 0 && stop > start then raise (Invalid_argument \"Stop is greater than start, this will never stop\") else let k = fun x -> if step < 0 then x <= stop else x >= stop in let map_list = map (fun y -> start + step * y) nats in keep_until k map_list end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -1 * a.num; den = a.den} let inv a = {num = a.den; den = a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = (not a && b) || (not b && a) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let mazeDims = MazeGen.dims maze in let (mazeWidth, mazeHeight) = mazeDims in  let getCoords (stateQuery: MazeGen.state) : int * int = let (x, y, _) = stateQuery in (x, y) in  let getStateDir (stateQuery : MazeGen.state) : MazeGen.dir = let (_, _, d) = stateQuery in d in  let getNextState cell dir : MazeGen.state = let (x, y) = cell in let currentState = (x, y, dir) in if MazeGen.has_wall maze (x, y, dir) then currentState else | MazeGen.North -> if y > 0 then (x, y-1, dir) else currentState | MazeGen.East -> if x < (mazeWidth-1) then (x+1, y, dir) else currentState | MazeGen.West -> if x > 0 then (x-1, y, dir) else currentState | MazeGen.South -> if y < (mazeHeight-1) then (x, y+1, dir) else currentState in  let turnAround state = let (x, y, opposite) = state in match opposite with | MazeGen.North -> (x, y, MazeGen.South) | MazeGen.South -> (x, y, MazeGen.North) | MazeGen.East -> (x, y, MazeGen.West) | MazeGen.West -> (x, y, MazeGen.East) in else if MazeGen.has_wall maze goRight then if MazeGen.has_wall maze goStraight then if MazeGen.has_wall maze goLeft then maze_runner maze (getNextState currentCell oppositeDir) (fun r -> cont (List.append (oppositeDir::[]) r)) else maze_runner maze (getNextState currentCell thirdDir) (fun r -> cont (List.append (thirdDir::[]) r)) else maze_runner maze (getNextState currentCell secondDir) (fun r -> cont (List.append (secondDir::[]) r)) else maze_runner maze (getNextState currentCell firstDir) (fun r -> cont (List.append (firstDir::[]) r))  in maze_runner maze (mazeWidth-1, mazeHeight-1, MazeGen.North) (fun r -> r) *)  let rec maze_runner maze state sc fc = let currentCell = getCoords state in let currentDir = getStateDir state in let oppositeState = turnAround state in let newDirs = MazeGen.dirs_to_check (getStateDir state) in let (firstDir, secondDir, thirdDir) = newDirs in else let sc1 = fun r -> sc (List.append (firstDir::[]) r) in let sc2 = fun r -> sc (List.append (secondDir::[]) r) in let sc3 = fun r -> sc (List.append (thirdDir::[]) r) in let fc3 = fun () -> maze_runner maze oppositeState sc fc in let fc2 = fun () -> maze_runner maze (getNextState currentCell thirdDir) sc3 fc3 in let fc1 = fun () -> maze_runner maze (getNextState currentCell secondDir) sc2 fc2 in  maze_runner maze (getNextState currentCell firstDir) sc1 fc1 in maze_runner maze (mazeWidth-1, mazeHeight-1, MazeGen.North) (fun r -> r) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = raise NotImplemented let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec path has_wall maze (x,y) direction sc fc  = match (x,y), direction with |(0,0), _  -> sc [] |(x,y), direction -> let dirs = MazeGen.dirs_to_check direction in let get_right (right,_,_) = right in let get_front (_,front,_) = front  in let get_left (_,_,left) = left in let right = get_right dirs in let front = get_front dirs in let left = get_left dirs in let next_cell direction = match direction with |MazeGen.North -> (x,(y-1)) |MazeGen.South -> (x,(y+1)) |MazeGen.East -> ((x+1),y) |MazeGen.West->  ((x-1),y) in  let (x',y') = next_cell direction in if not (has_wall maze (x,y,direction )) then if (x',y') = (0,0) then sc [] else path has_wall maze  (x',y') right (fun r -> sc (right::r)) (fun () -> path has_wall maze (x',y') front (fun r -> sc (front::r)) (fun () -> path has_wall maze (x',y') left (fun r -> sc (left::r)) fc )) else fc ()  in let open MazeGen in let maze_size = MazeGen.dims maze in let init_coordinate = ((fst maze_size)-1,(snd maze_size) -1) in path MazeGen.has_wall maze init_coordinate MazeGen.North (fun l -> MazeGen.North::l) (fun () -> path MazeGen.has_wall maze init_coordinate MazeGen.West  (fun l->MazeGen.West::l) (fun () -> raise NotFound))   ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2()  with |Nil,_ -> Nil |_,Nil -> Nil |Cons (a, a'), Cons (b,b')-> Cons((a,b), zip a' b') let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with |Nil -> Nil |Cons(s,s') -> if (p s) then Nil else Cons (s, keep_until p s') let to_list (seq : 'a seq) : 'a list = let rec seq_to_list seq = match seq () with |Nil -> [] |Cons (s,s')-> s :: (seq_to_list s') in seq_to_list seq let range (start : int) (step : int) (stop : int) : int seq = let inc x = start + x * step in let map_to_nats = Seq.map inc nats in if step = 0 || (start > 0 && stop>0 && step <0) || (start < 0 && stop <0 && step >0) ||(start = stop) then raise (Invalid_argument \"Wrong Inputs\") else if step > 0 then  keep_until (fun x -> x>= stop) map_to_nats else keep_until (fun x -> x <= stop) map_to_nats end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = (~-) a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=) let add = (<>) let mul = (&&) let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w, h) = MazeGen.dims maze in let start_state = (w-1, h-1, MazeGen.North) in let next_cell st = match st with | (x, y, MazeGen.West) -> (x - 1, y, MazeGen.West) | (x, y, MazeGen.North) -> (x, y - 1, MazeGen.North) | (x, y, MazeGen.East) -> (x + 1, y, MazeGen.East) | (x, y, MazeGen.South) -> (x, y + 1, MazeGen.South) in let rec solve_mzz maze st succ_func fail_func = let (cur_x, cur_y, cur_dir) = st in let (rgt, fwd, lft) = MazeGen.dirs_to_check cur_dir in if (cur_x, cur_y) = (0, 0) then succ_func [] else ( let go_left = fun () -> if not (MazeGen.has_wall maze (cur_x, cur_y, lft)) then solve_mzz maze (next_cell (cur_x, cur_y, lft)) (fun dirs -> succ_func (lft::dirs)) fail_func else fail_func () in let go_fwd = fun () -> if not (MazeGen.has_wall maze (cur_x, cur_y, fwd)) then solve_mzz maze (next_cell (cur_x, cur_y, fwd)) (fun dirs -> succ_func (fwd::dirs)) go_left else go_left () in if not (MazeGen.has_wall maze (cur_x, cur_y, rgt)) then solve_mzz maze (next_cell (cur_x, cur_y, rgt)) (fun dirs -> succ_func (rgt::dirs)) go_fwd else go_fwd () ) in let first_fail = fun () -> solve_mzz maze (next_cell (w-1, h-1, MazeGen.West)) (fun dirs -> MazeGen.West::dirs) (fun () -> raise NotFound) in solve_mzz maze (next_cell start_state) (fun dirs -> MazeGen.North::dirs) first_fail ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let node1 = seq1() in let node2 = seq2() in match node1, node2 with | Nil, _ -> fun () -> Nil | _, Nil -> fun () -> Nil | Cons(hd1, tl1), Cons(hd2, tl2) -> fun () -> Cons((hd1, hd2), (zip tl1 tl2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let node = seq() in match node with | Nil -> fun () -> Nil | Cons(hd, tl) -> if p hd then fun () -> Nil else fun () -> Cons(hd, (keep_until p tl))  let to_list (seq : 'a seq) : 'a list = let rec to_list_tl (seq_t : 'a seq) acc = let node = seq_t() in match node with |Nil -> acc |Cons(hd, tl) -> to_list_tl tl (acc@[hd]) in to_list_tl seq [] let range (start : int) (step : int) (stop : int) : int seq = let num = abs ((abs (stop - start) - 1) / step) in let stream = keep_until ((<) (num)) nats in map (fun a -> (start + (step * a))) stream end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num*b.den + b.num*a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = (a && not b) || (not a && b) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (width,height) = dims maze in let nextCell (x,y,_) dir :state= match dir with | West -> (x-1,y,West) | North -> (x,y-1,North) | East ->(x+1,y,East) | South -> (x,y+1,South) in let tuple_map f (dir1,dir2,dir3) = (f dir1, f dir2, f dir3) in  let rec find_path (state:state) back (path:dir list -> dir list) : dir list = match state with | (0,0,_) -> path [] | (x,y,dir) -> let (right,front,left) = dirs_to_check dir in let (r_wall,f_wall,l_wall) = tuple_map (has_wall maze) ((x,y,right),(x,y,front),(x,y,left)) in let cont = back in if not l_wall then let cont = fun () ->  find_path (nextCell state left) cont (fun acc -> path (left::acc)) in if not f_wall then let cont = fun () -> find_path (nextCell state front) cont (fun acc-> path (front::acc)) in if not r_wall then let cont = fun () -> find_path (nextCell state right) cont (fun acc-> path (right::acc)) in cont () else cont () else if not r_wall then let cont = fun () -> find_path (nextCell state right) cont (fun acc-> path (right::acc)) in cont () else cont () else if not f_wall then let cont = fun () -> find_path (nextCell state front) cont (fun acc-> path (front::acc)) in if not r_wall then let cont = fun () -> find_path (nextCell state right) cont (fun acc-> path (right::acc)) in cont () else cont () else if not r_wall then let cont = fun () -> find_path (nextCell state right) cont (fun acc -> path (right::acc)) in cont () else cont () in find_path (width-1,height-1,North) (fun () -> []) (fun l -> l)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (),seq2 () with | Nil,_ | _,Nil-> fun () -> Nil | Cons(x,xs),Cons(y,ys) -> fun () -> Cons ((x,y),zip xs ys)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons(x,xs) -> if p x then fun () -> Nil else fun () -> Cons (x, keep_until p xs) let to_list (seq : 'a seq) : 'a list = let rec helper seq cont = match seq () with | Nil -> cont [] | Cons(x,xs)-> helper xs (fun l -> cont (x::l)) in helper seq (fun l -> l) let range (start : int) (step : int) (stop : int) : int seq = if start <stop then if step <= 0 then invalid_arg (\"Infinite Sequence\") else keep_until (fun x-> x>= stop) (map (fun x -> x*step + start) nats) else if start > stop then if step >= 0 then invalid_arg (\"Infinite Sequence\") else keep_until (fun x-> x<= stop) (map (fun x -> x*step + start) nats) else fun () -> Nil end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num =  0; den = 1} let one = {num = 1 ; den = 1} let add x y= let num = x.num * y.den + y.num * x.den in let den = x.den * y.den in match num, den with | 0,_ -> zero | x,y when x = y -> one | x,y -> {num = x ; den = y} let mul x y = let num = x.num * y.num in let den = x.den * y.den in match num,den with | 0,_ ->zero | x,y when x=y -> one | x,y -> {num = x ; den = y}  let neg x = {num = -x.num ;den= x.den} let inv x = {num = x.den ; den= x.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add x y= match x ,y with | false , false -> zero | true , true -> zero | true , false -> true | false, true -> true let mul = (&&) let neg x =  x let inv x =  x let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = let two = F.add F.one F.one in let three = F.add two F.one in not (F.equal F.zero two) && not (F.equal F.zero three);; ",
  "let onCurve p q (x,y)= let lhs = F.mul y y in let rhs = F.add (F.add (F.mul x (F.mul x x)) (F.mul p x)) q in F.equal lhs rhs;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =   let (w,h) = MazeGen.dims maze in let start_state = (w - 1, h - 1, MazeGen.North) in  let next_dir dir (d1, d2, d3) = if dir = d1 then Some d2 else if dir = d2 then Some d3 else None in  let forward (w,h,dr) = match dr with | MazeGen.North -> (w,h-1,MazeGen.East) | MazeGen.South -> (w,h+1,MazeGen.West) | MazeGen.East -> (w+1,h,MazeGen.South) | MazeGen.West -> (w-1,h,MazeGen.North) in  let backward (w,h,dr) = match dr with | MazeGen.North -> (w-1,h,MazeGen.North) | MazeGen.South -> (w+1,h,MazeGen.South) | MazeGen.East -> (w,h-1,MazeGen.East) | MazeGen.West -> (w,h+1,MazeGen.West) in  let is_opposite d1 d2 = match d1 with | MazeGen.North -> d2 = MazeGen.South | MazeGen.South -> d2 = MazeGen.North | MazeGen.East -> d2 = MazeGen.West | MazeGen.West -> d2 = MazeGen.East in  let rec inner (maz : MazeGen.maze) ((a,b,dir): MazeGen.state) ls (d1,d2,d3) sc fc =  match (a,b,dir) with | (0,0,_) -> ls | (_,_,_) -> if MazeGen.has_wall maze (a,b,dir) then match next_dir dir (d1,d2,d3) with | Some x -> inner maz (a,b,x) ls (d1,d2,d3) sc fc | None -> let (x,y,dr) = backward (a,b,dir) in inner maz (x,y,dr) (fc ls) (MazeGen.dirs_to_check dr) sc fc else inner maz (forward (a,b,dir)) (sc dir ls) (MazeGen.dirs_to_check dir) sc fc in  let fail ls = match List.rev ls with | [] -> [] | h::t -> List.rev t in let success x ls = match List.rev ls with | [] -> [x] | h :: t -> if is_opposite x h then fail ls else ls @ [x] in  inner maze start_state [] (MazeGen.dirs_to_check MazeGen.North) success fail ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(), seq2()) with | ( Cons (hd1, tl1), Cons (hd2, tl2) ) -> (fun () -> Cons ((hd1, hd2), (zip tl1 tl2))) | (Nil, _) -> empty | (_, Nil) -> empty  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons (hd, tl) -> if p hd then empty else (fun () -> Cons (hd, keep_until p tl)) let to_list (seq : 'a seq) : 'a list = let rec list_tr seq lst = match seq() with | Nil -> lst | Cons (hd, tl) -> list_tr tl (hd :: lst) in List.rev (list_tr seq []) let range (start : int) (step : int) (stop : int) : int seq =  if step > 0 then if start > stop then raise (Invalid_argument \"Your stop value is less than your start value but your step is positive\") else let legal_ints = keep_until (fun b -> let x = (stop - start)/step in if (mod) (stop - start) step = 0 then b = x else b = x + 1) nats in map (fun x -> start + x * step) legal_ints   else if step < 0 then if start < stop then raise (Invalid_argument \"Your start value is less than your stop value but your step is negative\") else let legal_ints = keep_until (fun b -> let x = (stop - start)/step in if (mod) (stop - start) step = 0 then b = x else b = x + 1) nats in map (fun x -> start + (x * step)) legal_ints  else raise (Invalid_argument \"A step of 0 is illegal\") end ;; ",
  " let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if equal a zero then b else if equal b zero then a else {num = (a.num * b.den + a.den * b.num); den = (a.den * b.den)}  let mul a b = if equal a zero || equal b zero then zero else if equal a one then b else if equal b one then a else {num = (a.num * b.num); den = (a.den * b.den)}  let neg a = if equal a zero then zero else {num = 0 - a.num; den = a.den}  let inv a = if equal a zero then raise DivideByZero else if equal a one then one else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = match (a,b) with | (false, false) -> false | (true, true) -> false | _ -> true  let mul a b = match (a,b) with | (false, false) -> false | (true, true) -> true | _ -> false  let neg a = a  let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w,h) = MazeGen.dims maze in let start_w = w - 1 and start_h = h - 1 in let next_cell (x, y, dir_go) = match dir_go with |MazeGen.West -> (x-1, y, dir_go) |MazeGen.North -> (x, y-1, dir_go) |MazeGen.East -> (x+1, y, dir_go) |MazeGen.South -> (x, y+1, dir_go) in let rec maze_solve (a,b,c) sc fc = if MazeGen.has_wall maze (a, b, c) then fc () else let (d, e, f) = next_cell (a, b, c) in if (d = 0) && (e = 0) then sc [f] else let (g, h, i) = MazeGen.dirs_to_check f in maze_solve (d, e, g) (fun x -> sc (c :: x)) (fun () -> maze_solve (d, e, h) (fun x -> sc (c :: x)) (fun () -> maze_solve (d, e, i) (fun x -> sc (c :: x)) (fc))) in maze_solve (start_w, start_h, MazeGen.North) (fun x -> x) (fun () -> maze_solve (start_w, start_h, MazeGen.West) (fun x -> x) (fun () -> [])) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2() with |Cons(x, xs), Cons(y, ys) -> Cons ((x,y), zip xs ys) |_ -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with |Nil -> Nil |Cons(x, xs) -> if p x then Nil else Cons (x, keep_until p xs)  let to_list (seq : 'a seq) : 'a list = let rec transform seq = match seq () with |Nil -> [] |Cons(x,xs) -> x::(transform xs) in transform seq let range (start : int) (step : int) (stop : int) : int seq = if (stop < start && step > 0) || (step = 0) || (stop > start && step < 0) then raise (Invalid_argument \"Invalid input parameters. Step cannot be 0. Start cannot be greater than stop if step is positive. Start cannot be less than stop if step is negative.\") else let change_n_p p = let rec change p acc = if p = 0 then acc else change (p-1) (acc + step) in change p start in let change_n_n p = let rec change p acc = if p = 0 then acc else change (p-1) (acc + step) in change p start in let test_positive x = x >= stop in let test_negative y = y <= stop in if (step > 0) then keep_until test_positive (map change_n_p nats) else keep_until test_negative (map change_n_n nats)   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den ;den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=) let add = ( <> ) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let new_position (x, y) dir = match dir with | MazeGen.West -> (x-1, y) | MazeGen.North -> (x, y-1) | MazeGen.East -> (x+1, y) | MazeGen.South -> (x, y+1) in let rec find_path (x, y) list dir fail succeed = let (r, f, l) = MazeGen.dirs_to_check dir in if ((x, y) = (0, 0)) then succeed list else if (MazeGen.has_wall maze (x, y, dir)) then fail () else find_path (new_position (x, y) dir) (list@[dir]) r (fun () -> find_path (new_position (x, y) dir) (list@[dir]) f (fun () -> find_path (new_position (x, y) dir) (list@[dir]) l fail succeed) succeed) succeed in let (x, y) = MazeGen.dims maze in find_path (x-1, y-1) [] MazeGen.North (fun () -> find_path (x-1, y-1) [] MazeGen.West (fun () -> raise NotFound) (fun x -> x)) (fun x -> x) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ -> empty | _, Nil -> empty | Cons (x, xs), Cons (y, ys) -> (fun () -> Cons ((x,y), zip xs ys)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (x, xs) -> if (p x) then empty else (fun () -> Cons (x, keep_until p xs)) let to_list (seq : 'a seq) : 'a list = let rec create acc seq = match seq() with | Nil -> acc | Cons (x, xs) -> create (acc@[x]) xs in create [] seq  exception Invalid_argument let range (start : int) (step : int) (stop : int) : int seq = if (start == stop) then raise Invalid_argument else if (start > stop && step > 0) then raise Invalid_argument else if (start < stop && step < 0) then raise Invalid_argument else keep_until (fun x -> (step > 0 && x >= stop) || (step < 0 && x <= stop)) (map (fun x -> start + x * step) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = (not a && b) || (not b && a) let mul = (&&)  let neg a = a let inv a = a end ;; ",
  "let move (input:MazeGen.state) : (MazeGen.state)  = match input with | (x, y ,MazeGen.West)-> (x-1, y, MazeGen.West) | (x, y ,MazeGen.North)-> (x, y-1, MazeGen.North) | (x, y ,MazeGen.East)-> (x+1, y, MazeGen.East) | (x, y ,MazeGen.South)-> (x, y+1, MazeGen.South) in let (width, height) = MazeGen.dims maze in  let rec solver (my_state:MazeGen.state) maze sc fc: MazeGen.dir list= match my_state with  | (0,0, final_dir) -> sc [final_dir] | (x, y, direction) -> let (right,forward,left) = MazeGen.dirs_to_check direction in  if (MazeGen.has_wall maze (x,y,right)) then fc else solver (move (x,y,right)) maze (fun p -> sc (right:: p)) (fun () -> helper (move (x,y,forward)) maze (fun p -> sc (forward ::p)) fc) in solver (width-1,height-1,MazeGen.North) maze (fun r -> r) (fun r -> r) ) ;; ",
  "*)     let move_helper (input:MazeGen.state) : (MazeGen.state)  = match input with | (x, y ,MazeGen.West)-> (x-1, y, MazeGen.West) | (x, y ,MazeGen.North)-> (x, y-1, MazeGen.North) | (x, y ,MazeGen.East)-> (x+1, y, MazeGen.East) | (x, y ,MazeGen.South)-> (x, y+1, MazeGen.South) in  let move_backwards (input:MazeGen.state) : (MazeGen.state) = match input with | (x, y ,MazeGen.West)-> (x+1, y, MazeGen.East) | (x, y ,MazeGen.North)-> (x, y+1, MazeGen.South) | (x, y ,MazeGen.East)-> (x-1, y, MazeGen.West) | (x, y ,MazeGen.South)-> (x, y-1, MazeGen.North) in  let opposite (input:MazeGen.dir) : (MazeGen.dir) = match input with | MazeGen.West-> (MazeGen.East) | (MazeGen.North)-> (MazeGen.South) | (MazeGen.East)-> (MazeGen.West) | (MazeGen.South)-> (MazeGen.North) in  let (width, height) = MazeGen.dims maze in   let rec solver (my_state:MazeGen.state) maze cont straight: MazeGen.dir list= match my_state with  | (0,0, final_dir) -> cont [final_dir]  | (x, y, direction) -> let (right,forward,left) = MazeGen.dirs_to_check direction in if(straight) then(  if(not(MazeGen.has_wall maze (x,y,right)))then solver (move_helper (x,y,right)) maze (fun r -> cont (right:: r)) true   else if (not(MazeGen.has_wall maze (x,y,forward))) then solver (move_helper (x,y,forward)) maze (fun r -> cont (forward::r)) true   else if (not(MazeGen.has_wall maze (x,y,left))) then solver (move_helper (x,y,left)) maze (fun r -> cont (left::r)) true   else solver (move_backwards (x,y, forward)) maze (fun r -> cont (List.tl r )) false ) else( if(straight) then solver (move_helper (x,y, forward)) maze (fun r -> cont (List.tl r)) false solver (move_helper (x,y,right)) maze (fun r -> cont (right:: r)) true )    in solver (width-1,height-1,MazeGen.North) maze (fun r -> r) true ) ;; ",
  "*) let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match Seq1.node, Seq2.node with |Nil, Nil -> [] | Nil, _ -> [] |_,Nil -> [] |x::xs, y::ys -> (x,y):: zip xs ys  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "    *) module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num =0; den =1} let one = {num =1; den =1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num=(a.den*b.num +b.den*a.num); den = (a.den*b.den)} let mul a b = {num=(a.num*b.num); den = (a.den*b.den)}  let neg a = {num = a.num*(-1); den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=) let add a b = (a && not b) || (b && not a) let mul = (&&)  let neg a = a let inv a = a end;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = ((F.add F.one F.one) != F.zero) && ((F.add (F.add F.one F.one) F.one) != F.zero)  let onCurve p q point = let (x,y) = point in F. equal (F.mul y y)  (F.add (F.add (F.mul x (F.mul x x))  (F.mul p x)) q)  end;; ",
  "let next_cell (state : MazeGen.state) : MazeGen.state = let (x,y,d) = state in match d with | MazeGen.West -> (x-1, y, d) | MazeGen.North -> (x, y-1, d) | MazeGen.East -> (x+1, y, d) | MazeGen.South -> (x,y+1,d) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w,h) = MazeGen.dims maze in let startState = (w-1,h-1, MazeGen.West) in let rec rec_solve maze2 state fail succeed l : MazeGen.dir list = let (x,y,dir) = state in if x = 0 && y = 0 then succeed l else let dirs = MazeGen.dirs_to_check dir in let (right, front, left) = dirs in if MazeGen.has_wall maze2 (x,y,right) then fail () else let (x1,y1,d1) = (next_cell (x,y,right)) in rec_solve maze2 (x1,y1,d1) (fun () -> rec_solve maze2 (x1,y1,front) (fun() -> rec_solve maze2 (x1,y1,left) fail succeed l) succeed l) succeed l@[right]  in rec_solve maze startState (fun () -> raise NotFound) (fun r -> r) []  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1 () with | Nil -> Nil | Cons(x,f) -> match seq2 () with | Nil -> Nil | Cons(x2,f2) -> Cons((x,x2), zip f f2)   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons(x,f) -> if p x then Nil else Cons(x, keep_until p f)  let to_list (seq : 'a seq) : 'a list = let rec rec_list (seq2 : 'a seq) : 'a list = match seq2 () with | Nil -> [] | Cons(x,f) -> x :: rec_list f in rec_list seq let range (start : int) (step : int) (stop : int) : int seq = if step == 0 then raise (Invalid_argument \"Step = 0\") else if (stop > start && step < 0) || (start > stop && step > 0) then raise (Invalid_argument \"Impossible 1\") else if stop > start then let finish = keep_until (fun x -> x == (stop-start)) nats in let seq = Seq.filter (fun x -> x mod step == 0) finish in let seq1 = Seq.map (fun x -> x + start) seq in seq1 else let finish = keep_until (fun x -> x == (start-stop)) nats in let seq = Seq.filter (fun x -> x mod step == 0) finish in let seq1 = Seq.map (fun x -> (-x) + start) seq in seq1   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1 }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num= (a.num*b.den) + (b.num*a.den); den= a.den*b.den } let mul a b = {num= a.num*b.num; den= a.den*b.den} let neg a = {num= -a.num; den= a.den} let inv a = {num= a.den; den= a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = a != b let mul a b = a && b let neg a = a let inv a = a end ;; ",
  "let nextstate (a:MazeGen.state):MazeGen.state= let (x,y,dir) = a  in match dir with |North->(x,y-1,dir) |South-> (x,y+1,dir) |East->(x+1,y,dir) |West -> (x-1,y,dir)     let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = []  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun ()-> match seq1 () with |Nil->Nil |Cons(v,a)->match seq2() with |Nil->Nil |Cons(v2,a2)->Cons((v,v2),zip a a2)   let rec keep_until (p : 'a -> bool)(seq : 'a seq ) : 'a seq = fun () -> match seq () with |Nil->Nil |Cons(a,s')-> if (p a)==false then Cons (a,keep_until p s') else Nil let to_list (seq : 'a seq) : 'a list = let rec tolist (seq : 'a seq) : 'a list= match seq () with |Nil->[] |Cons(a,s')-> a::tolist s' in tolist seq  let range (start : int) ( step :int) (stop : int) : int seq = if((stop-start)mod step !=0) then raise (Invalid_argument(\"Infinite sequence produced \")) else keep_until (fun x -> x==stop) (map (fun x ->(x*step)+start) nats)  ;; ",
  "end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero =  {num = 0; den = 1} let one=  {num = 1; den = 1}  let neg t= let  {num = a; den = b}  = t in {num = -a; den = b} let inv t= let  {num = a; den = b}  = t in {num = b; den = a}  let mul t1 t2= let  {num = a; den = b}  = t1 in let  {num = p; den = q}  = t2 in {num = a*p; den = b*q} let add t1 t2= let  {num = a; den = b}  = t1 in let  {num = p; den = q}  = t2 in {num = (a*q)+(b*p); den = b*q}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one= true  let neg a = match a with |true->true |false->false let inv a = match a with |true->true |false->false  let mul a b= match a with |true->(match b with |true->true |false->false) |false->(match b with |true->false |false->false) let add a b= match a with |true->(match b with |true->false |false->true) |false->(match b with |true->true |false->false)  let equal = (=) end ;; ",
  "exception Problem let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let state_update state dir = let (x0,y0,_) = state in match dir with | MazeGen.North -> (x0,y0-1,MazeGen.North) | MazeGen.South -> (x0,y0+1,MazeGen.South) | MazeGen.East -> (x0+1,y0,MazeGen.East) | MazeGen.West -> (x0-1,y0,MazeGen.West) in let keep_dirs l1 l2 = let [dir1; dir2; dir3] = l1 in match l2 with | [false; false; false] -> [dir1; dir2; dir3] | [false; false; true] -> [dir1; dir2] | [false; true; true] -> [dir1] | [false; true; false] -> [dir1; dir3] | [true; false; false] -> [dir2; dir3] | [true; false; true] -> [dir2] | [true; true; false] -> [dir3] | [true; true; true] -> [] in let rec dirs_to_take state1 l sc fc = let (x, y, d) = state1 in let (d1, d2, d3) = MazeGen.dirs_to_check d in let (b1, b2, b3) = ( (MazeGen.has_wall maze (x,y,d1)), (MazeGen.has_wall maze (x,y,d2)), (MazeGen.has_wall maze (x,y,d3)) ) in let valid_d = keep_dirs [d1;d2;d3] [b1;b2;b3] in let rec aux state2 list vald sc2 fc2 = match vald with | [] -> raise Problem | h :: t -> dirs_to_take (state_update state1 h) (l @ [h]) sc (fun () -> aux state2 t list sc2 fc2) in if (x, y) = (0, 0) then sc l else try aux state1 l valid_d sc fc with Problem -> fc() in let (w,h) = MazeGen.dims maze in dirs_to_take (w-1, h-1, MazeGen.North) [] (fun x -> x) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, Nil -> (fun () -> Nil) | Cons(x, xs), Cons(y, ys) -> (fun () -> Cons( (x, y) , zip xs ys )) | (Cons(_, _), Nil) | (Nil, Cons(_, _)) -> (fun () -> Nil)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> (fun () -> Nil) | Cons(x, xs) -> match p x with | false -> (fun () -> Cons(x, keep_until p xs)) | true -> (fun () -> Nil) let to_list (seq : 'a seq) : 'a list = let rec helper list s = match s() with | Nil -> [] | Cons(x, xs) -> x :: helper [x] xs in helper [] seq let range (start : int) (step : int) (stop : int) : int seq = if (start > stop && step > 0) || (start < stop && step < 0) || (step == 0) then raise (Invalid_argument (\"This outputs an infinite sequence\")) else let x = start + step in keep_until (fun x -> not (step > 0 && x < stop || step < 0 && x > stop)) (map (fun y -> start + (step * y)) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0 ; den = 1} let one = {num = 1 ; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den <> 0 && b.den <> 0 then {num = a.num * b.den + b.num * a.den ; den = a.den * b.den} else raise DivideByZero let mul a b = if a.den <> 0 && b.den <> 0 then {num = a.num * b.num ; den = a.den * b.den} else raise DivideByZero let neg a = if a.den <> 0 then {num = -1 * a.num ; den = a.den} else raise DivideByZero let inv a = if a.den <> 0 && a.num <> 0 then {num = a.den ; den = a.num} else raise DivideByZero end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = ( = )  let mul = ( && ) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let next_cell ((x, y, d) : MazeGen.state) = match d with | MazeGen.East -> (x + 1, y, d) | MazeGen.West -> (x - 1, y, d) | MazeGen.South -> (x, y + 1, d) | MazeGen.North -> (x, y - 1, d) in  let rec solve ((x, y, d) : MazeGen.state) sc fc = match (x, y, d) with | (0, 0, d) -> sc [] | _ -> let (r, f, l) = MazeGen.dirs_to_check d in let sc1 = fun a -> (sc a) @ [l] in let sc2 = fun a -> (sc a) @ [f] in let sc3 = fun a -> (sc a) @ [r] in let next1 = next_cell (x, y, l) in let next2 = next_cell (x, y, f) in let next3 = next_cell (x, y, r) in let fc1 = fun() -> solve next1 sc1 fc in let fc2 = fun() -> solve next2 sc2 fc in let fc3 = fun() -> solve next2 sc2 fc1 in  match (MazeGen.has_wall maze (x, y, r), MazeGen.has_wall maze (x, y, f), MazeGen.has_wall maze (x, y, l)) with | (true, true, true) -> fc () | (true, true, false) -> fc1 () | (true, false, true) -> fc2 () | (true, false, false) -> fc3 () | (false, false, false) -> solve next3 sc3 fc3 | (false, false, true) -> solve next3 sc3 fc2 | (false, true, false) -> solve next3 sc3 fc1 | (false, true, true) -> solve next3 sc3 fc in let (x, y) = MazeGen.dims maze in solve (x - 1, y - 1, MazeGen.North) (fun a -> a) (fun () -> raise NotFound)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil, _ | _, Nil -> (fun () -> Nil) | Cons (a, b), Cons (c, d) -> (fun () -> Cons ((a, c), zip b d))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (a, b) -> if p a then (fun () -> Nil) else (fun () -> Cons (a, keep_until p b)) let to_list (seq : 'a seq) : 'a list = let rec l seq1 acc = match seq1 () with | Nil -> acc | Cons (a, b) -> l b (acc @ [a]) in l seq [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Step cannot be 0.\") else if step > 0 && start > stop then raise (Invalid_argument \"The sequence will increase infinitely.\") else if step < 0 && start < stop then raise (Invalid_argument \"The sequence will decrease infinitely.\") else let m = map (fun a -> start + a * step) nats in if step <= 0 then keep_until (fun a -> a <= stop) m else keep_until (fun a -> a >= stop) m end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1}  let one = {num = 1; den = 1}  let add (a : t) (b : t) = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = (a.num * b.den + b.num * a.den); den = (a.den * b.den)}  let mul (a : t) (b : t) = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = (a.num * b.num); den = (a.den * b.den)}  let neg (n : t) = if n.den = 0 then raise DivideByZero else {num = -1 * n.num; den = n.den}  let inv (n : t) = if n.den = 0 || n.num = 0 then raise DivideByZero else {num = n.den; den = n.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add (a : t) (b : t) = (not (not a || b)) || (not (not b || a)) let mul (a : t) (b : t) = a && b let neg (a : t) = a let inv (a : t) = a  let equal = (=) end ;; ",
  " open MazeGen ;; ",
  " let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (x, y) = MazeGen.dims(maze) in  let getNext (current_state : int * int * dir)= if (has_wall maze current_state = true) then None else match current_state with | (a,b,West) -> if (a - 1) >= 0 then Some (a-1,b,West) else None | (a,b,North) -> if (b - 1) <= y then Some (a,b-1,North) else None | (a,b,East) -> if (a + 1) <= x then Some (a+1,b,East) else None | (a,b,South) -> if (b + 1) >= 0 then Some (a,b+1,South) else None in  let rec getExit current_state acc f = match current_state with | None -> f() | Some (0, 0, _) -> acc | Some (m, n, dir) -> let (right, forward, left) = dirs_to_check dir in getExit (getNext (m, n, right)) (acc @ [right]) (fun() -> getExit (getNext (m, n, forward)) (acc @ [forward]) (fun() -> getExit (getNext (m, n, left)) (acc @ [left]) f)) in getExit (Some(x-1, y-1, North)) [] (fun() -> []) ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, Nil -> empty | Nil, _ | _, Nil -> empty | Cons (x, xs), Cons (y, ys) -> fun() -> Cons ((x, y), (zip xs ys))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons (x, xs) -> if p x then (fun() -> Nil) else (fun() -> Cons(x, keep_until p xs))  let to_list (seq : 'a seq) : 'a list = let rec helper seq = match seq() with | Nil -> [] | Cons (x, xs) -> x :: helper xs in helper seq   let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = ({num = 0; den = 1})  let one = ({num = 1; den = 1})  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add x y = match (x.den, y.den) with | (0, 0) -> raise DivideByZero | _,_ -> ({num = ((x.num * y.den) + (y.num * x.den)); den = (x.den * y.den)})  let mul x y = match (x.den, y.den) with | (0, 0) -> raise DivideByZero | _,_ -> ({num = (x.num * y.num); den = (x.den * y.den)})  let neg x = ({num = -x.num ; den = x.den})  let inv x = ({num = x.den ; den = x.num})  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false  let one = true  let equal x y= (x = y)  let add x y = not (x && not y) || not (y && not x)  let mul x y = (x&&y)  let neg x = x  let inv x = x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = in let getNextCell (x,y,direction) = match direction with | MazeGen.North -> (x, y-1) | MazeGen.East -> (x+1, y) | MazeGen.West -> (x-1, y) | MazeGen.South -> (x, y+1) in let rec solve_maze_cont (x,y,direction) failure success = match (x,y) with | (0,0) -> success [] | _ -> if MazeGen.has_wall maze (x,y,direction) then failure () else let (right, front, left) = MazeGen.dirs_to_check direction in let (x',y') = getNextCell (x,y,direction) in solve_maze_cont (x',y',right) (fun () -> solve_maze_cont (x',y',front) (fun () -> solve_maze_cont (x',y',left) (failure) (fun r3 -> success (direction :: r3)))  (fun r2 -> success (direction :: r2))) (fun r1 -> success (direction :: r1)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq fun () -> match (seq1 (), seq2 ()) with | (_, Nil) -> Nil | (Nil, _) ->  Nil | (Cons (h1,t1), Cons (h2, t2))-> Cons ((h1,h2), zip (t1) (t2))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Cons(h, t) -> if p h then Nil else Cons ((h), keep_until p (t)) | Nil -> Nil  let to_list (seq : 'a seq) : 'a list = let rec to_list_rev seq  = match seq () with | Cons (h, t) -> h::to_list_rev t | Nil -> [] in to_list_rev seq  let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) || (step > 0 && start > stop) || (step < 0 && start < stop) then raise (Invalid_argument \"This is an invalid argument\") else if step < 0 then keep_until (fun x -> not (x < (start+1) && x > (stop))) ((map (fun x -> (x * step)+ start) nats)) else keep_until (fun x -> not (x > (start-1) && x < (stop))) ( (map (fun x -> (x * step) + start ) nats))  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "let rec print_sequence (seq : int seq) acc = match seq () with | Seq.Cons(h, t) -> print_sequence t (acc ^ (string_of_int h)) | Seq.Nil -> acc module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if a.num = 0 || b.num = 0 then raise DivideByZero else {num = ((a.den*b.num) + ( b.den * a.num)); den = (a.den * b.den)} let mul a b = {num = (a.num*b.num); den = (a.den * b.den)} let neg a = {num = 0-(a.num); den = a.den} let inv a = if(a.num = 0) then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = match (a,b) with | (true, true) -> false | (false, false) -> false | (_,_) -> true let mul a b = (&&) a b let neg a = a let inv a = a end ;; ",
  " module type MazeGenSig = sig type maze type dir = West | North | East | South type state = int * int * dir val dims : maze -> int * int val string_of_maze : ?path: dir list -> maze -> string val random : int -> int -> maze val has_wall : maze -> state -> bool val dirs_to_check : dir -> dir * dir * dir end ;; ",
  "open MazeGen;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = dims maze in let start = (width - 1 , height - 1 , North) in let next_cell (s: state) : (int*int) = let (x,y,d) = s in match d with |North -> (x  , y-1) |South  -> (x  , y+1) |East  -> (x+1, y  ) |West  -> (x-1, y  ) in  let rec s_maze m (s: state) (fc: unit -> dir list) (sc: dir -> dir list ) = let (a,b,c) = s in print_string (\"x=\" ^ string_of_int a ^ \" y=\" ^string_of_int b);match c with |North -> print_string(\"north \\n\"); |South  -> print_string(\"south\\n\"); |East  -> print_string(\"east\\n\"); |West  -> print_string(\"west\\n\"); ; match s with |(0,0,d) -> sc d |(x,y,d) -> if has_wall m s then fc () else let (d1,d2,d3) = dirs_to_check d in let (x1,y1)= next_cell s in let fff () = s_maze m (x1,y1,d3) (fc)  (fun r -> d::(sc r)) in let ff ()  = s_maze m (x1,y1,d2) (fff) (fun r -> d::(sc r)) in s_maze m (x1,y1,d1) (ff) (fun r -> d::(sc r)) in let l = s_maze maze start (fun unit -> []) (fun r -> [r]) in match (List.rev l) with |[]-> s_maze maze (width - 1 , height - 1 , West) (fun unit -> []) (fun r -> [r]) |h::t -> t ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () , seq2 () with |Nil,_ -> fun () -> Nil |_,Nil -> fun () -> Nil |Cons(a,sa) , Cons(b,sb)  -> fun () ->Cons ((a,b),(zip sa sb) )   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Nil -> fun () -> Nil |Cons(a,sa) -> if (p a) then fun () -> Nil else fun () -> Cons(a, keep_until p sa)   let rec to_list (seq : 'a seq) : 'a list = match seq () with |Nil -> [] |Cons(a,sa) -> a::(to_list sa) exception Invalid_argument of string let range (start : int) (step : int) (stop : int) : int seq = if ((step > 0)&&(start > stop)) ||((step <0)&&(start<stop)) then raise (Invalid_argument \"Combination of start, stop and step value create an infinite range\") else let b = map (fun r -> (step * r)+start) nats in let ff i = if step > 0 then (i >= stop) else (i <= stop) in keep_until ff b  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module type AlgField = sig type t val zero: t val one: t val equal: t -> t -> bool val add: t -> t -> t val mul: t -> t -> t val neg: t -> t val inv: t -> t end ;; ",
  "module FloatField : (AlgField with type t = float) = struct type t = float let zero = 0. let one = 1. let equal a b = abs_float (a -. b) < 0.000001  let add = ( +. ) let mul = ( *. ) let neg = ( ~-. ) let inv = ( /. ) one end type rational = {num : int; den : int} module type ECSig = functor (F : AlgField) -> sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den   let one = {num= 1 ; den= 1}  let zero = {num= 0 ; den= 1}  let add a b = {num= ((b.den * a.num)+(b.num * a.den)); den = a.den * b.den}  let mul a b = {num = (a.num * b.num); den = (a.den * b.den)}  let neg a = {num = a.num * (-1); den = a.den}  let inv a = if a.num = 0 then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) let zero = false let one = true let add = (<>) let mul = (&&) let neg a = a let inv a =  a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_coord (w:int) (h:int) (next_dir:MazeGen.dir) : MazeGen.state = match next_dir with |MazeGen.North -> (w,h-1,next_dir) |MazeGen.South -> (w,h+1,next_dir) |MazeGen.East -> (w+1,h,next_dir) |MazeGen.West -> (w-1,h,next_dir) in let rec find_path (cur:MazeGen.state) fail success = match cur with |(0,0,_) -> success [] |(w,h,d) -> ( let (r,f,l) = MazeGen.dirs_to_check d in let bools = (not (MazeGen.has_wall maze (w,h,r)), not (MazeGen.has_wall maze (w,h,f)), not (MazeGen.has_wall maze (w,h,l))) in match bools with |(true,true,true)-> find_path (next_coord w h r) ( fun () -> find_path (next_coord w h f) ( fun () -> find_path (next_coord w h l) (fail) (fun next -> success (l::next)) ) (fun next -> success (f::next)) ) (fun next -> success (r::next)) |(true,true,false)-> find_path (next_coord w h r) ( fun () -> find_path (next_coord w h f) (fail) (fun next -> success (f::next)) ) (fun next -> success (r::next)) |(true,false,true)-> find_path (next_coord w h r) ( fun () -> find_path (next_coord w h l) (fail) (fun next -> success (l::next)) ) (fun next -> success (r::next)) |(true,false,false)-> find_path (next_coord w h r) (fail) (fun next -> success (r::next)) |(false,true,true)-> find_path (next_coord w h f) ( fun () -> find_path (next_coord w h l) (fail) (fun next -> success (l::next)) ) (fun next -> success (f::next)) |(false,true,false)-> find_path (next_coord w h f) (fail) (fun next -> success (f::next)) |(false,false,true)-> find_path (next_coord w h l) (fail) (fun next -> success (l::next)) |(false,false,false)-> fail () ) in let (w,h) = MazeGen.dims maze in find_path (w-1,h-1,MazeGen.North) (fun () -> raise NotFound) (fun x->x) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with |_,Nil -> (fun () -> Nil) |Nil,_ -> (fun () -> Nil) |Cons(a,seq1),Cons(b,seq2) -> (fun () -> Cons( (a,b), zip seq1 seq2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons(a, seq') -> if p a then (fun () -> Nil) else (fun () -> Cons(a, keep_until p seq')) let to_list (seq : 'a seq) : 'a list = let rec create seq' cont = match seq' () with | Nil -> cont [] | Cons(a, seq'') -> create seq'' (fun x -> cont (a::x)) in create seq (fun x -> x) let range (start : int) (step : int) (stop : int) : int seq = if (step = 0 || (start > stop && step > 0) || (start < stop && step < 0)) then raise (Invalid_argument \"arguments lead to infinite calc\") else begin if stop > start then keep_until (fun x -> x>=stop) (map (fun n -> start + n*step) nats) else keep_until (fun x -> x<=stop) (map (fun n -> start + n*step) nats) end end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add = (fun {num = n1;den = d1} {num = n2;den = d2} -> {num = (n1*d2+n2*d1); den = d1*d2}) let mul = (fun a b -> {num = a.num*b.num; den = a.den*b.den}) let neg = (fun a -> {num = (-a.num); den = a.den}) let inv = (fun a -> {num = a.den; den = a.num}) end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&) let neg = (fun a -> a) let inv = (fun a -> a) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let open MazeGen in let next_cell (curState : MazeGen.state)  = let (x,y,direction) = curState in match (direction : MazeGen.dir) with |North -> (x, (y-1), North) |South -> (x, (y+1), South) |East-> ((x+1), y, East) |West -> ((x-1), y, West) in let turn_around (direction : MazeGen.dir) = match direction with |North -> South |West-> East |East -> West |South -> North in let rec get_direction curState sc fc  = let (x,y) = dims maze in let (x,y) =  (x-1, y-1) in match curState with |(0,0,dir) -> sc([]) |(x,y,dir) -> let (right, front, left) = dirs_to_check dir in let fc1 = fun() -> get_direction (x,y,(turn_around dir)) sc fc in if not (has_wall maze (x,y,right)) then get_direction (next_cell(x,y,right)) (fun r -> sc(right::r)) fc1 else if not (has_wall maze (x,y,front)) then get_direction (next_cell(x,y,front)) (fun r -> sc(front::r)) fc1 else if not (has_wall maze (x,y,left)) then  get_direction (next_cell(x,y,left)) (fun r -> sc(left::r)) fc1 else fc1() in let (x,y) = dims maze in let (x,y) =  (x-1, y-1) in get_direction (x,y,North) (fun r -> r)  (fun() -> raise NotImplemented)    ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let force = fun (f) -> f () let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match force(seq1), force(seq2) with |(Cons(h,t)), (Cons(h1,t1)) -> Cons((h,h1), zip t t1) |_ -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match force(seq) with |Nil ->  Nil |Cons(h,t) -> if p h then Nil else Cons(h, (keep_until p t))  let to_list (seq : 'a seq) : 'a list = let list = ref [] in Seq.iter (fun r -> list := r :: !list) seq; let finalList = List.rev !list in finalList   let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Zero is invalid step value\") else  if (step < 0) && (stop > 0) && (start < stop) then raise (Invalid_argument \"Stop cannot be reached with negative step\") else if (step > 0) && (stop < 0) && (start > stop) then raise (Invalid_argument \"Stop cannot be reached with positive step\")  else let list = map (fun r -> (start) + (step * r)) nats in  let final = if (step < 0) then keep_until (fun r -> r <= stop) list else keep_until (fun r -> r >= stop) list in final end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one  = {num=1;den=1} let zero  = {num=0;den=1} let mul x y = {num=(x.num * y.num);den=(x.den*y.den)} let add x y = {num=((x.num*y.den)+(y.num*x.den));den=(x.den*y.den)} let inv x  = {num=x.den;den=x.num} let neg x = {num=(zero.num-x.num); den=x.den}   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let one  = true let zero  = false  let add x y = match x,y with |true, true -> false |false, false -> false |true, false -> true |false,true -> true let mul x y = match x,y with |true, true -> true |false, false -> false |false, true -> false |true, false -> false let neg x = x  let inv x = x  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let nextCell_move (x : int) (y : int) (d : MazeGen.dir) : MazeGen.state  = let failMarker : MazeGen.state = (-1,-1, North) in let curState : MazeGen.state = (x,y,d) in if (not (MazeGen.has_wall maze curState)) then match d with | North ->let newState : MazeGen.state = (x, y-1, d) in newState | East  ->let newState : MazeGen.state = (x+1, y, d) in newState | South ->let newState : MazeGen.state = (x, y+1, d) in newState | West -> let newState : MazeGen.state = (x-1, y, d) in newState else failMarker in  let rec solve_path_c (curState : MazeGen.state) (maze : MazeGen.maze) sc fc : MazeGen.dir list = match curState with | (0,0,d) -> sc [] | (-1,-1,_) -> fc () let (rFromCur, fFromCur, lFromCur) = MazeGen.dirs_to_check d in solve_path_c (nextCell_move x y rFromCur) maze (fun r -> sc (rFromCur::r)) (fun () -> solve_path_c (nextCell_move x y fFromCur) maze (fun r -> sc (fFromCur::r)) (fun () -> solve_path_c (nextCell_move x y lFromCur) maze (fun r -> sc (lFromCur::r)) fc )) | (_,_,_) -> fc()  in let (startP_x, startP_y) = MazeGen.dims maze in  solve_path_c (startP_x-1, startP_y-1, North) maze (fun r -> r) (fun () -> raise NotFound) ;; ",
  "let test_maze 4 4 = let maze = MazeGen.random 4 4 in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun() -> match seq1(), seq2() with | Cons (hd1, tl1), Cons (hd2, tl2) -> Cons ((hd1, hd2), zip tl1 tl2) | _, _ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with | Nil -> Nil | Cons (hd, tl) -> if p hd then Nil else Cons (hd, keep_until p tl) let to_list (seq : 'a seq) : 'a list = let rec to_listR (seq : 'a seq) (acc : 'a list) : 'a list = match seq () with | Nil -> acc | Cons (hd, tl) -> to_listR tl (acc@[hd]) in to_listR seq [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Infinite sequence caused by step = 0\") else if (step > 0 && start > stop) then raise (Invalid_argument \"Infinite sequence caused by start > stop and increasing step\") else if (step < 0 && start < stop) then raise (Invalid_argument \"Infinite sequence caused by start < stop and decreasing step\") else let adjustedNat : int seq = map mapF (nats) in (step > 0 && n >= stop) || (step < 0 && n <= stop) in keep_until checkStep adjustedNat  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b : t = if (a.num = 0) then b else if (b.num = 0) then a else if (a.num = (-1 * b.num) && (a.den = (-1 * b.den))) then zero else {num = a.num * b.den + b.num * a.den ; den = a.den * b.den}  let mul a b : t = if (a.num = 1 && a.den = 1) then b else if (b.num = 1 && b.den = 1) then a else if (b.num = a.den && a.num = b.den) then one else { num = a.num * b.num ; den = a.den * b.den}  let neg a : t = {num = -1 * a.num; den = a.den}  let inv a : t = if (a.num = 0) then zero end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add a b : bool = not (a = b)  let mul a b : bool = a && b  let neg a : bool = a  let inv a : bool = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(), seq2()) with | (Nil, _) -> empty | (_, Nil) -> empty | (Cons(e1, s1), Cons(e2, s2)) -> fun () -> Cons((e1, e2), zip s1 s2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun () -> Nil | Cons(e1, s1) -> if p e1 then fun () -> Nil else fun () -> Cons(e1, keep_until p s1) let to_list (seq : 'a seq) : 'a list = let rec f s acc = match s() with | Nil -> acc | Cons(e, se) -> f se (e::acc) in List.rev (f seq []) let range (start : int) (step : int) (stop : int) : int seq = let s = map (fun x -> x * step + start) nats in if step < 0 then keep_until (fun x -> x <= stop) s else keep_until (fun x -> x >= stop) s end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = (a.num * b.den) + (b.num * a.den); den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = not (a = b) let mul = (&&) let neg a = a let inv a = a  end ;; ",
  "match dir_list with | [] -> fc () | h :: t -> if h == left then ( if (has_wall maze (x, y, h)) == false then helper maze (get_coord state h) (dirs_to_check h) (fun r -> h::r) (fun () -> helper maze (remove_coord state else fc () ) else if (has_wall maze (x, y, h)) == false then sc else let open MazeGen in let width, height = dims maze in let get_coord dir state = let xs, ys, _ = state in match dir with |North -> (xs, (ys-1), North) |South -> (xs, (ys+1), South) |West -> ((xs-1), ys, West) |East -> ((xs+1),ys, East) in let remove_coord dir state = let xs, ys, d = state in match d with |North -> (xs, (ys+1), dir) |South -> (xs, (ys-1), dir) |West -> ((xs+1), ys, dir) |East -> ((xs-1),ys, dir) in let rec helper maze state sc fc = let (xs, ys, ds) = state in match ds with |North -> Printf.printf \"North \"; if state == (0, 0, North) then sc [] else if state == (0, 0, West) then sc [] else let right, front, left = dirs_to_check ds in let has_right = has_wall maze (xs, ys, right) in let has_front = has_wall maze (xs, ys, front) in let has_left = has_wall maze (xs, ys, left) in if has_right == false then helper maze (get_coord right state) (fun r -> right :: r) (fun q -> ds :: q) else ( if has_front == false then helper maze (get_coord front state) (fun r -> front :: r) (fun q -> ds :: q) else ( if has_left == false then helper maze (get_coord left state) (fun r -> left :: r) (fun q -> ds :: q) else match fc [] with | x::xs -> helper maze (remove_coord x state) (fun r -> match r with |x :: xs -> xs | _ -> []) (fun r -> match r with |x :: xs -> xs | _ -> []) | _ -> raise NotFound ) ) |South -> Printf.printf \"South \"; if state == (0, 0, North) then sc [] else if state == (0, 0, West) then sc [] else let right, front, left = dirs_to_check ds in let has_right = has_wall maze (xs, ys, right) in let has_front = has_wall maze (xs, ys, front) in let has_left = has_wall maze (xs, ys, left) in if has_right == false then helper maze (get_coord right state) (fun r -> right :: r) (fun q -> ds :: q) else ( if has_front == false then helper maze (get_coord front state) (fun r -> front :: r) (fun q -> ds :: q) else ( if has_left == false then helper maze (get_coord left state) (fun r -> left :: r) (fun q -> ds :: q) else match fc [] with | x::xs -> helper maze (remove_coord x state) (fun r -> match r with |x :: xs -> xs | _ -> []) (fun r -> match r with |x :: xs -> xs | _ -> []) | _ -> raise NotFound ) ) |West -> Printf.printf \"West \"; if state == (0, 0, North) then sc [] else if state == (0, 0, West) then sc [] else let right, front, left = dirs_to_check ds in let has_right = has_wall maze (xs, ys, right) in let has_front = has_wall maze (xs, ys, front) in let has_left = has_wall maze (xs, ys, left) in if has_right == false then helper maze (get_coord right state) (fun r -> right :: r) (fun q -> ds :: q) else ( if has_front == false then helper maze (get_coord front state) (fun r -> front :: r) (fun q -> ds :: q) else ( if has_left == false then helper maze (get_coord left state) (fun r -> left :: r) (fun q -> ds :: q) else match fc [] with | x::xs -> helper maze (remove_coord x state) (fun r -> match r with |x :: xs -> xs | _ -> []) (fun r -> match r with |x :: xs -> xs | _ -> []) | _ -> raise NotFound ) ) |East -> Printf.printf \"East \"; if state == (0, 0, North) then sc [] else if state == (0, 0, West) then sc [] else let right, front, left = dirs_to_check ds in let has_right = has_wall maze (xs, ys, right) in let has_front = has_wall maze (xs, ys, front) in let has_left = has_wall maze (xs, ys, left) in if has_right == false then helper maze (get_coord right state) (fun r -> right :: r) (fun q -> ds :: q) else ( if has_front == false then helper maze (get_coord front state) (fun r -> front :: r) (fun q -> ds :: q) else ( if has_left == false then helper maze (get_coord left state) (fun r -> left :: r) (fun q -> ds :: q) else match fc [] with | x::xs -> helper maze (remove_coord x state) (fun r -> match r with |x :: xs -> xs | _ -> []) (fun r -> match r with |x :: xs -> xs | _ -> []) | _ -> raise NotFound ) ) in helper maze ((width-1), (height-1), North) (fun r -> North :: r) ( fun q -> q) let state = (xs+x, ys, East) in if has_wall then let state = (xs, ys-y, North) in if has_wall then let state = (xs-x, ys West) in if has_wall then fc () else helper maze sc fc else helper maze sc fc else helper maze sc fc  |South -> |East -> |West ->*) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "*)  let _ = print_string \"before access any items\" *) let seq1= fun () -> Seq.Cons(1, fun () -> Seq.Cons(2, fun () ->Seq.Cons(3, fun () -> Seq.Cons(4, fun () -> Seq.Cons (5, fun () -> Nil))))) let seq2= fun () -> Seq.Cons(2, fun () -> Seq.Cons(3, fun () -> Seq.Nil)) module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let Cons (x, f) = seq1 () in let Cons (y, g) = seq2 () in if f() == Nil then fun () -> Cons ((x, y), (fun () -> Nil)) else if g() == Nil then fun () -> Cons ((x, y), (fun () -> Nil)) else fun () -> Cons ((x, y), zip (fun () -> f()) (fun () -> g())) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let Cons (x, f)  = seq () in if p x then fun () -> Cons (x, fun () -> Nil) else fun () -> Cons( x, keep_until p f)  let to_list (seq : 'a seq) : 'a list = let rec helper s = match s() with | Nil -> [] | Cons (x, f) -> x :: (helper (fun () -> f())) in helper seq let range (start : int) (step : int) (stop : int) : int seq = if step >= 0 then (if start > stop then raise (Invalid_argument \"Start cannot be greater than stop when the step is positive\") else keep_until (fun x -> x > stop) (map (fun x ->if x == 0 then start else ((start+step)*x)) nats) ) else (if start < stop then raise (Invalid_argument \"Start cannot be smaller than stop when the step is negative\") else keep_until (fun x -> x < stop) (map (fun x ->if x == 0 then start else ((start+step)*x)) nats) ) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if (a.den == b.den) then {num = a.num+b.num; den= a.den} else {num = (a.num*b.den)+(b.num*a.den); den = (a.den*b.den)}  let mul a b = {num= (a.num*b.num); den= (a.den*b.den)}  let neg a = {num= -a.num; den= a.den} let inv a = {num= a.den; den= a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b =  not (a == b)  let mul a b = match a, b with | true, true -> true | _, _ -> false  let neg a = a == true  let inv = neg  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (x, y) = dims maze in let start : state = (x-1, y-2, East) in  let get_next ((x, y, d) : state) : state= let (r, _, _) = dirs_to_check d in match d with | North -> (x, y-1, r) | East -> (x+1, y, r) | South -> (x, y+1, r) | West -> (x-1, y, r) in  let rec solve current list sc fc= let (x, y, d) = current in  let (_, f1, l1) = dirs_to_check d in  if (x, y) = (0, 0) then List.rev (sc [])  else if not (has_wall maze current) then match list with | [] -> solve (get_next current) (f1::l1::[]) (fun l -> d::(sc l)) fc | h::t -> solve (get_next current) (f1::l1::[]) (fun l -> d::(sc l)) (fun () -> solve (x, y, h) t sc fc)  else match list with | [] -> fc () | h::t -> solve (x, y, h) t sc fc  in  solve start (North::West::[]) (fun l -> North::l) (fun () -> solve (x-1, y-1, West) [] (fun l -> l) (fun () -> [])) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons (a, at), Cons (b, bt) -> (fun () -> (cons (a, b) (zip at bt) ())) | _, _  -> (fun () -> Nil) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (a, at) -> if not (p a) then (fun () -> (cons a (keep_until p at) ())) else (fun () -> empty ()) let to_list (seq : 'a seq) : 'a list = let rec helper (seq1: 'a seq) l = match seq1 () with | Nil -> l | Cons (a, at) -> helper at (l@[a]) in helper seq [] let range (start : int) (step : int) (stop : int) : int seq = if ((stop > start) && (step < 0)) || ((stop < start) && (step > 0)) then invalid_arg \"Infinite sequence!\"; let n = ref 0 in if ((stop - start) mod step) <> 0 then n := (abs ((stop - start) / step) +1) else n := (abs ((stop - start) / step)) ; let is_end (x:int) = (x = !n) in let seq1 = keep_until is_end nats in let seq2 = map (fun x -> start + (step * x)) seq1 in seq2 end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den = b.den then {num = a.num + b.num; den = a.den} else {num = (a.num * b.den) + (b.num * a.den); den = a.den * b.den}  let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -(a.num); den = a.den}  let inv a = {num = a.den; den = a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a let inv a = a   end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let get_state x y (dir: MazeGen.dir) next_dir = match dir with | MazeGen.North -> (x, y-1, next_dir) | MazeGen.South -> (x, y+1, next_dir) | MazeGen.East -> (x+1, y, next_dir) | MazeGen.West -> (x-1, y, next_dir) in let rec solver state sc fc = match state with | (0, 0, _) -> sc [] | (x, y, dir) -> if MazeGen.has_wall maze state then fc () else let (right, straight, left) = MazeGen.dirs_to_check dir in let sc1 = (fun r -> sc (dir::r)) in let fc2 = (fun () -> solver (get_state x y dir left) sc1 fc) in let fc1 = (fun () -> solver (get_state x y dir straight) sc1 fc2) in solver (get_state x y dir right) sc1 fc1 in let (a, b) = MazeGen.dims maze in solver (a-1, b-1, MazeGen.North) (fun x -> x) (fun () -> solver (a-1, b-1, MazeGen.West) (fun x -> x) (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze); ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Cons (x, a'), Cons (y, b') -> fun () -> Cons ((x,y), zip a' b') | Nil, _ | _, Nil -> fun () -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun () -> Nil | Cons (x, a') -> if (p x) then fun () -> Nil else fun () -> Cons (x, keep_until p a') let to_list (seq : 'a seq) : 'a list = let rec sol seq = match seq () with | Nil -> [] | Cons (x, a') -> x::sol a' in sol seq let range (start : int) (step : int) (stop : int) : int seq = if ((start > stop && step > 0) || (start < stop && step < 0)) then raise (Invalid_argument \"Infinite sequence produced.\") else if step >0 then keep_until (fun x -> x >= stop) (map (fun x -> x*step+start) nats) else keep_until (fun x -> x <= stop) (map (fun x -> x*step+start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if a.den <> b.den then {num = b.den*a.num+a.den*b.num; den = a.den*b.den} else {num = a.num+b.num; den = a.den} let mul a b = {num=a.num*b.num; den = a.den*b.den} let neg a = {num = (~-)a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let seqs = (seq1()), (seq2()) in match seqs with | Cons(x, x'), Cons (y, y') -> fun() -> let zipXY = zip x' y' in Cons ((x,y), zipXY) | Nil, _ | _, Nil -> fun() -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun () -> Nil | Cons (a, b) -> if p a then ( fun () -> Nil ) else ( fun() -> Cons(a, keep_until p b) ) let to_list (seq : 'a seq) : 'a list = let rec aux s = match s() with | Nil -> [] | Cons(x,y) -> x :: aux y in aux seq exception Invalid_argument let range (start : int) (step : int) (stop : int) : int seq = if (step > 0 && (start > stop)) then raise Invalid_argument else let test_ftn a = if start < stop then ( a >= stop ) else ( a <= stop ) in keep_until test_ftn ((map (fun b -> b + start)) (map (fun b -> b * step) nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let equal a b = a.den = 0 && b.den = 0 && a.den * b.num = a.num * b.den let zero = { den = 1; num = 0; } let one = { den = 1; num = 1; } let add x y = { den = ( x.den*y.den ); num = ( x.num * y.den ) + ( y.num * x.den ); } let inv x = { den = (x.num); num = x.den; } let neg x = { den = (x.den); num = x.num * (-1); } let mul x y = { den = ( x.den * y.den ); num = ( x.num * y.num ); } end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_cell (cur_state:MazeGen.state): (int*int) = match cur_state with |(x,y,MazeGen.West)->(x-1,y) |(x,y,MazeGen.North)->(x,y-1) |(x,y,MazeGen.East)->(x+1,y) |(x,y,MazeGen.South)->(x,y+1) in  let rec solve_maze_help (wanted_state:MazeGen.state) fail succ : MazeGen.dir list= match wanted_state with |(0,0,_)-> succ []  |(cur_x,cur_y,dir)-> let right,straight,left= MazeGen.dirs_to_check dir in let next_x,next_y = next_cell (cur_x,cur_y,dir) in if not (MazeGen.has_wall maze (cur_x,cur_y,dir)) then solve_maze_help (next_x,next_y,right)  (fun() -> solve_maze_help (next_x,next_y,straight)  (fun()-> solve_maze_help (next_x,next_y,left) fail (fun l-> succ (dir::l))) (fun l-> succ (dir::l))) (fun l-> succ (dir::l)) else fail() in let width,height=MazeGen.dims maze in solve_maze_help (width-1,height-1,MazeGen.North) (fun()-> solve_maze_help (width-1,height-1,MazeGen.West) (fun ()-> raise NotFound)  (fun x->x)   ) (fun x->x)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(),seq2() with |_,Nil -> fun ()-> Nil |Nil,_ -> fun()-> Nil |Cons(el1,s1),Cons(el2,s2)-> fun()->Cons((el1,el2),(zip s1 s2))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil-> fun()->Nil |Cons(el, s)-> if p el then fun()->Nil else fun()->Cons(el,(keep_until p s)) let to_list (seq : 'a seq) : 'a list = let rec to_list_help (seq : 'a seq) succ: 'a list = match seq() with |Nil-> succ [] |Cons(el,subseq)-> to_list_help subseq (fun r-> succ (el::r)) in to_list_help seq (fun x-> x)    let range (start : int) (step : int) (stop : int) : int seq =   let help_range= let every_step_nats=  map (fun x-> x*step) (nats) in let range_to_recurse= map (fun x->x+start) (every_step_nats) in if stop<start then keep_until (fun x-> x<=stop) (range_to_recurse) else keep_until (fun x-> x>=stop) (range_to_recurse) in  if start > stop  && step >0 then raise (Invalid_argument \"if start > stop then step must be negative\")  else if start < stop  && step < 0 then raise (Invalid_argument \"if start < stop then step must be positive\") else if step=0 then raise(Invalid_argument \"Step cannot be 0\")  else help_range end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let one={num=1;den=1}  let add x y= {num= (x.num*y.den)+(y.num*x.den) ; den=(x.den*y.den)}  let mul x y = if x=zero || y=zero then zero else {num = x.num*y.num; den=x.den*y.den}  let neg x={num= -(x.num) ; den = x.den } let inv x={num=x.den; den=x.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero=false let one=true let add (x:bool) (y:bool)= match x,y with |true,true-> false |false,false->false |_,_->true  let mul= (&&) let neg x= x let inv x= x let equal = (=) end ;; ",
  "let reverser (path :MazeGen.dir list) : MazeGen.dir list = let rec inner (path :MazeGen.dir list) (accum :MazeGen.dir list) = match path with | [] -> accum | h::t -> (inner t (h::accum)) in inner path []  let take_a_step ((x, y) :(int * int)) (state :MazeGen.dir) : (int * int) =  if state = MazeGen.West then (x-1,y) else if state = MazeGen.North then (x,y-1) else if state = MazeGen.East then (x+1,y) else (x,y+1) let wall_checker (maze : MazeGen.maze) ((x, y) :(int * int)) (lastD: MazeGen.dir): MazeGen.dir list = let (a,b,c) = MazeGen.dirs_to_check lastD in  let rec appender (maze : MazeGen.maze) ((x, y) :(int * int)) (listofDir : MazeGen.dir list) = match listofDir with |[] -> [] | h::t -> if MazeGen.has_wall maze (x,y,h) then appender maze (x,y) t else h::(appender maze (x,y) t) in appender maze (x,y) (a::b::[c])   let rec fail_clause (path :MazeGen.dir list) (memo1 :MazeGen.dir list list) (memo2 :(int*int) list) : (MazeGen.dir list)*(MazeGen.dir)*(int*int)*(MazeGen.dir list list)*((int*int) list)=  match (memo1, memo2, path) with | ([]::t, _::y, _::x) -> fail_clause x t y | ([h::t], [x], _) -> (path,h,x,[t], memo2) | ((h::t)::t1, x::_, _ )-> (path,h,x,t::t1,memo2) | (_,_,_) -> raise NotFound   let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let (x,y) = MazeGen.dims maze in  let rec rec_solve (maze :MazeGen.maze) (path : MazeGen.dir list)  ((x,y) : (int*int)) (memo1 :MazeGen.dir list list) (memo2 :(int*int) list)  =  if (x,y) = (0,0) then path else  match memo1 with | [] -> raise NotImplemented | []::_ -> let (path, state,(x,y),memo1,memo2) = fail_clause path memo1 memo2 in  let path = state::path in let (x,y) = take_a_step (x,y) state in let memo1 = (wall_checker maze (x,y) state)::memo1 in let memo2 = (x,y)::memo2 in rec_solve maze path (x,y) memo1 memo2   | (h::t)::t1 -> let state = h in let path = state::path in let (x,y) = take_a_step (x,y) state in let memo2 = (x,y)::memo2 in let new_memo1 = (wall_checker maze (x,y) state)::t::t1  in rec_solve maze path (x,y) new_memo1 memo2   in let x = reverser(rec_solve maze [MazeGen.North]  (x-1,y-1) ([wall_checker maze (x-1,y-1) MazeGen.North]) [(x-1,y-1)]) in match x with | _::t -> t | _ -> x ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "  module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, _ | _, Nil -> empty |Cons(a, x),Cons(b, y) -> fun() -> Cons((a,b), (zip x y))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> empty |Cons(a, x) -> if p(a) then keep_until p empty else fun() -> Cons(a, (keep_until p x))  let to_list (seq : 'a seq) : 'a list =  let rec adder (seq : 'a seq)   = match seq() with |Nil -> [] |Cons(a, x) -> a::(adder x) in adder seq  let range (start : int) (step : int) (stop : int) : int seq =  if start = stop then raise (Invalid_argument \"start = stop\") else if step = 0 then raise (Invalid_argument \"Step cannot be 0\") else if (start > stop && step > 0) ||(start < stop && step < 0) then raise (Invalid_argument \"invaild range\") else  let mapF = (fun cur -> start+(cur*step)) in let new_nats = map mapF nats in  let f1 = (fun cur -> (cur >= stop) && (step > 0))  in let f2 = (fun cur -> (cur <= stop) && (step < 0))  in  let filtered1 = keep_until f1 new_nats in let filtered2 = keep_until f2 filtered1 in filtered2 end ;; ",
  " let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "let x = range ~start:(23) ~step:(-4) ;; ",
  "let z = x (-6) ;; ",
  "let listlist = Range.to_list(z) ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0;den = 1} let one = {num = 1;den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + b.num * a.den ;den = a.den  *  b.den} let mul a b = {num = a.num * b.num; den =a.den  *  b.den } let neg a = {num = a.num * (-1); den = a.den} let inv a = if a.den = 0 && a.num = 0 then zero else {num = a.den;den = a.num}   end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false  let one = true let equal = (=) let add a b = if ((a) && (b)) then false else a || b let mul a b = not ((not a) || (not b)) let neg a = a let inv a = a end ;; ",
  "let next (state : MazeGen.state): int * int  = let (x,y,dir) = state in match dir with | MazeGen.West -> (x-1,y) | MazeGen.North -> (x,y-1) | MazeGen.East -> (x+1,y) | MazeGen.South -> (x,y+1) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec maze_helper maze cell dir path cont = match cell with | (0,0) -> List.rev path | (x,y) -> let (rt,fd,lt) = MazeGen.dirs_to_check dir in  if not (MazeGen.has_wall maze (x,y,rt)) then maze_helper maze (next (x,y,rt)) rt (rt::path) (fun () -> if not (MazeGen.has_wall maze (x,y,fd)) then maze_helper maze (next (x,y,fd)) fd (fd::path) (fun () -> if not (MazeGen.has_wall maze (x,y,lt)) then maze_helper maze (next (x,y,lt)) lt (lt::path) cont else cont ()) else if not (MazeGen.has_wall maze (x,y,lt)) then maze_helper maze (next (x,y,lt)) lt (lt::path) cont else cont ())  else if not (MazeGen.has_wall maze (x,y,fd)) then maze_helper maze (next (x,y,fd)) fd (fd::path) (fun () -> if not (MazeGen.has_wall maze (x,y,lt)) then maze_helper maze (next (x,y,lt)) lt (lt::path) cont else cont ())  else if not (MazeGen.has_wall maze (x,y,lt)) then maze_helper maze (next (x,y,lt)) lt (lt::path) cont  else cont ()  in maze_helper maze (let (x,y) = MazeGen.dims maze in x-1,y-1) MazeGen.West [] (fun () -> [])  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () with | Nil -> fun () -> Nil | Cons (a, sub_seq) -> match seq2 () with | Nil -> fun () -> Nil | Cons (b,sub_seq_2) -> fun () -> Cons ((a,b), zip sub_seq sub_seq_2) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> fun () -> Nil | Cons (h, t) -> if not (p h) then fun () -> Cons (h, keep_until p t) else fun () -> Nil let to_list (seq : 'a seq) : 'a list = let to_list_helper (init : 'a list) (el : 'a) : 'a list = match init with | [] -> [el] | h::t -> init @ [el] in fold_left to_list_helper [] seq let range (start : int) (step : int) (stop : int) : int seq = if step = 0 || (start > stop && step  >0) || (start < stop && step < 0) then raise (Invalid_argument \"Invalid argument\") else if step > 0 then let filter a = if a < start then None else if a >= stop then None else if (a-start) mod step = 0 || a = start then Some a else None in let until b = b >= stop in filter_map filter (keep_until until (map (fun a -> a+start) nats)) else let filter a = if a > start then None else if a <= stop then None else if (start-a) mod step = 0 || a = start then Some a else None in let until b = b <= stop in filter_map filter (keep_until until (map (fun a ->  start-a) nats)) end ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0;den=1} let one = {num=1;den=1}    let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = match (a,b) with | ({num=0;_},_) -> b | (_,{num=0;_}) -> a | (_,_) -> if a.num * b.den + b.num * a.den = 0 then {num=0;den=1} else {num=a.num * b.den + b.num * a.den;den=a.den*b.den} let mul a b = match (a,b) with | ({num=0;_},_) -> zero | (_,{num=0;_}) -> zero | (_,_) -> if a.num * b.num = a.den * b.den then {num=1;den=1} else {num=a.num * b.num;den=a.den * b.den} let neg a = {num = 0 - a.num;den = a.den} let inv a = match a with | {num=0;_} -> {num=0;den=1} | _ -> {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = match (a,b) with | (true,true) -> false | (false,false) -> false | _ -> true let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let go_dir s d = let (x, y, _) = s in match d with |MazeGen.North -> (x, y - 1, d) |MazeGen.South -> (x, y + 1, d) |MazeGen.East  -> (x + 1, y, d) |MazeGen.West  -> (x - 1, y, d) in  let rec maze_solver m s fail success = let (x, y, d) = s in let (r, f, l) = MazeGen.dirs_to_check d in  if x = 0 && y = 0 then success [] else ( match (MazeGen.has_wall m (x, y, r), MazeGen.has_wall m (x, y, f), MazeGen.has_wall m (x, y, l)) with |(true , true , true ) -> fail () |(false, true , true ) -> maze_solver m (go_dir s r) fail (fun dir -> success (let (_, _, d) = go_dir s r in d:: dir)) |(false, false, true ) -> ( maze_solver m (go_dir s r) (fun ()  ->  maze_solver m (go_dir s f) fail (fun dir -> success (let (_, _, d) = go_dir s f in d:: dir))) (fun dir -> success (let (_, _, d) = go_dir s r in d:: dir)) ) |(false, true , false) -> ( maze_solver m (go_dir s r) (fun ()  ->  maze_solver m (go_dir s l) fail (fun dir -> success (let (_, _, d) = go_dir s l in d:: dir))) (fun dir -> success (let (_, _, d) = go_dir s r in d:: dir)) ) |(false, false, false) -> ( maze_solver m (go_dir s r) (fun ()  -> maze_solver m (go_dir s f) (fun ()  -> maze_solver m (go_dir s l) fail (fun dir -> success (let (_, _, d) = go_dir s l in d:: dir))) (fun dir -> success (let (_, _, d) = go_dir s f in d:: dir)) ) (fun dir -> success (let (_, _, d) = go_dir s r in d:: dir)) ) |(true , false, true ) -> maze_solver m (go_dir s f) fail (fun dir -> success (let (_, _, d) = go_dir s f in d:: dir)) |(true , false, false) -> ( maze_solver m (go_dir s f) (fun ()  -> maze_solver m (go_dir s l) fail (fun dir -> success (let (_, _, d) = go_dir s l in d:: dir))) (fun dir -> success (let (_, _, d) = go_dir s f in d:: dir)) ) |(true , true , false) -> maze_solver m (go_dir s l) fail (fun dir -> success (let (_, _, d) = go_dir s l in d:: dir)) ) in  let (start_x, start_y) = MazeGen.dims maze in maze_solver maze (start_x - 1, start_y - 1, MazeGen.North) (fun () -> []) (fun l -> l) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match ((seq1 ()), (seq2 ())) with |(Cons(a, t1), Cons(b, t2)) -> fun () -> Cons((a, b), (zip t1 t2)) |(_          , _          ) -> fun () -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Cons(h, t) -> ( if (not (p h)) then fun () -> Cons(h, keep_until p t) else                fun () -> Nil ) |_         -> fun () -> Nil let to_list (seq : 'a seq) : 'a list = let rec add_to_list seq l = match seq () with | Nil -> l | Cons(h, t) -> h :: add_to_list t l in add_to_list seq []  let range (start : int) (step : int) (stop : int) : int seq = match (start < stop, step < 0) with | (true , false)  -> ( if (step <> 0) then keep_until (fun i -> i >= stop) (map (fun i -> start + i * step) nats) else raise (Invalid_argument \"Step should be non-trivial\") ) | (false, true ) -> ( if (step <> 0) then keep_until (fun i -> i <= stop) (map (fun i -> start + i * step) nats) else raise (Invalid_argument \"Step should be non-trivial\") ) | (_    , _    ) -> raise (Invalid_argument \"Stop cannot be reached\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t    = rational let  zero = {num = 0; den = 1} let  one  = {num = 1; den = 1}  let rec gcd a b = if b = 0 then a else gcd b (a mod b)  let simplify i = let nd_gcd = gcd i.num i.den in {num = i.num / nd_gcd; den = i.den / nd_gcd}   let  equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let  add   a b = let a = simplify a and b = simplify b in let result = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} in simplify result  let  mul   a b = let a = simplify a and b = simplify b in let result = {num = a.num * b.num; den = a.den * b.den} in simplify result  let  neg   i   = {num = i.num * -1; den = i.den} let  inv   i   = if (i.num = 0) then raise (Invalid_argument \"Zero does not have inverse\") else {num = i.den; den= i.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t     = bool let  zero  = false let  one   = true  let  equal = (=) let  add   = (<>) let  mul   = (&&)  let  neg a = a let  inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in  let move_square (cur_state : MazeGen.state) : MazeGen.state = if (MazeGen.has_wall maze cur_state) then raise NotFound else match cur_state with | x, y, MazeGen.West -> (x-1,y,MazeGen.West) | x, y, MazeGen.North -> (x, y-1, MazeGen.North) | x, y, MazeGen.East -> (x+1, y, MazeGen.East) | x, y, MazeGen.South -> (x, y+1, MazeGen.South) in  let rec solve_maze' (cur_state : MazeGen.state) : MazeGen.dir list = let (x,y,dir) = cur_state in if(x=0 && y=0) then [] else let (right, straight, left) = MazeGen.dirs_to_check dir in try (right::solve_maze' (move_square (x,y,right))) with NotFound -> (try (straight:: solve_maze' (move_square (x,y,straight))) with NotFound -> (left::solve_maze' (move_square (x,y,left)))) in try (solve_maze' (width-1, height-1,MazeGen.North)) with NotFound -> (solve_maze' (width-1, height-1, MazeGen.West)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(),seq2()) with | Cons(a,s1), Cons(b,s2) -> (cons (a,b)  (fun ()->(zip s1 s2) ())) | _, _ -> empty let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Cons(a,s) -> if p a then empty else (cons a (fun ()-> (keep_until p s) ())) | _ -> empty let to_list (seq : 'a seq) : 'a list = fold_left (fun a b -> a@[b]) [] seq let range (start : int) (step : int) (stop : int) : int seq = keep_until (fun a -> if(step < 0) then a<=stop else a>=stop) (map (fun a -> (a*step)+start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero =  {num = 0; den = 1} let one =  {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num=a.den*b.num + a.num*b.den; den=a.den*b.den} let mul a b = {num=a.num*b.num; den=a.den*b.den} let neg a = {num=(~-)a.num;den=a.den} let inv a = {num=a.den; den=a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (!=) let mul = (&&) let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let get_next (cur_state : MazeGen.state) : MazeGen.state = match cur_state with | (x, y, MazeGen.North) -> (x, y - 1, MazeGen.North) | (x, y, MazeGen.South) -> (x, y + 1, MazeGen.South) | (x, y, MazeGen.East) -> (x + 1, y, MazeGen.East) | (x, y, MazeGen.West) -> (x - 1, y, MazeGen.West) in  let rec solve maze position succeed fail = let (x, y, direction) = position in if (x = 0 && y = 0) then succeed [] else if MazeGen.has_wall maze position then fail () else let possible_dirs = MazeGen.dirs_to_check direction in let (right, straight, left) = possible_dirs in let next = get_next position in let (next_x, next_y, _) = next in solve maze (next_x, next_y, right) (fun l -> succeed (direction :: l)) (fun () -> solve maze (next_x, next_y, straight) (fun l -> succeed (direction :: l)) (fun () -> solve maze (next_x, next_y, left) (fun l -> succeed (direction :: l)) fail ) ) in let start = MazeGen.dims maze in let (start_x, start_y) = start in solve maze (start_x - 1, start_y - 1, MazeGen.North) (fun l -> l) (fun () -> solve maze (start_x - 1, start_y - 1, MazeGen.West) (fun l -> l) (fun () -> []) ) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let node1 = seq1 () in let node2 = seq2 () in match node1, node2 with | Cons (hd1, tl1), Cons (hd2, tl2) -> (fun () -> Cons ((hd1, hd2), (zip tl1 tl2))) | _, _ -> (fun () -> Nil) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let node = seq () in match node with | Cons (hd, tl) when not (p hd) -> (fun () -> Cons (hd, keep_until p tl)) | _ -> (fun () -> Nil) let to_list (seq : 'a seq) : 'a list = let rec convert s = let node = s () in match node with | Nil -> [] | Cons (hd, tl) -> hd :: (convert tl) in convert seq  let range (start : int) (step : int) (stop : int) : int seq =  if ((start < stop && step <= 0) || (start <= stop && step < 0)) then raise (Invalid_argument \"start <(=) stop and step backward -> infinite sequence!\") else if ((start > stop && step >= 0) || (start >= stop && step > 0)) then raise (Invalid_argument \"start >(=) stop and step forward -> infinite sequence!\") else keep_until (fun a -> if step > 0 then a >= stop else a <= stop) (map (fun n -> start + step * n) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add (a : t) (b : t) : t = if (a.den = 0 || b.den = 0) then raise DivideByZero else {num = a.num * b.den + b.num * a.den; den = a.den * b.den}  let mul (a : t) (b : t) : t = if (a.den = 0 || b.den = 0) then raise DivideByZero else {num = a.num * b.num; den = a.den * b.den}  let neg (a : t) : t = if a.den = 0 then raise DivideByZero else {num = - a.num; den = a.den}  let inv (a : t) : t = if a.num = 0 then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add (a : t) (b : t) : t = match a, b with | false, _ -> b | _, false -> a | _, _ -> false  let mul (a : t) (b : t) : t = ( && ) a b  let neg (a : t) : t = a let inv (a : t) : t = neg a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (w,h) = dims maze in let getCoord state = let (tX,tY,tDIR) = state in match tDIR with |North-> (tX, tY-1, North) |South-> (tX, tY+1, South) |East-> (tX+1, tY, East) |West-> (tX-1, tY, West) in let rec solver maze state sc fc  = let (xC,yC,dir) = state in if (xC = 0 && yC = 0 ) then sc [] else if (MazeGen.has_wall maze state) then fc () else let xc,yc,dc = getCoord (xC,yC,dir) in let (r, f, l) = MazeGen.dirs_to_check dir in solver maze (xc,yc,r) (fun d -> sc (dir :: d)) (fun () -> solver maze (xc,yc,f) (fun d -> sc (dir :: d)) (fun () -> solver maze (xc,yc,l) (fun d -> sc (dir :: d)) fc )) in solver maze (w-1 , h-1 , North) (fun r -> r) (fun () -> solver maze (w-1, h-1, West) (fun r -> r) (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 () , seq2 () with |Cons(hd1,tl1), Cons(hd2,tl2)-> Cons((hd1,hd2),zip tl1 tl2) |_-> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with |Nil -> Nil |Cons(hd,tl) -> if (p hd) then Nil else Cons(hd, keep_until p tl) let to_list (seq : 'a seq) : 'a list = let rec lhelper seq l = match seq () with |Nil -> l |Cons(hd,tl) -> hd :: lhelper tl l in lhelper seq [] let range (start : int) (step : int) (stop : int) : int seq = if ((start<stop && step < 0) || (start>stop && step > 0) || step = 0) then raise (Invalid_argument \"Infinite Stream inputted\") else keep_until (fun x -> if (step > 0) then x >= stop else x <= stop) (map (fun x -> (x * step) + start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add x y = let n1 = (x.num)*(y.den) + (x.den)*(y.num) in let d1 = (x.den)*(y.den) in {num = n1; den = d1} let mul x y = let n1 = (x.num)*(y.num) in let d1 = (x.den)*(y.den) in {num = n1; den = d1} let neg x = let z = (-1)*(x.num) in {num = z; den = x.den} let inv x = {num = x.den; den = x.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add x y = match x,y with |false,false |true,true -> zero |_ -> one let mul x y = match x,y with |true,true -> one |_ -> zero let neg x = x let inv = neg end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (width, height) = MazeGen.dims maze in let cur_state = ((width -1, height -1, North) : MazeGen.state) in  let move_in_dir (state: MazeGen.state) (dir: MazeGen.dir) : MazeGen.state = let (x, y, _) = state in match dir with | East -> (x + 1, y, East) | West -> (x - 1, y, West) | South -> (x, y + 1, South) | North -> (x, y - 1, North) in let rec solve_maze_tr (maze: MazeGen.maze) (state: MazeGen.state) fail succeed : MazeGen.dir list = match state with | _ -> begin let (x, y, cur_dir) = state in let (right, front, left) = MazeGen.dirs_to_check cur_dir in if (not (MazeGen.has_wall maze (x,y,right))) then let a = (solve_maze_tr maze (move_in_dir state right) fail (fun r -> (succeed [right]) @ r)) in match a with begin if (not (MazeGen.has_wall maze (x,y,front))) then let b = (solve_maze_tr maze (move_in_dir state front) fail (fun r -> (succeed [front]) @ r)) in match b with begin solve_maze_tr maze (move_in_dir state left) fail (fun r -> (succeed [left]) @ r) fail() end | _ -> b else solve_maze_tr maze (move_in_dir state left) fail (fun r -> (succeed [left]) @ r) fail() end else if (not (MazeGen.has_wall maze (x,y,front))) then let b = (solve_maze_tr maze (move_in_dir state front) fail (fun r -> (succeed [front]) @ r)) in match b with begin solve_maze_tr maze (move_in_dir state left) fail (fun r -> (succeed [left]) @ r) fail() end else solve_maze_tr maze (move_in_dir state left) fail (fun r -> (succeed [left]) @ r) fail() end  in solve_maze_tr maze cur_state (fun () -> []) (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1() with | Seq.Nil -> Seq.empty | Seq.Cons (n1, f1) -> begin match seq2() with | Seq.Nil -> Seq.empty | Seq.Cons (n2, f2) -> fun() -> Seq.Cons((n1, n2), (zip f1 f2)) end let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Seq.Nil -> Seq.empty | Seq.Cons (n, f) -> begin Seq.empty else fun() -> Seq.Cons(n, keep_until p f) end let to_list (seq : 'a seq) : 'a list = let rec helper (seq : 'a seq) (acc: 'a list) : 'a list = match seq() with | Seq.Nil -> acc | Seq.Cons(n, f) -> helper f (n::acc) in List.rev (helper seq []) let range (start : int) (step : int) (stop : int) : int seq = let ex1 = Invalid_argument \"step is 0\" and ex2 = Invalid_argument \"start is larger than stop but step is positive\" and ex3 = Invalid_argument \"stop is larger than start but step is negative\" in if (step = 0) then raise ex1 else if ((step > 0) && (start > stop)) then raise ex2 else if ((step < 0) && (start < stop)) then raise ex3 else let mySeq = Seq.map (fun x -> x * step + start) nats  in if (step > 0) then keep_until (fun x -> x >= stop) mySeq else keep_until (fun x -> x <= stop) mySeq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = let a = {num = 0; den = 1} in a let one = let a = {num = 1; den = 1} in a  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = let c = {num = a.num * b.den + b.num * a.den; den = a.den * b.den} in c let mul a b = let c = {num = a.num * b.num; den = a.den * b.den} in c  let neg a = let b = {num = -a.num; den = a.den} in b let inv a = let b = {num = a.den; den = a.num} in b end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=)  let add a b = a <> b let mul a b = a && b  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let nextstate states dir = let (x,y,z) = states in if z = East then (x+1,y,dir) else if z = South then (x,y+1,dir) else if z = West then (x-1,y,dir) else (x,y-1,dir) in let rec dir_state (states: MazeGen.state) fl sc = match states with | (0,0,_) -> List.rev(List.tl(sc North)) | (x,y,z) -> let (a,b,c) = dirs_to_check z in if not (has_wall maze (x,y,z)) then dir_state (nextstate (x,y,z) a) (fun () -> dir_state (nextstate(x,y,z) b) (fun () -> dir_state (nextstate(x,y,z) c) fl (fun v -> v::(sc z))) (fun v -> v::(sc z))) (fun v -> v::(sc z)) else fl () in let (p,q) = dims maze in dir_state(p-1,q-1,North) (fun () -> dir_state (p-1,q-1,West) (fun ()-> raise NotFound) (fun v -> v::[])) (fun v -> v::[]) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1() with | Cons (x, xs) -> (match seq2() with |  Cons (y, ys) -> fun () -> Cons ((x, y), zip xs ys) | _ -> empty) | _ -> empty let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Cons (x, xs) -> if not (p x) then cons x (keep_until p xs) else empty | _ -> empty let rec to_list (seq : 'a seq) : 'a list = match seq() with | Cons (x, xs) -> x::to_list xs | _ -> [] let range (start : int) (step : int) (stop : int) : int seq = keep_until (fun (x) -> (x - stop) * step >= 0) (map (( + ) start) (map (( * ) step) nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = a.den * b.num + a.num * b.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = fun (a : bool) (b : bool) -> not (a = b) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, Nil -> (fun() -> Nil) | Nil, Cons(_,_) -> (fun() -> Nil) | Cons(_,_), Nil -> (fun() -> Nil) | Cons(x,xs), Cons(x',xs') -> (fun() -> Cons((x,x'), zip xs xs'))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> (fun() -> Nil) | Cons(x,xs) -> if p x then (fun() -> Nil) else (fun() -> Cons(x, keep_until p xs))  let to_list (seq : 'a seq) : 'a list = let rec list_helper (seq' : 'a seq) : 'a list = match seq'() with | Nil -> [] | Cons(x,xs) -> x::(list_helper (xs)) in list_helper seq let range (start : int) (step : int) (stop : int) : int seq =  let change x = x*step + start in if step = 0 then invalid_arg \"Cannot have step size 0\" else if ((step > 0 && stop < start) || (step < 0 && stop > start)) then invalid_arg \"Infinite range: stop will never be reached\" keep_until (fun n -> n >= stop) (map change nats) else keep_until (fun n -> n <= stop) (map change nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0;den=1} let one = {num=1;den=1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num=((a.num*b.den)+(a.den*b.num));den=(a.den*b.den)} let mul a b = {num=(a.num * b.num);den=(a.den * b.den)}  let neg a = {num=(-a.num);den=(a.den)} let inv a = {num=(a.den);den=(a.num)} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = (false) let one = (true)  let equal = (=)  let add = (!=) let mul = (&&)  let neg a = (a) let inv a = (a) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t  let two = F.add (F.one) (F.one) ;; ",
  "let three = F.add (F.one) (two) ;; ",
  "let easyECs = not (F.equal (two) (F.zero)) && not (F.equal (three) (F.zero));; ",
  " let onCurve (p : F.t) (q : F.t) ((x,y) : point) = let y_squared = F.mul (y) (y) in let x_cubed = F.mul (F.mul (x) (x)) (x) in let px = F.mul (p) (x) in let right = F.add (F.add (x_cubed) (px)) (q) in F.equal y_squared right ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let list = ref [] in let (w, h) = MazeGen.dims maze in let mover (x, y) a_dir = match a_dir with | MazeGen.West -> (x-1, y, a_dir) | MazeGen.North -> (x, y-1, a_dir) | MazeGen.East -> (x+1, y, a_dir) | MazeGen.South -> (x, y+1, a_dir) in let rec path_finder (x, y, dir) contin = if x = 0 && y = 0 then true else if x < 0 || y < 0 || x = w || y = h then false else let (right, front, left) = MazeGen.dirs_to_check dir in if not (MazeGen.has_wall maze (x, y, right)) && path_finder (mover (x, y) right) contin then contin right else if not (MazeGen.has_wall maze (x, y, front)) && path_finder (mover (x, y) front) contin then contin front else if not (MazeGen.has_wall maze (x, y, left)) && path_finder (mover (x, y) left) contin then contin left else false in let contin input_dir = in if path_finder (w-1, h-1, MazeGen.North) contin then !list else if path_finder (w-1, h-1, MazeGen.West) contin then !list else [] ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | (Cons(hd1, tl1), Cons(hd2, tl2)) -> fun () -> Cons((hd1, hd2), zip tl1 tl2) | (_, _) -> fun () -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Cons(hd, tl) -> if p hd then fun () -> Nil else fun () -> Cons(hd, keep_until p tl ) | Nil -> fun () -> Nil let rec to_list (seq : 'a seq) : 'a list = match seq () with | Nil -> [] | Cons(hd, tl) -> List.cons hd (to_list tl) let range (start : int) (step : int) (stop : int) : int seq = if (stop > start && step < 0) || (start > stop && step > 0) || (step = 0) then raise (Invalid_argument \"infinite sequence\") else if step > 0 then let new_seq = Seq.map (fun n -> start + (step * n)) nats in keep_until (fun p -> p >= stop) new_seq else let new_seq = Seq.map (fun n -> start + (step * n)) nats in keep_until (fun p -> p <= stop) new_seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let mul a b = {num = a.num * b.num; den = a.den * b.den} let add a b = {num = (a.num * b.den) + (b.num * a.den) ; den = a.den * b.den} let neg a = {num = (-1) * a.num; den = a.den} let inv a = {num = a.den; den = a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = (a && not b) || (b && not a) let mul = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let nextState state = match state with | (w, h, MazeGen.North) -> (w, h-1) | (w, h, MazeGen.South) -> (w, h+1) | (w, h, MazeGen.East) -> (w+1, h) | (w, h, MazeGen.West) -> (w-1, h) in let rec findPath state sc fc = match state with | (0, 0, _) -> sc [] | (x, y, d) -> let (right,forward,left) = MazeGen.dirs_to_check d  in  let (x', y') = nextState state in if (not (MazeGen.has_wall maze state)) then findPath (x', y', right) (fun l -> sc (d :: l)) (fun () -> findPath (x',y',forward) (fun l -> sc (d :: l)) (fun () -> findPath (x',y',left) (fun l -> sc (d :: l)) fc))  else fc ()  in let (x, y) = MazeGen.dims maze in findPath (x-1, y-1, MazeGen.North) (fun l -> l) (fun () -> findPath (x-1, y-1, MazeGen.West) (fun l -> l) (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 () with | Nil -> Nil | Cons (h1, t1) -> match seq2 () with | Nil -> Nil |Cons (h2, t2) -> Cons ((h1, h2), zip t1 t2) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (h, t) -> if p h then Nil else Cons (h, keep_until p t) let to_list (seq : 'a seq) : 'a list = let rec loop s = match s () with | Nil -> [] | Cons (h, t) -> h :: loop t in loop seq let range (start : int) (step : int) (stop : int) : int seq = if ((start > stop) && (step >= 0)) then raise (Invalid_argument \"impossible\") else if ((start < stop) && (step <= 0)) then raise (Invalid_argument \"impossible\") else let rec from s = fun () -> match s () with | Nil -> Nil | Cons (h, t) -> if h = start then Cons (h, t) else Cons (h, from t) in if step < 0 then keep_until (fun x -> x <= stop) (map (fun x -> start + step * x) (from nats)) else keep_until (fun x -> x >= stop) (map (fun x -> start + step * x) (from nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den <> 0 && b.den <> 0 then if a.den <> b.den then {num = (a.num * b.den + b.num * a.den); den = (a.den * b.den)} else {num = (a.num + b.num); den = a.den} else raise DivideByZero  let mul a b =  if a.den <> 0 && b.den <> 0 then {num = a.num * b.num; den = a.den * b.den} else raise DivideByZero  let neg a = if a.den <> 0 then {num = (-a.num); den = a.den} else raise DivideByZero  let inv a = if a.den <> 0 then {num = a.den; den = a.num} else raise DivideByZero  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = not (a = b)  let mul a b = match a, b with | true, true -> true | _, _ -> false  let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let rec discover k l = match l with | [] -> false | (x,y,_)::t -> if (let (c1,c2,_) = k in (c1 = x && c2 = y)) then true else (discover k t) in let next direction s v =  match direction with |MazeGen.North -> let (x,y,_) = s in (x,y-1,v) |MazeGen.South -> let (x,y,_) = s in (x,y+1,v) |MazeGen.East -> let (x,y,_) = s in (x+1,y,v) |MazeGen.West -> let (x,y,_) = s in (x-1, y, v) in  let rec solvr sc back s f r p li= match s with | (0,0,_) -> sc [] | (x,y,d) -> let (right,front,left) = MazeGen.dirs_to_check d in if (MazeGen.has_wall maze s) then if (d = r) then solvr sc back (x,y,f) f r p li else if (d = f) then solvr sc back (x,y,p) f r p li else back () else if (discover (next front s front) li) then back () else solvr (fun c -> sc(d :: c)) (fun () -> solvr sc back (x,y,left) f r p li) (next front s right) front right left (s :: li) match s with |(0,0,d) -> sc [] |(x,y,d) -> let (right,front,left) = MazeGen.dirs_to_check d in if(MazeGen.has_wall maze s) then ( if (d = r) then solvr sc back (x,y,f) f r l p li else if (d = f) then solvr sc back (x,y,p) f r l p li else back()) else if ((discover s li) && ((x+1,y+1) != MazeGen.dims maze)) then back () else (print_string \"\\n Adding \"; print_string (print_d d) ;print_string \" List is :\";print_list l ;solvr (fun c -> sc (d::c))(fun () -> solvr (fun c -> sc (d::c)) back (x,y,left) front right (remove l) left li)   (next front s right) front right ((d :: l)) left (s::li)))*) in  (fun d -> d) (fun d -> solvr (fun c -> c)(fun() -> raise NotFound) (let (x,y) = MazeGen.dims maze in (x-1,y-1,MazeGen.West) ) MazeGen.West MazeGen.North MazeGen.South []) (let (x,y) = MazeGen.dims maze in ((x-1,y-1,MazeGen.North))) MazeGen.North MazeGen.East MazeGen.West [] ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () , seq2 () with | Nil, _ -> empty | _, Nil -> empty | Cons(h, xf), Cons(h2, xf2) -> fun() -> Cons((h,h2) , zip (xf) (xf2))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> seq | Cons(h,xf) -> if (p h) then empty else cons h (keep_until p xf) let to_list (seq : 'a seq) : 'a list = let rec to_listtr s l = match s() with |Nil -> l |Cons(h,xf) -> to_listtr xf (l @ [h]) in match seq() with |Nil -> [] |Cons(hd, t) -> to_listtr t (hd::[])  let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then let excp = Invalid_argument \"step cannot be 0\" in raise excp else if start < stop then  if (step < 0) then let excp = Invalid_argument \"step cannot be negative here\" in raise excp else let st = map (fun x -> (x * step)) nats in let s = map (fun x -> (x + start)) st in keep_until (fun x -> x  >= stop) s  else if (step > 0) then let excp = Invalid_argument \"step cannot be positive here\" in raise excp else let st = map (fun x -> (x * step)) nats in let s = map (fun x -> (x + start)) st in keep_until (fun x -> x  <= stop ) s  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop    ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}    let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add x y = { num = (x.num * y.den) + (y.num * x.den); den = (x.den * y.den)} let mul x y =  {num = (x.num * y.num); den = (x.den * y.den)}  let neg x = {num = (-1 * x.num); den = x.den} let inv x = {num = x.den; den = x.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one  = true  let equal = (=)  let add x y = (x && not(y)) || (y && not(x)) let mul x y = if x = zero then zero else (x && y) || (not(x) && not(y))  let neg x = match x with |false -> false |true -> true let inv x = match x with |false -> false |true -> true end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let open MazeGen in  let next_cell (cur_state : state ) : state = let (x, y, dir) = cur_state in match dir with | West -> x-1, y, dir; | North -> x, y-1, dir; | East -> x+1, y, dir; | South -> x, y+1, dir;  in  let rec solver cur_state sc fc = match cur_state with | (0, 0, _) -> sc [] | _ ->  if has_wall maze cur_state then fc () else let (next_x, next_y, next_dir) = next_cell cur_state in let (right, straight, left) = dirs_to_check next_dir in  solver (next_x, next_y, right) (fun r -> sc (next_dir::r)) (fun () -> solver (next_x, next_y, straight) (fun  r -> sc (next_dir::r)) (fun () -> solver (next_x, next_y, left) (fun r -> (sc (next_dir::r))) fc)) in let (width, height) = dims maze in  solver (width-1, height-1, North) (fun r -> r) (fun () -> solver (width-1, height-1, West) (fun r -> r) (fun () -> []))  ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq  let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Cons (x, seq1s), Cons (y, seq2s) -> fun () -> Cons ((x, y), (zip seq1s seq2s)) | _ -> fun () -> Nil ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Cons (x, seqs) -> if p x then fun () -> Nil else fun () -> Cons (x, keep_until p seqs) | Nil -> fun () -> Nil ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec listing seq acc = match seq () with | Cons (x, seqs) -> x:: (listing seqs acc) | Nil -> acc in listing seq [] ;; ",
  " let range (start : int) (step : int) (stop : int) : int seq =  match start > stop , step > 0, step with | _, _, 0 -> raise (Invalid_argument \"step is zero\") | true, true, _ -> raise (Invalid_argument \"step is positive, start > stop\") | false, false, _ -> raise (Invalid_argument \"step is negative, start < stop\") | _ ->  let rec get_seq seq = match seq () with | Nil -> fun () -> Nil | Cons (hd, tl) -> fun () -> Cons (start + hd, get_seq tl) in let range_seq = get_seq (map (( * ) step) nats) in  let check_stop x = match step < 0 with | true -> x <= stop | false -> x >= stop in keep_until check_stop range_seq ;; ",
  "end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} ;; ",
  "let one = {num = 1; den = 1} ;; ",
  " let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den ;; ",
  "let add a b = {num = (a.num*b.den) + (b.num*a.den); den = a.den*b.den} ;; ",
  "let mul a b = {num = a.num*b.num; den = a.den*b.den};; ",
  "let inv a = {num = a.den; den = a.num } ;; ",
  "let neg a = {num = a.num * (-1) ; den = a.den};; ",
  " end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let equal = (=) ;; ",
  "let zero = false ;; ",
  "let one = true ;; ",
  " let add (a : bool) (b : bool) = match a, b with | true, false -> true | false, true -> true | _ -> false ;; ",
  " let mul a b = (a, b) = (true, true) ;; ",
  " let neg a = a ;; ",
  "let inv a = a  ;; ",
  " end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs : bool = let two = F.add F.one F.one in let three = (F.add (F.add F.one F.one) F.one) in (not (F.equal two F.zero)) && (not (F.equal three F.zero)) ;; ",
  " let onCurve p q point = let (x, y) = point in F.equal (F.mul y y) (F.add ((F.add (F.mul (F.mul x x) x) (F.mul p x))) q) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec solver (state : (int * int * MazeGen.dir)) continue dead_end = let next_cell (state : MazeGen.state) = let (x, y, dirc) = state in match dirc with | MazeGen.West  -> (x - 1, y, MazeGen.West) | MazeGen.North -> (x, y - 1, MazeGen.North) | MazeGen.East  -> (x + 1, y, MazeGen.East) | MazeGen.South -> (x, y + 1, MazeGen.South) in let (x, y, dirc) = state in if x < 0 || x >= fst(MazeGen.dims maze) || y < 0 || y > snd(MazeGen.dims maze) then dead_end() else match (x,y) with | (0,0) -> continue([]) | (a,b) -> let (right, forward, left) = MazeGen.dirs_to_check(dirc) in match (not (MazeGen.has_wall maze (x, y , right)), not (MazeGen.has_wall maze (x, y , forward)), not (MazeGen.has_wall maze (x, y , left))) with | (true, true, true) -> solver (next_cell (a,b,right)) (fun l -> continue(right::l)) (fun () -> solver (next_cell(a,b,forward)) (fun l -> continue(forward::l)) (fun () -> solver (next_cell(a,b,left)) (fun l -> continue(left::l)) dead_end)) | (true, true, false) -> solver (next_cell (a,b,right)) (fun l -> continue(right::l)) (fun () -> solver (next_cell(a,b,forward)) (fun l -> continue(forward::l)) dead_end) | (true, false, true) -> solver (next_cell (a,b,right)) (fun l -> continue(right::l)) (fun () -> solver (next_cell(a,b,left)) (fun l -> continue(left::l)) dead_end) | (true, false, false) -> solver (next_cell (a,b,right)) (fun l -> continue(right::l)) dead_end | (false, true, true) -> solver (next_cell (a,b,forward)) (fun l -> continue(forward::l)) (fun () -> solver (next_cell(a,b,left)) (fun l -> continue(left::l)) dead_end) | (false, true, false) -> solver (next_cell (a,b,forward)) (fun l -> continue(forward::l)) dead_end | (false, false, true) -> solver (next_cell (a,b,left)) (fun l -> continue(left::l)) dead_end | (false, false, false) -> dead_end() in let (x, y) = MazeGen.dims(maze) in solver (x - 1, y - 1, MazeGen.North) (fun l -> l) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1(), seq2()) with | (Nil, Nil) -> Nil | (Nil, _) -> Nil | (_, Nil) -> Nil | (Cons(v1, tl1), Cons(v2, tl2)) -> Cons((v1, v2), (zip tl1 tl2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun() -> match seq() with | Nil -> Nil | Cons(v, tail) -> if (p v) then Nil else Cons(v, (keep_until p tail)) let to_list (seq : 'a seq) : 'a list = fold_left (fun l a -> l @ [a]) [] seq let range (start : int) (step : int) (stop : int) : int seq = if (start < 0 && step < 0 && start < stop) || (step == 0) then raise (Invalid_argument \"Invalid inputs for range - infinite sequence\") else keep_until (fun n -> if (step < 0) then n <= stop else n >= stop) (map (fun n -> start + (n * step)) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0; den= 1} let one = {num=1; den= 1} let add = fun a b -> {num=(a.num * b.den) + (b.num * a.den); den=(a.den * b.den)} let mul = fun a b -> {num=(a.num * b.num);den=(a.den * b.den)} let neg = fun a -> {num= -1 * a.num; den = a.den} let inv = fun a -> {num=a.den; den = a.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = fun a b -> (a || b) && not (a && b) let mul = (&&) let neg = fun a -> a let inv = fun a -> a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let m = maze in let rec go state fail suc = let go_west (i,j,(d:MazeGen.dir))=  go (i-1,j,MazeGen.West) in let go_north (i,j,(d:MazeGen.dir))=  go (i,j-1,MazeGen.North) in let go_east (i,j,(d:MazeGen.dir))=  go (i+1,j,MazeGen.East) in let go_south (i,j,(d:MazeGen.dir))=  go (i,j+1,MazeGen.South) in let left_1 (d:MazeGen.dir) (s:MazeGen.state) fail suc = match d with |MazeGen.West  -> go_west s (fun () -> go_south s fail (fun rs -> suc ((MazeGen.South)::rs))) (fun rs -> suc (d::rs)) |MazeGen.North -> go_north s (fun () -> go_west s fail (fun rs -> suc (MazeGen.West::rs))) (fun rs -> suc (d::rs)) |MazeGen.East  -> go_east s (fun () -> go_north s fail (fun rs -> suc (MazeGen.North::rs))) (fun rs -> suc (d::rs)) |MazeGen.South -> go_south s (fun () -> go_east s fail (fun rs -> suc (MazeGen.East::rs))) (fun rs -> suc (d::rs)) in let left_12 (d:MazeGen.dir) (s:MazeGen.state) fail suc = match d with |MazeGen.West  -> go_west s (fun () -> go_south s (fun () -> go_east s fail (fun rs -> suc ((MazeGen.East)::rs))) (fun rs -> suc ((MazeGen.South)::rs))) (fun rs -> suc (d::rs)) |MazeGen.North -> go_north s (fun () -> go_west s (fun () -> go_south s fail (fun rs -> suc ((MazeGen.South)::rs))) (fun rs -> suc (MazeGen.West::rs))) (fun rs -> suc (d::rs)) |MazeGen.East  -> go_east s (fun () -> go_north s (fun () -> go_west s fail (fun rs -> suc ((MazeGen.West)::rs))) (fun rs -> suc (MazeGen.North::rs))) (fun rs -> suc (d::rs)) |MazeGen.South -> go_south s (fun () -> go_east s (fun () -> go_north s fail (fun rs -> suc ((MazeGen.North)::rs))) (fun rs -> suc (MazeGen.East::rs))) (fun rs -> suc (d::rs)) in let left_2 (d:MazeGen.dir) (s:MazeGen.state) fail suc = match d with |MazeGen.West  -> go_west s (fun () -> go_east s fail (fun rs -> suc (MazeGen.East::rs))) (fun rs -> suc (d::rs)) |MazeGen.North -> go_north s (fun () -> go_south s fail (fun rs -> suc (MazeGen.South::rs))) (fun rs -> suc (d::rs)) |MazeGen.East  -> go_east s (fun () -> go_west s fail (fun rs -> suc (MazeGen.West::rs))) (fun rs -> suc (d::rs)) |MazeGen.South -> go_south s (fun () -> go_north s fail (fun rs -> suc (MazeGen.North::rs))) (fun rs -> suc (d::rs)) in let left_fail (d:MazeGen.dir) (s:MazeGen.state) fail suc = match d with |MazeGen.West  -> go_west s (fun () -> fail ()) (fun rs -> suc (d::rs)) |MazeGen.North -> go_north s (fun () -> fail ()) (fun rs -> suc (d::rs)) |MazeGen.East  -> go_east s (fun () -> fail ()) (fun rs -> suc (d::rs)) |MazeGen.South -> go_south s (fun () -> fail ()) (fun rs -> suc (d::rs)) in match state with |(0,0,_) -> suc [] |(i,j,d) as s -> let (dr,df,dl) = MazeGen.dirs_to_check d in match((MazeGen.has_wall m (i,j,dr)),(MazeGen.has_wall m (i,j,df)),(MazeGen.has_wall m (i,j,dl))) with |(true,true,true) -> fail () |(false,false,true) -> left_1 dr s fail suc |(false,true,false) -> left_2 dr s fail suc |(false,true,true) -> left_fail dr s fail suc |(true,false,true) -> left_fail df s fail suc |(true,false,false) ->left_1 df s fail suc |(true,true,false) -> left_fail dl s fail suc  in let (x,y) = MazeGen.dims m in go (x-1,y-1,MazeGen.North) (fun () -> []) (fun e -> e) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (),seq2 ()) with |Nil,_ -> empty |_,Nil -> empty |(Cons(a,al), Cons(b,bl))-> fun () -> Cons((a,b),(zip al bl)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq ()) with |Nil -> empty |Cons(a,al) -> if (p a) then empty else fun () ->  Cons(a,keep_until p al) let to_list (seq : 'a seq) : 'a list = match (seq ()) with |Nil -> [] |Cons(a,al) -> fold_left (fun list el -> list@[el]) [] seq let range (start : int) (step : int) (stop : int) : int seq = let check start step stop = let negative_step = step < 0 in let small_start = start < stop in match (negative_step,small_start) with |true,true -> raise (Invalid_argument \"cannot reach stop when counting down\" ) |false,false -> raise (Invalid_argument \"cannot reach stop when counting up\" ) |_ -> () in let rec range_help start step stop next_nat : int seq= check start step stop; match step,next_nat () with |0,_ -> raise (Invalid_argument \"step = 0 result in infinite loop\" ) |_,Cons(n,nl) -> (fun () -> Cons((start+ n),(range_help start step stop nl)))  in keep_until ( fun el -> if step > 0 then el >= stop else el <= stop) (range_help start step stop (map (fun el -> el * step) nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add x y = {num = (x.num * y.den) + (y.num * x.den); den = (x.den * y.den) } let mul x y= {num = (x.num * y.num); den = (x.den * y.den) } let neg x = {num = (-x.num); den = x.den} let inv x = {num = x.den; den = x.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = (<>) let mul = (&&) let neg b = b let inv b = b  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Cons (a1, b1), Cons(a2, b2) -> (fun () -> Cons((a1,a2), zip b1 b2)) | Nil, _ -> empty | _, Nil -> empty  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons (a, b) -> if p a then empty else fun() ->Cons(a, keep_until p b) let to_list (seq : 'a seq) : 'a list = let rec to_list_tr seq acc = match seq() with | Nil -> acc | Cons (a, b) ->to_list_tr b (acc@[a]) in to_list_tr seq [] let range (start : int) (step : int) (stop : int) : int seq = let equal_tr (input :int) = ((stop >= input) && (step<0)) || ((stop<= input) && (step>0)) in let change (input: int) = input*step+start in keep_until equal_tr (map change nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den=1} let one = {num=1; den=1} let add a b = if (a.den = b.den) then {num=(a.num+b.num); den=a.den} else {num=(a.num*b.den+b.num*a.den); den=(a.den*b.den)} let mul a b = {num =(a.num*b.num); den=(a.den*b.den)} let neg a = {num = -(a.num); den= a.den} let inv a = {num = a.den; den= a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = match b with | true -> not a | false -> a let mul a b = match b with | true -> a | false -> false let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let next_move (x,y,d) = match d with |MazeGen.North -> (x,y-1) |MazeGen.West -> (x-1,y) |MazeGen.East -> (x+1,y) |MazeGen.South -> (x,y+1) in  let rec solve_maze_tr (x,y,d) fail succ = if (x,y) = (0,0) then succ [] else if (MazeGen.has_wall maze (x,y,d)) then fail () else let (right,forward,left) = MazeGen.dirs_to_check d in let (x',y') = next_move (x,y,d) in solve_maze_tr (x',y',right) (fun () -> solve_maze_tr (x',y',forward) (fun () -> solve_maze_tr (x',y',left) fail (fun directions -> succ (d::directions))) (fun directions -> succ (d::directions))) (fun directions -> succ (d::directions)) in  let (width,height) = MazeGen.dims maze in solve_maze_tr (width-1, height-1, MazeGen.North) (fun () -> solve_maze_tr (width-1, height-1, MazeGen.West) (fun () -> raise NotFound) (fun directions -> directions)) (fun directions -> directions) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with |Nil, _ -> Nil |_, Nil -> Nil |Cons(x,at),Cons(y,yt) -> Cons ((x,y), zip at yt)   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> fun() -> Nil |Cons(z,zs) -> fun() -> if not(p z) then Cons (z, keep_until p zs) else Nil let to_list (seq : 'a seq) : 'a list = let rec helper seq acc = match seq() with |Nil -> acc |Cons(x,xs) -> helper xs (x::acc) in List.rev (helper seq []) let range (start : int) (step : int) (stop : int) : int seq = if start = stop then empty else if step = 0 then raise (Invalid_argument \"Did not increment\") else if ((step > 0 && start > stop) || ( step < 0 && start < stop)) then raise (Invalid_argument \"Infinite sequence \") else let seq = map (fun a -> a * step +start) nats in keep_until (fun b -> if stop > start then b >= stop else b <= stop ) seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = a.num*b.den + b.num*a.den; den = a.den*b.den} let mul a b =  {num = a.num*b.num; den = a.den*b.den} let neg a =  {num = 0-a.num; den = a.den} let inv a =  {num = a.den; den = a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let add a b = match a,b with |true, true |false,false  -> false |false,true |true,false-> true  let mul = (&&) let neg x = match x with |true -> true |false -> false  let inv x = match x with |true -> true |false -> false  let equal = (=) end ;; ",
  "exception DeadEnd ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let travel (x,y) (dir : MazeGen.dir) = match dir with | MazeGen.North -> (x,y-1,MazeGen.North) | MazeGen.East -> (x+1,y,MazeGen.East) | MazeGen.South -> (x,y+1,MazeGen.South) | MazeGen.West -> (x-1,y,MazeGen.West) in let travelS myState dir = let (x,y,_) = myState in travel (x,y) dir in  let valid_dirs dirL wallL = let rec valid_dirs_aux dirLP wallLP auxL = match dirLP with | [] -> auxL | x::xs -> match wallLP with | [] -> auxL | y::ys -> if (y) then valid_dirs_aux xs ys (auxL @ [x]) else valid_dirs_aux xs ys auxL in valid_dirs_aux dirL wallL [] in  let rec maze_aux myState mySucc myFail = let (x,y,dir) = myState in let (d1,d2,d3) = MazeGen.dirs_to_check dir in let (w1,w2,w3) = ( not (MazeGen.has_wall maze (x,y,d1)), not (MazeGen.has_wall maze (x,y,d2)), not (MazeGen.has_wall maze (x,y,d3)) ) in let v_dirs = valid_dirs [d1;d2;d3] [w1;w2;w3] in   let rec maze_aux2 myState2 vdirs2 mySucc2 myFail2 = match vdirs2 with | [] -> raise DeadEnd | x::xs -> let mySucc3 = (fun myList -> mySucc2 (x :: myList)) in let myFail3 = (fun() -> maze_aux2 myState2 xs mySucc2 myFail2) in maze_aux (travelS myState x) mySucc3 myFail3 in   if (x,y) = (0,0) then mySucc [] else try maze_aux2 myState v_dirs mySucc myFail with DeadEnd -> myFail()  in let (w,h) = MazeGen.dims maze in maze_aux (w-1,h-1,MazeGen.North) (fun r -> r) (fun () -> raise NotFound)   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze maze); print_string (\"\\n \\n\"); print_string (MazeGen.string_of_maze ~path maze); ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1() with | Nil -> (fun unit -> Nil) | Cons(a,aS) -> match seq2() with | Nil -> (fun unit -> Nil) | Cons(b,bS) -> (fun unit -> Cons((a,b), zip aS bS)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> seq | Cons(a,aS) -> if (p a) then (fun unit -> Nil) else (fun unit -> Cons(a, (keep_until p aS))) let to_list (seq : 'a seq) : 'a list = let rec aux seqP list = match seqP() with | Nil -> list | Cons(a,aS) -> aux (aS) (list@[a]) in aux seq [] exception Invalid_argument  let range (start : int) (step : int) (stop : int) : int seq =  let mul x y = x * y in let add x y = x + y in  let myBool myStep myLim myInput = if (myStep > 0) then (myInput >= myLim) else (myInput <= myLim) in  if (step = 0) then (print_string(\"Step cannot be zero.\"); raise Invalid_argument) else if ((start < stop) && (step < 0)) then (print_string(\"Step must be positive if start is less than stop.\"); raise Invalid_argument) else if ((start > stop) && (step > 0)) then (print_string(\"Step must be negative if start is greater than stop.\"); raise Invalid_argument) else   keep_until (myBool step stop) ( Seq.map (add start) (Seq.map (mul step) (nats) ) )  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  " module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = { num = a.num * b.den + a.den * b.num ; den = a.den * b.den } let mul a b = { num = a.num * b.num ; den = a.den * b.den } let neg a = { num = a.num * -1 ; den = a.den } let inv a = { num = a.den ; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = if a then (not b) else b let mul a b = ( a && b ) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let move_to (state : MazeGen.state) (dir : MazeGen.dir) (next_dir : MazeGen.dir) : MazeGen.state = let open MazeGen in let x, y, _ = state in match dir with | North -> (x, y - 1, next_dir) | South -> (x, y + 1, next_dir) | West -> (x - 1, y, next_dir) | East -> (x + 1, y, next_dir) in  let rec solve (maze : MazeGen.maze) (state : MazeGen.state) (succ : MazeGen.dir list -> MazeGen.dir list) (fail : unit -> MazeGen.dir list) : MazeGen.dir list = let (x, y, facing) = state in if x = 0 && y = 0 then else if MazeGen.has_wall maze state then fail () else let (right, fwd, left) = MazeGen.dirs_to_check facing in solve maze (move_to state facing right) (fun lst -> succ (facing :: lst)) (fun () -> solve maze (move_to state facing fwd) (fun lst -> succ (facing :: lst)) (fun () -> solve maze (move_to state facing left) (fun lst -> succ (facing :: lst)) fail ) ) in let (w, h) = MazeGen.dims maze in solve maze (w - 1, h - 1, MazeGen.North) (fun lst -> lst) (fun () -> solve maze (w - 1, h - 1, MazeGen.West) (fun lst -> lst) (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> let node1, node2 = seq1 (), seq2 () in match node1, node2 with | Nil, _ -> Nil | _, Nil -> Nil | Cons(hd1, tl1), Cons(hd2, tl2) -> Cons((hd1, hd2), zip tl1 tl2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> let node = seq () in match node with | Nil -> Nil | Cons(hd, _) when p hd -> Nil | Cons(hd, tl) -> Cons(hd, keep_until p tl) let to_list (seq : 'a seq) : 'a list = let rec to_list' seq acc = let node = seq () in match node with | Nil -> acc | Cons(hd, tl) -> to_list' tl (acc @ [hd]) in to_list' seq [] let range (start : int) (step : int) (stop : int) : int seq = let nats_mapped = map (fun int -> start + int * step) nats in keep_until (fun int -> if step >= 0 then int >= stop else int <= stop ) nats_mapped end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1} let one  = { num = 1; den = 1}  let add x y = { num = x.num * y.den + y.num * x.den ; den = x.den * y.den }  let mul x y : t = { num = x.num * y.num; den = x.den * y.den }  let neg x = { num = -x.num; den = x.den }  let inv x = { num = x.den; den = x.num }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add a b = (a || b) && not (a && b)  let mul = (&&)  let neg x = x  let inv x = x let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec aux (x,y,d) sc fc = if (x,y) = (0,0) then sc [] else let rec try_dirs d_list = match d_list with | [] -> fc () | dir::dirs -> let new_state = match dir with | MazeGen.North -> (x, y-1, dir) | MazeGen.South -> (x, y+1, dir) | MazeGen.East -> (x+1, y, dir) | MazeGen.West -> (x-1, y, dir) in aux new_state (fun path -> sc (dir::path)) (fun () -> try_dirs dirs) in let a,b,c = MazeGen.dirs_to_check d in try_dirs (List.filter (fun dir -> not (MazeGen.has_wall maze (x,y,dir))) [a;b;c]) in let width, height = MazeGen.dims maze in aux (width-1, height-1, MazeGen.North) (fun x -> x) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1() with | Nil -> empty | Cons(x,xs) -> match seq2() with | Nil -> empty | Cons(y,ys) -> fun () -> Cons((x,y), zip xs ys) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(x,xs) -> if p x then empty else fun () -> Cons(x, keep_until p xs) let to_list (seq : 'a seq) : 'a list = List.rev (fold_left (fun lst x -> x::lst) [] seq) let range (start : int) (step : int) (stop : int) : int seq = if start <> stop && step*(stop-start) <= 0 then raise (Invalid_argument \"Range sequence is unbounded.\") else keep_until (fun r -> step*r >= step*stop) (map (fun n -> n*step+start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let equal a b = (a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den) let zero = {num=0; den=1} let one = {num=1; den=1} let add x y = {num=x.num*y.den + y.num*x.den; den=x.den*y.den} let mul x y = {num=x.num*y.num; den=x.den*y.den} let neg x = {num=(-x.num); den=x.den} let inv x = {num=x.den; den=x.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) let zero = false let one = true let add = (<>) let mul = (&&) let neg x = x let inv x = x end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let nextCell_helper state = let (x_coord, y_coord, direction) = state in match direction with | MazeGen.East -> (x_coord + 1, y_coord) | MazeGen.North -> (x_coord, y_coord - 1) | MazeGen.West -> (x_coord - 1, y_coord) | MazeGen.South -> (x_coord, y_coord + 1) in let rec maze_solver_HELPER x_position y_position cardinal_direction fail_cont succ_cont = match (x_position, y_position) with | (0,0) -> succ_cont [] | _ ->  let (first_check_dir, second_check_dir, third_check_dir) = MazeGen.dirs_to_check cardinal_direction in if ( not ( MazeGen.has_wall maze (x_position,y_position,first_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,first_check_dir) ) in maze_solver_HELPER next_x_position next_y_position first_check_dir ( fun () -> if( not ( MazeGen.has_wall maze (x_position,y_position,second_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,second_check_dir) ) in maze_solver_HELPER next_x_position next_y_position second_check_dir ( fun () -> if( not ( MazeGen.has_wall maze (x_position,y_position,third_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,third_check_dir) ) in maze_solver_HELPER next_x_position next_y_position third_check_dir fail_cont (fun er -> succ_cont (third_check_dir :: er))  else fail_cont () ) (fun er -> succ_cont (second_check_dir :: er))  else if( not ( MazeGen.has_wall maze (x_position,y_position,third_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,third_check_dir) ) in maze_solver_HELPER next_x_position next_y_position third_check_dir fail_cont (fun er -> succ_cont (third_check_dir :: er))  else fail_cont ()  ) (fun er -> succ_cont (first_check_dir :: er))  else if( not ( MazeGen.has_wall maze (x_position,y_position,second_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,second_check_dir) ) in maze_solver_HELPER next_x_position next_y_position second_check_dir ( fun () -> if( not ( MazeGen.has_wall maze (x_position,y_position,third_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,third_check_dir) ) in maze_solver_HELPER next_x_position next_y_position third_check_dir fail_cont (fun er -> succ_cont (third_check_dir :: er))  else fail_cont () ) (fun er -> succ_cont (second_check_dir :: er))  else if( not ( MazeGen.has_wall maze (x_position,y_position,third_check_dir) ) ) then let ( next_x_position, next_y_position) = ( nextCell_helper (x_position,y_position,third_check_dir) ) in maze_solver_HELPER next_x_position next_y_position third_check_dir fail_cont (fun er -> succ_cont (third_check_dir :: er))  else fail_cont ()  in let (maze_width,maze_height)= MazeGen.dims maze in maze_solver_HELPER (maze_width - 1) (maze_height - 1) (MazeGen.North) (fun () -> []) (fun el -> el)   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 () ) with | ( Nil, Nil ) | ( Nil, _  ) | (_, Nil ) -> ( fun () -> ( Nil ) ) | ( Cons (hd_x,tail_x), Cons (hd_y,tail_y) ) -> ( fun () -> Cons ( (hd_x , hd_y), (zip ( tail_x ) ( tail_y )) ) )  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match (seq ()) with | ( Nil) -> ( fun () -> ( Nil ) ) | ( Cons (hd_x,tail_x) ) -> if ( p hd_x ) then ( fun () -> ( Nil ) ) else ( fun () ->  Cons (hd_x, (keep_until p tail_x) ) )   let to_list (seq : 'a seq) : 'a list = let rec helperFunction acc pass_seq = match (pass_seq ()) with | ( Nil ) -> acc | ( Cons (hd_x,tail_x) ) -> helperFunction ( acc @ [hd_x] ) tail_x in helperFunction [] seq    let range (start : int) (step : int) (stop : int) : int seq = if start = stop then ( fun () -> ( Nil ) ) else if ( (step = 0) ||  ( start > stop && step > 0 ) || (start < stop && step < 0 ) ) then raise (Invalid_argument \"Given the inputted parameters, the stop value will never be reached or passed as step diverges from the stop value given the start value, instead of converging toward the stop value\") else keep_until ( fun x -> if step > 0 then x >= stop else x <= stop)  ( Seq.map (fun x -> start + step*(x) ) nats ) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1; } let one = { num = 1; den = 1; } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add = ( fun x y -> { num = (x.num * y.den) + (y.num * x.den) ; den = (x.den * y.den); } ) let mul = ( fun x y -> { num =  (x.num * y.num); den = (x.den * y.den); } ) let neg = ( fun x -> { num =  (-1 * x.num ); den = (x.den ); } ) let inv = ( fun x -> { num =  x.den ; den = x.num ; } ) end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool   let zero = false let one = true let equal = (=)  let add = ( fun x y -> if x && y  then false else x || y ) let mul = ( && ) let neg = ( fun x -> x ) let inv = ( fun x ->  x  )  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = (MazeGen.dims maze) in let curstate = ((width-1), (height-1), MazeGen.North) in let nextcell (state : MazeGen.state) (dir : MazeGen.dir) : MazeGen.state = match dir with | MazeGen.East -> let (curx, cury, _) = state in ((curx+1), cury, MazeGen.East) | MazeGen.North -> let (curx, cury, _) = state in (curx, (cury-1), MazeGen.North) | MazeGen.West -> let (curx, cury, _) = state in ((curx-1), cury, MazeGen.West) | MazeGen.South -> let (curx, cury, _) = state in (curx, (cury+1), MazeGen.South) in let rec recurse (state : MazeGen.state) fc sc : MazeGen.dir list = match state with |(0, 0, _) -> (sc []) |(curx, cury, dir) -> let (dir1, dir2, dir3) = MazeGen.dirs_to_check(dir) in let (bool1, bool2, bool3) = ((MazeGen.has_wall maze (curx, cury, dir1) ),(MazeGen.has_wall maze (curx, cury, dir2)),(MazeGen.has_wall maze (curx, cury, dir3))) in match (bool1, bool2, bool3) with | (true, true, true) -> (fc ())  | (false, true, true) -> recurse (nextcell state dir1) fc (fun el -> sc (dir1::el)) | (true, false, true) -> recurse (nextcell state dir2) fc (fun el -> sc (dir2::el)) | (true, true, false) -> recurse (nextcell state dir3) fc (fun el -> sc (dir3::el)) | (true, false, false) -> recurse (nextcell state dir2) (fun () -> recurse (nextcell state dir3) fc (fun el -> sc (dir3::el))) (fun el -> sc (dir2::el)) | (false, true, false) -> recurse (nextcell state dir1) (fun () -> recurse (nextcell state dir3) fc (fun el -> sc (dir3::el))) (fun el -> sc (dir1::el)) | (false, false, true) -> recurse (nextcell state dir1) (fun () -> recurse (nextcell state dir2) fc (fun el -> sc (dir2::el))) (fun el -> sc (dir1::el))  | (false, false, false) -> recurse (nextcell state dir1) (fun () -> recurse (nextcell state dir2) (fun () -> recurse (nextcell state dir3) fc (fun el -> sc (dir3::el))) (fun el -> sc (dir2::el)) ) (fun el -> sc (dir1::el))  in recurse curstate (fun () -> raise NotFound) (fun x -> x) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = if (seq1 () = Nil || seq2 () = Nil) then (fun () -> Nil) else let Cons(a,seq1b) = seq1 () in let Cons(b,seq2b) = seq2 () in (fun () -> Cons( (a,b), (zip seq1b seq2b))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = if ( seq () <> Nil) then let Cons(a,b) = seq () in if (p a) then (fun () -> Nil) else (fun () -> Cons(a, keep_until p b)) else (fun () -> Nil) let to_list (seq : 'a seq) : 'a list = let rec listgen (seq : 'a seq) (acc : 'a list) : 'a list = match seq () with | Nil -> acc | Cons(a,b) -> listgen b (acc@[a]) in listgen seq [] let range (start : int) (step : int) (stop : int) : int seq = match start,step,stop with |_,0,_ -> raise (Invalid_argument \"step size is 0\") |a,b,c -> if (a < c && b < 0) then raise (Invalid_argument \"start < stop and step is negative; infinite\") else if (a > c && step > 0) then raise (Invalid_argument \"start > stop and step is positive; infinite\") else let stepseq = (map (fun x -> a + x*b) nats ) in if (a > c) then keep_until (fun x -> x <= c) stepseq else keep_until (fun x -> x >= c) stepseq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add a b = {num = ((a.num*b.den)+(b.num*a.den)); den = (a.den*b.den) } let mul a b = {num = (a.num*b.num); den = (a.den*b.den)} let neg a = {num = (a.num * -1); den = a.den} let inv a = {num = a.den; den = a.num }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = not (a = b) let mul a b = (a && b) let neg a = (a) let inv a = (a)  let equal = (=) end ;; ",
  "open MazeGen  let nextCell (state: MazeGen.state) : MazeGen.state = let (x,y,direction)  =state in  match state with |(_,_,West) -> (x-1,y,West) |(_,_,North) ->  (x,y-1,North) |(_,_,East) ->  (x+1,y,East) |(_,_,South) ->  (x,y+1,South)   ;; ",
  " let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let rec solve_maze_rec maze  state sc fc = let (width,height) = MazeGen.dims maze in  let x,y,direction =  state in if x==0 && y==0 then sc([])  else if MazeGen.has_wall maze state then fc ()  else  let (first,second,third) = MazeGen.dirs_to_check (direction) in  let nextX,nextY,newdir = nextCell state in  solve_maze_rec (maze) ( (nextX,nextY,first)) (fun r -> sc (direction::r)) ( fun () -> solve_maze_rec (maze) ( (nextX,nextY,second)) (fun r -> sc (direction::r)) ( fun () -> solve_maze_rec (maze) ( (nextX,nextY,third)) (fun r -> sc (direction::r)) (fc)  ) )   in solve_maze_rec maze (width-1,height-1,North) (fun r -> r)  (fun () -> solve_maze_rec maze (width-1,height-1,West) (fun r -> r) ( fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq   let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq =  let rec zipper s t = fun () -> match s () , t()  with |  Cons (x,s'),  Cons (y,t') -> Cons ((x,y), (zipper s' t' ) ) |_ -> Nil  in zipper seq1 seq2 ;; ",
  " let keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq =  let rec recurse p s= fun () -> match s () with |Cons (x,xs) -> if p x then Nil else Cons (x, recurse p xs) |_-> Nil in recurse p seq  ;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec listbuilder sequence= match sequence () with |Nil -> [] |Cons (h,tl) -> h::(listbuilder tl) in listbuilder seq  ;; ",
  "let hd (Cons (x,_)) = x;; ",
  "let range (start : int) (step : int) (stop : int) : int seq =     let shiftedStart = map (fun el-> el+start-step) nats in  let rec recurse curr stream= fun () -> match stream () with |Cons (x,xs) -> Cons (curr+step, recurse (curr+step) xs) |_-> Nil in if step = 0 then raise (Invalid_argument (\"wrong name\")) else let rangedList = recurse (hd (shiftedStart())) shiftedStart in  keep_until (fun el -> if step>0 then el>=(stop) else if step<0 then el<=(stop) else true ) rangedList ;; ",
  "end ;; ",
  "let sequence = Range.range 10 1 20 ;; ",
  "let sequence2 = Range.range 32 (-2) 0 ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let one = {num = 1;den = 1} let zero = {num = 0; den = 1} let add a b= let denominator = a.den * b.den in if denominator = 0 then raise DivideByZero else  { num=(a.num*b.den + b.num * a.den)  ;den=denominator}   let mul a b = if a.den*b.den = 0 then raise DivideByZero else  {num = (a.num * b.num); den = a.den*b.den} let neg a = let negation = (-1)*a.num in if a.den = 0 then raise DivideByZero else {num = negation;den = a.den}  let inv a =  if a.num = 0 then raise DivideByZero else {num = a.den;den = a.num}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b= a && not b let mul a b = a && b let neg a =  a let inv a =  a  let equal = (=)  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w,h) = MazeGen.dims maze in let d1 = MazeGen.North in if w = 1 && h=1 then [] else let move (state:MazeGen.state)= let (x,y,d) = state in match d with |MazeGen.North -> (x,y-1,d) |MazeGen.South-> (x,y+1,d) |MazeGen.East-> (x+1,y,d) |MazeGen.West-> (x-1, y,d) in let rec result state sc fc = let (x,y,d) = state in let (r, s, l) = MazeGen.dirs_to_check d in let s1 = (x, y, r) in let s2 = (x, y, s) in let s3 = (x, y, l) in if x = 0 && y = 0 then sc [] else let l = fun () -> if not (MazeGen.has_wall maze s3) then result (move(s3)) (fun x -> sc (l::x)) fc else fc () in let s = fun () -> if not (MazeGen.has_wall maze s2) then result  (move(s2)) (fun x -> sc (s::x)) l else l () in if not (MazeGen.has_wall maze s1) then result (move(s1)) (fun x -> sc (r::x)) s else s () in result (w -1,h-1,d1) (fun y-> y) (fun ()->[]) ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Nil,_ |_,Nil ->fun () -> Nil |Cons(x,xs), Cons(y, ys )->fun ()-> Cons((x,y), zip (xs) (ys)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Nil -> fun () -> Nil |Cons(x,_)  when p x-> fun ()-> Nil |Cons(x,xs) -> fun ()-> Cons(x,keep_until p xs)  let to_list (seq : 'a seq) : 'a list = match seq () with |Nil ->[] |Cons(x,y)->Seq.fold_left (fun x y -> x @ [y]) [x] y let range (start : int) (step : int) (stop : int) : int seq = keep_until (fun x -> if step > 0 then x >= stop else x <= stop )(Seq.map (fun x -> x + start) (Seq.map ( fun x-> x * step) nats)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num =0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let mul a b = {num = a.num * b.num;den = a.den * b.den} let add a b = {num = a.num*b.den + a.den * b.num; den = a.den * b.den} let neg a ={num = -1 * a.num; den = a.den} let inv a = if equal a zero then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = if  a && b then false else a || b let mul = (&&) let inv a = a let neg a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq): ('a * 'b) seq =  match seq1(),seq2() with |Nil,_ |_,Nil-> fun ()->Nil | Cons (hd1, a'), Cons (hd2, b') -> fun()->Cons ((hd1,hd2), zip a' b' ) ;; ",
  "  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Cons(h,t) -> then fun()->Nil else fun()->Cons (h,keep_until p t) |Nil->fun()->Nil  let to_list (seq : 'a seq) : 'a list = let rec build seq sc = match seq() with |Nil-> sc ([]) |Cons(h,t)-> build t (fun r->sc (h::r)) in build seq (fun r->r)   let range (start : int) (step : int) (stop : int) : int seq = let helper_range (start0 : int) (step0 : int) (stop0 : int) : int  = let bol0 = (step0 = 0)in let bol1 = (start0 < 0) in let bol2 = (step0 <0) in let bol3 = (stop0 <0 ) in let bol4 = (start0<stop0) in match  (bol0,bol1,bol2,bol3,bol4) with |(true,_,_,_,_)-> 1 |(false,true,true,true,false) |(false,false,false,false,true) | (false,false,true,false,false) |(false,true,false,false,true)| (false,false,true,true,false)->0 |(_,_,_,_,_)->  1 in let result = helper_range start step stop in let my_seq0 = map (fun x-> (start) +(x) *(step) ) nats in let check_2 x = if (x >= 0 && (stop) >= 0 ) then  (x <= stop) else if (x>= 0 && (stop)<=0 ) then ((x)  <=stop) else if (x<=0 && stop >=0 ) then (x>=stop) else (x<=stop) in match result with |1-> raise (Invalid_argument \" no such seq can build \") |_-> keep_until (check_2) my_seq0  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num =0;den=1} let one = {num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num=(a.num * b.den +b.num * a.den);den=(a.den * b.den)} let mul a b = {num=(a.num*b.num);den=(a.den * b.den)} let neg a = {num= -a.num;den=a.den} let inv a = {num=a.den;den=a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = not zero let equal  = (=) let add a b = if(a=b) then false else not (a=b) let mul a b = match (a,b) with |(true,true)-> true |(_,_)->false let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec solve_maze_helper (maze : MazeGen.maze) state sc fc = match state with |(0,0,_) -> sc [] |(x,y,dir) -> let move state dir = match (state,dir) with |((x,y,_),MazeGen.West) -> (x-1,y,MazeGen.West) |((x,y,_),MazeGen.East) -> (x+1,y,MazeGen.East) |((x,y,_),MazeGen.North) -> (x,y-1,MazeGen.North) |((x,y,_),MazeGen.South) -> (x,y+1,MazeGen.South) in let (dir1,dir2,dir3) = MazeGen.dirs_to_check dir in match (MazeGen.has_wall maze (x,y,dir1),MazeGen.has_wall maze (x,y,dir2),MazeGen.has_wall maze (x,y,dir3)) with |(true,true,true) -> fc () |(false,true,true) -> solve_maze_helper maze (move state dir1) (fun r -> sc (dir1 :: r)) fc |(true,false,true) -> solve_maze_helper maze (move state dir2) (fun r -> sc (dir2 :: r)) fc |(true,true,false) -> solve_maze_helper maze (move state dir3) (fun r -> sc (dir3 :: r)) fc |(false,false,true) -> solve_maze_helper maze (move state dir1) (fun r -> sc (dir1 :: r)) (fun () -> solve_maze_helper maze (move state dir2) (fun r -> sc (dir2 :: r)) fc) |(false,true,false) -> solve_maze_helper maze (move state dir1) (fun r -> sc (dir1 :: r)) (fun () -> solve_maze_helper maze (move state dir3) (fun r -> sc (dir3 :: r)) fc) |(true,false,false) -> solve_maze_helper maze (move state dir2) (fun r -> sc (dir2 :: r)) (fun () -> solve_maze_helper maze (move state dir3) (fun r -> sc (dir3 :: r)) fc) |(false,false,false) -> solve_maze_helper maze (move state dir1) (fun r -> sc (dir1 :: r)) (fun () -> solve_maze_helper maze (move state dir2) (fun r -> sc (dir2 :: r)) (fun () -> solve_maze_helper maze (move state dir3) (fun r -> sc (dir3 :: r)) fc)) in let (w,h) = MazeGen.dims maze in solve_maze_helper maze (w-1,h-1,MazeGen.North) (fun r -> r) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (),seq2 ()) with |(Cons(a,t),Cons(b,h)) -> (fun () -> Cons((a,b),zip t h)) |(_,_) -> (fun () -> Nil) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Cons(a,t) -> if p a then (fun () -> Nil) else (fun () -> Cons(a,keep_until p t)) |Nil -> (fun () -> Nil) let to_list (seq : 'a seq) : 'a list = let rec to_list_helper (seq : 'a seq) acc = match seq () with |Nil -> acc |(Cons(a,t)) -> to_list_helper t (acc @ [a]) in to_list_helper seq [] let range (start : int) (step : int) (stop : int) : int seq = if start >= stop then raise (Invalid_argument \"Stop should be greater than start.\") else let seq = keep_until (fun n -> (start + (n * step))>= stop) nats in map (fun n -> (n * step + start)) seq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = (a.num * b.den) + (a.den * b.num); den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = 0 - a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = match (a,b) with |(false,false) -> false |(true,true) -> false |(_,_) -> true  let mul a b = match (a,b) with |(true,true) -> true |(_,_) -> false  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = raise NotImplemented ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with |Nil,_|_,Nil -> fun() -> Nil |Cons(x, xs), Cons(y, ys) -> fun() -> Cons((x,y), (zip xs ys))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with |Nil -> fun() -> Nil |Cons(x,xs)-> if p x then fun()->Nil else fun() -> Cons(x, (keep_until p xs)) let to_list (seq : 'a seq) : 'a list = let rec tolist (x: 'a seq) = match x() with |Nil->[] |Cons(x,xs) -> x::(tolist xs) in tolist seq let range (start : int) (step : int) (stop : int) : int seq = let seq = Seq.map (fun x -> x*step + start ) (nats) in if start > 0 && step <0 then let f= (fun x-> x<=stop)in (keep_until (f) (seq)) else  let f= (fun x-> x>=stop) in (keep_until (f) (seq)) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let mul x y = {num= (x.num*y.num) ; den= (x.den*y.den)} let neg x = {num=x.num; den= -x.den} let inv x = {num=x.den; den=x.num} let zero = {num=0; den=1} let one = {num =1;den =1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add x y = {num= (x.num*y.den) + (y.num*x.den); den= (x.den*y.den)}   end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero=false let one=true let inv a = a let neg a = a let mul = (&&) let add a b = if a && b then false else (a || b) let equal = (=)  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let update_cell (state: MazeGen.state) : MazeGen.state  * MazeGen.state  =  let helper (state: MazeGen.state) : MazeGen.state = let (x,y,dir) = state in if dir = MazeGen.West then (x-1 , y, dir) else if dir = MazeGen.North then (x, y-1 , dir) else if dir = MazeGen.East then (x+1, y, dir) else let state =  (x, y+1 , dir) in state in  let (x, y, dir) = state in let (dir1, dir2, dir3) = MazeGen.dirs_to_check dir in if  not ( MazeGen.has_wall (maze) ( (x,y,dir1) )  ||  MazeGen.has_wall (maze) ((x,y,dir2)) ) then ( ((helper ((x,y,dir1)) ) ), ( (helper ( (x,y, dir2) ) ) ) )  else if not  ( MazeGen.has_wall (maze) ( (x,y,dir1) ) ) && not (MazeGen.has_wall (maze) ((x,y,dir3))) then ( ((helper ((x,y,dir1)) ) ), ( (helper ((x,y, dir3) ) ) ) )  else if not  ( MazeGen.has_wall (maze) ((x,y,dir2)) ) && not (MazeGen.has_wall (maze) ((x,y,dir3))) then ( (helper ((x,y,dir2)) ) , ( (helper ((x,y, dir3)) ) ) )  else if not ( MazeGen.has_wall (maze) ((x,y,dir1)) ) then (  (helper ((x,y,dir1)) ) , (-1, -1 , MazeGen.South) )  else if not ( MazeGen.has_wall (maze) ((x,y,dir2)) ) then (  (helper ((x,y,dir2)) ) , (-1,-1, MazeGen.South) ) else if not ( MazeGen.has_wall (maze) ((x,y,dir3)) ) then (  (helper ((x,y,dir3)) ) , (-1,-1,MazeGen.South) )  else ((-1,-1,MazeGen.South), (-1,-1,MazeGen.South)) in     let rec findPath (state:MazeGen.state) fail succeed path =    match state with | (-1,-1,_) -> fail () | (0,0,_) -> succeed path | (x, y, dir) -> let (s1, s2) = update_cell  (x,y,dir) in  let (_,_,dir1) = s1 in let (_, _ , dir2) = s2 in  findPath (s1) (fun () -> findPath (s2) (fail) (succeed) (dir2 :: path) ) (succeed) (dir1:: (path )) in   let dims = MazeGen.dims maze in let (x,y) = dims in let init = (x-1 , y-1 , MazeGen.North) in let list = findPath (init) (fun () -> raise NotFound ) (fun x -> x) ([]) in List.rev list   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq    let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () , seq2 () with | Nil , _ -> fun () -> Nil | _ , Nil -> fun () -> Nil |Cons(v1, s1) , Cons(v2,s2) ->  fun () -> Cons((v1,v2) , zip(s1) (s2) ) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with |Cons(v , s) -> if  p v then (fun () -> Nil ) else fun () -> Cons(v , keep_until (p) (s) ) |Nil -> empty  let to_list (seq : 'a seq) : 'a list =  let rec list' seq'  = match seq' () with | Nil -> [] | Cons(v,s) -> v :: list' (s) in list' seq  let range (start : int) (step : int) (stop : int) : int seq =  if start > stop && step >= 0 then raise (Invalid_argument \"Arguments will result in an infinite sequence\") else if start < stop && step <=0 then raise (Invalid_argument \"Arguments will result in an infinite sequence\")  else  let adder = ref start in  let mapper input = let output = input + !adder in adder := !adder + step - 1; output in  let seq' = map mapper nats in  let p cur_val = if step > 0 then cur_val >= stop else cur_val <= stop in  keep_until (p) (seq')  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0 ; den = 1}  let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den   let add a b = if a.den = 0 || b.den = 0 then raise DivideByZero else  let normalize rat = if rat.num = 0 then zero else if rat.num = rat.den then one else rat in  let a' = normalize a in let b' = normalize b in  let a1 = a'.num in let b1 = b'.num in let a2 = a'.den in let b2 = b'.den in let num' = ( ( a1 * b2 ) + (a2 * b1) ) in let den' = a2 * b2 in let c' = {num = num' ; den = den' } in normalize c'   let mul a b = if a.den = 0 || b.den = 0 then raise DivideByZero else   let normalize rat = if rat.num = 0 then zero else if rat.num = rat.den then one  else rat in  let a' = normalize a in let b' = normalize b in let a1 = a'.num in let b1 = b'.num in let a2 = a'.den in let b2 = b'.den in let num' = a1 * b1 in let den' = a2 * b2 in let c'  = { num = num' ; den = den' } in normalize c'   let neg a = let a'  = {num = -1 * a.num ; den = a.den} in a' let inv a = let a' = {num = a.den ; den = a.num } in a'      end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool  let one = true let zero = false let equal = (=)  let add a b = (a || b) && not (a && b)   let mul = ( && )  let neg a = if a = zero then zero else one let inv a = if a = one then one else zero  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (r0,f0,l0) = MazeGen.dirs_to_check MazeGen.North in let (w,h) = MazeGen.dims maze in let (x,y) = (w-1,h-1) in  let next_state (x1,y1,d) = match d with | MazeGen.West -> (x1-1,y1,d) | MazeGen.East -> (x1+1,y1,d) | MazeGen.South -> (x1,y1+1,d) in  let rec solve cur_state sc fc = let (x,y,d) = next_state cur_state in let (r,f,l) = MazeGen.dirs_to_check d in   match MazeGen.has_wall maze cur_state with if x=0 && y=0 then sc (d::[]) else let sc1 = fun r -> sc (d::r) in let fc1 = fun () -> solve (x,y,f) (fun r -> sc (d::r)) in  in let sc0 = fun r -> r in let fc0 = fun() -> [] in  let fc1 = fun() -> solve (x,y,f0) sc0 (fun () -> solve (x,y,l0) sc0 fc0) in solve (x,y,r0) sc0 fc1      ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq =  match seq1 (),seq2 () with | Nil, _ -> empty | _, Nil -> empty | Cons (x, a'), Cons (y, b') -> fun () -> Cons((x,y),zip a' b')   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (x,a') -> if p x then fun() -> Nil else fun()-> Cons(x, keep_until p a')   let to_list (seq : 'a seq) : 'a list =  match seq () with | Nil -> [] | Cons(x,a') -> let list = ref [] in let ini_f a = list := !list @ [a] in iter (ini_f) seq ; !list    let range (start : int) (step : int) (stop : int) : int seq =  let new_seq = map (fun x -> x*step+start) nats in if step < 0 then keep_until (fun r -> r <= stop) new_seq else if step > 0 then keep_until (fun r-> r>=stop) new_seq else raise (Invalid_argument(\"step cannot be 0\")) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1; } let one = { num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if a.den = 0 || b.den = 0 then raise DivideByZero else let common_mul = a.den * b.den in { num = a.num *b. den + b.num * a.den; den = common_mul } let mul a b = if a.den = 0 || b.den = 0 then raise DivideByZero else {num = a.num * b.num; den = a.den * b.den } let neg a = if a.den = 0 then raise DivideByZero else {num = a.num * (-1); den = a.den}  let inv a = if a.den = 0 || a.num=0 then raise DivideByZero else {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add a b = if a  && b then false else a||b  let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let test width height = let maze = MazeGen.random width height in print_string (MazeGen.string_of_maze maze) ; maze module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons (h1, t1), Cons (h2, t2) -> Cons ((h1, h2), zip t1 t2) | _, _ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Cons (h, t) -> if p h then Nil else Cons (h, keep_until p t) | Nil -> Nil let to_list (seq : 'a seq) : 'a list = fold_left (fun l h -> l @ [h]) [] seq let range (start : int) (step : int) (stop : int) : int seq = if step = 0 || (step < 0 && stop > start) || (step > 0 && stop < start) then raise (Invalid_argument \"argument invalid\") else keep_until (fun x -> if step < 0 then x <= stop else x >= stop) (map (fun x -> start + x * step) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den}  let neg a = {num = -a.num; den = a.den} let inv a = {num = a.den; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let equal = (=)  let add = (<>) let mul = (&&)  let neg a = a let inv a = a  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let next_move (x,y,d) = match d with |MazeGen.North -> (x,y-1) |MazeGen.West -> (x-1,y) |MazeGen.East -> (x+1,y) |MazeGen.South -> (x,y+1) in  let rec findway (x,y,d) fail succ = if (x,y) = (0,0) then succ [] else if ( MazeGen.has_wall maze (x,y,d)) then fail () else let (right,forward,left) = MazeGen.dirs_to_check d in let (x',y') = next_move (x,y,d) in findway (x',y',right) (fun () -> findway (x',y',forward) (fun () -> findway (x',y',left) fail (fun directions -> succ (left::directions))) (fun directions -> succ (forward::directions))) (fun directions -> succ (right::directions)) in  let (width,height) = MazeGen.dims maze in let (right,forward,left) = MazeGen.dirs_to_check MazeGen.North in let (x',y') = next_move (width-1,height-1,MazeGen.North) in let _::t = List.rev ( findway(width-1, height-1, MazeGen.North) (fun () -> findway(width-1, height-1, MazeGen.West) (fun () -> raise NotFound) (fun directions -> MazeGen.West::directions) ) (fun directions -> MazeGen.North::directions) ) in List.rev t ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = raise NotImplemented let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = raise NotImplemented let to_list (seq : 'a seq) : 'a list = raise NotImplemented let range (start : int) (step : int) (stop : int) : int seq = raise NotImplemented end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct  type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num*b.den + b.num*a.den; den = a.den*b.den} let mul a b =  {num = a.num*b.num; den = a.den*b.den} let neg x =  {num = 0-x.num; den = x.den} let inv x =  {num = x.den; den = x.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = (a || b) && (not (a && b)) let mul a b = a && b let equal = (=) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let move state = let (x,y,d) = state in match d with | MazeGen.East -> (x+1,y,d) | MazeGen.North -> (x,y-1,d) | MazeGen.West -> (x-1,y,d) | MazeGen.South -> (x,y+1,d) in let rec aux_solve state sc fail = if MazeGen.has_wall maze state then fail else let (x,y,d) = move state in if( x=0 && y=0 )then sc [d] else let (a,b,c) = MazeGen.dirs_to_check d in aux_solve (x,y,a) (fun r -> (sc [d])@r) ( aux_solve (x,y,b) (fun r -> (sc [d])@r) ( aux_solve (x,y,c) (fun r -> (sc [d])@r) ( fail ) ) )in let (init_x,init_y) = MazeGen.dims maze in aux_solve (init_x-1,init_y-1,MazeGen.North) (fun r->r) (aux_solve (init_x-1,init_y-1,MazeGen.West) (fun r->r) [MazeGen.East]) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 () with | Nil -> Nil | Cons (a1, s1') -> match seq2 () with | Nil -> Nil | Cons (a2, s2') -> Cons ((a1,a2),zip s1' s2') let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (a, s') -> if p a then Nil else Cons (a, keep_until p s') let to_list (seq : 'a seq) : 'a list = let rec aux_list s = match s () with | Nil -> [] | Cons (v, s') -> v :: aux_list  s' in aux_list seq  let range (start : int) (step : int) (stop : int) : int seq = let bool_func x = if step<0 then ((x) * step) + start <= stop else ((x) * step) + start >= stop in map (fun r -> (r * step) + start) (keep_until bool_func nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num=0;den=1} let one = {num=1;den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = (a.num*b.den) + (a.den*b.num); den = a.den*b.den} let mul a b = {num = a.num*b.num;den = a.den*b.den} let neg a = {num = 0-a.num;den = a.den} let inv a = {num = a.den;den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = (a || b) && (not (a && b)) let mul a b = a && b let neg a = a let inv a = a end ;; ",
  "let get_next_state (s : MazeGen.state) = let (x, y, dir) = s in match dir with | West -> (x - 1, y) | North -> (x, y - 1) | East -> (x + 1, y) | South -> (x, y + 1) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let rec traverse (maze : MazeGen.maze) (s : MazeGen.state) (l : MazeGen.dir list) succ fail = let (x, y, dir) = s in if x = 0 & y = 0 then succ l else if MazeGen.has_wall maze s then fail () else let (x2, y2) = get_next_state s in let (dir1, dir2, dir3) = MazeGen.dirs_to_check dir in traverse maze (x2, y2, dir1) (l @ [dir]) succ (fun() -> traverse maze (x2, y2, dir2) (l @ [dir]) succ (fun () -> traverse maze (x2, y2, dir3) (l @ [dir]) succ fail)) in let (startX, startY) = MazeGen.dims maze in traverse maze (startX - 1, startY - 1, North) [] (fun v -> v) (fun () -> traverse maze (startX - 1, startY - 1, West) [] (fun v -> v) (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 () with | Nil -> Seq.empty | Cons(el, f) -> let el1,f1 = el,f in match seq2 () with | Nil -> Seq.empty | Cons(el, f) -> let el2,f2 = el,f in fun () -> Seq.Cons((el1, el2), (zip f1 f2))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> Seq.empty | Cons(el, f) -> if p el then Seq.empty else fun () -> Seq.Cons(el, keep_until p f) let to_list (seq : 'a seq) : 'a list = let rec aux (seqp : 'a seq) (l : 'a list) = match seqp () with | Nil -> l | Cons(el, f) -> aux f (l @ [el]) in aux seq [] let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument (\"Step cannot be 0\")) else if step < 0 & start < stop then raise (Invalid_argument (\"Invalid arguments\")) else if step > 0 & start > stop then raise (Invalid_argument (\"Invalid arguments\")) else let f = fun x -> start + (x * step) in let seq_ = map f nats in keep_until (fun y -> if step > 0 then y >= stop else y <= stop) (seq_) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = ((a.num*b.den) + (a.den*b.num)); den = (a.den*b.den)} let mul a b = {num = (a.num*b.num); den = (a.den*b.den)}  let neg a = {num = (-1 * a.num); den = (a.den)} let inv a = if a.num = 0 then {num=0;den=1} else {num=a.den;den=a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add a b = match a,b with | true, true -> false | false, true -> true | true, false -> true | false, false -> false let mul a b = match a,b with | true, false -> false | true, true -> true | false, true -> false | false, false -> false  let neg a = match a with | true -> true | false -> false  let inv a = match a with | true -> true | false -> false end ;; ",
  " let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let acc = [] in let w = let r = MazeGen.dims maze in let (w,h) = r in w in let h = let r = MazeGen.dims maze in let (w,h) = r in h in in let (w,h,car) = (w -1, h -1, car) in let next_dir (maze : MazeGen.maze) state: MazeGen.dir option = let (w, h, car) = state in let (r,f,l) = MazeGen.dirs_to_check car in if MazeGen.has_wall maze (w,h,r) then if MazeGen.has_wall maze (w,h,f) then if MazeGen.has_wall maze (w,h,l) then else else else in let next_cell (maze : MazeGen.maze) (w,h,car) : MazeGen.state = match car with  in let is_dead_end maze x y (a,b,c) : bool= (MazeGen.has_wall maze (x, y, a)) && (MazeGen.has_wall maze (x, y, b)) && (MazeGen.has_wall maze (x, y, c)) in let rec rec_solver maze (w,h,car) result succeed fail: MazeGen.dir list = begin let (r,f,l) = (MazeGen.dirs_to_check car) in match (w,h,car) with | (0,0,_) -> succeed result | _ -> if MazeGen.has_wall maze (w,h,car) then fail() else let (w,h,car) = next_cell maze (w,h,car) in let  fc2 = fun() -> rec_solver maze (w,h,l) result (fun acc -> succeed (car::acc)) (fun() -> fail()) in  let fc1 = fun() -> rec_solver maze (w,h,f) result (fun acc -> succeed (car::acc)) (fun() -> fc2()) in rec_solver maze (w,h,r) result (fun acc -> succeed (car::acc)) (fun() -> fc1())  end in let (r,f,l) = (MazeGen.dirs_to_check car) in rec_solver maze (w,h,car) [] (fun r  -> r ) (fun() -> rec_solver maze (w,h, MazeGen.West) [] (fun r -> r) (fun() -> raise NotFound)) )*)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq =  match (seq1(), seq2()) with | Cons(hA, tA), Cons(hB, tB) -> fun() -> Cons ((hA, hB), zip tA tB) | Cons(hA, _), Nil -> empty | Nil, _ -> empty   ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun() -> Nil | Cons(h, t) -> if (p h) then fun() -> Nil else fun() -> Cons(h, keep_until p t)   let to_list (seq : 'a seq) : 'a list = let rec to_list_rec seq acc = match seq() with | Nil -> [] | Cons(h,t) -> let y = to_list_rec t acc in h::y  in to_list_rec seq []  let range (start : int) (step : int) (stop : int) : int seq =  if step > 0 then (if stop < start then raise (Invalid_argument \"infinite, wrong inputs\");)  else if stop > start then raise (Invalid_argument \"infinite, wrong inputs\");  if stop > 0 then let f x = (x * step) + start in let p x = (x >= stop) in keep_until p (map f nats)  else let f x = (x * step) + start in let p x = (x <= stop) in keep_until p (map f nats)       end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = {num = (a.num*b.den) + (b.num*a.den) ; den = (b.den*a.den)} let mul a b = {num = a.num * b.num ; den = a.den * b.den}  let neg a = {num = ~-(a.num); den = a.den} let inv a = {num = a.den ; den = a.num}   end ;; ",
  " module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add a b = match (a,b) with (true, true) -> false | _ -> a || b let mul  = (&&)  let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let nextState s (d: MazeGen.dir): MazeGen.state = let (x, y, _) = s in match d with | East -> (x+1, y, East) | North -> (x, y-1, North) | South -> (x, y+1, South) | West -> (x-1, y, West) in  let rec aux s f sc: MazeGen.dir list = let (_, _, currD) = s in let (r_dir, f_dir, l_dir) = dirs_to_check currD in match s with | (0, 0, _) -> sc [] | (x, y, d) -> if not (has_wall maze (x, y, r_dir)) then aux (nextState s r_dir) (fun () -> if not (has_wall maze (x, y, f_dir)) then aux (nextState s f_dir) (fun () -> if not (has_wall maze (x, y, l_dir)) then aux (nextState s l_dir) f (fun er -> sc (l_dir::er)) else f ()) (fun er -> sc (f_dir::er)) else if not (has_wall maze (x, y, l_dir)) then aux (nextState s l_dir) f (fun er -> sc (l_dir::er)) else f ()) (fun er -> sc (r_dir::er))  else if not (has_wall maze (x, y, f_dir)) then aux (nextState s f_dir) (fun () -> if not (has_wall maze (x, y, l_dir)) then aux (nextState s l_dir) f (fun er -> sc (l_dir::er)) else f ()) (fun er -> sc (f_dir::er))  else if not (has_wall maze (x, y, l_dir)) then aux (nextState s l_dir) f (fun er -> sc (l_dir::er))  else f () in let (w, h) = dims maze in aux (w-1, h-1, North) (fun () -> raise NotFound) (fun x -> x) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let el1 = seq1 () in let el2 = seq2 () in match el1, el2 with | Nil, Nil | Nil, _ | _, Nil-> empty | Cons (x1, s1), Cons (x2, s2) -> fun () -> Cons((x1, x2), zip s1 s2);; ",
  "let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let el = seq () in match el with | Nil -> empty | Cons (x, s) -> if not (p x) then (fun () -> Cons (x, keep_until p s)) else empty;; ",
  "let to_list (seq : 'a seq) : 'a list = let rec aux s = let el = s () in match el with | Nil -> [] | Cons (x, seq) -> x::(aux seq) in aux seq  let range (start : int) (step : int) (stop : int) : int seq = if (step<0 && stop>start) then raise (Invalid_argument \"Invalid argument: stepping down infinitely\") else if (step>0 && start>stop) then raise (Invalid_argument \"Invalid argument: stepping up infinitely\") else if (step=0) then raise (Invalid_argument \"Invalid argument: step must not be 0\") else let multiples = map (fun x -> x*step) nats in let seq = map (fun x -> x + start) multiples in if step < 0 then keep_until (fun x -> x<=stop) seq else keep_until (fun x -> x>=stop) seq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1; } let one = { num = 1; den = 1; }  let add t1 t2 = { num = (t1.num*t2.den) + (t1.den*t2.num); den = (t1.den*t2.den); } let mul t1 t2 = { num = (t1.num*t2.num); den = (t1.den*t2.den); }  let neg n = { num = -n.num; den = n.den; } let inv n = { num = n.den; den = n.num; }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let add t1 t2 = match t1, t2 with | false, false | true, true -> false | _, _ -> true let mul t1 t2 = t1 && t2  let neg n = n let inv n = n let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = let open F in let two = add one one in let three = add (add one one) one in let bool1 = not (equal two zero) in let bool2 = not (equal three zero) in bool1 && bool2  let onCurve p q pnt = let open F in let (x, y) = pnt in let y_squared = mul y y in let x_cubed = mul (mul x x) x in let px = mul p x in equal y_squared (add (add x_cubed px) q);; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in  let rec maze_helper maze path state goto cont = let (x,y,v) = state in let finish = fun r -> r in  if (x,y) = (0,0) then finish (Some path) else let (a,b,c) = dirs_to_check v in let rec continuation = fun () -> if goto = a then maze_helper maze path state b continuation else if goto = b then maze_helper maze path state c continuation else finish None in  if has_wall maze (x,y,goto) then continuation() else let aux_move m = let (x,y,d) = m in match d with |(North) ->(x, y - 1) |(South) ->(x, y + 1) |(East) -> (x + 1, y) |(West) -> (x - 1, y) in  let (j,k) = aux_move (x,y,goto) in let newstate = (j,k,goto) in let newpath = path @ [goto] in let (dir1,dir2,dir3) = dirs_to_check goto in let return = maze_helper maze newpath newstate dir1 continuation in if return = None then continuation() else finish return in let (w, h) = dims maze in let (Some path) = maze_helper maze [] (w - 1,h - 1,North) East (fun()->None) in path  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let force = fun f -> f() in let rec aux seq1 seq2 = let a = force seq1 in let b = force seq2 in match a,b with |Cons(hd1,tl1) , Cons(hd2,tl2) -> fun ()-> Cons( (hd1,hd2) ,aux tl1 tl2 ) |_ -> fun ()-> Nil in aux seq1 seq2 let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let force = fun f -> f() in let a = force seq in match a with |Nil -> fun () -> Nil |Cons(hd,tl) when not (p hd) -> fun () -> Cons(hd, keep_until p tl) |Cons(_,_) -> fun () ->Nil let to_list (seq : 'a seq) : 'a list = let force = fun f -> f() in let rec aux seq list = let a = force seq in if a = Nil then list else let Cons(hd,tl) = a in let catlist = list @ [hd] in aux tl catlist  in aux seq [] let range (start : int) (step : int) (stop : int) : int seq =  if not((start < stop && (step < 0 ))|| (start > stop && step > 0)) then let give = fun f -> f() in let helperbool x = x = stop in let rec map_range st : 'a seq = if stop > 0 then fun () -> Cons(st, map_range (st+1)) else if (st >= 0 && step > 0) then nats else fun () -> Cons(st, map_range (st-1)) in let seq_to_map = map_range start in  let range_stream = keep_until helperbool seq_to_map in let aux x = if not((x = start) || (((x- start) mod step)= 0)) then None else if (((x - start) mod step)= 0) then Some x else Some x  in let final_list = Seq.map aux range_stream in let rec aux seq = let node = give seq in if node = Nil then Nil else match node with |Cons(h,t) when (h = None) -> aux t |Cons(h,t) -> let (Some n) = h in Cons(n, fun () -> aux t) in fun () -> aux final_list  else invalid_arg \"This range would result in an infinite loop, please check vars\" end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField: (AlgField with type t = rational) = struct type t = rational let zero = {num=0; den=1} let one = {num=1; den=1} let mul a b = {num=a.num*b.num;den=a.den*b.den} let add a b = {num=(a.num*b.den)+(b.num*a.den);den=a.den*b.den} let inv a = {num=a.den;den=a.num} let neg a = {num=(-a.num);den=a.den} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add= (!=) let mul=(&&) let inv a = a let neg a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let helper state dir = match dir,state with | MazeGen.North,(x,y,z) -> (x,y-1,MazeGen.North) | MazeGen.South,(x,y,z) -> (x,y+1,MazeGen.South) | MazeGen.East,(x,y,z) -> (x+1,y,MazeGen.East) | MazeGen.West,(x,y,z) ->(x-1,y,MazeGen.West) in  let rec aux curr fail list= let (a,b,c) =curr in let (x,y,z) = (MazeGen.dirs_to_check c) in  if (a,b) <> (0,0) then let fail_1 = if not(MazeGen.has_wall maze (helper curr z)) then aux (helper curr z) (fail) (z::list) else fail in let fail_2 = if not(MazeGen.has_wall maze (helper curr y)) then aux (helper curr y) (fail_1) (y::list) else fail_1 in let fail_3 = if not(MazeGen.has_wall maze (helper curr y)) then aux (helper curr x) (fail_2) (x::list) else fail_2 in    if not(MazeGen.has_wall maze (helper curr x)) then aux (helper curr x) fail_1 (x::list) else if not(MazeGen.has_wall maze (helper curr y)) then aux (helper curr y) fail_3 ( y::list) else if not(MazeGen.has_wall maze (helper curr z)) then aux (helper curr z) fail_3 ( z::list) else fail else list in let (p,q) = MazeGen.dims maze in aux (p-1,q-1,MazeGen.North) [] []    ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq)  : ('a * 'b) seq = match seq1(), seq2() with | Nil, _ | _, Nil -> fun() -> Nil | Cons (x, a'), Cons (y, b') -> fun()->Cons ((x,y), zip a' b')  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun() -> Nil | Cons (x,xs) -> if p x then fun() -> Nil else fun() -> Cons(x,keep_until p xs) let to_list (seq : 'a seq) : 'a list = let rec helper seq = match seq() with | Nil -> [] | Cons (x,xs) -> x :: helper xs in helper seq exception Invalid_argument let range (start : int) (step : int) (stop : int) : int seq = if (step >= 0 && (start > stop)) then raise Invalid_argument else if (step <= 0 && (start < stop)) then raise Invalid_argument else let helper a = if step > 0 then not (a < stop) else not (a > stop) in let c = map (fun x -> x*step) nats in let d = map (fun x -> x + start) c in keep_until (helper) d  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0;den=1} let one = {num=1;den=1}   let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if(a.den == 0 ||b.den ==0) then raise DivideByZero else{num=(a.num * b.den + b.num * a.den);den=(b.den*a.den)} let mul a b= if(a.den == 0 || b.den ==0) then raise DivideByZero else {num = (a.num * b.num); den = (a.den * b.den)} let neg a = if(a.den == 0 ) then raise DivideByZero else {num = ((-1)*a.num);den=(a.den)} let inv a = if(a.den == 0 || a.num==0) then raise DivideByZero else {num=a.den;den=a.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = match a,b with | false,false -> false | true ,true -> false |_,_ -> true let mul a b = match a,b with | true,true -> true | _,_ -> false let neg a = match a with | true -> true | false -> false let inv a = match a with | true -> true | false -> false  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let next_cell (s : MazeGen.state) (d : MazeGen.dir) : MazeGen.state = let (x,y,_) = s in match d with |MazeGen.North -> (x,y-1,d) |MazeGen.South -> (x,y+1,d) |MazeGen.East -> (x+1,y,d) |MazeGen.West -> (x-1,y,d) in  let rec mylist (maze : MazeGen.maze) (s : MazeGen.state) (ml : MazeGen.dir list) cont : MazeGen.dir list = match s with |(0,0,_) -> ml |(x,y,z) -> let (r,_,l) = (MazeGen.dirs_to_check z) in let tright = not (MazeGen.has_wall maze (x,y,r)) in let front = not (MazeGen.has_wall maze s) in let tleft = not (MazeGen.has_wall maze (x,y,l)) in if tright then mylist maze (next_cell s r) (ml@[r]) (fun () -> if front then mylist maze (next_cell s z) (ml@[z]) (fun () -> if tleft then mylist maze (next_cell s l) (ml@[l]) cont else cont ()) else if tleft then mylist maze (next_cell s l) (ml@[l]) cont else cont ()) else if front then mylist maze (next_cell s z) (ml@[z]) (fun () -> if tleft then mylist maze (next_cell s l) (ml@[l]) cont else cont () ) else if tleft then mylist maze (next_cell s l) (ml@[l]) cont else cont () in  let (width, height) = MazeGen.dims maze in let s1 = (width-1, height-2, MazeGen.North) in let s2 = (width-2, height-1, MazeGen.West) in mylist maze s1 [MazeGen.North] (fun () -> mylist maze s2 [MazeGen.West] (fun () -> raise NotFound)) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let node1 = seq1 () in let node2 = seq2 () in match node1 with |Nil -> Seq.empty |Cons (h1,t1) -> match node2 with |Nil -> Seq.empty |Cons (h2,t2) -> (fun () -> Cons ((h1,h2), (zip t1 t2)))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let node = seq () in match node with |Seq.Nil -> Seq.empty |Seq.Cons (h,t) -> if p h then Seq.empty else Seq.cons h (keep_until p t) let to_list (seq : 'a seq) : 'a list = let rec mylist seq list= let node = seq () in match node with |Seq.Nil -> list |Seq.Cons (h,t) -> mylist t (list@[h]) in mylist seq [] let range (start : int) (step : int) (stop : int) : int seq = let stepnats = map (fun x -> start + (step * x)) nats in if step < 0 then keep_until (fun x -> x <= stop) stepnats else keep_until (fun x -> x >= stop) stepnats  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let add a b = let {num = an; den = ad} = a in let {num = bn; den = bd} = b in {num = (an * bd + ad * bn); den = (ad * bd)} let mul a b = let {num = an; den = ad} = a in let {num = bn; den = bd} = b in {num = (an * bn); den = (ad * bd)}  let neg a = let {num = an; den = ad} = a in {num = (0 - an); den = ad} let inv a = let {num = an; den = ad} = a in {num = ad; den = an}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let add a b = if a = b then zero else one let mul a b = if a = b then if a = one then one else zero else zero  let neg a = a let inv a = a let equal = (=) end ;; ",
  "let print_dir d = let open MazeGen in print_string begin match d with | West -> \"West\" | North -> \"North\" | East -> \"East\" | South -> \"South\" end let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let has_wall = has_wall maze in let (w, h) = dims maze in let step (x, y, d) = match d with | West -> (x - 1, y, d) | North -> (x, y - 1, d) | East -> (x + 1, y, d) | South -> (x, y + 1, d) in let rec solve ((x, y, _) as state) sk fk = match (x, y) with | (0, 0) -> sk [] | _ when has_wall state -> fk () | _ -> let (x, y, d) = step state in let (r, f, l) = dirs_to_check d in solve (x, y, r) (fun ds -> sk (d :: ds)) (fun _ -> solve (x, y, f) (fun ds -> sk (d :: ds)) (fun _ -> solve (x, y, l) (fun ds -> sk (d :: ds)) fk ) ) in solve (w - 1, h - 1, North) (fun ds -> ds) (fun _ -> solve (w - 1, h - 1, West) (fun ds -> ds) (fun _ -> raise NotFound) ) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze); ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with | (Cons (a, seq1), Cons (b, seq2)) -> Cons ((a, b), zip seq1 seq2) | _ -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Cons (v, seq) when not (p v) -> Cons (v, keep_until p seq) | _ -> Nil let to_list (seq : 'a seq) : 'a list = List.rev (fold_left (fun xs x -> x :: xs) [] seq) let range (start : int) (step : int) (stop : int) : int seq = let pred = if step >= 0 then (<=) stop else (>=) stop in nats |> map (fun n -> start + n * step) |> keep_until pred end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let equal a b = a.den <> 0 && b.den <> 0 && a.num * b.den = a.den * b.num let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 } let add a b = { num = a.num * b.den + a.den * b.num; den = a.den * b.den; } let mul a b = { num = a.num * b.num; den = a.den * b.den; } let neg a = { a with num = - a.num } let inv { num; den } = { num = den; den = num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let equal = (=) let zero = false let one = true let add = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "module EllipticCurves (F : AlgField) = struct type point = F.t * F.t  let easyECs : bool = not (F.equal (F.add F.one F.one) F.zero) && not (F.equal (F.add F.one (F.add F.one F.one)) F.zero)  let onCurve (p : F.t) (q : F.t) ((x, y) : point) : bool = F.equal (F.mul y y) (F.add (F.mul x (F.mul x x)) (F.add (F.mul p x) q)) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x,y,_) = astate in | MazeGen.North -> (x, (y -1), ndir) | MazeGen.South -> (x, (y +1), ndir) | MazeGen.East -> ((x +1), y, ndir) | MazeGen.West -> ((x -1), y, ndir) in let rec solve_tr (maze : MazeGen.maze) (cstate : MazeGen.state) (success : MazeGen.dir list -> MazeGen.dir list) (failure : unit -> MazeGen.dir list) : MazeGen.dir list = let (x,y,d) = cstate in if (x = 0) && (y = 0) then else let (r,s,l) = MazeGen.dirs_to_check d in solve_tr maze (get_next_cell cstate l) (fun li -> success (l::li)) failure else failure () in (solve_tr maze (get_next_cell cstate s) (fun li -> success (s::li)) third_step) else third_step () ) in solve_tr maze (get_next_cell cstate r) (fun li -> success (r::li)) second_step else in let (width, height) = MazeGen.dims maze in ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 () ,seq2 ()) with | (Nil,_ ) | (_, Nil) -> Nil | (Cons(e1, s1), Cons(e2, s2)) -> Cons ((e1,e2), (zip s1 s2)) ;; ",
  " let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons (el, s) -> if p el then Nil else Cons (el, keep_until p s) ;; ",
  " let to_list (seq : 'a seq) : 'a list = let rec helper (seq : 'a seq) (l : 'a list) : 'a list = match seq () with | Nil -> l | Cons (el, s) -> helper s (l @ [el]) in helper seq [] ;; ",
  "let range (start : int) (step : int) (stop : int) : int seq = let get_num_steps (start : int) (step : int) (stop : int) = if ((step > 0) && (start < stop)) then ((stop - start - 1) / step) + 1 else if ((step < 0) && (start > stop)) then ((start - stop - 1) / (-step)) + 1 else raise (Invalid_argument \"Invalid input. This will result in an infinite sequence. Please enter range which will lead to a finite sequence\") in let num_steps = get_num_steps start step stop in let nats_to_map = keep_until (fun el -> el >= num_steps) nats in Seq.map (fun nat -> ((nat * step) + start)) nats_to_map end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational ;; ",
  "let zero = {num = 0; den = 1};; ",
  "let one = {num = 1; den = 1};; ",
  "let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den ;; ",
  "let neg a = {num = (-a.num); den = a.den} ;; ",
  "let inv a = {num = a.den; den = a.num};; ",
  "let add a b = {num = (((a.num)*(b.den)) + ((b.num)*(a.den))); den = (a.den * b.den)};; ",
  "end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool;; ",
  "let zero = false;; ",
  "let one = true;; ",
  "let neg a = a;; ",
  "let inv a = a;; ",
  "let add a b = (a && (not b)) || (b && (not a));; ",
  "let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t;; ",
  "let easyECs = let two = F.add (F.one) (F.one) in let three =  F.add (two) (F.one) in (not (F.equal (two) (F.zero))) && (not (F.equal (three) (F.zero))) ;; ",
  "exception NotFound open MazeGen  let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let next_cell state = let x, y, current_dir = state in match current_dir with | West -> (x-1, y, West) | North -> (x, y-1, North) | East -> (x+1, y, East) | South -> (x, y+1, South) in  let rec find_path state sc fc = match state with | 0, 0,  _ -> sc [] | _, _, dir -> let d1, d2, d3 = dirs_to_check dir in if has_wall maze state then fc () else let next_x, next_y, _ = next_cell state in let new_sc = fun l -> sc (dir::l) in find_path (next_x, next_y, d1) new_sc (fun () -> find_path (next_x, next_y, d2) new_sc (fun () -> find_path (next_x, next_y, d3) new_sc (fun () -> fc ()) ) ) in let m, n = dims maze in find_path (m-1, n-1, North) (fun x -> x) (fun () -> find_path (m-1, n-1, West) (fun x-> x) (fun () -> raise NotFound))  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze)     module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Cons (hd1, tl1), Cons (hd2, tl2) -> fun () -> Cons( (hd1, hd2), zip tl1 tl2) | _ -> fun () -> Nil  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Cons (hd, tl) -> if p hd then fun () -> Nil else fun () -> Cons(hd, keep_until p tl) | _ -> fun() -> Nil  let to_list (seq : 'a seq) : 'a list = List.rev (Seq.fold_left (fun l e -> e::l) [] seq) let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"Can't have step of 0\") else if start > stop && step > 0 then raise (Invalid_argument \"Leads to infinite sequence since start > stop and step > 0\") else if start < stop && step < 0 then raise (Invalid_argument \"Leads to infinite sequence since start < stop and step < 0\") else let func x = if start < stop then x >= stop else x <= stop in keep_until func (Seq.map (fun x -> x * step + start) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = if a.den = b.den then { num = a.num + b.num; den = a.den } else { num = a.num * b.den + b.num * a.den; den = a.den * b.den } let mul a b = { num = a.num * b.num; den = a.den * b.den } let neg a = { num = -a.num; den = a.den } let inv a = { num = a.den; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let add a b = (a || b) && ((not a) || (not b)) let mul = (&&)  let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (width, height) = MazeGen.dims maze in let rec directions current_state fail succeed = let get_direction x y dir = match dir with | MazeGen.North -> (x, y - 1, MazeGen.North) | MazeGen.East -> (x + 1, y, MazeGen.East) | MazeGen.South -> (x, y + 1, MazeGen.South) | MazeGen.West -> (x - 1, y, MazeGen.West) in match current_state with | (0, 0,  _) -> succeed [] | (x, y, dir) -> let (right, forward, left) = MazeGen.dirs_to_check (dir) in if not (MazeGen.has_wall maze (x, y, right)) then directions (get_direction x y right) (fun() -> if not (MazeGen.has_wall maze (x, y, forward)) then directions (get_direction x y forward) (fun() -> if not (MazeGen.has_wall maze (x, y, left)) then directions (get_direction x y left) (fail) (fun a -> succeed (left::a)) else fail()) (fun a -> succeed (forward::a)) else if not (MazeGen.has_wall maze (x, y, left)) then directions (get_direction x y left) (fail) (fun a -> succeed (left::a)) else fail()) (fun a -> succeed (right::a)) else if not (MazeGen.has_wall maze (x, y, forward)) then directions (get_direction x y forward) (fun() -> if not (MazeGen.has_wall maze (x, y, left)) then directions (get_direction x y left) (fail) (fun a -> succeed (left::a)) else fail()) (fun a -> succeed (forward::a)) else if not (MazeGen.has_wall maze (x, y, left)) then directions (get_direction x y left) (fail) (fun a -> succeed (left::a)) else fail() in directions (width - 1, height - 1, MazeGen.North) (fun() -> raise NotFound) (fun list -> list) let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil, _ -> fun() -> Nil | _, Nil -> fun() -> Nil | Cons (h1, t1), Cons (h2, t2) -> fun() -> Cons ((h1, h2), zip t1 t2) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> fun() -> Nil | Cons (h, t) -> if (p h) then fun() -> Nil else fun() -> Cons (h, fun() -> keep_until p t()) let to_list (seq : 'a seq) : 'a list = let rec helper (seq : 'a seq) = match seq() with | Nil -> [] | Cons (h, t) -> h :: helper t in helper seq  let range (start : int) (step : int) (stop : int) : int seq = if (step < 0 && stop > start) then raise (Invalid_argument \"stop value cannot be reached\") else if (step > 0 && start > stop) then raise (Invalid_argument \"stop value cannot be reached\") else if (step = 0) then raise (Invalid_argument \"stop value cannot be reached\") else let a = fun a -> start + step * a in let b = keep_until (fun x -> if step < 0 then x <= stop else x >= stop) nats in keep_until (fun x -> if step < 0 then x <= stop else x >= stop) (Seq.map a b) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.num * b.den + a.den * b.num; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = - a.num ; den = a.den} let inv a = {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add = (<>) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (width,height) = dims(maze) in let next_cell current_state = if (has_wall maze current_state) then None else let (x,y,curr_dir) = current_state in match curr_dir with | West -> if x-1 < 0  then None else Some (x-1,y,West) | East -> if x+1 > width then None else Some (x+1,y,East) | North -> if y-1 > height then None else Some (x,y-1,North) | South -> if y+1 < 0 then None else Some (x,y+1,South) in let rec find_exit current_state list cont = match current_state with | None -> cont () | Some (0,0,_) -> list | Some (x,y,curr_dir) -> let (right,front,left) = dirs_to_check curr_dir in find_exit (next_cell (x,y,right)) (list @ [right]) (fun () -> find_exit (next_cell (x,y,front)) (list @ [front]) (fun () -> find_exit (next_cell (x,y,left)) (list @ [left]) cont)) in find_exit (Some(width-1, height-1,North)) [] (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1(), seq2() with | Nil,Nil -> empty | Cons (_,_), Nil -> empty | Nil, Cons (_,_) -> empty | Cons (x, xf) , Cons (y, yf) -> fun () -> Cons ( (x,y), (zip xf yf))   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> empty | Cons (x,xf) -> if not (p x) then fun () -> Cons (x, (keep_until p xf)) else fun () -> Nil  let to_list (seq : 'a seq) : 'a list = let rec helper seq = match seq () with | Nil -> [] | Cons (x,xf) -> x ::(helper xf) in helper seq let range (start : int) (step : int) (stop : int) : int seq = let increment item = item * step + start in let seqs = map increment nats in let condition i  =  (i >= stop && step > 0) || (i <= stop && step < 0 ) in keep_until condition seqs   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = ({num =0; den= 1}) let one = ({num =1; den=1}) let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = let x = a.num * b.den + b.num * a.den in let y = a.den * b.den in ({num=x; den=y}) let mul a b = ({num = a.num * b.num; den= a.den * b.den}) let neg a  = ({num = -a.num; den = a.den}) let inv a = ({num = a.den; den = a.num}) end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add a b = (a && not b) || (not a && b) let mul  = (&&) let neg a = a let inv a = a let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let rec createList state sc fc = match state with | (0, 0, _) -> sc [] | (x, y, dir) ->  let next_state (x, y, dir) = if MazeGen.has_wall maze (x, y, dir) then fc () else match dir with | MazeGen.North -> (x, y-1, MazeGen.North) | MazeGen.West -> (x-1, y, MazeGen.West) | MazeGen.South -> (x, y+1, MazeGen.South) | MazeGen.East -> (x+1, y, MazeGen.East) in  let (d1, d2, d3) = MazeGen.dirs_to_check dir in  try let state = next_state (x, y, d1) in createList state (fun l -> sc(d1::l)) fc with NotFound -> try let state = next_state (x, y, d2) in createList state (fun l -> sc(d2::l)) fc with NotFound -> let state = next_state (x, y, d3) in createList state (fun l -> sc(d3::l)) fc  in  let (width, height) = MazeGen.dims maze in createList (width-1,height-1, MazeGen.North) (fun l -> l) (fun () -> raise NotFound) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 (), seq2 ()) with | Cons (x, xs), Cons (y, ys) -> fun () -> Cons ((x, y), zip xs ys) | _ -> empty  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Cons (x, xs) -> if p x then empty else fun () -> Cons(x, keep_until p xs) | Nil -> empty  let to_list (seq : 'a seq) : 'a list = let rec make_list seq = match seq () with | Cons (x, xs) -> x::make_list xs | Nil -> [] in make_list seq let range (start : int) (step : int) (stop : int) : int seq = let m = fun x -> if step < 0 then x <= stop else x >= stop in let f = fun x -> x * step + start in let seq = map f nats in keep_until m seq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den <> 0 && b.den <> 0 then {num = a.num * b.den + b.num * a.den; den = a.den * b.den} else raise DivideByZero  let mul a b = if a.den <> 0 && b.den <> 0 then {num = a.num * b.num; den = a.den * b.den} else raise DivideByZero  let neg a = if a.den <> 0 then {num = (-1)*a.num; den = a.den} else raise DivideByZero  let inv a = if a.den <> 0 then {num = a.den; den = a.num} else raise DivideByZero  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let add a b = if a && b then false else (a || b) let mul a b = (a && b)  let neg a = a let inv a = a   end ;; ",
  " let solve_maze (maze : MazeGen.maze) : MazeGen.dir list =  let getnext state = let (x,y,d)=state in match d with |MazeGen.South -> (x,y, MazeGen.East) |MazeGen.East -> (x,y, MazeGen.North) |MazeGen.North -> (x,y, MazeGen.West) |MazeGen.West -> (x,y, MazeGen.South) in  let forward state = let (x,y,d)=state in match d with |MazeGen.South -> (x,y+1, MazeGen.West) |MazeGen.East -> (x+1,y, MazeGen.South) |MazeGen.North -> (x,y-1, MazeGen.East) |MazeGen.West -> (x-1,y, MazeGen.North) in  let rec solve_maze_helper state sc fc=  let (x,y,_)=state in if (x,y)=(0,0) then sc [] else if MazeGen.has_wall maze state then fc () else  let (_,_,d)=state in let sc1 = fun r -> (sc r)@[d] in let fc1 = fun () -> solve_maze_helper (getnext(getnext(forward state))) sc1 fc in let fc2 = fun () -> solve_maze_helper (getnext(forward state)) sc1 fc1 in solve_maze_helper (forward state) sc1 fc2   in let (width, height)=MazeGen.dims maze in let fc = fun () -> solve_maze_helper (width-1, height-1, MazeGen.West) (fun r -> r) (fun () -> []) in solve_maze_helper (width-1, height-1, MazeGen.North) (fun r -> r) fc   ;; ",
  " let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1(),seq2()) with | (Nil,_) -> empty | (_, Nil)-> empty | (Cons(a1,t1), Cons(a2,t2)) -> fun () -> Cons ((a1,a2), zip t1 t2)  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq() with | Nil -> empty | Cons(a,t) -> if p a then empty else fun () -> Cons(a, keep_until p t) let to_list (seq : 'a seq) : 'a list = let rec to_list_h seq cont= match seq() with | Nil -> cont([]) | Cons(a,t) -> to_list_h t (fun r -> cont(r)@[a]) in to_list_h seq (fun r->r) exception Invalid_argument  let range (start : int) (step : int) (stop : int) : int seq = let seq= map (fun i -> i+start) (map (fun i -> i*step) nats) in  if (step > 0) then if stop<start then (print_string \"The sequence is infinite because it is increasing and the stop is less than the start.\"; raise Invalid_argument) else keep_until (fun i -> (i>=stop)) seq else if (step=0) then (print_string \"The sequence is infinite because the step is 0 so we get an infinite constant sequence.\"; raise Invalid_argument) else if stop>start then (print_string \"The sequence is infinite because it is decreasing and the stop is greater than the start.\"; raise Invalid_argument) else keep_until (fun i -> (i<=stop)) seq  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num=0; den=1} let one = {num=1; den=1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num= (a.num * b.den) + (b.num * a.den); den= a.den * b.den} let mul a b = {num= a.num * b.num; den= a.den * b.den} let neg a = {num= - a.num; den= a.den} let inv a = if a.num = 0 then raise DivideByZero else {num= a.den; den= a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = not (a=b) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let (w,h) = dims maze in let cur = (w-1,h-1,North) in let update_state (state : state) = match state with |(x,y,North) -> (x,y-1,North) |(x,y,South) -> (x,y+1,South) |(x,y,West)  -> (x-1,y,West) |(x,y,East)  -> (x+1,y,East) in let rec find_path (cur_state : state) (sublist : dir list) (count : 'a list -> 'a list) = match cur_state with |(0,0,d) -> count sublist |(x,y,d) -> let (d1,d2,d3) = dirs_to_check d in if has_wall maze (x,y,d1) && has_wall maze (x,y,d2) && has_wall maze (x,y,d3) then raise NotFound else try (if has_wall maze (x,y,d1) = false then find_path (update_state (x,y,d1)) sublist (fun l -> (count l) @ [d1]) else raise NotFound) with NotFound -> try (if has_wall maze (x,y,d2) = false then find_path (update_state (x,y,d2)) sublist (fun l -> (count l) @ [d2]) else raise NotFound) with NotFound -> if has_wall maze (x,y,d3) = false then find_path (update_state (x,y,d3)) sublist (fun l -> (count l) @ [d3]) else raise NotFound in find_path cur [] (fun l -> l) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match (seq1 (), seq2 ()) with |(Cons(e1,s1),Cons(e2,s2)) -> Seq.Cons ((e1,e2), zip s1 s2) |(_,_) -> Nil let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with |Nil -> Nil |Cons(e,s) -> if p e then Nil else Seq.Cons (e, keep_until p s)  let to_list (seq : 'a seq) : 'a list = let l = ref [] in let f (e : 'a) = l := !l @ [e] in iter f seq ; !l let range (start : int) (step : int) (stop : int) : int seq = let f n = if step > 0 && n >= stop then true else if step < 0 && n <= stop then true else false in keep_until f (map (fun n -> start + n * step) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add a b = {num = a.den * b.num + a.num * b.den; den = a.den * b.den} let mul a b = {num = a.num * b.num; den = a.den * b.den} let neg a = {num = -a.num ; den = a.den} let inv a = {num = a.den ; den = a.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal a b = (a = b) let add a b = a != b let mul a b = a && b let neg a = a let inv a = a end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let dims : (int * int) = dims maze in let right ((x, y, z) : (dir * dir * dir)) = x in let left ((x, y, z) : (dir * dir * dir)) = z in let initiate_state ((x,y) : (int*int)) (z : dir) : state = ((x-1), (y-1), z) in let state1 = initiate_state (dims) (North) in let decrease_state_x ((x, y, z) : state) = ((x-1), y, z) in let decrease_state_y ((x, y, z) : state) = (x, (y-1), z) in let increase_state_x ((x, y, z) : state) = ((x+1), y, z) in let increase_state_y ((x, y, z) : state) = (x, (y+1), z) in let change_direction ((x, y, z) : state) (d : dir) = (x, y, d) in let direction_of_state ((x, y, z) : state) = z in let cord_of_state ((x, y, z) : state) = (x, y) in let left_of_state ((x, y, z) : state) = (x, y, (left (dirs_to_check (direction_of_state (x, y, z))))) in let right_of_state ((x, y, z) : state) = (x, y, (right (dirs_to_check (direction_of_state (x, y, z))))) in let take_step s : state = match direction_of_state s with | North -> (decrease_state_y s) | East ->  (increase_state_x s) | West ->  (decrease_state_x s) | South -> (increase_state_y s) in   let rec check m is s = if cord_of_state s = (0,0) then true else if (cord_of_state is) = (cord_of_state s) then false else if has_wall m (right_of_state s) then check m is (left_of_state s) else match direction_of_state s with | North -> check m is (change_direction (increase_state_x (s)) East) | South -> check m is (change_direction (decrease_state_x (s)) West) | East -> check m is (change_direction (increase_state_y (s)) South) | West -> check m is (change_direction (decrease_state_y (s)) North) in   let rec move m s cs = if cord_of_state s = (0,0) then cs [] else if has_wall m (right_of_state s) then move m (left_of_state s) cs else if check m (right_of_state (s)) (take_step (right_of_state (s))) then match direction_of_state s with | North -> move m (change_direction (increase_state_x (s)) East) (fun r -> cs (East :: r)) | South -> move m (change_direction (decrease_state_x (s)) West) (fun r -> cs (West :: r)) | East -> move m (change_direction (increase_state_y (s)) South) (fun r -> cs (South :: r)) | West -> move m (change_direction (decrease_state_y (s)) North) (fun r -> cs (North :: r)) else move m (left_of_state s) cs in move maze state1 (fun r -> r) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with  | _, Nil -> (fun () -> Nil) | Nil, _ -> (fun () -> Nil) | Cons (v, s), Cons (v2, s2) -> (fun () -> Cons ((v, v2) , (zip s s2))) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Nil -> (fun () -> Nil) | Cons (v,s) -> if p v then (fun () -> Nil) else (fun () -> Seq.Cons ((v) , (keep_until p s)))  let to_list (seq : 'a seq) : 'a list = let rec aux s = match s () with | Nil -> [] | Cons (v, s2) -> v :: aux s2 in aux seq  let range (start : int) (step : int) (stop : int) : int seq = if (stop < start && step > 0) || (step < 0 && stop > start) || (step = 0) then raise (Invalid_argument \"the inputs provided produce an infinite sequence\") else  let step_fun = fun start step x -> (x*(step)) + start in  if stop < start then let final1 = fun stop x -> x <= stop in keep_until (final1 stop) (map (step_fun start step) nats) else let final2 = fun stop x -> x >= stop in keep_until (final2 stop) (map (step_fun start step) nats)  end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  " module RationalField : (AlgField with type t = rational) = struct type t = rational let zero : t = ( let num = 0 in let den = 1 in {num ; den} ) let one : t = ( let num = 1 in let den = 1 in {num ; den} )   let equal a b = a.den <> 0 && b.den <> 0 && (a.den * b.num = a.num * b.den)  let add a b : t = if a.num = 0 then b else if b.num = 0 then a else ( let num = (a.num * b.den) + (b.num * a.den) in let den = (a.den * b.den) in {num ; den} )  let mul a b : t = let zero = ( let num = 0 in let den = 1 in {num ; den} ) in if a.num = 0 then zero else if b.num = 0 then zero else ( let num = (a.num * b.num) in let den = (a.den * b.den) in {num ; den} )  let neg a : t = ( let num = ((-1) * a.num) in let den = a.den in {num ; den} )  let inv a : t = ( let num = a.den in let den = a.num in {num ; den} )  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero : t = false let one : t = true let equal = (=) let add a b = ((not a || not b) && (a <> b)) let mul = (&&) let neg a = a let inv a = a end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t  let easyECs = (not (F.equal (F.add F.one F.one) F.zero)) && (not (F.equal (F.add (F.add F.one F.one) F.one) F.zero))  let onCurve p q point = let (x, y) = point in let square y = F.mul y y in let cube x = (F.mul x (F.mul x x)) in F.equal (square y) ( F.add (cube x) ( F.add (F.mul p x) q ) )  end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in let new_coor state dir = match dir, state with | North, (x,y,_) -> (x, y-1, North) | South, (x,y,_) -> (x, y+1, South) | West, (x,y,_) -> (x-1, y, West) | East, (x,y,_) -> (x+1, y, East) in let rec aux (next_state:MazeGen.state) sc fc = match next_state with | (0,0,_) -> sc [] | (x, y, dir) -> let (r, f, l) = dirs_to_check dir in if not (has_wall maze (x,y,r)) then aux (new_coor (x,y,dir) r) (fun rs -> sc(r::rs)) if not(has_wall maze (x,y,f)) then aux (new_coor (x,y,dir) f) (fun rs -> sc(f::rs)) (fun () -> if not(has_wall maze (x,y,l)) then aux (new_coor (x,y,dir) l) (fun rs -> sc(l::rs)) (fc) else fc() ) else if not(has_wall maze (x,y,l)) then aux (new_coor (x,y,dir) l) (fun rs -> sc(l::rs)) (fc) else fc() ) else if not(has_wall maze (x,y,f)) then aux (new_coor (x,y,dir) f) (fun rs -> sc(f::rs)) (fun () -> if not(has_wall maze (x,y,l)) then aux (new_coor (x,y,dir) l) (fun rs -> sc(l::rs)) (fc) else fc () ) else if not(has_wall maze (x,y,l)) then aux (new_coor (x,y,dir) l) (fun rs -> sc(l::rs)) (fc) else fc () in let (n,m) = dims maze in let next_state = (n-1, m-2, North) in let sc1 = fun rs -> North::rs in let sc2 = fun rs -> West::rs in let fc1 = fun () -> if not(has_wall maze (n-1,m-1,West)) then aux (new_coor (n-1,m-1,North) West) (sc2) (fun () -> []) else [] in aux (next_state) (sc1) (fc1) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1(), seq2() with | Nil,Nil | Nil,_ | _, Nil -> Nil | Cons(v1, s1), Cons(v2, s2) -> Cons((v1, v2), zip (s1) (s2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with | Nil -> Nil | Cons(v, s) -> if p v then empty() else Cons(v, keep_until (p)(s)) let rec to_list (seq : 'a seq) : 'a list = match seq() with | Nil -> [] | Cons(v, s) -> v::to_list (s) let range (start : int) (step : int) (stop : int) : int seq = if step = 0 || (step < 0 && start <= stop) then raise (Invalid_argument (\"Step is zero or step is negative but start is smaller than stop\")) else let p = fun x -> if step > 0 then x >= stop x <= stop in let f x = start + x * step in keep_until (p) (map (f) nats) end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module type ECSig = functor (F : AlgField) -> sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end ;; ",
  "*) module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den let add x y = let num = x.num*y.den + y.num*x.den in let den = x.den*y.den in {num; den} let mul x y = let num = x.num*y.num in let den = x.den*y.den in {num; den} let neg x = {num = -x.num; den = x.den} let inv x = {num = x.den; den = x.num} end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add x y = match x, y with | false, false -> false | true, true -> false | _ -> true let mul x y = match x, y with | false, _ | _, false -> false | _ -> true let neg x = x let inv x = x let equal = (=) end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = not (F.equal (F.add(F.one)(F.one)) (F.zero)) && not (F.equal (F.add(F.add(F.one)(F.one))(F.one))(F.zero))  let onCurve (p:F.t) (q:F.t) (d:point) = let (x,y) = d in F.equal (F.mul(y)(y)) (F.add(F.add(F.mul(F.mul(x)(x))(x))(F.mul(p)(x)))(q)) end;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let open MazeGen in raise NotImplemented   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = let hd1 = seq1 () in let hd2 = seq2 () in match hd1, hd2 with | Nil, Nil -> empty | Nil, _ -> empty | _, Nil -> empty | Cons (h1, s1),Cons (h2, s2) -> fun () -> Cons((h1, h2), (zip s1 s2)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let hd = seq () in match hd with | Nil -> empty | Cons(h,s) -> if p h then empty else (fun () -> Cons(h, keep_until p s));; ",
  "let to_list (seq : 'a seq) : 'a list = let rec to_list' sq (lst: 'a list) = let hd = sq () in match hd with | Nil -> lst | Cons(h,s) -> to_list' s (lst@[h]) in to_list' seq [];; ",
  "let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument \"step is zero\") else if (start > stop && step > 0) then raise (Invalid_argument \"start is greater than stop with positive step\") else if (start < stop && step < 0) then raise (Invalid_argument \"start is less than stop with negative step\") else let seq = map (fun x -> x*step) nats in let s = map (fun x -> x+start) seq in if step > 0 then keep_until (fun x -> x > stop || x = stop) s else keep_until (fun x -> x < stop || x = stop) s   end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = { num = 0; den = 1; } let one = { num = 1; den = 1; } let add t1 t2 = { num = t1.num*t2.den + t2.num*t1.den; den = t1.den*t2.den; } let mul t1 t2 = { num = t1.num*t2.num; den = t1.den*t2.den; } let neg t1 = { num = -t1.num; den = t1.den; } let inv t1 = { num = t1.den; den = t1.num; }  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true let add t1 t2 = not (((not t1) && (not t2)) || (t1 && t2)) let mul = (&&) let neg t1 = t1 let inv t1 = t1 let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (x,y) = MazeGen.dims maze in let initialState = ((x -1),( y -1), MazeGen.North) in let increment (s : MazeGen.state) (direction : MazeGen.dir) = let (x,y,_) = s in match direction with | MazeGen.North -> (x,y-1,direction) | MazeGen.East -> (x+1,y,direction) | MazeGen.West -> (x-1,y,direction) | MazeGen.South -> (x,y+1,direction) in let next (s : MazeGen.state) (maz : MazeGen.maze) = let (x,y,d) = s in let (a,b,c) = MazeGen.dirs_to_check d in let walls = (MazeGen.has_wall maz (x,y,a), MazeGen.has_wall maz (x,y,b), MazeGen.has_wall maz (x,y,c)) in match walls with |(true,true,true)-> [] |(true,false,true)-> b::[] |(true,true,false)-> c::[] |(true,false,false)-> b::c::[] |(false,true,true)-> a::[] |(false, false, true)-> a::b::[] |(false, true, false)-> a::c::[] |(false, false, false)-> a::b::c::[] in let rec solve_m succ fail currState = match currState with |(0,0,_)-> succ [] |(_,_,_)-> match next currState maze with |a::[] -> solve_m (fun d1 -> (succ d1)@[a] ) fail (increment currState a) |a::b::[] -> solve_m (fun d1 -> (succ d1)@[a] ) (fun () -> solve_m (fun d1 -> (succ d1)@[b] ) fail (increment currState b)) (increment currState a) |a::b::c::[] -> solve_m (fun d1 -> (succ d1)@[a] ) (fun () -> solve_m (fun d1 -> (succ d1)@[b] ) (fun () -> solve_m (fun d1 -> (succ d1)@[c] ) fail (increment currState c) ) (increment currState b)) (increment currState a) |_ -> fail() in let success = fun ogd -> ogd in let failure = fun () -> [] in solve_m success failure initialState ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1() with |Nil -> Nil |Cons(x,xs) -> match seq2() with |Nil -> Nil |Cons(y,ys) -> Cons( (x,y), (zip xs ys)) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq() with |Nil -> Nil |Cons (x,xs)-> if (not (p x)) then Cons (x, (fun () -> keep_until p xs())) else Nil let to_list (seq : 'a seq) : 'a list = let rec helper l seq = match seq() with |Nil -> l |Cons (x,xs)-> helper (l@[x]) (xs) in helper [] seq let range (start : int) (step : int) (stop : int) : int seq = if (stop > start && step < 0) then raise (Invalid_argument \"Stop number is larger than Start number but we are decreasing.\") else if (stop < start && step > 0) then raise (Invalid_argument \"Stop number is smaller than Start number but we are increasing.\") else if (step = 0 && start<>stop) then raise (Invalid_argument \"Can't increase/decrease \") else let f nbr = start+step*nbr in let p nbr = if (nbr < stop && step > 0) then false else not ((nbr > stop) && (step < 0)) in keep_until (p) (Seq.map (f) (nats))   end;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let add = fun (x:t) (y:t) -> {num = x.num*y.den+y.num*x.den; den = x.den*y.den} let mul = fun (x:t) (y:t) -> {num = x.num*y.num; den = x.den*y.den} let neg = fun (x:t) -> {num = 0-x.num; den= x.den} let inv = fun (x:t) -> {num = x.den; den = x.num} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let add = fun (x:t) (y:t) -> not (x = y) let mul = fun (x:t) (y:t) -> x && y let neg = fun (x:t) -> x let inv = fun (x:t) -> x  let equal = (=) end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w, h) = MazeGen.dims maze in let next_cell state = match state with | (x,y,MazeGen.North) -> (x,y-1,MazeGen.North) | (x,y,MazeGen.South) -> (x,y+1,MazeGen.South) | (x,y,MazeGen.West) -> (x-1,y,MazeGen.West) | (x,y,MazeGen.East) -> (x+1,y,MazeGen.East) in let rec solve s fail succ = match s with | (0,0,d) -> succ [] | (x,y,d) -> let (right,front,left) = MazeGen.dirs_to_check d in  if (MazeGen.has_wall maze (x,y,right)) then if (MazeGen.has_wall maze (x,y,front)) then if (MazeGen.has_wall maze (x,y,left)) then fail () else solve (next_cell (x,y,left)) (fun () -> solve (x,y,right) fail succ) (fun d -> succ (left::d)) else  solve (next_cell (x,y,front)) (fun () -> solve (x,y,left) fail succ) (fun d -> succ (front::d)) else solve (next_cell (x,y,right)) (fun () -> solve (x,y,left) fail succ) (fun d -> succ (right::d)) in solve (w-1,h-1,MazeGen.North) (fun () -> raise NotFound) (fun d -> d)  ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | (Nil, _) -> (fun () -> Nil) | (Cons (_, _), Nil) -> (fun () -> Nil) | Seq.Cons(a,s1), Seq.Cons(b,s2) -> fun () -> Cons ((a,b), zip s1 s2) let keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let rec keep p seq acc = match seq () with | Nil -> acc | Cons (v,s) -> if p v then acc else keep p s (Seq.append acc (return v)) in keep p seq (fun () -> Nil)  let to_list (seq : 'a seq) : 'a list = let rec app seq acc = match seq () with | Nil -> acc | Cons (v,s) -> app s (acc @ [v]) in app seq []  let range (start : int) (step : int) (stop : int) : int seq = let neg = Seq.map (fun r -> r * (-1)) nats in if (start < stop && step > 0) then let s = Seq.map (fun r -> r * step + start) nats in keep_until (fun r -> r >= stop) s else if (start > stop && step < 0) then let sN' = Seq.map (fun r -> (r * (abs step) + start)) neg in keep_until (fun r -> r <= stop) sN' else raise (Invalid_argument \"Wrong step!\") end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = {num = 0; den = 1} let one = {num = 1; den = 1} let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = let num' = a.num * b.den + a.den * b.num in let den' = a.den * b.den in {num = num' ; den = den'  }  let mul a b = let num' = a.num * b.num in let den' = a.den * b.den in {num = num' ; den = den' }   let neg a = match a with | ({num = 0; den = _}) -> a | ({num = _; den = _}) ->  ({num = 0 - a.num; den = a.den}) let inv a = match a with | {num = 0; den = 1} -> ({num = 0; den = 1}) | _ -> ({num = a.den; den = a.num}) end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true let equal = (=) let add a b = match a,b with | (true,true) -> false | (true,false) -> true | (false,true) -> true | (false,false) -> false let mul a b = match a,b with | (true,true) -> true | (true,false) -> false | (false,true) -> false | (false,false) -> false let neg a = match a with | true -> true | false -> false let inv a = match a with | true -> true | false -> false end ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let helper_next_cell curr = let (x_cord, y_cord, direction) = curr in match direction with | MazeGen.West -> (x_cord-1, y_cord, direction) | MazeGen.North -> (x_cord, y_cord-1, direction) | MazeGen.East -> (x_cord+1, y_cord, direction) | MazeGen.South -> (x_cord, y_cord+1, direction) in in in let start_y = height - 1 in let (right, front, left) = MazeGen.dirs_to_check MazeGen.North in let rec aux curr sc fc = let (x_cord, y_cord, dir) = helper_next_cell curr in let (right, front, left) = MazeGen.dirs_to_check dir in else let sc1 = fun r -> sc (dir::r) in let fc1 = (fun () -> aux (x_cord, y_cord, front) (fun r -> sc (dir::r)) (fun () -> aux (x_cord, y_cord, left) (fun r -> sc (dir::r)) fc)) in aux (x_cord, y_cord, right) sc1 fc1 in aux (start_x, start_y, right) (fun r -> r) (fun () -> aux (start_x, start_y, front) (fun r -> r) (fun () -> aux (start_x, start_y, left) (fun r -> r) (fun() -> [])))   ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match seq1 (), seq2 () with | Seq.Nil, _ -> Seq.empty | _, Seq.Nil -> Seq.empty | Seq.Cons (hd1, tl1), Seq.Cons (hd2, tl2) -> fun () -> Seq.Cons ((hd1, hd2), zip tl1 tl2) let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = match seq () with | Seq.Nil -> Seq.empty | Seq.Cons (hd, tl) -> if p hd then Seq.empty else fun () -> Seq.Cons (hd, keep_until p tl) let to_list (seq : 'a seq) : 'a list = match seq () with | Seq.Nil -> [] | Seq.Cons (hd, tl) -> let ref_list = ref [] in let take_ele x = ref_list := (!ref_list@[x]) in Seq.iter take_ele seq; !ref_list let range (start : int) (step : int) (stop : int) : int seq = if step = 0 then raise (Invalid_argument \"The step value cannot be zero!\") else if start >= stop && step > 0 then raise (Invalid_argument \"Stuck in infinite loop!\") else if start <= stop && step < 0 then raise (Invalid_argument \"Stuck in infinite loop!\") else let update x = start + x*step in let result = map update nats in if stop > 0 then keep_until (fun x -> x >= stop) result else keep_until (fun x -> x <= stop) result end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let zero = {num = 0; den = 1} let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let neg a = if equal a zero then zero else let negative = {num = (-a.num); den = a.den} in negative  let inv a = if equal a zero then raise NotImplemented else let inverse = {num = a.den; den = a.num} in inverse  let add a b = if equal a zero then b else if equal b zero then a else if equal b (neg a) then zero else let result = {num = (a.num * b.den + a.den * b.num); den = a.den * b.den} in result  let mul a b = if equal a one then b else if equal b one then a else if equal b (inv a) then one else let result = {num = a.num * b.num; den = a.den * b.den} in result  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false let one = true  let equal = (=)  let neg a = if equal a zero then zero else one  let inv a = if equal a one then one else zero  let add a b = if equal a zero then b else if equal b zero then a else zero  let mul a b = if equal a one then b else if equal b one then a else if equal a one && equal b one then one else zero end ;; ",
  "let solve_maze (maze : MazeGen.maze ) : MazeGen.dir list = let (x0, y0) = (MazeGen.dims maze) in let (dir : MazeGen.dir) = let open MazeGen in West in let (curr_state : MazeGen.state) = (x0-1, y0-1, dir) in let rec solve_maze_cont explore_next (go_back) explored steps states curr_state= let (x,y,orientation) = curr_state in let (right, front, left) = let open MazeGen in (MazeGen.dirs_to_check orientation) in if (x,y) = (0,0) then steps else match explored with | [] -> (if (MazeGen.has_wall maze (x,y,right)) then solve_maze_cont explore_next (go_back) [right] steps states curr_state else solve_maze_cont explore_next (go_back) [] (right::steps) (curr_state::states) (explore_next curr_state right) ) | [right] -> (if (MazeGen.has_wall maze (x,y,front)) then solve_maze_cont explore_next (go_back)  [right; front] steps states curr_state else solve_maze_cont explore_next (go_back)  [] (front::steps) (curr_state::states) (explore_next curr_state front) ) | [right; front] ->(if (MazeGen.has_wall maze (x,y,left)) then (let (arg1, arg2, arg3, arg4) = (go_back explored steps states curr_state) in solve_maze_cont explore_next (go_back) arg1 arg2 arg3 arg4) else solve_maze_cont explore_next (go_back) [] (left::steps) (curr_state::states) (explore_next curr_state left) ) in let explore_next = (fun (x,y,o) (dir : MazeGen.dir) -> match dir with | MazeGen.North -> (x,y-1, dir) | MazeGen.West -> (x-1,y, dir) | MazeGen.East -> (x+1,y, dir) | MazeGen.South -> (x,y+1, dir) )  in let rec go_back = ( fun explored (step::steps) ((x,y,orientation)::states) curr -> let (right, front, _) = let open MazeGen in dirs_to_check orientation in if step=right then ([step], steps, states, (x,y,orientation)) else if step = front then ([right; step], steps, states, (x,y,orientation)) else go_back [right; front; step] steps states (x,y,orientation) )in List.rev ( solve_maze_cont explore_next (go_back) [] [] [] curr_state ) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = fun () -> match seq1 (), seq2 () with | Cons(hd1 , tl1), Cons(hd2 , tl2) -> Cons((hd1, hd2),zip tl1 tl2) | _ -> Nil   let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = fun () -> match seq () with | Nil -> Nil | Cons(hd , tl) -> if p hd then Nil else Cons(hd, keep_until p tl)  let to_list (seq : 'a seq) : 'a list = let rec aux seq acc = match seq () with | Cons(hd , tl) -> aux tl (hd::acc) | Nil -> acc in List.rev (aux seq [])  let range (start : int) (step : int) (stop : int) : int seq = if abs ((stop-start)/step) >= max_int then raise (Invalid_argument \"Range exceeds maximum length.\") else begin let first = if step>0 then start else -start in let last = if step>0 then stop else -stop in let p x = x >= last in let steps x = (abs x mod abs step) = 0 in let f x = x + first in let g x = if step>0 then x else -x in let seq = let open Seq in map f (filter steps nats) in map g (keep_until p seq) end end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational let zero = { num = 0; den = 1 } let one = { num = 1; den = 1 } let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add a b = if a.den = b.den then { num = a.num + b.num; den = a.den } else { num = a.num*b.den + b.num*a.den; den = a.den*b.den }  let mul a b= { num = a.num*b.num; den = a.den*b.den } let neg a = { num = -a.num; den = a.den } let inv a = { num = a.den; den = a.num } end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool  let zero = false  let one = true  let equal = (=)  let add a b = (not a && b) || (a && not b)  let mul = (&&)  let neg a = a  let inv a = a end ;; ",
  "module EllipticCurves (F : AlgField) : sig type point = F.t * F.t val easyECs : bool val onCurve : F.t -> F.t -> point -> bool end = struct type point = F.t * F.t let easyECs = not (F.equal (F.add F.one F.one) F.zero) && not (F.equal (F.add (F.add F.one F.one) F.one) F.zero) ;; ",
  "let onCurve p q (x, y) = F.equal (F.mul y y) (F.add (F.add (F.mul x (F.mul x x)) (F.mul p x)) q) ;; ",
  "end ;; ",
  "module Rational_EC = EllipticCurves(RationalField);; ",
  "module Boolean_EC = EllipticCurves(BooleanField);; ",
  "module Float_EC = EllipticCurves(FloatField) ;; ",
  "let solve_maze (maze : MazeGen.maze) : MazeGen.dir list = let (w, h) = MazeGen.dims maze in let next_cell (state : MazeGen.state) : MazeGen.state = let (x, y, d) = state in match d with | MazeGen.West  -> (x - 1, y, d) | MazeGen.North -> (x, y - 1, d) | MazeGen.East  -> (x + 1, y, d) | MazeGen.South -> (x, y + 1, d) in let rec solve_maze_with_cont (maze : MazeGen.maze) (cur_state : MazeGen.state) (success : unit -> MazeGen.dir list) (fail : unit -> MazeGen.dir list) : MazeGen.dir list = match cur_state with | (0, 0, _) -> success () | (x, y, d) -> let (d1, d2, d3) = MazeGen.dirs_to_check d in match (MazeGen.has_wall maze (x, y, d1), MazeGen.has_wall maze (x, y, d2), MazeGen.has_wall maze (x, y, d3)) with | (false, false, false) -> solve_maze_with_cont maze (next_cell (x, y, d1)) (fun () -> (success ()) @ [d1]) (fun () -> solve_maze_with_cont maze (next_cell (x, y, d2)) (fun () -> (success ()) @ [d2]) (fun () -> solve_maze_with_cont maze (next_cell (x, y, d3)) (fun () -> (success ()) @ [d3]) fail)) | (true, false, false)  -> solve_maze_with_cont maze (next_cell (x, y, d2)) (fun () -> (success ()) @ [d2]) (fun () -> solve_maze_with_cont maze (next_cell (x, y, d3)) (fun () -> (success ()) @ [d3]) fail) | (false, true, false)  -> solve_maze_with_cont maze (next_cell (x, y, d1)) (fun () -> (success ()) @ [d1]) (fun () -> solve_maze_with_cont maze (next_cell (x, y, d3)) (fun () -> (success ()) @ [d3]) fail) | (false, false, true)  -> solve_maze_with_cont maze (next_cell (x, y, d1)) (fun () -> (success ()) @ [d1]) (fun () -> solve_maze_with_cont maze (next_cell (x, y, d2)) (fun () -> (success ()) @ [d2]) fail) | (true, true, false)   -> solve_maze_with_cont maze (next_cell (x, y, d3)) (fun () -> (success ()) @ [d3]) (fun () -> fail ()) | (false, true, true)   -> solve_maze_with_cont maze (next_cell (x, y, d1)) (fun () -> (success ()) @ [d1]) (fun () -> fail ()) | (true, false, true)   -> solve_maze_with_cont maze (next_cell (x, y, d2)) (fun () -> (success ()) @ [d2]) (fun () -> fail ()) | (true, true, true)    -> fail () in let start_state = (w - 1, h - 1, MazeGen.North) in solve_maze_with_cont maze start_state (fun () -> []) (fun () -> []) ;; ",
  "let test_maze width height = let maze = MazeGen.random width height in let path = solve_maze maze in print_string (MazeGen.string_of_maze ~path maze) ;; ",
  "module Range : RangeSig = struct open Seq let rec zip (seq1 : 'a seq) (seq2 : 'b seq) : ('a * 'b) seq = match (seq1 ()) with | Nil -> empty | Cons (e1, s1) -> match (seq2 ()) with | Nil -> empty | Cons (e2, s2) -> fun () -> (Cons ((e1, e2), (zip (s1) (s2))))  let rec keep_until (p : 'a -> bool) (seq : 'a seq) : 'a seq = let seqNode = seq () in match seqNode with | Nil -> empty | Cons (e, s) -> if (not (p e)) then fun () -> (Cons (e, keep_until p s)) else empty  let to_list (seq : 'a seq) : 'a list = let rec aux seq' = let seqNode = seq' () in match seqNode with | Nil -> [] | Cons (e, s) -> e :: (aux s) in aux seq let range (start : int) (step : int) (stop : int) : int seq = if (step = 0) then raise (Invalid_argument \"The step size cannot be zero.\") else let scaledSeq = map (( * ) step) nats in let translatedSeq = map ((+) start) scaledSeq in if (step > 0) then keep_until (fun n -> n >= stop) translatedSeq else keep_until (fun n -> n <= stop) translatedSeq end ;; ",
  "let range ?(start : int = 0) ?(step : int = 1) (stop : int) : int seq = Range.range start step stop ;; ",
  "let example_ranges () = [ range 10; range ~start:5 10; range ~step:2 20; range ~start:100 ~step:(~-2) 50 ] ;; ",
  "module RationalField : (AlgField with type t = rational) = struct type t = rational  let one = {num = 1; den = 1}  let equal a b = a.den <> 0 && b.den <> 0 && a.den * b.num = a.num * b.den  let add r1 r2 = let n1 = r1.num * r2.den in let n2 = r2.num * r1.den in {num = (n1 + n2); den = (r1.den * r2.den)}  let mul r1 r2 = {num = (r1.num * r2.num); den = (r1.den * r2.den)}  let neg r = {num = (-r.num); den = r.den}  let inv r = {num = r.den; den = r.num}  end ;; ",
  "module BooleanField : (AlgField with type t = bool) = struct type t = bool let zero = false let one = true  let equal = (=)  let add = (<>)  let mul = (&&)  let neg b = b  let inv b = b  end ;; "
]