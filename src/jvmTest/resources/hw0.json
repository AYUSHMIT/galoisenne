[
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.) ); ( (((-1), (-2)), (2, 2)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((1, 2), (3, 4)), (sqrt 8.) ); ( (((-3), (-4)), ((-2), (-1))), (sqrt 10.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int dx *. float_of_int dx +. float_of_int dy *. float_of_int dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (10, 1023); (31, 2147483647); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi_helper n m = if n = 1 then m else hanoi_helper (n-1) (m * 2 + 1) in if n < 1 then domain() else hanoi_helper n 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); ] ;; ",
    "let fact (n: int): float = let rec fact_helper n m = if n=0 then m else fact_helper (n-1) (float_of_int n *. m) in if n < 0 then domain() else fact_helper n 1. ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (7, 16); (9, 19); (15, 17); (18, 20); (27, 111); (28, 18); (77031, 350); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.5, 1.3414872572509171797567696933486121366230376295059865112537); (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (10.3, 1.0008061000784172493718609457989861910170942821267106740787); (40., 1.0000000000009094947840263889282533118386949087538600009908788285); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let m = n ** (0.-.k) in if m < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. m) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.0)) ); ( ((1,1), (1,1)), (0.0)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * (hanoi (n - 1)) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (0, 1.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. (float n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7); (4,2) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2 == 0) then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (5.,1.0369277551433699263313654864570341680570809195019128119741926779); (8.,1.0040773561979443393786852385086524652589607906498500203291102026 ) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ((float n) ** (-. k)) < acc then sum_so_far else approx_zeta k acc (n+1) (sum_so_far +. (float n) ** (-. k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1,1),(4,5)),(5.) ); ( ((1,1),(6,13)), (13.) ); ( ((0,0),(0,0)), (0.) );  ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in let xs = dx*dx in let ys = dy*dy in let floatx = float_of_int(xs) in let floaty = float_of_int(ys) in sqrt (floatx +. floaty) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3,7) ; ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.) ; (5,120.); (4,24.); (0,1.); ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1.0 else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7); (4,2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then (steps_so_far) else if  n mod 2 = 0 then collatz_helper (n/2)  (steps_so_far +1) else collatz_helper (3*n+1) (steps_so_far + 1)  ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    " let zeta_tests = [ (3.,1.2020569031); (50.,1.00000000000); (25.,1.000000029); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1.0/.float_of_int(n)**(k)) <= epsilon_float then sum_so_far else approx_zeta (k) (acc) (n+1) (sum_so_far +. (1.0/.float_of_int(n)**(k))) in if k < 2. then infinity else approx_zeta k epsilon_float (1) (0.) ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237) );  ( ((0, 0), (0, 0)), (0.) ); ( ((2, 3), (2, 3)), (0.) ); ( ((0, 0), (0, 1)), (1.) );  ( ((2, 3), (5, 7)), (5.) ); ( ((2, 3), (5, -7)), (10.4403065089) ); ( ((2, 3), (-5, 7)), (8.0622577483) ); ( ((2, 3), (-5, -7)), (12.2065556157) );  ( ((2, -3), (5, 7)), (10.4403065089) ); ( ((2, -3), (5, -7)), (5.) ); ( ((2, -3), (-5, 7)), (12.2065556157) ); ( ((2, -3), (-5, -7)), (8.0622577483) );  ( ((-2, 3), (5, 7)), (8.0622577483) ); ( ((-2, 3), (5, -7)), (12.2065556157) ); ( ((-2, 3), (-5, 7)), (5.) ); ( ((-2, 3), (-5, -7)), (10.4403065089) );  ( ((-2, -3), (5, 7)), (12.2065556157) ); ( ((-2, -3), (5, -7)), (8.0622577483) ); ( ((-2, -3), (-5, 7)), (10.4403065089) ); ( ((-2, -3), (-5, -7)), (5.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (10, 1023); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 0 then domain () else if n = 1 then 1 else 1 + 2 * hanoi (n-1) ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (3, 6.); (6, 720.); (20, 2432902008176640000.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. (float_of_int n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); (8, 3); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.6449340668482264364724151666460251892189499012067984377355582293); (2., 1.6449340516623121); (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (10., 1.0009945751278180853371459589003190170060195315644775172577889946); (5.5, 1.0252045799546856945924058281954052930788488933034108218222664804); (exp 1., 1.2690096043357171157655698666008611088564044625771904883358159287) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let nextTerm = n ** (-. k) in if nextTerm < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. nextTerm) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in let x = (dx * dx + dy * dy) in let y = sqrt (float_of_int x) in y ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 0 then domain () else if n = 0 then 0 else if n = 1 then 1 else ((hanoi(n-1) * 2 + 1)) ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (5, 5); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 0 then domain() else if n = 0 then 1 else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1./.n ** k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. 1./.n ** k ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.0) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ) ; ( ((1, 5), (2, 9)), (4.123106) ); ( ((0, 0), (0, 0)), (0.0) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi n= if n <= 1 then 1 else hanoi (n-1) * 2 + 1 in hanoi n ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0,1.); ] ;; ",
    "let rec fact (n: int): float = if n=0 then 1.0 else float_of_int(n)*.fact(n-1)  ;; ",
    "let collatz_tests = [ (1,0) ; (2,1) ; (3,7) ; ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n>1 && n mod 2=0 then collatz_helper (n/2) (steps_so_far+1) else if n=1 then steps_so_far else collatz_helper (3*n+1) (steps_so_far+1)       ;; ",
    "let collatz (n: int) : int = collatz_helper n 0     ;; ",
    "let zeta_tests = [ (2.,1.6449); (3.0,1.202); (4.0,1.0823); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if acc> 1.0/. n**(k) then sum_so_far else approx_zeta (k) (epsilon_float) (n +.1.0) (sum_so_far+.1.0/. n**(k))   in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((-2, 0), (1, -3)), (4.24264068711928477) ); ( ((0, 0), (0, 0)), (0.0) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int(x1) -. float_of_int(x2) in let dy = float_of_int(y1) -. float_of_int(y2) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (8, 255); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1. else float_of_int n *. fact (n-1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (5, 5); (29384839,175); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "exception Domain;; ",
    "let collatz (n: int) : int = if n <= 0 then raise Domain else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (4., 1.08232323371051709); (5.12939823, 1.03342138347723611); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n ** (-. k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n ** (-. k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ( ((0, 0), (0, 0)), (0.) ); ( ((-1, 0), (1, 2)), (sqrt(8.)) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let hanoi (n: int) : int = let rec helper n acc = if n <= 1 then acc else helper (n-1) (2 * acc + 1 ) in helper n 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let fact (n: int): float = let rec helper n acc = if n <= 0 then float_of_int(acc) else helper (n-1) (acc * n) in helper n 1 ;; ",
    "let collatz_tests = [ ( (4), (2) ); ( (1), (0) ); ( (2), (1) ); ( (5), (5) ); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 1 then collatz_helper (3 * n + 1) (steps_so_far + 1) else collatz_helper (n / 2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ ( (3.), (1.20205) ); ( (5.0, 1.03692) ) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-. k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n ** (-. k) ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((3, 5), (9, 1)), (7.211103) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = abs (x2 - x1) in let dy = abs (y2 - y1) in sqrt (float dx *. float dx +. float dy *. float dy);; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 0 then domain () else if n = 0 then 0 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if float n = 0. then 1. else fact (n - 1) *. float n ;; ",
    "let collatz_tests = [ (1, 0 ); (2, 1 ); (3, 7 ); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n <= 0 then domain() else if n == 1 then steps_so_far else if (n mod 2 == 0) then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017 ); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. (n ** k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (1. /. (n ** k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((3, 1), (9, 9)), (10.) ); ( ((5, 12), (0, 0)), (13.) ); ( ((2, 5), (7, 3)), (5.38516480713450374) ); ( ((1, 1), (1, 1)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (4,2); (10, 6); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2 = 1) then collatz_helper (3 * n + 1) (steps_so_far + 1) else collatz_helper (n / 2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (10., 1.00099457512781753); (2.1, 1.56021652764539853) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n**(0. -. k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n**(0. -. k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.4142135) ); ( ((0, 0), (0, 0)), (0.)) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy))  ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain() else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain() else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (2, 1); (8, 3); (3, 7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n < 1 then domain() else if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n : int) : int = collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ (2., 1.645); (3., 1.202) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-. k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (n ** (-. k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); (((0, 0), (0, 0)), (0.)) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let hanoi (n: int) : int = let rec h n = if n = 1 then 1 else (h (n-1)) * 2 + 1 in if n < 1 then domain() else h n ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if  n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n +1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569); (4., 1.0823232); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-.k) < acc then sum_so_far +. n ** (-.k) else approx_zeta k acc (n +.1.) (sum_so_far +. n ** (-.k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.414213562) ); ( ((1, 1), (0, 0)), (1.414213562) ); ( ((2, 5), (8, 3)), (6.32455532) ); ( ((7, 1), (2, 2)), (5.099019514) );  ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int(x1 - x2) in let dy = float_of_int(y1 - y2) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31);  ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (5, 120.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if float_of_int(n) < 0. then domain () else if float_of_int(n) = 0. then 1.0 else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (7, 16); (12, 9); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3*n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942854); (3.319682, 1.14921518384761611546775789); (5., 1.03692775514337); (6.865, 1.0092060532811162246); (8., 1.00407735619794434);  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let to_add = n ** (-. k) in if to_add < acc then sum_so_far else approx_zeta k epsilon_float (n +. 1.) (sum_so_far +. to_add) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421) ); ( ((3, 2), (5, -1)), (3.60555) ); ( ((6, 2), (-3, -5)), (11.4018) ); ( ((0, 0), (0, 0)), (0.) ); ( ((4, 7), (4, 7)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (7, 127); (10, 1023) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n=1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (7, 5040.); (10, 3628800.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 || n = 1 then 1. else float_of_int(int_of_float(fact (n - 1)) * n) ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (7, 16); (20, 7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n < 1 then domain() else if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (10., 1.00099457512781808533714595890031901700601953156447751725778899); (1000., 1.000000000000000000000000000000000000000000000000000000000000) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-.k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n ** (-.k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 2), (5, 5)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (8, 255);  ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi' n = if n = 1 then 1 else 2 * hanoi' (n-1) + 1 in if n < 1 then domain () else hanoi' n ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (6, 720.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (3, 7); (1, 0); (8, 3); (500, 110); (337, 112);  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n == 1 then steps_so_far else if ((n mod 2) == 0) then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper ((3*n)+1) (steps_so_far +1)   ;; ",
    "let collatz (n: int) : int = if n == 1 then 0 else if ((n mod 2) == 0) then collatz_helper (n/2) 1 else collatz_helper ((3*n)+1) 1 ;; ",
    "let zeta_tests = [ (3., 1.20205690315959429); (8., 1.00407735619794434);  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ((n**(-1. *. k)) < acc) then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far+.(n**(-1. *. k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (18, 262143) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then n else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (8, 40320.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else float(n) *. fact (n - 1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (97, 118) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n + 1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (4.5, 1.05471); (5., 1.0369277551433699263313654864570341680570809195019128119741926779); (6.7, 1.01038); (10., 1.0009945751278180853371459589003190170060195315644775172577889946) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. n**k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +.(1. /. n**k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((8, 7), (2, 4)), (6.70820393249936942) ); ( ((9, 1), (9, 9)), (8.) ); ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then  1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (4, 24.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (2, 1); (1, 0); (3, 7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far +1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ (3., 1.20205690315959428); (4., 1.08232323371113819); (5., 1.03692775514336992) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1./.(n**k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (1./.(n**k)))  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.0) ); ( ((0, 0), (1, 1)), (sqrt(2.0)) ); ( ((0, 0), (0, 0)), (0.0) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float x1 -. float x2 in let dy = float y1 -. float y2 in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (10,1023) ] ;; ",
    "let rec hanoi (n: int) : int = if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (0, 1.); (5, 120.) ] ;; ",
    "let rec fact (n: int): float = if n = 0 then 1.0 else float n *. fact(n-1) ;; ",
    "let collatz_tests = [ (7, 16); (9, 19); (1, 0) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3.0,1.20205690314079017); (5.0,1.0369277551433699); (7.0,1.00834927738192282); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. n ** k < acc) then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. 1. /. n ** k) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float (x2 - x1) in let dy = float (y2 - y1) in sqrt (dx ** 2. +. dy ** 2.) ;; ",
    "let hanoi_tests = [ (1, 1); (3, 7) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else float (int_of_float (fact (n - 1)) * n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (4,2); (3,7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020509632) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1. /. (n ** k) < acc then sum_so_far else approx_zeta k epsilon_float (n +. 1.) (sum_so_far +. 1. /. (n ** k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); (((0,0), (0,0)), (0.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 1), (10, 15)), (16.6433169770932388) ); ( ((-3, -4), (0, 0)), (5.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x2 - x1) in let dy = float_of_int (y2 - y1) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (16, 65535); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1. else fact ( n - 1 ) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (9, 19); (27, 111); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 <> 0 then collatz_helper (3 * n + 1) (steps_so_far + 1) else collatz_helper (n/2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 1 then 0 else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (4., 1.08232323371051709); (6., 1.01734306198443); (5.3, 1.02933220568317285); (7., 1.00834927738191671); (100., 1.); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let add = (n **(~-.k)) in if add < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. add) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((4, 5), (6, 9)), (4.47213595499958) ); ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx =  (x2 - x1) in let dy =  (y2 - y1) in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (4, 24.) ] ;; ",
    "let rec fact (n: int): float = if float_of_int(n) < 0. then domain () else if float_of_int(n) <= 1. then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (4, 2); (12, 9) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n != 1 then if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3 * n + 1) (steps_so_far+1) else steps_so_far ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (2., 1.6449340668482264364724151666460251892189499012067984377355582293) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1. /. (n ** k) < acc then sum_so_far else approx_zeta (k) (acc) (n +. 1.) (sum_so_far +. (1. /. (n ** k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ( ((1, 1), (1, 1)), (0.) ); ( ((0, 1), (2, 3)), (2. *. sqrt(2.)) ); ( ((1, 10), (100, 1000)), (99. *. sqrt(101.)) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (14, 17) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.6449340668482264); (3., 1.2020569031595942) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-.k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) ( sum_so_far +. n ** (-.k) ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 2)), (sqrt(5.)) ); ( ((1, 2), (1, 2)), (0.)) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in let prod_dx = float_of_int (dx * dx) in let prod_dy = float_of_int (dy * dy) in sqrt (prod_dx +. prod_dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (16, 65535) ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else (2 * hanoi(n-1)) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (2, 1); (6, 8); (9, 19); (1, 0) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1)  ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.202056903); (2.8, 1.24703) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. (n ** k)) -. (1. /. ((n +. 1.) ** k)) < acc then sum_so_far else approx_zeta k (epsilon_float) (n +. 1.) (sum_so_far +. (1. /. (n ** k))) in approx_zeta k (epsilon_float) 1. 0.; if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (-1, -1)), (1.4142) ); ( ((-2, -1), (2,2)), (5.) ); ( ((2,2), (-4, -1)), (6.7082) ); ( ((-2, -1), (-4, -1)), (2.) ); ( ((-7, -4), (17, 62)), (70.2282) ); ( ((0, 0), (0, 0)), (0.));   ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x1 - x2) in let dy = float_of_int (y1 - y2) in sqrt (((dx *. dx)) +. ((dy *. dy))) ;; ",
    "let hanoi_tests = [ (1, 1); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); (9, 511); (10, 1023); ] ;; ",
    "let rec hanoi (n: int) : int = if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); (8, 40320.); (9, 362880.); (10, 3628800.); (11, 39916800.); (12, 479001600.); ] ;; ",
    "let rec fact (n: int): float = if n = 0 then 1. else float_of_int (n) *. fact(n-1) ;; ",
    "let collatz_tests = [ (5, 5); (21, 7); (15, 17); (35, 13); (1, 0); (7, 16); (2, 1); (3, 7); (10, 6) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 1 then collatz_helper ((n*3) +1) (steps_so_far + 1) else collatz_helper (n/2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then (-1) else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020); (4., 1.0823); (5., 1.0369); (7., 1.0083); (6., 1.0173) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta (k: float) acc n sum_so_far = let tmp = n**(-.k) in if (tmp < acc) then sum_so_far else approx_zeta k (acc) (n+.1.) (sum_so_far +. tmp) in if k < 2. then (-1.) else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int x2 -. float_of_int x1 in let dy = float_of_int y2 -. float_of_int y1 in sqrt ((dx *. dx) +. (dy *. dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (10, 1023); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else 1 + (2 * hanoi (n-1)) ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n < 1 then 1. else (fact (n - 1)) *. float_of_int n ;; ",
    "exception Domain;; ",
    "let collatz_tests = [ (1, 0); (12, 9); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper ((3 * n) + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3. , 1.20205); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n ** (-1. *. k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (n ** (-1. *. k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.) ); ( ((0, 0), (6, 8)), (10.) ); ( ((1, 1), (2, 2)), (sqrt 2.) ); ( ((2, 2), (2, 2)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let hanoi (n: int) : int = if n < 1 then domain () else let rec hanoin acc c n = if c = n then acc else hanoin (2*acc + 1) (c+1) n in hanoin 1 1 n ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = let x = (float_of_int n) in if x < 0. then domain () else if x <= 1. then 1. else fact (int_of_float (x -. 1.)) *. x ;; ",
    "let collatz_tests = [ (1, 0) ; (2, 1) ; (20, 7); (5, 5); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 1 then collatz_helper (3*n+1) (steps_so_far + 1) else collatz_helper (n/2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain()  else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1./.n**k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (1./.n**k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt (2.)) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt(float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (8,255) ] ;; ",
    "let rec hanoi (n: int) : int = if n = 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n = 1 then 1. else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (6,8); (11,14); (27,111); (1,0) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else collatz_helper (if n mod 2 == 1 then 3 * n + 1 else n / 2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690315959424); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1. /. (n ** k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (1. /. (n ** k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt ((float_of_int ((dx * dx) + (dy * dy)) )) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (10, 1023); (24, 16777215); ] ;; ",
    "let rec hanoi (n : int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. (float_of_int n) ;; ",
    "let collatz_tests = [ (1,0); (2, 1); (12,9); (11,14); (255, 47) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if ((n mod 2) = 0) then collatz_helper (n/2) (1 + steps_so_far) else collatz_helper (n*3 + 1) (1 + steps_so_far) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0; ;; ",
    "let zeta_tests = [ (2., 1.64493406684822644); (3., 1.20205690315959428); (12.,1.00024608655330805); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next = 1. /. (n ** k) in if (next < acc) then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.4142135) ); ( ((1, 1), (1, 1)), (0.) ); ( ((0, 1), (5, 1)), (5.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x1) -. float_of_int (x2)  in let dy = float_of_int (y1) -. float_of_int (y2)  in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi_helper n  acc= if n < 1 then acc else hanoi_helper (n-1) (2*acc + 1) in hanoi_helper n  0 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (10, 3628800.); (0, 1.); (5, 120.);  ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1. else fact (n-1) *. (float)n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (123,46); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then (steps_so_far) else if n mod 2 = 0 then (collatz_helper (n / 2) (steps_so_far + 1)) else (collatz_helper ((3 * n) + 1) (steps_so_far + 1)); ;; ",
    "let collatz (n: int) : int = collatz_helper (n) (0) ;; ",
    "let zeta_tests = [  (2., 1.6449); (4., 1.0823); (6., 1.0173); (8., 1.00407);   ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. (n **k)) < acc then sum_so_far else approx_zeta (k) (acc) (n +. 1.) (sum_so_far +. 1. /. (n ** k)) in if k < 2. then 1. else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1- y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (2, 3); (3,7); (4,15) ] ;; ",
    "let rec hanoi (n: int) : int =  if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0,1.); (1, 1.); (2, 2.); (3,6.); (4,24.); ] ;; ",
    "let rec fact (n: int): float = let float_n = float_of_int(n) in if n < 0 then domain () else if n = 0 then 1. else if n = 1 then 1. else fact (int_of_float((float_n -. 1.))) *. float_n  ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) == 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain()else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.,1.64493); (3.,1.2020569) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-. k) <= acc then sum_so_far else approx_zeta (k) (acc) (n+.1.) (sum_so_far+. (n ** (-. k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)): float = if x1<0 || x2<0 || y1<0 || y2<0  then domain () else let dx = float (x1 - x2) in let dy = float (y1 - y2) in sqrt (dx ** 2. +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n=1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = let m = float (n) in if n < 0 then domain () else if n=0 then 1. else fact(n - 1) *. m ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = match n with | 1 -> steps_so_far | n -> if n mod 2 = 0  then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1); ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0; ;; ",
    "let zeta_tests = [ (2., 1.6449340516623121); (4., 1.08232323371051709); (5., 1.03692775514329338); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let valueAdd = n ** (-1. *. k) in if(valueAdd<acc) then sum_so_far else approx_zeta k acc (n +.1.) (sum_so_far +. valueAdd) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 4), (7, 5)), (6.08276253029821934) ); ( ((1, 6), (5, 7)), (4.12310562561766059) ); ( ((1, 0), (1, 0)), (0.0) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx : float =  float_of_int (x2) -. float_of_int (x1)  in let dy : float = float_of_int (y2) -. float_of_int (y1) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (2, 3); (4, 15); (5, 31); (1, 1); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (4, 24.); (3, 6.); (10, 3628800.0); (0, 1.);  ] ;; ",
    "let rec fact (n : int ): float = if n < 0 then domain () else if n = 0 then 1.0 else fact ( n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1 , 0); (2, 1); (7, 16); (27, 111); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2 = 0) then collatz_helper  (n/2) (steps_so_far + 1) else collatz_helper (3*n +1) (steps_so_far +1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n  0 ;; ",
    "let zeta_tests = [ (3., 1.202); (4., 1.0823); (10., 1.00099);  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n)**(-1. *. k) <= acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (n)**(-1. *. k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0),(0, 0)), (0.) ); ( ((2,3),(6,6)),( 5.)); ( ((-1,-1),(-2,-2)),(1.41421356237309515) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = (x1 - x2) in let dy = (y1 - y2) in sqrt( float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4,15); (5,31);  ] ;; ",
    "exception Domain let  rec hanoi (n: int) : int = if n < 1 then domain() else if n==1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0,1.); (1, 1.); (2, 2.); (10,3628800.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain() else if n==0 then 1.0  else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (5,5); (6,8); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n==1 then steps_so_far else if n mod 2==0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n + 1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n<1 then domain() else collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ (3.,1.20205690314079017); (4.,1.08232323371051709); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n**(-.k) < acc then sum_so_far else approx_zeta (k) (acc) (n+.1.) (sum_so_far+.n**(-.k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.0) ); ( ((0, 0), (1, 1)), (1.4142135) );   ( ((0, 0), (0, 0)), (0.0) );  ( ((0, 0), (1, 1)), (1.414213562373095048801688724209698078569671875376948) ); ( ((1, 4), (3, -2)), (6.32455532033675866399778708886543706743911027865043) ); ( ((2, 3), (-2, 3)), (4.0) ); ( ((3, 2), (-1, -4)), (7.2111025509279785862384425349409918925025931476904) ); ( ((4, -1), (4, 1)), (2.0) ); ( ((1, -4), (3, -2)), (2.8284271247461900976033774484193961571393437507538) ); ( ((2, -3), (-2, 3)), (7.2111025509279785862384425349409918925025931476904) ); ( ((3, -2), (-1, -4)), (4.472135954999579392818347337462552470881236719223) ); ( ((-4, 1), (4, 1)), (8.0) ); ( ((-1, 4), (3, -2)), (7.2111025509279785862384425349409918925025931476904) ); ( ((-2, 3), (-2, 4)), (1.0) ); ( ((-3, 2), (-1, -4)), (6.324555320336758663997787088865437067439110278650) ); ( ((-4, -1), (4, 1)), (8.2462112512353210996428197119481540502943984507472) ); ( ((-1, -4), (3, -2)), (4.472135954999579392818347337462552470881236719223) ); ( ((-2, -3), (-2, 3)), (6.0) ); ( ((-3, -2), (-1, -4)), (2.82842712474619009760337744841939615713934375075) );  ( ((1, 2), (5, 7)), (6.403124237432848686488217674621813264520420132621018) ); ( ((-3, -3), (-7, -11)), (8.9442719099991587856366946749251049417624734384) ); ( ((-1, 2), (4, -11)), (13.92838827718411933846773892851329370619439640611) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt(float_of_int(dy * dy + dx * dx)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); (9, 511); (10, 1023); (11, 2047); (12, 4095); (13, 8191); (14, 16383); (15, 32767); (16, 65535); (17, 131071); (18, 262143); (19, 524287); (20, 1048575); (21, 2097151); (22, 4194303); (23, 8388607); (24, 16777215); (25, 33554431); (26, 67108863); (27, 134217727); (28, 268435455); (29, 536870911); (30, 1073741823); (31, 2147483647); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain (); if n = 1 then 1 else 2 * hanoi (n - 1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); (8, 40320.); (9, 362880.); (10, 3628800.); (11, 39916800.); (12, 479001600.); ] ;; ",
    "let rec fact (n: int): float = if (n < 0) then domain (); if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); (7, 16); (8, 3); (9, 19); (10, 6); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if ( n mod 2 = 0) then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if (n <= 0) then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.0, 1.6449340668482264364724151666460251892189499012067984377355582293); (3.0, 1.2020569031595942853997381615114499907649862923404988817922715553); (4.0, 1.0823232337111381915160036965411679027747509519187269076829762154); (4.673473, 1.047662269962506385438390531629636347801476762300051116815491827); (5.0, 1.0369277551433699263313654864570341680570809195019128119741926779); (6.0, 1.0173430619844491397145179297909205279018174900328535618424086640); (6.483481, 1.012151705587764714163443389343407708973164920962765771235010036); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let nextFraction = 1. /. exp(k *. log(n)) in if (acc > nextFraction) then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. nextFraction) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.0)  ); ( ((0, 0), (0, 0)), (0.)  ); ( ((1, 1), (1, 1)), (0.)  ); ( ((-231, 1), (1, -3431)), (3439.8325540642236)  ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let d1 = float_of_int x1 -. float_of_int x2 in let d2 = float_of_int y1 -. float_of_int y2 in sqrt (d1 *. d1 +. d2 *. d2) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (10, 1023); ] ;; ",
    "let hanoi (n: int) = if n < 1 then domain () else let rec hanoi_helper m acc = else hanoi_helper (m-1) (2*acc + 1) in hanoi_helper n 1   let fact_tests = [ (1, 1.); (3, 6.); (7 , 5040.); (0, 1.) ] ;; ",
    "let fact (n: int): float = if n < 0 then domain () else let n = float_of_int n in let rec fact_helper m acc = if m = 0. then acc else fact_helper (m -. 1.) (acc *. m) in fact_helper n 1.  let collatz_tests = [ (2,1); (3,7); (27, 111); (871, 178); (1, 0); ] ;; ",
    "let collatz_helper (n: int) (steps_so_far: int) : int = let rec collatz_acc m acc = else if (m mod 2) = 0 then collatz_acc (m/2) (acc+1) else collatz_acc (3*m + 1) (acc+1) in collatz_acc n 0 ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0  let zeta_tests = [ (2., 1.6449340668482264364724151666460251892189499012067984377355582293); (2.5, 1.34149); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. (n ** ((-1.)*. k)))  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) );  ( ((0, 0), (0, 0)), (0.) ); ( ((4, 4), (4, 4)), (0.) ); ( ((0, 0), (-2, -2)), (2.82842712474619029) ); ( ((0, 0), (-2, 2)), (2.82842712474619029) ); ( ((0, 5), (0, 10)), (5.)); ( ((-3, 0), (-10, 0)), (7.)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x1 - x2) in let dy = float_of_int (y1 - y2) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (2, 3); (5, 31); (10, 1023); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi_helper n acc = else hanoi_helper (n-1) (2 * acc + 1) in if n <= 1 then domain () else hanoi_helper n 0  ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (5, 120.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = let n = float_of_int n in if n < 0. then domain() else fact (int_of_float(n -. 1.)) *. n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (10, 6); (21, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (3.00000000001, 1.20205690313880798); (4., 1.08232323371051709); (10., 1.00099457512781753); (100., 1.); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let to_add = n ** (-.k) in if to_add < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. to_add) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.4142135623730950488016887) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in let squaredDist = float_of_int((dx * dx) + (dy * dy)) in sqrt(squaredDist) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (5, 31); (10, 1023) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n==1 then 1 else 2 * (hanoi (n-1)) + 1 ;; ",
    "let hanoi (n: int) : int =  let rec hanoiHelper (n: int) (acc: int) : int = if  (n-1) < 1 then acc else hanoiHelper (n-1) (2*acc + 1) in  if n < 1 then domain () else hanoiHelper n 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.) ] ;; ",
    "let rec fact (n: int): float =  if n < 0 then domain () else if n <= 1 then 1. else (float_of_int n) *. (fact (n-1))  ;; ",
    "let fact (n: int): float =  let rec factHelper (n:int) (acc:int) : int = if (n-1) <= 1 then acc*n else factHelper (n-1) (acc*n) in  if n < 0 then domain () else if n == 0 then 1. else float_of_int (factHelper n 1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (4, 2); (5, 5); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = let nNext = if n mod 2 == 0 then n/2 else 3*n + 1 in if n == 1 then steps_so_far else collatz_helper nNext (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (12., 1.00024608655330804829863799804); (2., 1.644934066848226436472415166646) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let term = n**(-1. *. k) in if term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (term +. sum_so_far) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (-3,-4)), (5.) ); ( ((3,3),(3,3)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in let value = float_of_int(dx * dx + dy * dy)in sqrt value ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (4, 24.); (3, 6.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1. else let m = float_of_int n in fact (int_of_float (m -. 1.)) *. m ;; ",
    "let collatz_tests = [ (2, 1); (1, 0); (21, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper(3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 0 then domain() else collatz_helper(n)(0) ;; ",
    "let zeta_tests = [ (3.0, 1.20205690314079017) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1. /. (n ** k) < acc then sum_so_far else let x = sum_so_far +. 1. /. (n ** k) in approx_zeta (k) (acc) (n +. 1.) (x) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), 0. ); ( ((0, 0), (1, 1)), sqrt(2.) ); ( ((0, 0), (1, 2)), sqrt(5.) ); ( ((0, 0), (3, 3)), sqrt(18.) ); ( ((0, 0), (4, 5)), sqrt(16. +. 25.) ); ( ((0, 0), (5, 6)), sqrt(25. +. 36.) );  ( ((0, 0), (3, 4)), 5. ); ( ((0, 0), (5, 12)), 13. ); ( ((0, 0), (12, 5)), 13. );  ( ((0, 0), (7, 24)), 25. ); ( ((0, 0), (8, 15)), 17. ); ( ((0, 0), (9, 40)), 41. ); ( ((0, 0), (11, 60)), 61. ); ( ((0, 0), (13, 84)), 85. );  ( ((4, 6), (9, 1)), sqrt(50.));  ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt ( float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 0 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); (8, 40320.); (9, 362880.); (10, 3628800.); (11, 39916800.); (12, 479001600.); (13, 6227020800.); ] ;; ",
    "let rec fact (n: int) : float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    " let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); (7, 16);  (31, 106); (35, 13); (21, 7); (12, 9); (36, 21); (20, 7); (27, 111); (40, 8); (51, 24); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else match n mod 2 with | 0 -> collatz_helper (n/2) (steps_so_far+1) | 1 -> collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.6449340668482264364724151666460251892189499012067984377355582293); (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (4.5, 1.05470751076125824);  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = else approx_zeta k acc (n +. 1.) (sum_so_far +. n ** (-.k) ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ( ((1, 2), (3, 4)), (sqrt(8.)) ); ( ((-31, 27), (22, 14)), (sqrt(2978.))); ( ((-1, -1), (-1, -1)), 0.); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1-x2 in  let dy = y1-y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    " let hanoi_tests = [ (1, 1); (2, 3); (10, 1023);   ] ;; ",
    "let rec hanoi (n: int) : int = if n<= 1 then 1 else hanoi (n-1)*2 +1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if float_of_int (n) <= 1. then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (2, 1); (15, 17); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper(3* n +1)(steps_so_far +1) ;; ",
    "let collatz (n: int) : int = collatz_helper (n)(0) ;; ",
    "let zeta_tests = [ (23., 1.); (3., 1.2020); (14., 1.); (21., 1.); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ( n +. 1. ) ** ( k *. -1.) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n**(k *. -1.)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0,0), (1,2)), (2.23606797749979) ); ( (((-1),2), (3,(-2))), (5.65685424949238058) ); ((((-1),(-2)),  ((-3),(-2))), (2.) ); ((((0),(0)),  ((0),(0))), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float(dx * dx + dy * dy));; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (0,1.); (1, 1.); (2, 2.); (3, 6.); ] ;; ",
    "let fact (n: int): float = let rec factorial (n:int): int = if n < 0 then domain() else if n = 0 then 1 else n * factorial (n-1) in (float)(factorial n)  ;; ",
    "let collatz_tests = [ (1,0); (2,1); (7,16); ] ;; ",
    "let rec collatz_helper n acc = if n = 1 then acc else if n mod 2 = 0 then collatz_helper (n/2) (acc+1) else collatz_helper (3*n+1) (acc+1)   let collatz n = if n < 1 then domain() else collatz_helper n 0  let zeta_tests = [ (3.,1.20205690314079017); (7., 1.00834927738191671) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1./.n**k <= acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. 1. /. n**k) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (1, 2)), (2.23606797749979) ); ( ((0, 0), (3, 4)), (5.) ); ( ((-1, -2), (2, 2)), (5.) ); ( ((-3,-9), (21,-7)), (24.0831891575845916)) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) :float= let dx = x1 - x2 in let dy = y1 - y2 in sqrt ((float_of_int)dx *. (float_of_int)dx +. (float_of_int)dy *. (float_of_int)dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); (9, 511); (10, 1023); (11, 2047); (12, 4095); (13, 8191); (14, 16383); (15, 32767); (16, 65535); (17, 131071); (18, 262143); (19, 524287); (20, 1048575);  ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then n else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.0); (1, 1.0); (2, 2.0); (3, 6.0); (4, 24.0); (5, 120.0); (6, 720.0); (7, 5040.0); (8, 40320.0); (9, 362880.0); (10, 3628800.0); (11, 39916800.0); (12, 479001600.0); (13, 6227020800.0); (14, 87178291200.0); (15, 1307674368000.0); (16, 20922789888000.0); (17, 355687428096000.0); (18, 6402373705728000.0); ] ;; ",
    "let rec fact (n: int): float = if n < 1 then (float_of_int) 1 else fact (n - 1) *. (float_of_int) n ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7); (4,2); (5,5); (6,8); (7,16); (8,3); (9,19); (10,6); (11,14); (12,9); (13,9); (14,17); (15,17); (16,4); (17,12); (18,20); (19,20); (20,7); (30,18); (50,24); (70,14); (90,17); (110,113); (130,28); (150,15); (170,10); (190,106); (210,39); (230,34); (250,109); (270,42); (290,117); (310,86); (330,112); (350,81); (370,45); (390,120); (410,27); (430,102); (450,53); (470,128); (490,22); (510,48); (530,123); (550,92); (570,105); (590,56); (610,38); (630,38); (650,25); (670,69); (690,126); (710,33); (730,95); (750,46); (770,33); (790,77); (810,28); (830,134); (850,59); (870,28); (890,72); (910,41); (930,36); (950,28); (970,98); (990,98); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1)  ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3.0, 1.2020569031595942853997381615114499907649862923404988817922715553); (4.0, 1.0823232337111381915160036965411679027747509519187269076829762154); (5.0, 1.0369277551433699263313654864570341680570809195019128119741926779); (6.0, 1.0173430619844491397145179297909205279018174900328535618424086640); (12.0, 1.0002460865533080482986379980477396709604160884580034045330409521); (20.0,1.0000009539620338727961131520386834493459437941874105957500564898); (100.0,1.0000000000000000000000000000007888609052210118073520537827660414); (2.36,1.4020160374711903424695537842639195385610543403175539771468818491); (3.14, 1.1765089176710207931334070744575314535776132323954561694821);  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (~-.k) < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. n**(~-.k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0.  ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((1, 1), (1, 1)), (0.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 1), (0, 0)), (1.41421356237309515) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int(x1 - x2) in let dy = float_of_int(y1 - y2) in sqrt (dx ** 2. +. dy ** 2.) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n=1 then 1 else (2 * (hanoi (n-1)) ) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if float_of_int(n) = 0. then 1.0 else fact (n - 1) *.float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper ((3*n)+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else if n = 1 then 0 else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (2., 1.6449340516623121)  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n)**(-.k) < acc then sum_so_far else approx_zeta k acc (n +. 1.0) (sum_so_far +. ((n)**(-.k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.414213562) ); ( ((0, 0), (0, 0)), (0.) ); ( ((-5, 0), (5, 0)), (10.) ); ( ((0, 6), (0, 6)), (0.) ); ( ((0, 6), (0, -6)), (12.) ); ( ((-1, 2), (2, -3)), (5.830951895) ); ] ;; ",
    "let distance ((x1,y1):(int*int)) ((x2,y2):(int*int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt(float_of_int(dx*dx + dy*dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then 0 else 2*hanoi(n-1)+1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); ] ;; ",
    "let rec fact (n: int): float = if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); (7, 16); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else (if ((n mod 2) = 0) then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1)) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (4., 1.0823232337111381915160036965411679027747509519187269076829762154); (5., 1.0369277551433699263313654864570341680570809195019128119741926779); (6., 1.0173430619844491397145179297909205279018174900328535618424086640); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let x = n**(k) in let y = 1. /. x in if(y < acc) then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. y) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((2,2),(2,2)),(0.)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (4,15) ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (3, 6.) ] ;; ",
    "let rec fact (n: int): float = if n <= 1 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2, 1); (3, 7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n<=1 then steps_so_far else if n mod 2 = 1 then collatz_helper((3*n)+1) (steps_so_far+1) else collatz_helper(n/2) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = collatz_helper(n)(0) ;; ",
    "let zeta_tests = [ (2.,1.6449340668482264); (3.2,1.16677); (12., 1.000246086553308) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if acc < 1./.(n**(k)) then approx_zeta (k) (acc) (n+.1.) (sum_so_far+.(1./.(n**k))) else sum_so_far  in  if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ( ((1, 2), (1, 2)), (0.) ); ( ((0, 1), (0, 2)), (1.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx*dx)  +.  float_of_int(dy*dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n=1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (5, 120.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n=0 then 1. else fact(n-1)*. float_of_int(n)  ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2);  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n + 1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553)  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let rec exp (k, n, sum) = if k-.1.<0. then if k!=0. then sum*.((1./.n)**(k)) else sum else exp ((k-.1.), n, (1./.n*.sum) ) in  if exp( k-.1., n ,1./.n) < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far+.exp( k-.1., n ,1./.n)) in   if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ (((0, 0), (0, 0)), (0.)); ( ((0, 0), (3, 4)), (5.) );   ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float =  let dx =  x2 - x1 in let dy =  y2 - y1 in let dx = float dx +. 0.0 in let dy = float dy +. 0.0 in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (5, 120.); (6, 720.); (7, 5040.); ] ;; ",
    "let rec fact (n: int): float = if n < 1 then 1. else let n_flo = float n +. 0.0 in fact (n - 1) *. n_flo ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (32, 5); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else begin if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3*n + 1) (steps_so_far + 1) end ;; ",
    "let collatz (n: int) : int = if n > 0 then collatz_helper n 0 else domain () ;; ",
    "let zeta_tests = [ (5., 1.03692775514329338); (3., 1.20205690314079017); (10., 1.00099457512781753); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far =  if n**(0.-. k) >= acc then approx_zeta k acc (n +.1.) (sum_so_far +. n**(0. -. k)) else sum_so_far in if k <= 2. then  domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.0 ) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in let sx = dx * dx in let sy = dy * dy in let addxy = sx + sy in let fxy = float_of_int addxy in sqrt fxy ;; ",
    "let hanoi_tests = [ (2, 3); (1, 1); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n = 1 then 1 else if n < 1 then domain() else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); ] ;; ",
    "let rec fact (n: int): float = if n = 0 || n = 1 then float_of_int 1 else if n > 0 then float_of_int ( int_of_float (fact (n - 1)) * n) else domain() ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (9, 19); (97, 118); (871, 178)  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = let steps_so_far = steps_so_far + 1 in if n = 1 then steps_so_far - 1 else if n mod 2 = 0 then collatz_helper(n/2) (steps_so_far) else collatz_helper(3*n + 1) (steps_so_far) ;; ",
    "let collatz (n: int) : int = if n = 1 then 0 else if n > 0 then collatz_helper(n) (0) else domain() ;; ",
    "let zeta_tests = [ (12., 1.00024608655330804); (2., 1.64493406684822643); (3., 1.2020569031595942853997381615114499907649862923404988817922715553); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let sum_so_far = sum_so_far +. n**(-1.*.k) in if n**(-1.*.k) < acc then sum_so_far else approx_zeta k acc (n+.1.) sum_so_far in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int((dx * dx) + (dy * dy)) ) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3,7) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else  hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); ] ;; ",
    "let rec fact (n: int): float = if  n < 0 then domain () else if n = 0 then 1.  else fact (n - 1) *. (float_of_int n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (5, 5) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (2., 1.6449340668482264364724151666460251892189499012067984377355582293); (4., 1.0823232337111381915160036965411679027747509519187269076829762154) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** ((-1.) *. k) < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. n ** ((-1.) *. k))   in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (4, 2)), (4.47213595499958) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx) +. float_of_int(dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (8, 255); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi' (n: int) = if n <= 1 then 1 else 2 * hanoi' (n-1) + 1 in if n < 0 then domain () else hanoi' n ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (5, 120.); ] ;; ",
    "let fact (n: int) : float = let rec fact' (n: int) = if n <= 1 then 1. else fact' (n - 1) *. float_of_int(n) in if n < 0 then domain () else fact' n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3*n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.202056); (4., 1.082323); (7., 1.008349); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next = n ** (-.k) in if next < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (3, 1)), (3.16227766017) ); ( ((-1, -1), (10, 9)), (14.866067473) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else match n with | 1 -> 1 | _-> 2 * hanoi(n-1) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (5, 120.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else match n with |0-> 1.0 |_-> (float_of_int n) *. (fact(n-1))  let rec f n acc = if n = 0 then (float_of_int acc) else f (n-1) (n * acc) in f n 1  ;;*) ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (6, 8); (7, 16) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else collatz_helper (if (n mod 2 =0) then n/2 else 3*n+1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    " let zeta_tests = [ (2.0, 1.6449340668482264364724151666460251892189499012067984377355582293); (3.0, 1.2020569031595942853997381615114499907649862923404988817922715553); (4.0, 1.0823232337111381915160036965411679027747509519187269076829762154); (5.0, 1.0369277551433699263313654864570341680570809195019128119741926779) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1.0 /. (n**k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.0) ((1.0 /. (n**k)) +. sum_so_far) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 1), (4, 6)), (5.830952) ); ( ((1, 1), (1, 1)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then n else ((hanoi (n-1)) * 2 + 1) ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (4, 24.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n < 1 then 1. else float_of_int(n * int_of_float(fact (n-1))) ;; ",
    "let collatz_tests = [ (1, 0); (5, 5); (3, 7); (2, 1); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n <= 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1./.(n**k)) < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. (1./.(n**k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.) ); ( ((3, 4), (0, 0)),  (5.) ); ( ((7, -2), (-54, 22)), (sqrt 4297.) ); ( ((-3, -2), (-1, -5)), (sqrt 13.) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int ((dx * dx) + (dy * dy))) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (8, 255); (15, 32767); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n == 1 then 1 else (hanoi (n - 1)) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (5, 120.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () 1. (fact (n - 1)) *. (float_of_int n) ;; ",
    "let collatz_tests = [ ( (1), (0) ); ( (123), (46) ); ( (3791), (175) ); ( (302), (16) ); ( (2021), (63) ); ( (7777), (83) ); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = steps_so_far else if (n mod 2) == 0 then else ;; ",
    "let collatz (n: int) : int = domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ ( (2.), (1.6449340668482264364724151666460251892189499012067984377355582293) ); ( (3.), (1.2020569031595942853997381615114499907649862923404988817922715553) ); ( (4.), (1.0823232337111381915160036965411679027747509519187269076829762154) ); ( (8.), (1.0040773561979443393786852385086524652589607906498500203291102026) ); ( (88.), (1.0000000000000000000000000032311742677852653861348141180266574174) ); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next_term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.414214) ); ( ((1, 7), (-2, 0)), (7.615773) ); ( ((-40, -100), (32, 82)), (195.724296) ); ( ((8, 0), (0, -7)), (10.630146) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float_of_int((dx * dx) + (dy * dy))) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 0 then domain () else if n = 1 then 1 else (2 * hanoi (n - 1)) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (3, 6.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then let n = n/2 in collatz_helper (n) (steps_so_far + 1) else let n = ((3 * n) + 1) in collatz_helper (n) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.6449340668482264364724151666460251892189499012067984377355582293); (5., 1.0369277551433699263313654864570341680570809195019128119741926779); (7.4, 1.00626); (10.3, 1.00081); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let term = (n ** (-1. *. k)) in if term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 0 then domain () else if n=1 then 1 else (2*hanoi(n-1)+1) ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n=0 then 1. else if n=1 then 1. else fact (n - 1) *. float_of_int(n)  ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else if n mod 2=0 then collatz_helper(n/2) (steps_so_far+1)  else  collatz_helper(3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n<=0 then domain() else collatz_helper(n)(0) ;; ",
    "let zeta_tests = [ (3., 1.20205); (2., 1.6449); (5., 1.03692); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if   1. /. (n ** k)< acc then sum_so_far else approx_zeta k acc (n+. 1.) (sum_so_far +. 1. /. (n**k))   in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515)); ( ((0,0), (0,0)), (0.)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int(dx) *. float_of_int(dx) +. float_of_int(dy) *. float_of_int(dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 0 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n=0 then 1.0 else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2)(steps_so_far+1) else collatz_helper (3*n+1)(steps_so_far+1) ;; ",
    "let collatz (n: int) : int = let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2)(steps_so_far+1) else collatz_helper (3*n+1)(steps_so_far+1) in if n<0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3.0,1.20205690315959424); (4.5,1.0547075107614543); (8.0,1.00407735619794436) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if  (n ** (k *. -1.)) < acc  then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. (n ** (k *. -1.))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((7,4), (8, 4)), (1.) ); ( ((3, 1), (6, 5)), (5.) ); ( ((7, 10), (19, 15)), (13.) ); ( ((5, 10), (7, 14)), (sqrt(20.)) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float (x1 - x2) in let dy = float (y1 - y2) in sqrt(dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (11, 2047); ] ;; ",
    "let hanoi (n: int) : int = let rec h n = if n = 1 then 1 else 2 * h (n-1) + 1 in  if n <= 0 then domain () else h n ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else match n mod 2 with | 0 -> collatz_helper (n/2) (steps_so_far+1) | 1 -> collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let pi = 2.0 *. asin 1.0 let zeta_tests = [ (4., (pi ** 4.) /. 90.); (6., (pi ** 6.) /. 945.); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta (k: float) acc n sum_so_far = let term = n ** ~-.k in if term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (0, 0)), (0.) ); ( ((2, 5), (1, 8)), (3.16227766016837952) ); (((2,2),(2,3)), (1.0)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (8, 255) ] ;; ",
    "let rec hanoi (n: int) : int = if n =1 then 1 else if n <= 0 then domain () else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (8, 40320.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n <= 1 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (3,7); (1,0); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n =1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n /2 ) (steps_so_far +1) else collatz_helper (3*n  + 1) (steps_so_far +1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.6449340516623121); (3., 1.20205690314079017); (100., 1.); (4.5, 1.05470751076125824); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (-.k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n ** (-.k))  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 1), (2, 2)), (1.41421356237309515) ); ( ((3, 4), (0, 0)), (5.) ); ( ((6, 8), (3, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((2, 1), (2, 1)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (10, 1023); ] ;; ",
    "let hanoi (n: int) : int = if n <= 0 then domain () else let rec hanoi_helper k acc = if k <= 0 then acc else hanoi_helper (k - 1) (acc * 2 + 1) in hanoi_helper n 0 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (2, 1); (3, 7); (5, 5); (10, 6); (7, 16); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1)  (steps_so_far + 1)  ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079); (5., 1.03692775514329316); (7., 1.00834927738191649); (9., 1.00200839282608034); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ((n +. 1.) ** (0. -. k) ) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. ((n ** (0. -. k) ) ))  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 1), (4, 5)), (5.) ); ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in (float_of_int (dx * dx + dy * dy))**0.5 ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain() else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.) ] ;; ",
    "let rec fact (n: int): float = if  n < 0 then domain () else if (n = 1) || (n = 0) then 1. else (fact (n-1)) *. (float_of_int n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8);  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2 = 0) then  collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1)  ;; ",
    "let collatz (n: int) : int = if n<0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [  (3., 1.202056903159594285); (10., 1.000994575127818085); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n**(-1. *. k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (n**(-1. *. k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((4, 6), (1, 5)), (3.162277660) ); ( ((1, 1), (1, 2)), (1.) ); ( ((3, 4), (2, 8)), (4.123105625) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float =  let dx = x1 - x2 in let dy = y1 - y2 in  sqrt(float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int =  if n = 0 then domain ()  else if n = 1 then 1  else hanoi (n - 1) * 2 + 1  ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float =  let rec factorial n =  if n = 0 then 1 else n * factorial(n-1) in  if n < 0 then domain()  else float_of_int(factorial n)  ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int =  if n = 1 then steps_so_far  else if n mod 2 = 0 then collatz_helper(n / 2) (steps_so_far + 1)  else collatz_helper((3 * n) + 1) (steps_so_far + 1)  ;; ",
    "let collatz (n: int) : int =  if n = 0 then domain()  else collatz_helper (n) (0)  ;; ",
    "let zeta_tests = [ (2., 1.644934066); (3., 1.202056903); (4., 1.082323233); (5., 1.036927755); (10., 1.000994575); (25., 1.000000029); (100., 1.000000000); ] ;; ",
    "let zeta (k: float) : float =  let rec approx_zeta k acc n sum_so_far =  if (1. /. (n ** k)) < acc  then sum_so_far  else approx_zeta (k) (acc) (n +. 1.) (sum_so_far +. (1. /. (n ** k)))  in  if k < 2.  then domain ()  else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt (2.)) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if (n == 1) then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n == 0 then 1. else if n == 1 then 1. else fact (n - 1) *. ((float_of_int) n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if (n == 1) then steps_so_far else if (n mod 2 == 0) then collatz_helper (n/2) (steps_so_far+1) else collatz_helper(3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 0 then domain () else if n == 1 then 0 else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n ** (-1.*.k) < acc) then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far+.(n**(-1.*.k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0.;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ( ((0, 0), (5, 12)), (13.) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x2 - x1) in let dy = float_of_int (y2 - y1) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15);  ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (4, 24.); (0, 1.);  ] ;; ",
    "let fact (n: int): float = let rec fact' (m: float) = if m = 0. then 1. else m *. fact' (m -. 1.) in if n < 0 then domain () else let m = float_of_int n in ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (4, 2); (3, 7); (5, 5); (11, 14); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int =  if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ (2., 1.64493 ); (3., 1.20205 ); (4., 1.082323 ); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let acc = epsilon_float in if (1. /. (n**k) ) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. ( 1. /. (n**k) ) ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (12, 16)), (20.) ); ( ((2, 2), (2, 2)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (abs (x2 - x1)) and dy = float_of_int (abs (y2 - y1)) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31); (10, 1023) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 0 then domain () else if n = 0 then 0 else 2 * hanoi (n - 1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (6, 720.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else float_of_int n *. fact (n - 1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (7, 16); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1); ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0; ;; ",
    "let zeta_tests = [ (3., 1.20205690315959429); (4., 1.08232323371113819); (10., 1.00099457512781809) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. ((n +. 1.) ** k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. 1. /. (n ** k)) if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.0) ); ( ((0, 0), (1, 1)), (1.414214) ); ( ((1, 1), (1, 1)), (0.0) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in (float_of_int (dx * dx) +. float_of_int (dy * dy)) ** 0.5 ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (1, 1.0); (2, 2.0); (0, 1.0); (3, 6.0); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1.0 else float_of_int n *. fact (n - 1) ;; ",
    "let collatz_tests = [ (1, 0); (3, 7); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2 = 0) then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper ((3*n) + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0;; ",
    "let zeta_tests = [ (12.0, 1.000246086553308048299); (10.0, 1.000994575127818085337); (3.0, 1.2020569031595942854); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ( n ** ((-1.0) *. k) ) < acc then sum_so_far else approx_zeta k acc (n +. 1.0) (sum_so_far +.  n ** ((-1.0) *. k)) in if k < 2.0 then domain () else approx_zeta k epsilon_float 1.0 0.0 ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 0)), (1.) ); ( ((-7, -4), (17, 3)), (25.) ); ( ((1, 4), (5, 7)), (5.) ); ( ((-1, -2), (4, 10)), (13.) ); ( ((0, 0), (9, 40)), (41.) ); ( ((1, 1), (1, 1)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 1 + 2 * hanoi (n - 1) ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.) ] ;; ",
    "let rec fact (n: int): float = if n = 0 then 1. else if n < 0 then domain () else float_of_int(n) *. fact(n - 1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if (n = 1) then steps_so_far else if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (1 + n * 3) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.644934066848226436472415166646); (4., 1.082323233711138191516003696541); (12., 1.00024608655330804829863799804) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. n ** k < acc) then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. 1. /. n ** k ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.)); ( ((0, 0), (1, 1)), (1.41421356237309515); ((-40, -32), (-20, -30)), (20.0997512422417799); ((-5, -6), (13, 24)), (34.9857113690718)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (7,127); (8,255); (3,7); (6,63); ] ;; ",
    "let hanoi (n: int): int = if n <= 0 then domain() else let rec hanoi_helper (level: int) (acc: int) = if level = 1 then acc else hanoi_helper (level - 1) (acc * 2 + 1) in hanoi_helper n 1;; ",
    "let fact_tests = [ (0,1.); (5, 120.); (10, 3628800.); (8, 40320.); (7, 5040.); (1, 1.); (2, 2.) ] ;; ",
    "let fact (n: int): float = if n < 0 then domain () else let rec fact_helper (n: int)(acc: float) = if n <= 1 then acc else fact_helper (n - 1) (acc *. float_of_int(n)) in fact_helper n 1.0;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (8, 3); (7, 16); (5, 5); (17, 12); (27, 111); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1)  ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (14., 1.00006124813505859); (9., 1.00200839282608056); (17., 1.00000763719763763); (3., 1.20205690314079017); (7.647, 1.00524483529102127); (12., 1.0002460865533076); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta (k: float) (acc: float) (n: float) (sum_so_far: float) : float =  let next_add = n ** ((-1.) *. k) in if next_add < acc then sum_so_far else approx_zeta k acc (n +. 1.0) (sum_so_far +. next_add) if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), sqrt(2.) ); ( ((1, 1), (0, 0)), sqrt(2.) ); ( ((0, 0), (0,0)), (0.) ); ( ((1, 1), (1, 1)), (0.) ); ( ((1,2), (3, 4)), sqrt(8.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (4, 24.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (30, 18) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3*n +1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., (acos (-1.) *. acos (-1.) /. 6.)); (4., (acos (-1.) *. acos (-1.) *. acos (-1.) *. acos (-1.) /. 90.)); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let newterm = n ** (-.k) in if newterm < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. newterm) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5. ) ); ( ((0, 0), (0, 0)), (0. ) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int dx *. float_of_int dx +. float_of_int dy *. float_of_int dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then 0 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.) ] ;; ",
    "let rec fact (n: int): float = if n < 1 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (7, 16); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n == 1 then steps_so_far else if (n mod 2 == 1) then collatz_helper (n*3+1) (steps_so_far + 1) else collatz_helper (n/2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [  (3. , 1.20205690314079039 );  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if acc < epsilon_float then sum_so_far else approx_zeta k ((1. /. n) ** k) (n+.1.) (sum_so_far +. (1. /. n) ** k) in if k < 2. then infinity else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421) ); ( ((3, 6), (12, 5)), (9.0553851381374173) ); ( ((11, 55), (52, 55)), (41.)); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if  n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3.0, 1.2020569031595942853997381615114499907649862923404988817922715553); (3.5, 1.1267338673170566464278124918549842722219969574036029638423960386); (4.0, 1.0823232337111381915160036965411679027747509519187269076829762154); (4.5, 1.0547075107614542640229672889602801172724938329562517306846845010); (5.0, 1.0369277551433699263313654864570341680570809195019128119741926779); (16.24, 1.0000129383261593594912904501275304683066318756819999123350341180); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ((n +. 1.) ** -.k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (n ** -.k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.414213562) ); ( ((2, 3), (5, 2)), (3.16227766) ); ( ((1, 1), (1, 1)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int ( dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (5, 31); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n=1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if float_of_int n < 0. then domain () else if n = 0 then 1. else (float_of_int n) *. fact (n - 1) ;; ",
    "let collatz_tests = [ (2, 1); (3, 7); (1, 0); (6, 8); (233333, 168); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 1 then collatz_helper (3 * n + 1) (steps_so_far + 1) else collatz_helper (n/2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.644934); (2.3, 1.43242); (3.22266, 1.16327); (5., 1.03693); (6.278965, 1.014117); (9.22555, 1.00171); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** (~-. k) < acc then sum_so_far else approx_zeta  k acc (n +. 1.) (sum_so_far +. n ** (~-. k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((-1, 1), (1, 1)), (2.) ); ( ((1, -1), (1, 1)), (2.) ); ( ((1, 1), (-1, 1)), (2.) ); ( ((1, 1), (1, -1)), (2.) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int dx *. float_of_int dx +. float_of_int dy *. float_of_int dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.);  ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (12, 9); (27, 111) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 1 then collatz_helper (3 * n + 1) (steps_so_far + 1) else collatz_helper (n / 2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0; ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942850); (4., 1.08232323371113819152); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1. /. (n ** k) < acc then sum_so_far else approx_zeta k epsilon_float (n +. 1.) (sum_so_far +. (1. /. (n ** k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((-1, 2), (3, -4)), (7.21110255092797825) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi_helper n = if n <= 0 then domain () else if n = 1 then 1 else 2 * (hanoi_helper (n-1)) + 1 in hanoi_helper n ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (7, 5040.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int (n) ;; ",
    "let collatz_tests = [ (5, 5); (6, 8); (9, 19); (1, 0); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n < 1 then domain () else if n = 1  then steps_so_far else (if n mod 2 = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1)) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (2.5, 1.341487257250917179757); (4., 1.0823232337111381915160036965411679027747509519187269076829762154); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. (n ** k)) < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. 1. /. (n ** k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((6, 3), (8, 14)), (11.180339887498949) ); ( ((7, 7), (7, 7)), (0.) );  ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x2 - x1) in let dy = float_of_int (y2 - y1) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (6, 63) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then n else 2 * (hanoi (n-1)) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (6, 720.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else if n = 1 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3*n+1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0  ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (4., 1.08232323371051709); (5., 1.03692775514329338) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta (k: float) acc n sum_so_far = if ((n ** (-.k)) >= acc) then approx_zeta k acc (n +.1.) (sum_so_far +. (n ** (-.k))) else sum_so_far in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.4142) ); ( ((1, 1), (7, 9)), (10.) ); ( ((1, 0), (3, 2)), (2.8284)); ( ((-2, -2), (-3, 1)), (3.16228)); ( ((1, 1), (0, 0)), (1.4142)); ( ((1, 1), (1, 1)), (0.)) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int(x1 - x2) in let dy = float_of_int(y1 - y2) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (10, 1023); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (5, 120.); (0, 1.); (10, 3628800.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (2, 1); (16, 4); (5, 5); (10, 6); (3, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.5, 1.34149); (3., 1.202057); (5., 1.03693); (7.578, 1.00551); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next_term = n**(-.k) in if next_term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next_term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1,1),  (3,3)),   (2.82842712475)); ( ((1,0),  (0,1)),   (1.41421356237309515) ); ( ((0,0),  (0,0)),   (0.) );  ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let  dx = float_of_int(x1 - x2) in let    dy = float_of_int (y1 - y2) in sqrt ((dx *. dx) +. (dy *. dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3,7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n =1 then 1 else ( hanoi (n-1) * 2) + 1   ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0,1.); (5,120.); ] ;; ",
    "let rec fact (n: int): float =  let  n = float_of_int(n)   in if n < 0. then domain () else if n = 0. then 1.  else  (fact (int_of_float(n -. 1.))) *. n   ;; ",
    "let collatz_tests = [ (1,0); (4,2); (2,1); (5,5);  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n= 1 then steps_so_far else if n mod 2= 0 then collatz_helper(n/2) (steps_so_far +1) else collatz_helper((3*n)+1) (steps_so_far +1) ;; ",
    "let collatz (n: int) : int = if n = 0 then 0 else if n<0 then  domain() else collatz_helper(n) (0) ;; ",
    "let zeta_tests = [ (3.,1.2020569031595942853997); (4.,1.0823232337111381915160036965411679027747); (5.,1.036927755143369926331365486457034168057080); (10.,1.00099457512781808533714595890031901700601953); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let sum_so_far = sum_so_far +. n**(-. k)  in if acc > (n+. 1.)**(-. k) then  sum_so_far else approx_zeta (k) (epsilon_float) (n+.1.) (sum_so_far) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 1)), (1.) ); ( ((0, 0), (1, 0)), (1.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.) ); ( ((0, 0), (-6, -8)), (10.) ); ( ((-2, -5), (4, 3)), (10.) ); ( ((1, 1), (1, 1)), (0.) ); ( ((3, -8), (0, -12)), (5.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); (9, 511) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else (hanoi (n - 1)) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); (7, 16); (8, 3); (9, 19); (10, 6) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.6449340668482264364724151666460251892189499012067984377355582293); (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (4., 1.0823232337111381915160036965411679027747509519187269076829762154); (5., 1.0369277551433699263313654864570341680570809195019128119741926779) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next_term = n ** (-.k) in if next_term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next_term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in let sum = float_of_int (dx * dx + dy * dy) in sqrt(sum) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); ] ;; ",
    "let rec hanoi (n: int) : int = let f n = if n = 1 then 1 else hanoi(n-1) * 2 + 1 in if n < 1 then domain () else f n ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); (8, 40320.); (9, 362880.); (10, 3628800.); ] ;; ",
    "if a = 0. then 1. else f (a -. 1.) *. a in if n < 0 then domain () else f (float_of_int(n)) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (12, 9); (19, 20); (27, 111); ] ;; ",
    "if n = 1 then steps_so_far else ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., 1.64493406684822643); (3., 1.20205690315959428); (4., 1.08232323371113819); (5., 1.03692775514336992); (6., 1.01734306198444913); (7., 1.00834927738192282); (8., 1.00407735619794433); (9., 1.00200839282608221);  ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next_term = 1. /. (n ** k) in if next_term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next_term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((2, 3), (4, 2)), (2.23606797749979) ); ( ((1, 2), (6, 6)), (6.40312423743284853) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 and dy = y1 - y2 in sqrt (float dx *. float dx +. float dy *. float dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31) ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 0 then domain () else if n = 1 then 1 else 2 * hanoi (n-1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else if n = 1 then 1. else fact (n - 1) *. float n ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (2, 1); (3, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n = 0 then 0 else if n mod 2 = 0 then collatz_helper(n/2) (steps_so_far + 1) else collatz_helper(3*n + 1) (steps_so_far + 1)  ;; ",
    "let collatz (n: int) : int = collatz_helper(n)(0) ;; ",
    "let zeta_tests = [ (3., 1.202056903159594285); ] ;; ",
    "let rec powerTime (theBase: float) (thePower: float) (acc: float) (floatSoFar : float): float = if acc > thePower then floatSoFar else powerTime (theBase) (thePower) (acc +. 1.0) (floatSoFar *. theBase) ;; ",
    "let rec divideTime (theBase: float) (thePower: float) (acc: float) (floatSoFar : float): float = if acc > thePower then floatSoFar else divideTime (theBase) (thePower) (acc +. 1.0) (floatSoFar /. theBase) ;; ",
    "let zeta (k: float) : float =  let rec approx_zeta k acc n sum_so_far = if exp ( (0. -. k) *. log n) < epsilon_float then sum_so_far else approx_zeta k epsilon_float (n +. 1.) (sum_so_far +. (exp ( (0. -. k) *. log n))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (6, 63); (10, 1023); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 0 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); (3, 6.); (10, 3628800.) ] ;; ",
    "let rec fact (n: int): float = if  n < 0 then domain () else if n = 0 then 1. else fact ( n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (4., 1.08232323371051709); (10., 1.00099457512781753) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1./. (n ** k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. 1. /. (n ** k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.414213562) ); ( ((5, 10), (5, 10)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt ( float_of_int ( (dx * dx) + (dy * dy) ) ) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31);  ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else if n = 1 then 1. else fact (n - 1) *. float_of_int ( n ) ;; ",
    "let collatz_tests = [ (5, 5); (1, 0); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if ( n mod 2 ) = 0  then collatz_helper ( n / 2 ) ( steps_so_far + 1) else collatz_helper ( 3 * n + 1 ) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if ( n < 1 ) then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690315959429); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ( n ** (-.k) < acc) then sum_so_far else approx_zeta k acc ( n +. 1. ) ( sum_so_far +. n ** (-.k) ) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.) )); ( ((-1,-5), (1, 1)), (sqrt(40.)) ); ( ((3, 4), (-1, -1)), (sqrt(41.)) ); ( ((0, 0), (0, 0)), (sqrt(0.)) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5,31); (8,255); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else ( if n = 1 then 1 else hanoi (n-1) * 2 + 1) ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (5, 120.); (0,1.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else( if n = 0 then 1. else fact (n - 1) *. float_of_int(n)) ;; ",
    "let collatz_tests = [ ((1,0)); ((5,5)); ((20,7)); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else ( if n mod 2 = 0 then collatz_helper(n/2) (steps_so_far+1)else ( collatz_helper(3*n+1) (steps_so_far+1))) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else( collatz_helper n 0) ;; ",
    "let zeta_tests = [ (2.,1.6449340668482264364724151666460251892189499012067984377355582293); (4.,1.0823232337111381915160036965411679027747509519187269076829762154); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if 1./.((n+.1.) ** k) <= acc then sum_so_far else( approx_zeta k acc (n +. 1.) (sum_so_far +. (1./.(n ** k)))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((3, 4), (0, 0)), (5.) ); ( ((0, 0), (1, 1)), sqrt(2.0) ); ( ((0, 0), (0, 0)), sqrt(0.0) ); ( ((-1, -1), (2, 3)), 5.0 ); ( ((2, 3), (-1, -1)), 5.0 ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int(x1 - x2) in let dy = float_of_int(y1 - y2) in sqrt (dx*.dx+.dy*.dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); ] ;; ",
    "let hanoi (n: int) : int = if n < 1 then domain () else let rec go n acc = if n=1 then acc else go (n-1) (2*acc) in (go n 2)-1;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); (8, 40320.); ] ;; ",
    "let rec fact (n: int): float = if n <0 then domain () else if n=0 then 1.0 else fact (n -1) *.float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7); (4,2); (5,5); (6,8); (7,16); (8,3); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else if (n mod 2)=0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3.0,1.20205690315959428); (3.5,1.12673386731705664); (4.0,1.08232323371113819); (4.5,1.05470751076145426); (5.0,1.03692775514336992); (10.0,1.0009945751278180); (50.0,1.0000000000000008); (100.0,1.000000000000000); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if acc<epsilon_float then sum_so_far else approx_zeta k (n**(-1.0*.k)) (n +. 1.0) (sum_so_far+.n**(-1.0*.k)) in if k < 2. then domain () else approx_zeta k infinity 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.)) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)):float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float(dx*dx+dy*dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15) ] ;; ",
    "let  hanoi (n: int) : int = if n < 1 then domain () else let rec h n m= if n=1 then m else h (n-1)  (m* 2 + 1) in h n 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else float(n) *. fact (n-1) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7) ] ;; ",
    "let  collatz_helper (n: int) (steps_so_far: int) : int = let rec c n s= if n=1 then s else if (n mod 2=0) then c (n/2) (s+1) else c (3*n+1) (s+1) in c n 0 ;; ",
    "let collatz (n: int) : int = if n<1 then domain() else collatz_helper n 0  ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); (4., 1.0823232337111381915160036965411679027747509519187269076829762154) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n=1. then approx_zeta k acc (n+.1.) (1.+.(n+.1.)**(-.k)) else if (n+.1.)**(-.k)<acc then sum_so_far else approx_zeta k acc (n+.1.) ((n+.1.)**(-.k)+.sum_so_far)  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((63, -77), (73, 100)), (177.28226081590904) ); ( ((93, 72), (70, 100)), (36.235341863986875) ); ( ((70, 8), (93, 100)), (94.83142938920619) ); ( ((-80, 71), (-82, 100)), (29.068883707497267) ); ( ((66, -32), (-79, 100)), (196.08416560242696) ); ( ((70, 30), (-85, 100)), (170.07351351694948) ); ( ((-99, 88), (-1, 100)), (98.73196037757987) ); ( ((-39, 0), (87, 100)), (160.86018774078315) ); ( ((98, 61), (-38, 100)), (141.4814475470194) ); ( ((-97, -2), (-45, 100)), (114.49017425089369) ); ( ((42, 90), (94, 100)), (52.952809179494906) ); ( ((-42, -24), (-66, 100)), (126.30122723077555) ); ( ((70, -96), (82, 100)), (196.36700333813724) ); ( ((-68, 7), (-37, 100)), (98.03060746521976) ); ( ((84, -28), (96, 100)), (128.56126943990557) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int(x1 - x2) in let dy = float_of_int(y1 - y2) in sqrt ((dx *. dx) +. (dy *. dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (19, 524287); (15, 32767); (14, 16383); (8, 255); (14, 16383); ] ;; ",
    "let hanoi (n: int) : int = let rec hanoi_tr n acc = if n = 1 then acc else hanoi_tr (n-1)(2*acc+1) in  if n < 1 then domain () else hanoi_tr n 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (5, 120.); (4, 24.); (3, 6.); ] ;; ",
    "let fact (n: int): float = let rec fact_tr n acc = if n = 0 then acc else fact_tr (n-1) (acc*n) in  if n < 0 then domain () else float_of_int(fact_tr n 1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (4, 2); (41313, 181); (22348, 113); (64627, 254); (38348, 75); (39536, 137); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper(n/2)(steps_so_far + 1) else collatz_helper(3*n+1)(steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper(n)(0) ;; ",
    "let zeta_tests = [ (2., 1.6449340516623121); (10.3, 1.00080610007841675); (3.3, 1.15194479471528988); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let term = n**(-.k) in if term < acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far+.term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.414213562) ); ( ((3, 4), (0, 0)), (5.) ); ( ((1, 1), (0, 0)), (1.414213562) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt ((float_of_int dx) *. (float_of_int dx) +. (float_of_int dy) *. (float_of_int dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact ( n - 1) *. (float_of_int n) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7);  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569); (4., 1.0823232); (5., 1.0369278); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (n ** -.k) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (n ** -.k)) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0), (-5, -5)), (7.071068)); ( ((0, 0), (0, 0)) , (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 0 then domain () else if n = 1 then 1 else if n = 0 then 0 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if float_of_int(n) < 0. then domain () else if float_of_int(n) = 1. then 1. else if float_of_int(n) = 0. then 1. else fact (int_of_float(float_of_int(n) -. 1.)) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (10, 6); (5, 5); (4, 2); (2, 1); (30, 18); (1, 0) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 == 0 then collatz_helper(n/2) (steps_so_far +1) else collatz_helper(3*n +1) (steps_so_far +1)    ;; ",
    "let collatz (n: int) : int =  if n < 0 then domain() else collatz_helper n 0;; ",
    " let zeta_tests = [ (12. , 1.0002460865533080482986379980477396709604160884580034045330409521); (2. , 1.6449340668482264364724151666460251892189499012067984377355582293) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let rest = n ** ( -1. *. k) in if rest < acc then sum_so_far else approx_zeta k epsilon_float (n +. 1.) (sum_so_far +. rest)  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.0) ); ( ((0, 0), (1, 1)), sqrt (2.0) ); ( ((3, 4), (0, 0)), (5.0) ); ( ((1, 1), (0, 0)), sqrt (2.0) ); ( ((0, 0), (0, 0)), (0.0) ); ( ((3, 2), (3, 1)), (1.0) ); ( ((31, 0), (17, 1)), sqrt (197.0) ); ( ((8, 6), (7, 12)), sqrt (37.0) ); ( ((0, 0), (3, 15)), sqrt (234.0) ); ( ((12, 9), (2, 23)), sqrt (296.0) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (8, 255); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else (2 * (hanoi (n-1)) + 1) ;; ",
    "let fact_tests = [ (1, 1.0); (2, 2.0); (3, 6.0); (10, 3628800.0); (0, 1.0); ] ;; ",
    "let rec fact (n: int): float = if n = 0 then 1.0 else float_of_int (n * int_of_float (fact (n-1))) ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (131, 28); (654, 144); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if (n = 1) then steps_so_far else if (n mod 2) = 0 then collatz_helper (n/2) (steps_so_far +1 ) else collatz_helper (3*n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.1, 1.5602165335033620837105167696914719247530509959059958626139); (18.37, 1.0000029534738637630939100788450893120021502961221074686372028406); (1000.0, 1.0); (2.0, 1.6449340668482264364724151666460251892189499012067984377355582293); ] ;; ",
    " let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ((n)**(-.k)) < epsilon_float then sum_so_far else approx_zeta k epsilon_float (n+.1.) (sum_so_far +. (n ** (-.k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1.0 0.0 ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 2), (1, 2)), (0.) ); ( ((1, 0), (1, 1)), (1.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((100, 200), (300, 50)), (250.) ); ( ((-5, -63), (45, -3)), (78.1024967590665398) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float (dx * dx) +. float (dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); (9, 511); (10, 1023); ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else 2 * hanoi(n-1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (7, 5040.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then 0. else if n <= 1 then 1. else fact(n-1) *. float n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 != 0 then collatz_helper ((3 * n) + 1) (steps_so_far + 1) else collatz_helper (n/2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (2., 1.64493405166231188); (12., 1.00024608655330804); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let cur = n**((-1.0)*.k) in if cur <= acc then sum_so_far else approx_zeta k acc (n+.1.) (sum_so_far +. cur) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.))); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = (abs) (x2 - x1) in let dy = (abs) (y2 - y1) in let sd = (float) ((dx * dx) + (dy * dy)) in sqrt (sd) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3) ; (3, 7); (4,15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else 2 * hanoi(n-1) + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (3, 6.); (4,24.); (0, 1.);  ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n=0 then 1. else (float)n *. fact(n-1) ;; ",
    "let collatz_tests = [ (1, 0) ; (2, 1); (3, 7); (4, 2); (5, 5); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else if n mod 2=0 then collatz_helper (n/2) (steps_so_far +1) else collatz_helper (3*n+1)(steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n<1 then domain () else let numSteps = collatz_helper (n) (0) in numSteps ;; ",
    "let zeta_tests = [ (2. , 1.64493406684822643641); (3. , 1.20205690315959428540); ] ;; ",
    "if k < 2. then domain () else approx_zeta (float)k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((0, 0),(0, 0)), 0.0 ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx= x1 - x2 in let dy= y1 - y2 in  sqrt (float_of_int(dx*dx+dy*dy)) ;; ",
    "exception Domain;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7) ] ;; ",
    "let rec hanoi (n: int) : int = if n <= 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.0) ] ;; ",
    "let rec fact (n: int): float = if n = 0 then 1.0 else fact (n-1) *. float_of_int n  ;; ",
    "let collatz_tests = [ (1,0); (6,8) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2)=0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3*n+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n<0 then raise Domain else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3.0,1.202056) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n**(-.k) < acc then sum_so_far else approx_zeta k acc (n+. 1.0) (sum_so_far +. n**(-.k)) in  if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 0)), (1.) ); ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (-3, -4)), (5.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x1 - x2) in let dy = float_of_int (y1 - y2) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (4, 15);  ] ;; ",
    "exception Domain ;; ",
    "let hanoi (n: int) : int = let rec hanoi' n = if n = 1 then 1 else hanoi' (n-1) * 2 + 1 in if n < 0 then raise Domain else hanoi' n ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if float_of_int n = 0. then 1. else fact ( n - 1 ) *. (float_of_int n) ;; ",
    "let collatz_tests = [ (1, 0); (5, 5); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (n*3+1) (steps_so_far+1) ;; ",
    "let collatz (n: int) : int = if n < 1 then raise Domain else collatz_helper n 0  ;; ",
    "let zeta_tests = [ (3. ,1.202); (4. ,1.082323); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. ( n ** k)) < epsilon_float then sum_so_far else approx_zeta k epsilon_float (n +. 1.) ( (1. /. (n ** k)) +. sum_so_far) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((-4, 3), (-4, -4)), (7.) ); ( ((-3, 4), (2, -8)), (13.) ); ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int(dx) *. float_of_int(dx) +. float_of_int(dy) *. float_of_int(dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 0 then domain () else if n = 0 then 0 else if n = 1 then 1 else hanoi(n-1)*2 +1 ;; ",
    "let fact_tests = [ (0,1.); (1, 1.); (2, 2.); (3, 6.) ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 || n = 1 then 1.0 else fact (n - 1) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1,0); (2,1); (3,7); (12,9); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n=1 then steps_so_far else if (n mod 2)=0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n<0 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.,1.64493406684822643); (3.,1.20205690315959428); (4.5,1.05470751076145426) ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n**(-.k)< acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n** (-.k))  in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((3, 0), (0, 4)), (5.) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt(float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else ((hanoi (n - 1) * 2) + 1) ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (int_of_float(float_of_int(n) -. 1.)) *. float_of_int(n) ;; ",
    "let collatz_tests = [ (1, 0) ; (2, 1) ; (5, 5) ; (6, 8) ; ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper ((3 * n) + 1 ) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper (n) (0) ;; ",
    "let zeta_tests = [ ( 3., 1.2020569031595942853997381615114499907649862923404988817922715553 ); ( 2., 1.6449340668482264364724151666460251892189499012067984377355582293700074704032008738336289006197587053040043189623371906796287246 ); ( 4., 1.0823232337111381915160036965411679027747509519187269076829762154441206161869688465569096359416999172329908139080427424145840715 ); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if ( (n +. 1.) ** (-.k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) ( sum_so_far +. ( n ** (-.k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt 2.) ); ( ((-1, 0), (0, 1)), (sqrt 2.) ); ( ((-2, -4), (1, 0)), (5.) ); ( ((1, -1), (-3, 2)), (5.) ); ( ((0, 0), (-1, -1)), (sqrt 2.) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int ((dx * dx) + (dy * dy))) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (1, 1.); (2, 2.); (0, 1.); (3, 6.); (4, 24.); (5, 120.); (6, 720.); (7, 5040.); (8, 40320.); (9, 362880.); (10, 3628800.); (11, 39916800.); (7, 5040.); (15, 1307674368000.); (20, 2432902008176640000.); (25, 15511210043330985984000000.); (50, 30414093201713378043612608166064768844377641568960512000000000000.) ] ;; ",
    "let rec fact (n: int): float = let n = float_of_int n in if n < 0. then domain () else if n = 0. then 1. else if n = 1. then 1. else fact (int_of_float (n -. 1.)) *. n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7);  ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else let n' = if n mod 2 = 0 then n / 2 else 3 * n + 1 in collatz_helper n' (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain() else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.2020569031595942853997381615114499907649862923404988817922715553); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next_term = n ** (-.k) in if next_term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next_term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.0) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ) ; ( ((0, 0), (0, 0)), (0.) ) ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int )) : float = let dx = float_of_int x1 -. float_of_int x2 in let dy = float_of_int y1 -. float_of_int y2 in sqrt ((dx *. dx) +. (dy *. dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); ] ;; ",
    "exception Domain;; ",
    "let rec hanoi (n: int) : int = if n < 0 then raise Domain else if n <= 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (1, 1.); (2, 2.); (0, 1.) ] ;; ",
    "let rec fact (n: int): float = if float n <= 1. then 1. else (float_of_int n) *. (fact (n -1)) ;; ",
    "let collatz_tests = [ (1); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = let rec h n = if (n = 1)then 3* n+ 1 else n / 2 in if n = 0 then raise Domain else h n ; notimplemented () ;; ",
    " let rec collatz (n: int) : int = notimplemented () ;; ",
    "let zeta_tests = [ ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = notimplemented () in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.4142135624) ); ( ((2, 4), (7, 9)), (7.07106781186547551) ); ( ((5, 5), (5, 5)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = float_of_int (x1 - x2) in let dy = float_of_int (y1 - y2) in sqrt (dx *. dx +. dy *. dy) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (5, 31) ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * hanoi (n - 1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1.0 else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (4, 2); (5, 5) ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 1 then collatz_helper (3 * n + 1) (steps_so_far + 1) else collatz_helper (n / 2) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (3., 1.20205690314079017); (10., 1.00099457512781753); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = let next_term = n ** ~-. k in if next_term < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. next_term) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (0, 0)), (0.) ); ( ((0, 0), (3, 4)), (5.) ); ( ((4, 6), (7, 10)), (5.) ); ( ((0, 0), (5, 12)), (13.) ); ( ((0, 0), (8, 15)), (17.) ); ( ((0, 0), (1, 1)), (sqrt 2.) ); ( ((2, 2), (4, 4)), (sqrt 8.) ); ( ((0, 0), (4, 5)), (sqrt 41.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); (5, 31); (6, 63); (7, 127); (8, 255); (9, 511); (10, 1023); (21, 2097151); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n - 1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.0); (1, 1.0); (2, 2.0); (3, 6.0); (4, 24.0); (5, 120.0); (6, 720.0); (7, 5040.0); (8, 40320.0); (9, 362880.0); (10, 3628800.0); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); (5, 5); (6, 8); (7, 16); (8, 3); (9, 19); (10, 6); (71, 102); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if (n mod 2) = 0 then collatz_helper (n / 2) (steps_so_far + 1) else collatz_helper (3 * n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n < 1 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2., (4. *. atan 1.) ** 2. /. 6.); (4., (4. *. atan 1.) ** 4. /. 90.); (6., (4. *. atan 1.) ** 6. /. 945.); (8., (4. *. atan 1.) ** 8. /. 9450.); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if (1. /. (n ** k)) < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. (1. /. (n ** k))) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (sqrt(2.0))); ( ((1, 1), (1, 1)), (0.)); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x1 - x2 in let dy = y1 - y2 in sqrt (float_of_int (dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else hanoi (n-1) * 2 + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (3, 6.); (4, 24.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n <= 1 then 1. else fact (n - 1) *. float_of_int n ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (4, 2); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n < 1 then domain() else if (n = 1) then steps_so_far else if (n mod 2 = 0) then collatz_helper (n/2) (steps_so_far+1) else collatz_helper (3 * n+1) (steps_so_far+1)  ;; ",
    "let collatz (n: int) : int = collatz_helper n 0 ;; ",
    "let zeta_tests = [ (2.0, 1.644934); (3.0, 1.2020569); ] ;; ",
    "let zeta (k: float) : float = let abs_val (v:float) = if v < 0. then -.v else v in  let rec approx_zeta (k:float) acc (n:float) sum_so_far = let current_step_val = n ** (-.(k)) in let next_step_val =  (n +.1.) ** (-.(k)) in if (abs_val((current_step_val) -. (next_step_val))) < acc then sum_so_far else approx_zeta (k) (acc) (n+.1.) (sum_so_far+.current_step_val) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; ",
    "let distance_tests = [ ( ((0, 0), (3, 4)), (5.) ); ( ((0, 0), (1, 1)), (1.41421356237309515) ); ( ((1, 3), (4, 5)), (3.60555127546398912) ); ( ((1, 1), (-2, 4)), (4.24264068711928477) ); ( ((-2, -3), (1, 1)), (5.) ); ( ((-3, -3), (-2, -8)), (5.09901951359278449) ); ( ((0, 0), (0, 0)), (0.) ); ] ;; ",
    "let distance ((x1, y1): (int * int)) ((x2, y2): (int * int)) : float = let dx = x2 - x1 in let dy = y2 - y1 in sqrt (float_of_int(dx * dx + dy * dy)) ;; ",
    "let hanoi_tests = [ (1, 1); (2, 3); (3, 7); (4, 15); ] ;; ",
    "let rec hanoi (n: int) : int = if n < 1 then domain () else if n = 1 then 1 else 2 * hanoi(n-1) + 1 ;; ",
    "let fact_tests = [ (0, 1.); (1, 1.); (2, 2.); (4, 24.); (5, 120.); ] ;; ",
    "let rec fact (n: int): float = if n < 0 then domain () else if n = 0 then 1. else float_of_int(n) *. fact (n - 1) ;; ",
    "let collatz_tests = [ (1, 0); (2, 1); (3, 7); (93, 17); ] ;; ",
    "let rec collatz_helper (n: int) (steps_so_far: int) : int = if n = 1 then steps_so_far else if n mod 2 = 0 then collatz_helper (n/2) (steps_so_far + 1) else collatz_helper (3*n + 1) (steps_so_far + 1) ;; ",
    "let collatz (n: int) : int = if n <= 0 then domain () else collatz_helper n 0 ;; ",
    "let zeta_tests = [ (7., 1.0083492773819228268397975498497967595998635605652387064172831365); (3.5, 1.1267338673170566464278124918549842722219969574036029638423960386); ] ;; ",
    "let zeta (k: float) : float = let rec approx_zeta k acc n sum_so_far = if n ** -.k < acc then sum_so_far else approx_zeta k acc (n +. 1.) (sum_so_far +. n ** -.k) in if k < 2. then domain () else approx_zeta k epsilon_float 1. 0. ;; "
]