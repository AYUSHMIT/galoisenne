[
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec tail_rec_find f l result = match l with | t::h -> if (f t)=None then tail_rec_find f h result else (f t) | [] -> None in tail_rec_find f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f_pass ele acc = if p ele then ele::acc else acc and f_fail ele acc = if p ele then acc else ele::acc in (List.fold_right f_pass l [], List.fold_right f_fail l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let times_correct = ref 0 in let times_wrong = ref 0 in let cur_master = ref masterpass in  let save masterpass address password = if !times_wrong >= 3 then raise AccountLocked else if masterpass = !cur_master then let _= times_correct := !times_correct + 1 in let _= times_wrong := 0 in ref_list := (address, encrypt !cur_master password)::!ref_list else let _= times_wrong := !times_wrong + 1 in raise WrongPassword in  let get_force masterpass address = let check_address address = fun (a, p) -> if (a = address) then Some p else None in match find_map (check_address address) !ref_list with | None -> None | Some p -> Some (decrypt masterpass p) in  let get masterpass address = if !times_wrong >= 3 then raise AccountLocked else if masterpass = !cur_master then let _= times_correct := !times_correct + 1 in let _= times_wrong := 0 in get_force !cur_master address else let _= times_wrong := !times_wrong + 1 in raise WrongPassword in  let update_master oldMaster newMaster = if oldMaster = !cur_master then let _= times_wrong := 0 in let _= times_correct := !times_correct + 1 in let rec reencrypt l acc = match l with | [] -> acc | (address,password)::t -> reencrypt t ((address, encrypt newMaster (decrypt oldMaster password))::acc) in let _= ref_list := List.rev (reencrypt !ref_list []) in cur_master := newMaster else let _= times_wrong := !times_wrong + 1 in raise WrongPassword in  let count_ops masterpass = if !times_wrong >= 3 then raise AccountLocked else if masterpass = !cur_master then let _= times_correct := !times_correct + 1 in let _= times_wrong := 0 in !times_correct else let _= times_wrong := !times_wrong + 1 in raise WrongPassword in { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec calc_catalan n i acc = count_rec_calls := !count_rec_calls + 1; if n=0 then 1 else sum_catalan n (n-1) 0 and sum_catalan n i acc = if n=0 then 1 else if i=0 then acc + (calc_catalan 0 (-1) 0)*(calc_catalan (n-1) (n-2) 0) else sum_catalan n (i-1) (acc+(calc_catalan i (i-1) 0)*(calc_catalan (n-1-i) (n-2-i) 0)) in let result = (calc_catalan n (n-1) 0) in (result, !count_rec_calls) ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let result = f f' x in let _= Hashtbl.add hash x result in let _= stats.entries := !(stats.entries) + 1 in result | Some a -> let _= stats.lkp := !(stats.lkp) + 1 in a in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec sum_cat n i acc = if n=0 then 1 else if i=0 then acc + (recf 0)*(recf (n-1)) else sum_cat n (i-1) (acc + (recf i)*recf (n-1-i)) in sum_cat n (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let record = { entries = ref 0; lkp = ref 0 } in let memfun = memoize memo_cat record in (memfun n, record) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> if (f x) != None then (f x) else (find_map f xs) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l1 = List.fold_right (fun x y -> if (p x) then (x :: y) else y) l [] in let l2 = List.fold_right (fun x y -> if (p x) then y else (x :: y)) l [] in (l1, l2) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let lock_counter = ref 0 in let op_counter = ref 0 in let ref_mp = ref masterpass in let veriMP mp = if mp = !ref_mp then (lock_counter := 0; op_counter := !op_counter + 1; true) else ((lock_counter := (!lock_counter + 1)); false) in let save = (fun mp ad pw -> if !lock_counter = 3 then raise AccountLocked else (if veriMP mp then (ref_list := ((ad, encrypt mp pw) :: !ref_list)) else raise WrongPassword)) in  let get_force = (fun mp ad -> find_map (fun x -> let (t,h) = x in if (t = ad) then Some (decrypt mp h) else None) !ref_list) in  let get = (fun mp ad -> if !lock_counter = 3 then raise AccountLocked else (if veriMP mp then get_force mp ad else raise WrongPassword)) in  let update_master = (fun mp np -> if veriMP mp then (ref_list := (List.map (fun (a,b) -> (a, encrypt np (decrypt mp b))) !ref_list); ref_mp := np) else raise WrongPassword) in  let count_ops = (fun mp -> if !lock_counter = 3 then raise AccountLocked else ( if veriMP mp then !op_counter else raise WrongPassword)) in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n = if n = 0 then (count_rec_calls := !count_rec_calls + 1; 1) else let rec compute i n acc = if i > n then acc else compute (i + 1) n (acc + cat i * cat (n - i)) in (count_rec_calls := !count_rec_calls + 1; compute 0 (n-1) 0) in let cat_value = cat n in (cat_value, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.mem hash x) then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else (let f2 = (f f' x) in (Hashtbl.replace hash x f2; stats.entries := !(stats.entries) + 1; f2 )) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else n ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in (memoize (memo_cat) s n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> let d = f h in if d  <> None then  d else find_map f t  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper e (t,f) = if p e then (e::t e::f) in List.fold_right helper l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mapass = ref masterpass in let count : int ref = ref 1 in let wrong : int ref = ref 0 in    let is_correct m  = if !mapass <> m then let _ = wrong := !wrong + 1 in false else let _ = count := !count + 1 in let _ = wrong := 0 in true in  let save = fun m a p -> if is_correct m then let t = encrypt !mapass p in  ref_list := (a,t)::!ref_list else if !wrong = 3 then raise AccountLocked else raise WrongPassword in let get_force = fun m a ->  let helper = fun (add,psw) -> if add = a then let  p = decrypt m psw in Some p else None in find_map helper !ref_list in  let get = fun m a -> if !wrong = 3 then raise AccountLocked else if is_correct m then get_force m a else raise WrongPassword in  let update_master = fun m n -> if is_correct m then  let _ =  ref_list := List.map(fun (adress,psw) -> (adress,(decrypt m psw))) !ref_list in let _ = wrong := 0 in  let _ = ref_list := List.map (fun (adress,psw) -> (adress,(encrypt n psw))) !ref_list in  mapass := n;  else raise WrongPassword in  let count_ops = fun m -> if !wrong  = 3 then raise AccountLocked else if is_correct m then  let _ = count := !count -1 in !count else raise WrongPassword in  { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan (n,count) =  if n = 0 then (1,!count_rec_calls+1)  else let rec aux i n acc count = if i > n then (acc,!count_rec_calls+1) else let (value1,_) = catalan(i,!count_rec_calls) in let (value2,_) = catalan(n-i,!count_rec_calls) in let _ = (count_rec_calls := !count_rec_calls+2) in aux (i+1) n (acc + value1 * value2) (!count_rec_calls) in aux 0 (n-1) 0 !count_rec_calls in catalan (n, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let  d = Hashtbl.find_opt hash x in let s = stats.lkp in let e = stats.entries in match d with | Some result -> let _ =  s := !s+1 in result | None -> let d = f (f') x in let _ = e:= !e+1 in let _ = Hashtbl.add hash x d in d in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let e : int ref = ref 0 in let l : int ref = ref 0 in let s = {entries =e; lkp = l } in  let partial_eval = memoize memo_cat s in let partial_result = partial_eval n in (partial_result, s)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: tail -> match f h with | Some v -> Some v | None -> find_map f tail ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let inner (el : 'a) ((l1, l2) : 'a list * 'a list) : ('a list * 'a list) = match p el with | true -> (el :: l1, l2) | false -> (l1, el :: l2) in List.fold_right inner l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpass = ref masterpass in let n_ops = ref 0 in let n_wrong_consec = ref 0 in let locked = ref false in if String.equal guess !masterpass then (incr n_ops ; n_wrong_consec := 0) else ( incr n_wrong_consec ; if !n_wrong_consec = 3 then locked := true ; raise WrongPassword ) in let get_force guess address = let is_found (tup : (string * password)) : password option = let (add, pass) = tup in if add = address then Some (decrypt guess pass) else None in find_map is_found !ref_list in { save = (fun guess address password -> ( if !locked then raise AccountLocked ; check_master guess ; ref_list := (address, encrypt !masterpass password) :: !ref_list )) ; get_force = get_force ; get = (fun guess address -> ( if !locked then raise AccountLocked ; check_master guess ; get_force guess address )) ; update_master = (fun oldmaster newmaster -> ( check_master oldmaster ; masterpass := newmaster ; let reencrypt (tup : (string * password)) : (string * password) = let (add, pass) = tup in let plaintext = decrypt oldmaster pass in (add, encrypt newmaster plaintext) in ref_list := List.map reencrypt !ref_list ; locked := false )) ; count_ops = (fun guess -> ( if !locked then raise AccountLocked ; check_master guess ; !n_ops )) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec aux_catalan i n acc = ( if i = 0 then incr count_rec_calls ; if n = 0 then 1 else if i > n-1 then acc else let fact1 = aux_catalan 0 i 0 in let fact2 = aux_catalan 0 (n-1-i) 0 in aux_catalan (i+1) n (acc + fact1 * fact2) ) in let ans = aux_catalan 0 n 0 in (ans, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in ( incr stats.lkp ; value ) with Not_found -> let value = f f' x in ( Hashtbl.add hash x value ; incr stats.entries ; value ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0 ; lkp = ref 0} in let memoized_fn = memoize memo_cat stats in (memoized_fn n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f(x) = None then find_map f xs else f(x)  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f i (j,k)= if p i then (i::j,k) else (j,i::k) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let pass = ref masterpass in let counter = ref 0 in let wrong = ref 0 in let ref_list : (address * password) list ref = ref [] in   let save a b c = if !wrong >= 3 then raise AccountLocked else if a = !pass then (wrong := 0; counter := !counter +1; ref_list :=(b,(encrypt a c))::!ref_list) else (wrong := !wrong + 1;raise WrongPassword) in   let get_force a b = let f (i,j) = if i = b then Some (decrypt a j) else None in find_map f !ref_list in    let get a b = if !wrong >= 3 then raise AccountLocked else if a = !pass then (wrong := 0; counter := !counter+1;get_force a b) else (wrong := !wrong + 1;raise WrongPassword) in    let update_master a b= let f l = let (x,y) = l in (x,(encrypt b(decrypt a y))) in if a = !pass then (pass := b; wrong := 0; counter := !counter+1; ref_list := List.map f !ref_list) else (wrong := !wrong + 1;raise WrongPassword) in   let count_ops a = if !wrong >= 3 then raise AccountLocked else if a = !pass then (counter := !counter +1; wrong := 0; !counter) else (wrong := !wrong + 1;raise WrongPassword) in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = count_rec_calls := !count_rec_calls+1; if n = 0 then (1,1) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else let (a,b) = helper i in let (c,d) = helper (n-i) in aux (i + 1) n (acc + a * c) in aux 0 (n-1) 0 in let (e,f) = helper n in (e, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let k = Hashtbl.find_opt hash x in if k = None then let j = f (f') x in Hashtbl.add hash x j; incr stats.entries; j else let i = Hashtbl.find hash x in incr stats.lkp; i in incr stats.entries; f f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec helper n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + helper i * helper (n-i)) in aux 0 (n-1) 0 in let a = helper n in a; ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp  = ref 0 in let x = { entries ; lkp  } in raise NotImplemented  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f(x) !=None then f(x) else find_map f xs  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter=ref 0 in let mas= ref masterpass in   raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n count_rec_calls= if n=0 then (1, !count_rec_calls+1) else let rec aux i n acc count_rec_calls= if i > n then (acc,!count_rec_calls+1) else let fix= count_rec_calls := !count_rec_calls+1 in let (x,y) = catalan i count_rec_calls in  let (x2,y2)= catalan (n-i) count_rec_calls in let  fix=count_rec_calls:= !count_rec_calls+1 in let z=x*x2 in aux (i+1) n (acc + z) count_rec_calls in aux 0 (n-1) 0 count_rec_calls in catalan n count_rec_calls  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with Hashtbl.add hash x y; incr stats.entries; y   in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats = let stats={ lkp= ref 0 } in ((memoize memo_cat stats)n,stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> if f h <> None then f h else find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with | [] -> ([],[]) | _ -> (List.fold_right (fun el acc -> if p el then el :: acc else acc) l []), (List.fold_right (fun el acc -> if p el then acc else el :: acc) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpassword = ref masterpass in let wrong_pass_cnt = ref 0 in let count_ops = ref 0 in  let check_masterpass = fun (given_pass : masterpass) : bool -> match given_pass = !masterpassword with | false -> wrong_pass_cnt := !wrong_pass_cnt + 1 ; false | true -> wrong_pass_cnt := 0 ; count_ops := !count_ops + 1 ; true in  let save = fun masterpass address password -> if !wrong_pass_cnt >= 3 then raise AccountLocked else match check_masterpass masterpass with | true -> ref_list := (address, (encrypt masterpass password)) :: !ref_list | false -> raise WrongPassword in  let get_force = fun masterpass address -> find_map (fun (el : address * password) : password option -> let (addr, pass) = el in if addr = address then Some (decrypt masterpass pass) else None) !ref_list in  let get = fun masterpass address -> if !wrong_pass_cnt >= 3 then raise AccountLocked else match check_masterpass masterpass with | true -> get_force masterpass address | false -> raise WrongPassword in  let rec reencrypt_all = fun oldmpass newmpass list -> match list with | [] -> [] | (addr,pass) :: t -> let decrypted_pass = (decrypt oldmpass pass) in let new_pass = encrypt newmpass decrypted_pass in (addr, new_pass) :: reencrypt_all oldmpass newmpass t in  let update_master = fun masterpass newmpass -> match check_masterpass masterpass with | true -> let new_list = (reencrypt_all masterpass newmpass !ref_list) in ref_list := new_list; masterpassword := newmpass | false -> raise WrongPassword in  let count_ops = fun masterpass -> if !wrong_pass_cnt >= 3 then raise AccountLocked else match check_masterpass masterpass with | true -> !count_ops | false -> raise WrongPassword in  { save; get_force; get; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan n = count_rec_calls := !count_rec_calls + 1 ; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in  let res = catalan n in (res, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in let cur_lkp = stats.lkp in stats.lkp := !cur_lkp + 1 ; value with Not_found -> let value = f f' x in let cur_entries = stats.entries in Hashtbl.add hash x value ; stats.entries := !cur_entries + 1 ; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats =  let stats = { entries = ref 0; lkp = ref 0; } in  let res = memoize memo_cat stats n in (res, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec helper_find l acc : 'b option = if acc <> None then acc else match l with | [] -> None | h::t -> helper_find t (f h) in helper_find l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (x : 'a) ((a : 'a list), (b : 'a list)) = if p x then (x::a , b) else (a, x::b) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let m = ref masterpass in let n = ref 0 in let ref_list : (address * password) list ref = ref [] in let save mp (ad : address) (p : password) = if mp = !m then (n := !n + 1; ref_list := ! ref_list @ [(ad, encrypt mp p)]) else raise WrongPassword in let get_force mp (ad : address) = let find ((x :address), (y: password)) :password option= if x == ad then Some (decrypt mp y) else None in find_map find !ref_list in let get mp ad = if mp = !m then (n := !n + 1; get_force mp ad) else raise WrongPassword in let update_master mp1 mp2 = if mp1 = !m then let rec reencrypt (l: (address * password) list) acc = match l with | (a, b)::t -> reencrypt t ((a,(encrypt mp2 (decrypt mp1 b))) :: acc) | [] -> acc in ref_list := reencrypt ! ref_list []; n := !n + 1; m := mp2 else raise WrongPassword in let count_ops mp = if mp = !m then (n := !n + 1; !n) else raise WrongPassword in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec help1 n i sum= count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else (if i < n then (count_rec_calls := !count_rec_calls - 1; help1 n (i+1) (sum + help1 i 0 0* help1 (n-1-i) 0 0)) else sum) in let v = help1 n 0 0 in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let y = Hashtbl.find hash x in (stats.lkp := !(stats.lkp) + 1; y) with Not_found -> let y = f f' x in (Hashtbl.add hash x y; stats.entries:= !(stats.entries) + 1; y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in (memoize memo_cat s n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> if f h == None then find_map f t else f h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper (ele: 'a) ((pass,fail) : 'a list * 'a list) : ('a list * 'a list) = if p ele then ((ele::pass),fail) else (pass,(ele::fail)) in List.fold_right helper l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrongcount = ref 0 in let succount = ref 0 in let master = ref masterpass in let save_ masterp address password = if !wrongcount >= 3 then raise AccountLocked else begin if masterp <> !master then begin wrongcount := !wrongcount + 1; raise WrongPassword end else begin wrongcount := 0; succount := !succount +1; ref_list := (address,(encrypt masterp password))::!ref_list end end in let get_force_ masterp addresss = find_map (fun ((x, y):(address * password)) -> match x with | addresss -> if x = addresss then Some (decrypt masterp y) else None | _ -> None ) !ref_list in let get_ masterp address = if !wrongcount >= 3 then raise AccountLocked else begin if masterp <> !master then begin wrongcount := !wrongcount + 1; raise WrongPassword end else begin wrongcount := 0; succount := !succount +1; get_force_ masterp address end end in    let update_master_ masterpo masterpn :unit = if masterpo = !master then begin let rec helper masto mastn x acc :((address * password) list) = match x with | [] -> acc | (x,y)::xs-> helper masto mastn xs ((x,(encrypt mastn (decrypt masto y)))::acc) in wrongcount := 0; master:=masterpn; succount := !succount +1; ref_list := (helper masterpo masterpn !ref_list []) end else begin wrongcount := !wrongcount + 1; raise WrongPassword end in     let count_ops_ masterp = if !wrongcount >= 3 then raise AccountLocked else begin if masterp <> !master then begin wrongcount := !wrongcount + 1; raise WrongPassword end else begin wrongcount := 0; succount := !succount +1; !succount end end in { save = save_; get_force=get_force_; get=get_; update_master=update_master_; count_ops=count_ops_} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec inner n = if n = 0 then begin count_rec_calls := !count_rec_calls +1; 1 end else let rec aux i n acc = if i > n then begin count_rec_calls := !count_rec_calls +1; acc end else aux (i + 1) n (acc + inner i * inner (n - i)) in aux 0 (n-1) 0 in let imple = (inner n) in (imple, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.find_opt hash x) = None then begin Hashtbl.add hash x (f f' x); stats.entries := !(stats.entries) + 1; (Hashtbl.find hash x) end else begin stats.lkp := !(stats.lkp) + 1; (Hashtbl.find hash x) end in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let newstats = {entries = ref 0 ; lkp = ref 0} in (((memoize memo_cat newstats) n),newstats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> if f x = None then find_map f xs else f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let q x (l1, l2) = if p x then (x :: l1, l2) else (l1, x :: l2) in match l with | [] -> ([], []) | _ -> List.fold_right q l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_change : (address * password) list ref = ref [] in let ref_master = ref masterpass in let rec change l m1 m2 = match l with | [] -> () | x :: xs -> let (a, b) = x in let c = encrypt m2 (decrypt m1 b) in let _ = ref_change := (a, c) :: !ref_change in change xs m1 m2 in  let count = ref 0 in let c2 = ref 0 in  let save = fun master addr pw -> if !c2 >= 3 then raise AccountLocked else if master = !ref_master then let _ = count := !count + 1 in let _ = c2 := 0 in ref_list := (addr, (encrypt master pw)) :: !ref_list else let _ = c2 := !c2 + 1 in raise WrongPassword in  let get_force = fun master addr -> let f addr pair = let (a, p) = pair in if a = addr then Some (decrypt master p) else None in if find_map (f addr) !ref_list = None then None else find_map (f addr) !ref_list in  let get = fun master addr -> if !c2 >= 3 then raise AccountLocked else if master = !ref_master then let _ = count := !count + 1 in let _ = c2 := 0 in get_force master addr else let _ = c2 := !c2 + 1 in raise WrongPassword in  let update_master = fun master1 master2 -> if master1 = !ref_master then let _ = count := !count + 1 in let _ = c2 := 0 in let _ = ref_master := master2 in change !ref_list master1 master2; ref_list := !ref_change else let _ = c2 := !c2 + 1 in raise WrongPassword in  let count_ops = fun master -> if !c2 >= 3 then raise AccountLocked else if master = !ref_master then let _ = count := !count + 1 in let _ = c2 := 0 in !count else let _ = c2 := !c2 + 1 in raise WrongPassword in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan2 n = count_rec_calls := !count_rec_calls + 1; if n = 0 then (1, !count_rec_calls) else let rec catalan1 i n acc = if i > n then (acc, !count_rec_calls) else let (x, _) = catalan2 i in let (y, _) = catalan2 (n-i) in catalan1 (i+1) n (acc + x * y) in catalan1 0 (n-1) 0 in catalan2 n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.find_opt hash x = None then let _ = stats.entries := !(stats.entries) + 1 in let value = f f' x in let _ = Hashtbl.add hash x value in Hashtbl.find hash x else let _ = stats.lkp := !(stats.lkp) + 1 in Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec helper i n acc = if i > n then acc else helper (i + 1) n (acc + recf i * recf (n - i)) in helper 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats () = { entries = ref 0; lkp = ref 0 } in let stat = new_stats () in let f = memoize memo_cat stat in let value = f n in (value, stat)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f x != None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (l1, l2) -> if p x then (x::l1, l2) else (l1, x::l2)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master_password = ref masterpass in let count_attempts = ref 0 in let count_operations = ref 0 in let attempt mp f = if !count_attempts >= 3 then raise AccountLocked else if mp = !master_password then (count_operations := !count_operations + 1; count_attempts := 0; f()) else (count_attempts := !count_attempts + 1; raise WrongPassword) in let save mp ads psd = attempt mp (fun() -> ref_list := (ads, encrypt mp psd)::!ref_list) in let get_force mp ads = let f (a, p) = if a = ads then Some(p) else None in match (find_map f !ref_list) with | Some(s) -> Some(decrypt mp s) | None -> None in let get mp ads= attempt mp (fun() -> get_force mp ads) in let update_master cur_mp new_mp = let rec update l = match l with | [] -> [] | (a,p)::t -> (a,encrypt new_mp (decrypt cur_mp p))::update t in if cur_mp = !master_password then (count_attempts := 0; count_operations := !count_operations + 1; master_password := new_mp; ref_list := update !ref_list) else (count_attempts := !count_attempts + 1; raise WrongPassword) in let count_ops mp = attempt mp (fun() -> !count_operations) in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec calculate n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + calculate i * calculate (n - i)) in aux 0 (n-1) 0 in let result = calculate n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let y = f f' x in incr stats.entries; Hashtbl.add hash x y; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let recf n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 in recf n ;; ",
  "let catalan_m (n : int) : int * stats = let cat_stats = {entries = ref 0;lkp = ref 0} in (((memoize memo_cat cat_stats) n), cat_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let y::ys = List.map f l  in match y with | None -> find_map f xs | Some y -> Some y ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let fold_function e acc = let (a, b) = acc in match (p e) with | true -> (e::a, b) | false -> (a, e::b) in List.fold_right fold_function l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master = ref masterpass in let wrong = ref 0 in let correct = ref 0 in let verify x = ( if (x = !ref_master) then (wrong := 0; incr correct; true) else (incr wrong; if (!wrong < 3) then raise WrongPassword else raise AccountLocked)) in let save master address password = if verify master then ref_list := (address, encrypt master password) :: !ref_list else () in let get_force master address = find_map (fun (x,y) -> if x = address then Some (decrypt master y) else None) !ref_list in let get master address = if (verify master) then get_force master address else None in let update_master master new_master= if (verify master) then (ref_master := new_master; (ref_list := List.map (fun(x,y) -> (x, encrypt new_master (decrypt master y))) !ref_list); wrong := 0) else () in let count_ops master= if (verify master) then !correct else 0 in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let num = catalan n in (num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec g x = match Hashtbl.find_opt hash x with | Some value -> incr stats.lkp; value | None -> let value = f g x in Hashtbl.replace hash x value; incr stats.entries; value in g ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (recf i) * (recf (n - i))) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0; } in let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let num = memoize memo_cat stats n in (num, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::xs -> if f h = None then find_map f xs else f h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper (head: 'a) (pass_list, fail_list) : ('a list * 'a list) = if not (p head) then (pass_list, head::fail_list) else (head::pass_list, fail_list) in List.fold_right helper l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrong_pass_counter = ref 0 in let master_location = ref masterpass in let op_counter = ref 0 in  let check_master (input_master : masterpass) = if not (!master_location = input_master) then let _ = (wrong_pass_counter := !wrong_pass_counter + 1) in raise WrongPassword; else wrong_pass_counter := 0 in  let get_force = fun input_master input_ad -> let compare (element : address * password) : 'b option = let (ad, encrypted) = element in if ad = input_ad then let decrypted = decrypt input_master encrypted in Some(decrypted) else None in find_map (compare) !ref_list in  {save = (fun input_master new_ad new_pass -> if !wrong_pass_counter >= 3 then raise AccountLocked else let _ = (check_master input_master) in let encrypted = encrypt input_master new_pass in let new_list = ((new_ad, encrypted)::!ref_list) in ref_list := new_list; op_counter := !op_counter + 1);  get_force = get_force;  get = (fun input_master input_ad -> if !wrong_pass_counter >= 3 then raise AccountLocked else let _ = (check_master input_master) in let _ = (op_counter := !op_counter + 1) in get_force input_master input_ad);  update_master = (fun current_master new_master -> let _ = (check_master current_master) in let _ = (master_location := new_master) in  let update_encryption (element : address * password) : 'b option = let (ad, encrypted) = element in let decrypted = decrypt current_master encrypted in let new_encrypted = encrypt new_master decrypted in let new_list = List.remove_assoc ad !ref_list in let new_list = ((ad, new_encrypted)::new_list) in let _ = (ref_list := new_list) in None in let _ = find_map (update_encryption) !ref_list in op_counter := !op_counter + 1);  count_ops = (fun input_master -> if !wrong_pass_counter >= 3 then raise AccountLocked else let _ = (check_master input_master) in op_counter := !op_counter + 1 ; !op_counter); } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let answer = catalan n in (answer, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match (Hashtbl.find_opt hash x) with | None -> let y = f f' x in Hashtbl.add hash x y; stats.entries := !(stats.entries) + 1; y | Some y -> stats.lkp := !(stats.lkp) + 1; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec sum i n acc = if i > n then acc else sum(i+1) n (acc + recf(i) * recf(n - i)) in sum 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let newStat () = {entries = (ref 0); lkp = (ref 0);} in let stat = newStat() in let result = memoize (memo_cat) stat in (result n, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match (f x) with | None -> find_map f xs | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (acc_true, acc_false) -> match (p x) with |true -> (x::acc_true, acc_false) |false -> (acc_true, x::acc_false)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let call_count : int ref = ref 0 in let err_count : int ref = ref 0 in  let check_pass = (fun input -> if input = masterpass.contents then (incr call_count; err_count.contents <- 0) else (incr err_count; if !err_count > 2 then raise AccountLocked else raise WrongPassword) ) in  let save = fun mpass addr local_pass -> if !err_count > 2 then raise AccountLocked else (check_pass mpass; ref_list.contents <-(addr, encrypt masterpass.contents local_pass) :: ref_list.contents) in  let get_force = (fun mpass addr -> find_map (fun (each_addr, each_pass) -> if each_addr = addr then Some (decrypt mpass each_pass) else None) ref_list.contents  in  let get = fun mpass addr -> if !err_count > 2 then raise AccountLocked else (check_pass mpass; get_force mpass addr)  in  let update_master = fun cur_pass new_pass -> if cur_pass <> masterpass.contents then (incr err_count; raise WrongPassword) else (incr call_count; let addr_list,pass_list = List.split ref_list.contents in let decr_pass_list = List.map (decrypt masterpass.contents) pass_list in (masterpass.contents <- new_pass; ref_list.contents <- List.combine addr_list (List.map (encrypt new_pass) decr_pass_list); err_count.contents <- 0 ) ) in  let count_ops = fun mpass -> if !err_count > 2 then raise AccountLocked else( check_pass mpass; call_count.contents ) in  {save; get_force; get; update_master; count_ops}      ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_help m = (incr count_rec_calls; if m = 0 then (1, !count_rec_calls) else let rec aux i m acc_result = if i > m then (acc_result, !count_rec_calls) else let result_i , _ = catalan_help i in let result_mi, _ = catalan_help (m-i) in aux (i+1) m (acc_result + result_i * result_mi) in aux 0 (m-1) 0) in catalan_help n   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let found = Hashtbl.find hash x in (incr stats.lkp; found) with Not_found -> ( Hashtbl.add hash x (f f' x); incr stats.entries; Hashtbl.find hash x) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i>n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let myStat = {entries = ref 0; lkp = ref 0} in let cat_n = (memoize memo_cat myStat) n in (cat_n, myStat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> if f x = None then find_map f xs else f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun x (acc: 'a list) -> if p x then x::acc else acc) l [] , List.fold_right (fun  x (acc: 'a list) -> if not (p x)  then x::acc  else acc) l [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let count_success = ref 0 in let count_wrong = ref 0 in let master = ref masterpass in let master_matches (input_master: masterpass) : bool = if (master.contents = input_master) then (count_wrong := 0; count_success := count_success.contents + 1;true) else (count_wrong := count_wrong.contents + 1 ;false) in let save (m: masterpass) (address:address) (password:password) : unit = if count_wrong.contents >= 3 then raise AccountLocked else if master_matches m then ref_list := (address, encrypt m password)::(ref_list.contents) else raise WrongPassword in let get_force (m1: masterpass) (address:address) : password option = find_map ( fun (a: (address*password)) -> if ((fst a) = address) then Some (decrypt m1 (snd a)) else None) ref_list.contents in let get (m2: masterpass) (address:address) : password option = if count_wrong.contents >= 3 then raise AccountLocked else if master_matches m2 then  get_force m2 address  else raise WrongPassword in let update_master (m: masterpass) (n: masterpass) = if master_matches m then (master := n; ref_list := List.map (fun (a: (address * password)) -> (fst a, encrypt n (decrypt m (snd a)))) ref_list.contents) else raise WrongPassword in let count_ops (m: masterpass) : int = if count_wrong.contents >= 3 then raise AccountLocked else if master_matches m then count_success.contents else raise WrongPassword in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan x = count_rec_calls := count_rec_calls.contents + 1; if x = 0 then 1 else let rec aux i x acc = if i > x then acc else aux (i + 1) x (acc + catalan i * catalan (x - i)) in aux 0 (x-1) 0 in let x = catalan n in (x, count_rec_calls.contents) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None ->( let v = f f' x in Hashtbl.add hash x v; stats.entries := stats.entries.contents + 1; v;) | Some y -> (stats.lkp := stats.lkp.contents + 1; y);  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = recf n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let f' = memoize (fun (f: int -> int) (n:int) -> if n = 0 then 1 else (let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + f i * f (n - i)) in aux 0 (n-1) 0)) stats in let answer = memo_cat f'  n in (answer, stats)   ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | Some v -> Some v | _ -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun (x : 'a) (y : 'a list) -> if (p x) then (x::y) else y) l [], List.fold_right (fun (x : 'a) (y : 'a list) -> if not (p x) then (x::y) else y) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let mpass = ref masterpass in let wrong_attempts = ref 0 in let operations = ref 0 in let is_locked = ref false in  let check_wa = fun (wa : int ref)  -> if !wa <= 3 then raise WrongPassword else (is_locked := true; raise AccountLocked)  in let verify (pass : password) : bool = if pass = !mpass then (wrong_attempts := 0; operations := !operations + 1; true) else (wrong_attempts := !wrong_attempts + 1; (check_wa wrong_attempts); false)  in let s = fun (mp : masterpass) (a : address) (p : password) : unit -> if verify mp && not !is_locked then ref_list := ((a, (encrypt mp p)) :: !ref_list)  in let gf = fun (mp : masterpass) (a : address) : password option -> find_map (fun (a', lp) -> if a' = a then Some (decrypt mp lp) else None) !ref_list  in let g = fun (mp : masterpass) (a : address) : password option -> if verify mp && not !is_locked then gf mp a else None  in let u = fun (mp : masterpass) (p : masterpass) : unit -> if verify mp then (ref_list := (List.map (fun (a, lp) -> let p' = (decrypt mp lp) in (a, (encrypt p p'))) !ref_list); mpass := p)  in let c = fun (mp : masterpass) : int -> if verify mp && not !is_locked then !operations else 0  in let pass_manager = { save = s; get_force = gf; get = g; update_master = u; count_ops = c } in pass_manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec c n = count_rec_calls := !count_rec_calls + 1; match n with | 0 -> 1 | _ -> let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + c i * c (n - i)) in aux 0 (n-1) 0 in let f = fun x y -> (y, x) in f !count_rec_calls (c n) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some h -> stats.lkp := !(stats.lkp) + 1; h | None -> stats.entries := !(stats.entries) + 1; Hashtbl.add hash x (f f' x); Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0 } in (memoize memo_cat stats n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let return_val = f h in if return_val = None then find_map f t else return_val ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (l1, l2) = if p x then (x::l1, l2) else (l1, x::l2) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass : (masterpass) ref = ref masterpass in let ref_wrong_attempts : (int) ref = ref 0 in let ref_count_ops : (int) ref = ref 0 in let verify_masterpass (tmp_masterpass : masterpass) : bool = (ref_wrong_attempts := 0; ref_count_ops := !ref_count_ops + 1; tmp_masterpass = !ref_masterpass) in { save = (fun tmp_masterpass address password -> (if !ref_wrong_attempts = 3  then raise AccountLocked else (if (verify_masterpass tmp_masterpass) then (ref_list := (address,(encrypt tmp_masterpass password))::(!ref_list)) else (ref_wrong_attempts :=  !ref_wrong_attempts + 1; raise WrongPassword))));  get_force = (fun tmp_masterpass find_address -> (find_map (fun (cur_address,cur_pass) -> (if cur_address=find_address then (Some (decrypt tmp_masterpass (cur_pass))) else None)) !ref_list));  get =( let get_force = (fun tmp_masterpass find_address -> (find_map (fun (cur_address,cur_pass) -> (if cur_address=find_address then (Some (decrypt tmp_masterpass (cur_pass))) else None)) !ref_list)); in (fun tmp_masterpass find_address -> (if !ref_wrong_attempts = 3  then raise AccountLocked else (if (verify_masterpass tmp_masterpass) then (get_force tmp_masterpass find_address) else (ref_wrong_attempts :=  !ref_wrong_attempts + 1; raise WrongPassword)))) );  update_master =  (fun cur_masterpass new_masterpass -> (if (verify_masterpass cur_masterpass) then ( let tmp_ref_list : (address * password) list ref = ref [] in ((List.iter (fun (add,pass) -> tmp_ref_list := (add,(encrypt new_masterpass (decrypt !ref_masterpass pass)))::(!tmp_ref_list)) !ref_list); ref_masterpass := new_masterpass; ref_list := !tmp_ref_list)) else (ref_wrong_attempts :=  !ref_wrong_attempts + 1; raise WrongPassword)));  count_ops = (fun tmp_masterpass -> if !ref_wrong_attempts = 3  then raise AccountLocked else (if (verify_masterpass tmp_masterpass) then (!ref_count_ops) else (ref_wrong_attempts :=  !ref_wrong_attempts + 1; raise WrongPassword)));  }  ;; ",
  "let pass1 = make_manager \"hey\" ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec inner_catalan m = (count_rec_calls := !count_rec_calls +1; (if m = 0 then 1 else let rec inner_aux i m acc = if i > m then acc else inner_aux (i + 1) m (acc + inner_catalan i * inner_catalan (m - i)) in inner_aux 0 (m-1) 0)) in let x = inner_catalan n in (x,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try ( let y = Hashtbl.find hash x in ( stats.lkp := !(stats.lkp) + 1; y ))  with Not_found -> ( stats.entries := !(stats.entries) + 1; let y = f f' x in Hashtbl.add hash x y; y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec mem_aux i n acc = if i > n then acc else mem_aux (i + 1) n (acc + recf i * recf (n - i)) in mem_aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = { entries = ref 0; lkp = ref 0; } in let result = memoize memo_cat new_stats n in (result,new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | []-> None | x::l-> if f(x) <> None then f(x) else find_map f l;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let fold x (list_true, list_false) = if not (p x) then (list_true, x::list_false) else (x::list_true, list_false) in List.fold_right fold l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass: masterpass ref = ref \"\" in ref_masterpass := masterpass; let time = ref 0 in let wrong_time = ref 0 in { save = (fun masterpass (add: address) (pass: password) -> if !wrong_time >= 3 then raise AccountLocked else if !ref_masterpass = masterpass then ( incr time; wrong_time := 0; (ref_list := [(add, encrypt masterpass pass)];())) else (incr wrong_time; if !wrong_time >= 3 then raise AccountLocked else raise WrongPassword ) ); get_force = (fun masterpass (add:address) -> find_map (fun ((add1,pass):(address*password)) -> if add1 = add then Some (decrypt masterpass pass) else None) !ref_list ); get = (fun masterpass (add:address)-> if !wrong_time >=3 then raise AccountLocked else if !ref_masterpass = masterpass then (incr time; wrong_time := 0; find_map (fun ((add1,pass):(address*password)) -> if add1 = add then Some (decrypt masterpass pass) else None) !ref_list) else (incr wrong_time; if !wrong_time >=3 then raise AccountLocked else raise WrongPassword) ); update_master = (fun (oldmaster:masterpass) (newmaster:masterpass) -> if !ref_masterpass = oldmaster then let z = oldmaster in ref_masterpass := newmaster; incr time; ref_list := List.map (fun (add,pass) : (address*password) -> (add, encrypt !ref_masterpass (decrypt z pass))) !ref_list else (incr wrong_time; raise WrongPassword) ); count_ops = (fun masterpass -> if masterpass = !ref_masterpass then (wrong_time :=0; incr time; !time) else(incr wrong_time; if !wrong_time >= 3 then raise AccountLocked else raise WrongPassword) ); } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_new n = if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else (count_rec_calls := !count_rec_calls +1; let (a,b) = catalan_new i in count_rec_calls := !count_rec_calls +1; let (c,d) = catalan_new (n-i) in aux (i + 1) n (acc + a*c)) in aux 0 (n-1) 0 in (count_rec_calls :=!count_rec_calls +1;catalan_new n) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with |Some w ->stats.lkp := !(stats.lkp) +1; w |None -> let result = f f' x in Hashtbl.add hash x result; stats.entries := !(stats.entries) +1; result in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries=ref 0;lkp= ref 0} in let m = memoize memo_cat stats n in (m, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | hd::tl -> match (f hd) with | Some v -> Some v | None -> find_map f tl ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun a b -> if (p a) then a::b else b) l [], List.fold_right (fun a b -> if not (p a) then a::b else b) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let fail = ref 0 in let succ = ref 0 in let check = if !fail >= 3 then raise AccountLocked in let save m a p = check; if m = !master then begin ref_list := (a, (encrypt m p)) :: !ref_list; succ := !succ + 1; fail := 0 end else begin fail := !fail + 1; raise WrongPassword end in let get_force m a = match find_map (fun (x, y) -> if (x = a) then Some y else None) !ref_list with | Some d -> Some (decrypt m d) | None -> None in let get m a = check; if m = !master then begin succ := !succ + 1; fail := 0; get_force m a end else begin fail := !fail + 1; raise WrongPassword end in let update_master m p = let rec f fc l acc = match l with | [] -> acc | (a,b)::tl -> f fc tl ((a,(fc b))::acc) in if m = !master then begin ref_list := f (encrypt p) (f (decrypt m) !ref_list []) []; master := p; succ := !succ + 1; fail := 0 end else begin fail := !fail + 1; raise WrongPassword end in let count_ops m = check; if m = !master then begin succ := !succ + 1; !succ end else begin fail := !fail + 1; raise WrongPassword end in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let result = catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try Hashtbl.find hash x; stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x with Not_found -> stats.entries := !(stats.entries) + 1; Hashtbl.add hash x (f f' x); Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let k = memoize memo_cat stats n in (k, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let v = f x in if v != None then v else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (left, right) = if p x then (x::left, right) else (left, x::right) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let num = catalan n in (num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let new_e = f f' x in Hashtbl.add hash x new_e; stats.entries := !(stats.entries) + 1; new_e | Some e -> stats.lkp := !(stats.lkp) + 1; e in stats.entries := !(stats.entries) + 1; f f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else recf n ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = {entries = ref 0; lkp = ref 0} in let rec_c = (fun f' n -> if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + f' i * f' (n - i)) in aux 0 (n-1) 0) in let recf = memoize (rec_c) new_stats in let res = memo_cat recf n in (res, new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::l -> match f x with |None -> find_map f l |_ -> f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let check v (tru, fal) = match p v with |true -> (v::tru, fal) |false -> (tru, v::fal) in List.fold_right check l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master : masterpass ref = ref masterpass in let success : int ref = ref 0 in let failure : int ref = ref 0 in let save = (fun (m_pass : masterpass) (add: address) (pass: password) -> if !failure < 3 then (let temp_m = !ref_master in if m_pass = temp_m then (success := !success + 1; failure := 0; ref_list := !ref_list@[(add, (encrypt m_pass pass))]) else (failure := !failure + 1; raise WrongPassword) ) else raise AccountLocked ) in let get_force =  (fun (m_pass: masterpass) (add: address) -> find_map (fun ((add_1,pass):(address*password)) -> if add_1 == add then Some (decrypt m_pass pass) else None) (!ref_list)) in let get = (fun (m_pass: masterpass) (add:address) -> if !failure < 3 then (let temp_m = !ref_master in if m_pass = temp_m then (success := !success + 1; failure := 0; get_force m_pass add) else (failure := !failure + 1; raise WrongPassword) ) else raise AccountLocked ) in let update_list = fun (m_pass:masterpass) (n_pass:masterpass) ((add,pass): (address*password)) -> let passwor = decrypt m_pass pass in let new_passwor = encrypt n_pass passwor in (add,new_passwor) in let update_master = (fun (m_pass:masterpass) (n_pass:masterpass) -> (let temp_m = !ref_master in if m_pass = temp_m then (success := !success + 1; failure := 0; ref_list := List.map (update_list (m_pass) (n_pass)) (!ref_list); ref_master := n_pass) else (failure := !failure + 1; raise WrongPassword) ))in let count_ops = (fun (m_pass:masterpass) -> if !failure < 3 then ( let temp_m = !ref_master in if m_pass = temp_m then (success := !success + 1; failure := 0; !success) else (failure := !failure + 1; raise WrongPassword) ) else raise AccountLocked) in { save; get_force; get; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = if n = 0 then (count_rec_calls := !count_rec_calls + 1;  ( 1 , !count_rec_calls )) else let rec aux i n acc = if i > n then (count_rec_calls := !count_rec_calls + 1; ( acc , !count_rec_calls )) else aux (i + 1) n (acc + fst(catalan i) * fst(catalan (n-i))) in aux 0 (n-1) 0 in catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let curVal = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; curVal with Not_found -> let curVal = (f f' x) in Hashtbl.add hash x curVal; stats.entries := !(stats.entries) + 1; curVal in f'  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats_f = { entries = ref 0; lkp = ref 0 } in ((memoize (memo_cat) (stats_f)) n, stats_f) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match f x with | None -> find_map f xs | sv -> sv ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun cur (lp, lf) -> if p cur then (cur :: lp, lf) else (lp, cur :: lf)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_wrong_cnt = ref 0 in let ref_op_cnt = ref 0 in let ref_mp = ref masterpass in  let verifymp mp = if mp = !ref_mp then (ref_wrong_cnt := 0; ref_op_cnt := !ref_op_cnt + 1) else (ref_wrong_cnt := !ref_wrong_cnt + 1; raise WrongPassword) in  let verifylock () = if !ref_wrong_cnt >= 3 then raise AccountLocked else () in  let save mp add pwd = ( verifylock (); verifymp mp; ref_list := (add, encrypt mp pwd) :: !ref_list ) in  let get_force mp add = try let (_, pwd_enc) = List.find (fun (add', _) -> add = add') !ref_list in Some (decrypt mp pwd_enc) with Not_found -> None in  let get mp add = ( verifylock (); verifymp mp; get_force mp add ) in  let update_master mp mp' = ( verifymp mp; ref_mp := mp'; ref_list := List.map ( fun (add, pwd) -> (add, encrypt mp' (decrypt mp pwd)) ) !ref_list ; ) in  let count_ops mp = ( verifylock (); verifymp mp; !ref_op_cnt ) in  { save ; get_force ; get ; update_master ; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n = ( count_rec_calls := !count_rec_calls + 1 ; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_helper i * catalan_helper (n - i)) in aux 0 (n-1) 0 ) in let ans = catalan_helper n in (ans, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try (let v = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; v) with Not_found -> let v = f f' x in (Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0 ; lkp = ref 0 } in let ans = memoize memo_cat stats n in (ans, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f x <> None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let part_helper (a : 'a) ((l1, l2) : 'a list * 'a list) : ('a list * 'a list) = if (p a) then (a::l1, l2) else (l1, a::l2) in List.fold_right part_helper l ([], [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let num_calls = ref 0 in let master = ref masterpass in let num_exceptions = ref 0 in let correct_pass (check_pass : masterpass) : bool = incr num_calls; if !master = check_pass then (num_exceptions := 0; true) else (incr num_exceptions; false) in let save (masterpass: masterpass) (add : address) (pass : password) : unit = if !num_exceptions = 3 then raise AccountLocked else if correct_pass masterpass then let my_pass = encrypt masterpass pass in ref_list := (add, my_pass) :: !ref_list; else raise WrongPassword in let get_force (masterpass : masterpass) (add : address) : password option = let find ((a, p) : address * password) : password option = if a = add then Some (decrypt masterpass p) else None in find_map find !ref_list in let get (masterpass : masterpass) (add : address) : password option = if !num_exceptions = 3 then raise AccountLocked else if correct_pass masterpass then get_force masterpass add else raise WrongPassword in let update_master (masterpass: masterpass) (newpass : masterpass) : unit = if correct_pass masterpass then (master := newpass; let decrypt_to_encrypt ((a,p) : address * password) : (address * password) = let dec = decrypt masterpass (p) in let en = encrypt !master dec in (a, en) in ref_list := List.map decrypt_to_encrypt !ref_list) else raise WrongPassword in let count_ops (masterpass : masterpass) : int = if !num_exceptions = 3 then raise AccountLocked else if correct_pass masterpass then !num_calls - !num_exceptions else raise WrongPassword in let my_pass_manager = {save; get_force; get; update_master; count_ops} in my_pass_manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec aux i n acc = if n = 0 then 1 else let change = n - 1 in if i > change then acc else let x = aux 0 (i) 0 in let y = aux 0 (change - i) 0 in (count_rec_calls := !count_rec_calls + 2; aux (i + 1) n (acc + x * y)) in let result = aux 0 (n) 0 in (incr count_rec_calls; (result, !count_rec_calls))  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some result -> (incr stats.lkp; result) | _ -> (let result = f f' x in Hashtbl.add hash x result; incr stats.entries; result) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let myStats = {entries = ref 1; lkp = ref 0} in let answer = memo_cat (memoize memo_cat myStats) n in (answer, myStats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> let r = f(x) in if   (r) = None then find_map f xs else f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let rec helper (p : 'a -> bool) (l : 'a list) (a , b)  = match l with |[] -> (a,b) |x :: xs -> if p(x) then helper p xs ( List.fold_right (fun a c -> a::c) a [x] , b) else helper p xs (a ,List.fold_right (fun b c -> b::c) b [x]) in helper p l ([], [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in {save = (fun pass add local -> if pass = masterpass then ref_list :=  !ref_list @ [( add , encrypt masterpass local)] else raise WrongPassword ) ;  get_force = ( fun  pass add -> raise NotImplemented ) ; get  = (fun pass add -> raise NotImplemented) ;  update_master = (fun  oldpass newpass -> else *) raise NotImplemented ) ; count_ops = (fun pass -> raise NotImplemented) }     ;; ",
  "let rec catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in if n = 0 then (1,1) else let rec aux i n (acc, ref) = if i > n then (acc, ref) else let (a,b) = catalan_count i in let (c,d) = catalan_count (n - i) in aux (i + 1) n (acc + a * c,  ref+b+d ) in aux 0 (n-1) (0, !count_rec_calls+1) let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x else let y = f f' x in Hashtbl.add hash x y; Hashtbl.find hash x  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_tr f l acc = match l with | [] -> acc | h::tail -> let result = f h in match result with | None -> find_map_tr f tail None | Some v -> Some v in find_map_tr f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let split elem (tl,fl) = if p elem then (elem::tl,fl) else tl, (elem::fl) in List.fold_right split l ([],[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let storedMpass = ref (encrypt masterpass masterpass) in let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let allowedAttempts = ref 3 in  let checkMpass (mpass:masterpass) = if !allowedAttempts = 0 then raise AccountLocked else if mpass = decrypt mpass !storedMpass then let _ = allowedAttempts := 3 in true else let _ = decr allowedAttempts in raise WrongPassword in  let count_ops = fun (mpass:masterpass) -> if checkMpass mpass then incr counter; !counter in  let save = fun (mpass:masterpass) addr (lpass:password) -> if not (checkMpass mpass) then raise WrongPassword else incr counter; let new_addr : address = addr in let new_pass : password = encrypt mpass lpass in let new_entry = (new_addr, new_pass) in ref_list := new_entry::!ref_list in  let get_force = fun (mpass:masterpass) addr -> find_map (fun entry -> let (addr2, passw) = entry in if addr = addr2 then (Some (decrypt mpass passw)) else None) !ref_list in  let get = fun (mpass:masterpass) addr -> if checkMpass mpass then let _ = incr counter in get_force mpass addr else raise WrongPassword in  let update_master = fun (currMpass:masterpass) (newMpass:masterpass) -> if currMpass = decrypt currMpass !storedMpass then let _ = incr counter in let _ = allowedAttempts := 3 in storedMpass := (encrypt newMpass newMpass); let updatePass el:(address * password) = let (addr, pass) = el in let original_pass = decrypt currMpass pass in let new_pass = encrypt newMpass original_pass in (addr, new_pass) in ref_list := List.map updatePass !ref_list; else let _ = decr allowedAttempts in raise WrongPassword  in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = let _ = incr count_rec_calls in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + catalan i * catalan (n - i)) in aux 0 (n - 1) 0 in let catalan_numb = catalan n in (catalan_numb, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let new_entry = f f' x in Hashtbl.add hash x new_entry; incr stats.entries; new_entry | Some v -> incr stats.lkp; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let stats = {entries = ref 0; lkp = ref 0} in let memo_cat' recf n1 = if n1 = 0 then 1 else recf (n1 - 1) * recf (n1 - 2) in let recf' = memoize memo_cat' stats in recf' n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let result = memoize memo_cat stats in ((result n), stats) ;; ",
  "let find_tests: ((('a -> 'b option) * 'a list) * ('b option)) list = [((let p x = match x with |0 -> None |_ -> (Some (100/x)) in (p, [])), (None)); ((let z x = match x with |0 -> None |_ -> (Some (100/x))in (z, [0;0;0;2;1])), (Some 50)); ((let q x = match x with |100 -> None |_ -> (Some (100-x)) in (q, [100;100;100])), (None)); ((let d x = match x with |100 -> None |_ -> (Some (100-x)) in (d, [100;100;99])), (Some 1))] ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match (f x) with |None -> find_map f xs |Some v -> Some v ;; ",
  "let part_tests: ((('a -> bool) * 'a list) * ('a list * 'a list)) list = [((let p x = x > 10 in (p, [])), ([],[])); ((let z x = x > 3 in (z, [2;2;2;2;2;1])), ([],[2;2;2;2;2;1])); ((let q x = x > 3 in (q, [3;2;1;4;5;6])), ([4;5;6],[3;2;1])); ((let d x = x > 10 in (d, [11;21;21;21])), ([11;21;21;21],[]))] ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let getplist element1 list1 = if (p element1) then element1::list1 else list1 in let getnplist element2 list2 = if not (p element2) then element2::list2 else list2 in ((List.fold_right getplist l []), (List.fold_right getnplist l [])) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let count_err = ref 0 in let count_succ = ref 0 in  let save master1 addr1 localpass1 = if (!count_err < 3) then if (master1 = !master) then (count_succ := !count_succ + 1; count_err := 0; ref_list := (addr1,(encrypt master1 localpass1))::!ref_list) else (count_err := !count_err + 1; raise WrongPassword) else raise AccountLocked in  let get_force master2 addr2 = let verify pair = let (a,b) = pair in if a = addr2 then Some b else None in let sresult = find_map verify !ref_list in if sresult = None then None else match sresult with |Some c -> Some (decrypt master2 c) |None -> None in  let get master3 addr3 = if (!count_err < 3) then if (master3 = !master) then (count_succ := !count_succ + 1; count_err := 0; get_force master3 addr3) else (count_err := !count_err + 1; raise WrongPassword) else raise AccountLocked in  let update_master masterold masternew = let rec update mo mn l l2= match l with |[] -> l2 |x::xs -> let (add,pass) = x in update mo mn xs l2@[(add, encrypt mn (decrypt mo pass))] in if (masterold = !master) then (ref_list := update masterold masternew !ref_list []; master := masternew; count_succ := !count_succ + 1; if !count_err >= 3 then count_err := 0 else ()) else (count_err := !count_err + 1; raise WrongPassword) in  let count_ops master5 = if !count_err < 3 then if !master = master5 then (count_succ := !count_succ + 1; count_err := 0; !count_succ) else (count_err := !count_err + 1; raise WrongPassword) else raise AccountLocked  in let manager = {save; get_force; get; update_master; count_ops} in manager ;; ",
  "let cat_tests: (int * (int*int)) list = [(10, (16796, 59049)); (12, (208012, 531441)); (11, (58786, 177147)); (0,(1,1))] let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalanc n count_rec_calls = count_rec_calls := !count_rec_calls+1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalanc i count_rec_calls * catalanc (n - i) count_rec_calls) in aux 0 (n-1) 0 in let catnum = catalanc n count_rec_calls in (catnum,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with |Some v -> (stats.lkp := !(stats.lkp) + 1; v) |None -> (stats.entries := !(stats.entries) + 1; let newv = f f' x in (Hashtbl.add hash x newv; newv)) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf(i)*recf(n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let record = {entries = ref 0; lkp = ref 0} in let catnum = memoize (memo_cat) (record) in (catnum n, record) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match f x with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (ps,fs) = if p x then (x :: ps,fs) else (ps, x :: fs) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in raise NotImplemented ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let check =  (f h) in if (check = None) then find_map f t else check ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with |[] -> ([],[]) |_::_ -> let in_f a (x,y) = if (p a) then (a::x,y) else (x,a::y) in List.fold_right in_f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let succ_call = ref 0 in let master_pass = ref masterpass in let num_wrong_pass = ref 0 in  let check_master (given_pass : masterpass) = if (given_pass = !master_pass) then begin succ_call := !succ_call + 1; true end else false in  let check_wrong_fun () = if(!num_wrong_pass = 2) then raise AccountLocked else begin num_wrong_pass := !num_wrong_pass +1;num_wrong_pass := 0; raise WrongPassword end in  let save = fun given_pass address password -> if (check_master given_pass) then ref_list := ( address,(encrypt given_pass password))::!ref_list else check_wrong_fun() in  let get_force = fun given_pass address :password option -> let f ((a,p):(address * password)) = if (a = address) then Some p else None in let pass = find_map f !ref_list in match pass with | None -> None | Some p -> (Some (decrypt given_pass p)) in  let get = fun given_pass address -> if (check_master given_pass) then (get_force given_pass address) else check_wrong_fun() in  let update_master = fun cur_pass new_pass -> if (check_master cur_pass) then let dec_enc (a,p):(address * password) = (a,(encrypt new_pass (decrypt cur_pass p))) in begin num_wrong_pass := 0; ref_list := (List.map dec_enc !ref_list ); master_pass := new_pass end else check_wrong_fun() in  let count_ops = fun given_pass -> if (check_master given_pass) then !succ_call else check_wrong_fun() in { save ; get_force ; get; update_master;count_ops }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in if n = 0 then (1,1) else let rec cat n = if n = 0 then 1 else let rec aux i n acc = if i>n then acc else begin count_rec_calls := !count_rec_calls + 2; aux (i+1) n (acc + cat i * cat (n - i)) end in aux 0 (n-1) 0 in let v = begin count_rec_calls := !count_rec_calls+ 1 ; cat n end in (v , !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let x_val_option = Hashtbl.find_opt hash x in match x_val_option with |None -> let new_val = f f' x in begin Hashtbl.add hash x new_val; stats.entries := !(stats.entries)+1; new_val end |Some x_val -> begin stats.lkp := !(stats.lkp)+1; x_val end in f'  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp  = ref 0 in let stats = {entries; lkp} in ( (memoize memo_cat stats n),stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[]-> None |x::xs-> if f x <> None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let first = List.fold_right (fun x y -> if ( p x) then x::y else y) l [] in let second = List.fold_right (fun x y -> if ( p x) then y else x::y) l [] in (first,second) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let count = ref 1 in let wrong = ref 0 in let current = ref masterpass in let check p = p = !current in if !wrong = 3 then raise AccountLocked else if check masterpass then wrong := 0; ref_list := !ref_list @ [(address, encrypt masterpass password)]) else (wrong := !wrong + 1; raise WrongPassword) in (match find_map (fun (address,p) -> Some p) !ref_list with | Some p -> Some (decrypt masterpass (p)) | None -> Some \"\") in if !wrong = 3 then raise AccountLocked else if check masterpass then (count := !count + 1; wrong := 0; get_force masterpass address) else (wrong := !wrong + 1; raise WrongPassword) in if !wrong = 3 then raise AccountLocked else if check masterpass then (wrong := 0; !count) else (wrong := !wrong + 1; raise WrongPassword) in if check on then (count := !count + 1; wrong := 0; current:= masterpass; let new_list = ref [] in let rec change o n = match o with | [] -> n | x::xs -> let (a,p) = x in change xs (n @ [(a,encrypt !current (decrypt on p))]) in ref_list := change !ref_list !new_list) else if !wrong = 3 then try let var = count_ops on in raise AccountLocked with AccountLocked -> raise WrongPassword else (wrong := !wrong + 1; raise WrongPassword) in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n= count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec counter i n acc = if i > n then acc else counter (i+1) n (acc + helper i * helper(n - i)) in counter 0 (n-1) 0 in let a = helper n in (a, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let acc1 = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; acc1 let acc2 = f (f') x in Hashtbl.add hash x acc2; stats.entries := !(stats.entries) + 1; acc2 in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | _ -> let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0} in (memoize memo_cat stats n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | None -> find_map f t | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (l_list,r_list) = if p x then (x::l_list,r_list) else (l_list,x::r_list) in List.fold_right f l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_fails : int ref = ref 0 in let ref_success : int ref = ref 0 in let ref_master : masterpass ref = ref masterpass in let check_pass (pass:masterpass) = if String.equal pass !ref_master then (incr ref_success; ref_fails := 0) else (incr ref_fails; raise WrongPassword) in let rec new_pass new_master l= match l with | []-> [] | h::t -> let (a,p) = h in (a, (encrypt new_master (decrypt !ref_master p))):: (new_pass new_master t) in let find_map_fun (x) (a,p) = if String.equal x a then Some p else None in let get_force (pass:masterpass) (a:address) : password option = match find_map (find_map_fun a) !ref_list with | None -> None | Some v -> Some (decrypt pass v) in let save master add pass = if !ref_fails = 3 then raise AccountLocked else try check_pass master; ref_list := !ref_list @ [(add, (encrypt !ref_master pass))]; with WrongPassword -> raise WrongPassword in let get (pass:masterpass) (address:string): password option= if !ref_fails = 3 then raise AccountLocked else try check_pass pass; get_force pass address with WrongPassword -> raise WrongPassword in let update_master master new_master = if !ref_fails = 3 then try check_pass master; ref_list := (new_pass new_master !ref_list); ref_master := new_master; ref_fails := 0; with WrongPassword -> raise WrongPassword else try check_pass master; ref_list := (new_pass new_master !ref_list); ref_master := new_master; with WrongPassword -> raise WrongPassword in let count_ops master = if !ref_fails = 3 then raise AccountLocked else try check_pass master;!ref_success; with WrongPassword -> raise WrongPassword in {save=save; get_force=get_force; get=get; update_master=update_master; count_ops=count_ops} ;; ",
  "let manager = make_manager \"jawnie\";; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_old n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_old i * catalan_old (n - i)) in aux 0 (n-1) 0 in let value = catalan_old n in (value,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let value = Hashtbl.find_opt hash x in match value with | None -> let a = (f f' x) in Hashtbl.add hash x a; incr stats.entries; a ; | Some x -> incr stats.lkp; x; in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat ={entries = ref 0; lkp = ref 0} in let value = (memoize (memo_cat) stat) n in (value,stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | head :: tail -> match f head with | Some x -> Some x | None -> find_map f tail ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let fn elem (l1, l2) = if p elem then (elem :: l1, l2) else (l1, elem ::l2) in List.fold_right fn l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let saveMaster = ref masterpass in let succeCalls = ref 0 in let wrongCalls = ref 0 in  let more3Wrong () = if !wrongCalls >= 3 then raise AccountLocked in  let checkMaster masterpassIn = if masterpassIn <> !saveMaster then (incr wrongCalls; raise WrongPassword;) in  let runFn () = succeCalls := !succeCalls + 1; wrongCalls := 0 in   let rec program = { save = (fun masterpassIn addIn pswIn -> begin more3Wrong (); checkMaster masterpassIn; let encryPws = encrypt masterpassIn pswIn in ref_list := (addIn, encryPws) :: !ref_list; runFn (); end );  get_force = (fun masterpassIn addIn -> begin let getPsw =  find_map  (fun pair -> let (addList, pswList) = pair in if addList = addIn then Some pswList else None)     !ref_list in match getPsw with | Some x ->  Some (decrypt masterpassIn x) | None -> None end );    get = (fun masterpassIn addIn -> begin more3Wrong (); checkMaster masterpassIn; runFn (); program.get_force masterpassIn addIn; end );   update_master= (fun oldMaster newMaster -> begin checkMaster oldMaster; ref_list := List.map (fun (add,pws) -> (add, encrypt newMaster (decrypt oldMaster pws))) !ref_list; saveMaster := newMaster; runFn (); end );  count_ops = (fun masterpassIn -> begin more3Wrong (); checkMaster masterpassIn; runFn (); !succeCalls end);   } in program ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let addcall () = count_rec_calls := !count_rec_calls + 1 in  let rec sumUp f = function 0 -> f(0) | n -> f(n) + sumUp f (n-1) in  let rec catalan n = addcall (); match n with | 0 -> 1 | n -> let  f i = catalan i * catalan (n-1-i) in  sumUp f (n-1) in  let cn = catalan n in (cn, !count_rec_calls) ;; ",
  "type counter_object = { addEntry : unit -> unit; getEntry: unit -> int; addLkp: unit -> unit; getLkp: unit -> int; };; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let insMech (stats : stats) = let insE = stats.entries in let insL = stats.lkp in { addEntry = (fun () -> insE:= !insE + 1); getEntry = (fun () -> !insE); addLkp = (fun () -> insL:= !insL + 1); getLkp = (fun () -> !insL) } in  let insStat = insMech stats in let rec f' x = match Hashtbl.find_opt hash x with | None -> insStat.addEntry (); let newValue = f f' x in Hashtbl.add hash x newValue; newValue; | Some x  -> insStat.addLkp (); x in  f' ; ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n=0 then 1 else let rec addUp i n  = if i>n-1 then 0 else addUp (i+1) n  + (recf i * recf (n-1-i)) in addUp 0 n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0 ; lkp= ref 0} in let memoize1  = memoize memo_cat stats in let bValue = memoize1 n in ( bValue, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> if (f x) <> None then (f x) else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let p_list y (partition_lists : ('a list * 'a list)) = if p y then let (ls, rs) = partition_lists in (y::ls, rs) else let (ls, rs) = partition_lists in (ls, y::rs) in List.fold_right (p_list) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterp = ref  masterpass in let successful_count = ref 0 in let wrongp_count = ref 0 in let p_check = fun mp -> if !wrongp_count < 3 && mp = !masterp then ( wrongp_count := 0; successful_count := !successful_count +1) else if !wrongp_count >= 3 then raise AccountLocked else (wrongp_count := !wrongp_count + 1; raise WrongPassword) in let save = fun mp address lp -> p_check mp; ref_list := (address, (encrypt mp lp))::(!ref_list) in let get_force = fun mp address -> find_map (fun a -> let (addr,pass) = a  in if addr = address then Some (decrypt mp pass) else None) !ref_list in let get = fun mp addr -> p_check mp; get_force mp addr in let update_master = fun mp np -> p_check mp; ref_list := List.map (fun x -> let (a,p) = x  in (a, encrypt np (decrypt mp p)) ) !ref_list; masterp := np in let count_ops = fun mp -> p_check mp; !successful_count; in {save; get_force; get ;update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec count_catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux_count i n acc = if i > n then acc else aux_count (i + 1) n (acc + count_catalan i * count_catalan (n - i)); in  aux_count 0 (n-1) 0 in let c = count_catalan n in (c, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let search_val = Hashtbl.find_opt hash x in match search_val with | Some s -> (stats.lkp := !(stats.lkp) + 1); s | None -> let value = f (f') x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in (memoize memo_cat s n , s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::t ->match f x with Some c->f x | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let fil x (a,b) = if p x then (x::a,b) else (a,x::b) in let (l1,l2) = List.fold_right fil l ([],[])  in (l1,l2) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrong_pass_consec = ref 0 in let count_ops_success = ref 0 in let master_pass = ref masterpass in let pass_eq pass = pass = !master_pass in let save =( fun master address local -> if !wrong_pass_consec>2 then raise AccountLocked else if pass_eq master then ( wrong_pass_consec := 0; count_ops_success := !count_ops_success+1; ref_list := !ref_list@[(address,encrypt master local)]) else( wrong_pass_consec := !wrong_pass_consec +1; if !wrong_pass_consec>2 then raise AccountLocked else raise WrongPassword ) ) in let get_force =( fun master address -> find_map (fun (a,b) -> if address=a then Some (decrypt master b) else None) !ref_list ); in let get = (fun master address -> if !wrong_pass_consec>2 then raise AccountLocked else if pass_eq master then ( wrong_pass_consec := 0; count_ops_success := !count_ops_success+1; get_force master address ) else( wrong_pass_consec := !wrong_pass_consec +1; if !wrong_pass_consec>2 then raise AccountLocked else raise WrongPassword) ) in let update_master = (fun current_master new_master -> if pass_eq current_master then ( master_pass:=new_master; ref_list := List.map (fun (a,b) -> (a,encrypt new_master (decrypt current_master b))) !ref_list; count_ops_success := !count_ops_success+1; wrong_pass_consec := 0 ) else( wrong_pass_consec := !wrong_pass_consec +1; raise WrongPassword ) ) in let count_ops = (fun masterpass -> if !wrong_pass_consec>2 then (raise AccountLocked) else (if pass_eq masterpass then (wrong_pass_consec := 0; count_ops_success:=!count_ops_success +1; !count_ops_success) else(wrong_pass_consec := !wrong_pass_consec +1; raise WrongPassword) ) ) in {save=save;get_force=get_force;get=get;update_master=update_master;count_ops=count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n= count_rec_calls:=!count_rec_calls+1; if n=0 then 1 else let rec aux i n acc = if i >n then acc else   aux (i+1) n (acc + cat i * cat (n-i)) in aux 0 (n-1) 0 in let x = cat n in (x,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then( stats.lkp:= !(stats.lkp)+1; Hashtbl.find hash x ) else let v = f f' x in stats.entries := !(stats.entries)+1; Hashtbl.add hash x v; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n=0 then 1 else let rec aux i n acc = if i>n then acc else aux(i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0;lkp = ref 0} in let x = memoize memo_cat s in (x n,s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> begin match f x with | Some _ as result -> result | None -> find_map f xs end ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let rec part yes no = function | [] -> (List.rev yes, List.rev no) | x::xs -> if p x then part (x::yes) no xs else part yes (x::no) xs in part [] [] (List.fold_right ( fun l ll -> (List.rev l) ) [] l) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let count = ref 0 in let ref_list : (address * password) list ref = ref [] in let masspass = ref masterpass in let saveINC mpass add pass = ref_list := (add, (encrypt mpass pass))::(!ref_list); count := !count + 1; in  let get_force = (fun (mpass: string) (add: string) -> find_map (fun (a,b) -> if (String.equal a add) then Some (decrypt mpass b) else None) !ref_list ) in let getINC mpass add = count := !count + 1; get_force mpass add; in let rec update list newp oldp : (unit) = masspass := newp; match list with | [] -> () | (a,b)::xs -> let decrypted = decrypt oldp b in b = encrypt newp decrypted; update xs newp oldp in let update_masterINC list newpass mpass = count := !count + 1; update !ref_list newpass mpass; in {save = (fun (mpass: string) (add: string) (pass: string) -> if (String.equal (!masspass) (mpass)) then saveINC mpass add pass else raise WrongPassword ); get_force; get = (fun (mpass: string) (add: string) -> if (String.equal (!masspass) (mpass)) then getINC mpass add else raise WrongPassword ); update_master = (fun (mpass: string) (newpass: string) -> if (String.equal (!masspass) (mpass)) then update_masterINC !ref_list newpass mpass else raise WrongPassword ); count_ops = (fun (mpass: string) -> if (String.equal (!masspass) (mpass)) then !count else raise WrongPassword ) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let cNum = catalan n in (cNum, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.mem hash x with | true -> incr stats.lkp; Hashtbl.find hash x; | false -> let result = f f' x in Hashtbl.add hash x result; incr stats.entries; result; in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | n -> recf (n - 1) * 2 * (2 * n - 1) / (n + 1) ;; ",
  "let catalan_m (n : int) : int * stats = let (st : stats) = {entries = (ref 0); lkp = (ref 0)} in (memoize memo_cat st n, st) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec aux f lst = match lst with | [] -> None | hd::tl ->  if (f hd <> None) then f hd else aux f tl in aux f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l_t = List.fold_right (fun x a -> if p x then x::a else a) l [] in let l_f = List.fold_right (fun x a -> if not (p x) then x::a else a) l [] in (l_t, l_f) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let curr_masterpass : string ref = ref masterpass in let remaining_attempts : int ref = ref 3 in let successful_attempts : int ref = ref 0 in let isAccountLocked : bool ref = ref false in let wrongPasswordAttempt () = if !remaining_attempts > 1 then (decr remaining_attempts ; raise WrongPassword) else (isAccountLocked := true; raise WrongPassword) in mpass = !curr_masterpass in let save mpass address local_pass : unit = if !isAccountLocked then raise AccountLocked else if (test_mpass mpass) then let encrypted_pass = encrypt mpass local_pass in (incr successful_attempts ; ref_list := (ref_list.contents @ [(address, encrypted_pass)]) ) else if (!remaining_attempts > 0) then wrongPasswordAttempt () else (isAccountLocked := true ; raise AccountLocked) in let get_force mpass local_add : password option = let f (addy, pass) : password option = if addy = local_add then Some pass else None in let local_pass_encrypt = find_map f ref_list.contents in let local_pass_decrypted = match local_pass_encrypt with | Some v -> Some (decrypt mpass v) | None -> None in local_pass_decrypted in let get mpass local_add : password option = if !isAccountLocked then raise AccountLocked else if (test_mpass mpass) then (incr successful_attempts ; isAccountLocked := false; reset_attempts () ; get_force mpass local_add) else if (!remaining_attempts > 0) then wrongPasswordAttempt () else (isAccountLocked := true ; raise AccountLocked) in let update_master old_mpass new_mpass = if !isAccountLocked && not (test_mpass old_mpass) then raise WrongPassword else if (test_mpass old_mpass) then let f (addy,pass) = (addy, encrypt new_mpass (decrypt old_mpass pass ) ) in (ref_list := List.map f ref_list.contents ; incr successful_attempts ; curr_masterpass := new_mpass ; isAccountLocked := false; reset_attempts ()) else if (!remaining_attempts > 0) then wrongPasswordAttempt () else (isAccountLocked := true ; raise AccountLocked) in let count_ops mpass = if !isAccountLocked then raise AccountLocked else if (test_mpass mpass) then (incr successful_attempts; isAccountLocked := false; reset_attempts (); !successful_attempts) else if (!remaining_attempts > 0) then wrongPasswordAttempt () else (isAccountLocked := true ; raise AccountLocked) in {save; get_force; get; update_master; count_ops} ;; ",
  "   let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalann = incr count_rec_calls ; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let final= catalan n in (final, !count_rec_calls) ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try (let value = Hashtbl.find hash x in stats.lkp := (stats.lkp.contents + 1) ; value) with Not_found->  let value = f f' x  in (Hashtbl.add hash x value ; stats.entries := (stats.entries.contents + 1) ; value) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf(n -i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats_new = {entries = ref 0 ; lkp = ref 0} in let a = (memoize memo_cat stats_new) in (a n, stats_new) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | Some v -> Some v | _ -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let build_lists element (acc1, acc2) = if (p element) then (element::acc1, acc2) else (acc1, element::acc2) in List.fold_right build_lists l ([], []) ;; ",
  "let rec make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let wrong_attempt = ref 0 in let successes = ref 0 in  let true_masterpass = ref masterpass in  { save = (fun master address password -> if !wrong_attempt >= 3 then raise AccountLocked else if master = !true_masterpass then (successes := !successes + 1; wrong_attempt := 0; ref_list := (!ref_list @ [(address, encrypt master password)])) else (wrong_attempt := !wrong_attempt + 1; raise WrongPassword));  get_force = (fun master address -> find_map (fun pair -> let (a, p) = pair in if a = address then Some (decrypt master p) else None) !ref_list);  get = (fun master address -> if !wrong_attempt >= 3 then raise AccountLocked else if master = !true_masterpass then (successes := !successes + 1; wrong_attempt := 0; find_map (fun pair -> let (a, p) = pair in if a = address then Some (decrypt master p) else None) !ref_list) else (wrong_attempt := !wrong_attempt + 1; raise WrongPassword));  update_master = (fun input_master new_master -> if input_master = !true_masterpass then (successes := !successes + 1; wrong_attempt := 0; true_masterpass := new_master; ref_list := List.map (fun pair -> let (a, p) = pair in (a, encrypt new_master (decrypt input_master p))) !ref_list) else (wrong_attempt := !wrong_attempt + 1; raise WrongPassword));  count_ops = (fun master -> if !wrong_attempt >= 3 then raise AccountLocked else if master = !true_masterpass then (successes := !successes + 1; wrong_attempt := 0; !successes) else (wrong_attempt := !wrong_attempt + 1; raise WrongPassword))} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan_func n = (count_rec_calls := !count_rec_calls+1 ) ;  if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_func i * catalan_func (n - i)) in aux 0 (n-1) 0  in let catalan_result = catalan_func n in (catalan_result, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let counter_entries = stats.entries in let counter_lkp = stats.lkp in  let value_to_return = Hashtbl.find hash x in counter_lkp := !counter_lkp + 1 ;  let value_to_add = f f' x in Hashtbl.add hash x value_to_add ; counter_entries := !counter_entries + 1 ;  in f'  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else recf n-1 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = {entries = ref 0; lkp = ref 0} in (memoize (memo_cat) new_stats n, new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |h::t -> let ans = f h in if ans = None then find_map f t else ans ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let appendByP (h: 'a) (x: ('a list * 'a list)) : ('a list * 'alist) = let (trues, falses) = x in if p h then (h::trues, falses) else (trues, h::falses) in List.fold_right appendByP l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrongs = ref 0 in let ops = ref 0 in let masterpassword = ref masterpass in  let checkPass (inMaster : masterpass) = if (compare inMaster !masterpassword != 0) then begin wrongs := (!wrongs + 1); if (!wrongs) <= 2 then raise WrongPassword else raise AccountLocked end else begin if (!wrongs >= 3) then raise AccountLocked else (wrongs := 0; ops := 1 + !ops) end in  let subtractOps () = ops:=!ops-1 in  let pswdAtAddress (adrs : address) (x : (address * password)) : (password option) = let (a,p) = x in if a = adrs then Some p else None in  let saveFunc (inMaster : masterpass) (address : address) (locPass : password) : unit = let unit = checkPass inMaster in ref_list := (address, (encrypt masterpass locPass)):: !ref_list in  let get_forceFunc (master : masterpass) (address : address) : (password option) = let encryptedPass = find_map (pswdAtAddress address) !ref_list in match encryptedPass with |Some p -> let (decryptedPass : password) = decrypt master p in Some decryptedPass |None -> None in  let getFunc (inMaster : masterpass) (address : address) : (password option) = let unit = checkPass inMaster in get_forceFunc inMaster address in  let update_masterFunc (curMas : masterpass) (newMas : masterpass) : unit = let passRecrypt (x : (address * password)) (l : (address * password) list) : (address * password) list= let (a,p) = x in let newPass = encrypt newMas (decrypt curMas p) in (a, newPass):: l in  if curMas = !masterpassword then wrongs := 0;  let unit = checkPass curMas in let newPasses = List.fold_right passRecrypt !ref_list [] in let unit = ref_list := newPasses in masterpassword := newMas in  let count_opsFunc (inMaster : masterpass) : int = let unit = checkPass inMaster in !ops in  {save = saveFunc; get_force = get_forceFunc; get = getFunc; update_master = update_masterFunc; count_ops = count_opsFunc}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec cat_count_helper (n : int) : int= let unit = count_rec_calls := !count_rec_calls + 1 in if n = 0 then 1  else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + cat_count_helper i * cat_count_helper (n - i)) in aux 0 (n-1) 0 in  let catNum = cat_count_helper n in (catNum, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' (x: 'a) : 'b = try let catNo = Hashtbl.find hash x in let unit = (stats.lkp := !(stats.lkp) + 1) in catNo with Not_found -> (let unit = stats.entries := !(stats.entries) + 1 in let catNo = f f' x in let unit = Hashtbl.add hash x catNo in catNo) in let unit = stats.entries := 1 in f f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let sum = ref 0 in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let (stats :stats) = {entries=ref 0; lkp=ref 0} in let catNo = (memoize memo_cat stats) n in (catNo,stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t  -> match f h with | None -> find_map f t | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f element (l1, l2) = if p element then (element :: l1, l2) else (l1, element :: l2) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter = 0 in let addr : address = \"address\" in let password : password = \"password\" in let mp : masterpass ref =  ref \"masterpass\" in  let checker masterpass = masterpass = !mp in  let save = fun masterpass addr password -> if checker masterpass then let v = encrypt masterpass password in ref_list := (addr, v) :: !ref_list else raise WrongPassword in  let get_force = fun masterpass addr -> find_map (fun x -> if fst x = addr then Some (decrypt (masterpass) (password)) else None) !ref_list  in let get = fun masterpass addr -> if checker masterpass then get_force masterpass addr else raise WrongPassword in  let update_master = fun masterpass password -> if checker masterpass then mp := password else raise WrongPassword  in  let count_ops = fun masterpass -> raise WrongPassword  in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops}   ;; ",
  "let catalan_count (n:int):(int * int) = let count_rec_calls = ref 0 in let rec count n = if n = 0 then !count_rec_calls + 1 else ( incr count_rec_calls; incr count_rec_calls; incr count_rec_calls; let rec aux2 i n acc = if i > n then !count_rec_calls else aux2 (i+1) n (acc + count i * count (n - i )) in aux2 0 (n-1) 0 ) in let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in catalan n, count n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with |None -> let result = f f' x in Hashtbl.add hash x result; incr stats.entries; result |Some v-> incr stats.lkp; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec memoize recf i n acc = if i > n then acc else memoize recf (i + 1) n (acc + recf i * recf (n - i)) in memoize recf 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let e1 = ref 1 in let lkp1 = ref 0 in let s1 = {entries = e1; lkp = lkp1} in memo_cat (memoize memo_cat s1) n, s1 ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match f x with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let pass1 = List.filter p l in let pass2 = List.fold_left (fun acc e -> if (p e) then acc @ [e] else acc) [] l in let pass = List.fold_right (fun e acc -> if (p e) then e :: acc else acc) l [] in let fail = List.fold_right (fun e acc -> if (p e) then acc else e :: acc) l [] in (pass, fail) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : ((address * password) list ref) = ref [] in let masterpass_ref = ref masterpass in let counter = ref 0 in let wrong_pass_times = ref 0 in  let verify_pw : 'a -> bool= ( fun mp -> if mp = !masterpass_ref then ( counter := !counter + 1; wrong_pass_times := 0; true ) else false ) in  let get_force2 = ( fun mp address -> (fun (addr, localpass) -> if address = addr then Some (decrypt mp localpass) else None) !ref_list ) ) in  { save = ( fun mp address localpass -> if !wrong_pass_times >= 3 then raise AccountLocked else if verify_pw mp then ( let newEntry = (address, encrypt mp localpass) in ref_list := !ref_list @ [newEntry] ) else ( wrong_pass_times := !wrong_pass_times + 1; raise WrongPassword; ) ; );  get_force = get_force2 ;  get = ( fun mp address -> if !wrong_pass_times >= 3 then raise AccountLocked else if verify_pw mp then ( ) else ( wrong_pass_times := !wrong_pass_times + 1; raise WrongPassword; ); );  update_master = ( fun old_mp new_mp -> if verify_pw old_mp then ( masterpass_ref := new_mp;  (fun (addr, localpass) -> (addr, encrypt new_mp (decrypt old_mp localpass))) !ref_list ) ) else ( wrong_pass_times := !wrong_pass_times + 1; raise WrongPassword; ) );  count_ops = ( fun mp -> if !wrong_pass_times >= 3 then raise AccountLocked else if verify_pw mp then ( !counter ) else ( wrong_pass_times := !wrong_pass_times + 1; raise WrongPassword; ); ); } ;; ",
  "let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 ;; ",
  "*) let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0; in  (v, !count_rec_calls); ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  try (let v = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; v) with Not_found -> (let v = f (f') (x) in Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v) in  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0; ;; ",
  "let catalan_m (n : int) : int * stats = let make_stats = { entries = ref 0; lkp = ref 0 }; in let s = make_stats in let v = memoize memo_cat s n in (v, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec helper f l acc = match l with | [] -> None | x::xs -> if f x = None then (helper f xs acc) else f x in helper f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  (List.fold_right (fun a alist -> if (p a) then a::alist else alist) l [], List.fold_right (fun a alist -> if not (p a) then a::alist else alist) l []  ) let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter_fail = ref 0 in let counter_operation = ref 0 in let masterpassword = ref masterpass in    let verify masterpwd = if masterpwd  = !masterpassword then  ( counter_fail := 0 ;  counter_operation := !counter_operation + 1 ) else  counter_fail:= !counter_fail +1; if !counter_fail > 2 then raise AccountLocked else if not (masterpwd = !masterpassword) then raise WrongPassword  in  let save masterpwd addr pwd = verify masterpwd; ref_list := (addr, encrypt !masterpassword pwd) :: !ref_list; in  let get_force masterpwd addr = let localpwd = find_map (fun (x, y) -> if  x = addr then Some (decrypt masterpwd y) else None ) !ref_list in localpwd in  let get masterpwd addr = verify masterpwd;  get_force masterpwd addr  in  let update_master masterpwd newpwd = if not (masterpwd = !masterpassword) then ( counter_fail := !counter_fail + 1; raise WrongPassword) else if masterpwd = !masterpassword then  counter_fail := 0; counter_operation := !counter_operation +1; masterpassword := newpwd; let newlist = List.map (fun (x, y) -> (x, decrypt masterpwd y)) !ref_list in let updatedlist = List.map (fun (x, y) -> (x, encrypt newpwd y)) newlist in ref_list := updatedlist  in let count_ops masterpwd = verify masterpwd; let v = !counter_operation in v in   { save  ; get_force  ; get ; update_master   ; count_ops  }    ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in   let rec catalan n = let _ = count_rec_calls  := !count_rec_calls + 1 in if n = 0 then 1 else let rec aux i n acc = if i > n then  acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0  in let v = catalan n in (v, !count_rec_calls ) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let temp = f f' x in let _ = Hashtbl.add hash x temp in let _ = incr stats.entries in temp | Some b ->  let _ = incr stats.lkp in b in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int =  if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let mystat = {entries = ref 0; lkp = ref 0} in  (memoize memo_cat mystat n, mystat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> if f h != None then f h else find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun y (l1,l2)-> if (p y) then (y::l1,l2) else (l1, y::l2) ) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpass = ref masterpass in let count = ref 0 in let failedCount = ref 0 in  let checkPass mPass = if !failedCount = 3 then raise AccountLocked else if !masterpass = mPass then ( count := !count + 1; failedCount := 0; ) else ( failedCount := !failedCount + 1; raise WrongPassword ) in  let save mPass addr (lPass: string) = checkPass mPass; ref_list := (addr,encrypt mPass lPass) :: !ref_list in  let get_force mPass addr = match find_map (fun x -> let (address,password) = x in if address = addr then Some password else None) !ref_list with | None -> None | Some encryptedPass -> Some (decrypt mPass encryptedPass) in  let get mPass addr = checkPass mPass; get_force mPass addr in  let update_master mPass newmPass = if !masterpass = mPass then ( count := !count + 1; failedCount := 0; ref_list := (List.map (fun x -> let (addr,pass) = x in let decrypted = decrypt mPass pass in (addr, encrypt newmPass decrypted )) !ref_list); masterpass := newmPass ) else ( failedCount := !failedCount +1; raise WrongPassword ) in let count_ops mPass = checkPass mPass; !count in { save; get_force; get; update_master; count_ops }; ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec new_catalan n = incr count_rec_calls; if n = 0 then 1 else aux 0 (n-1) 0 and aux i n acc = if i > n then acc else aux (i + 1) n (acc + (new_catalan i) * new_catalan (n - i)) in let x = new_catalan n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try ( let valueFound = Hashtbl.find hash x in (stats.lkp) := !(stats.lkp) + 1; valueFound; ) with Not_found -> let valueFound = f f' x in Hashtbl.add hash x valueFound; (stats.entries) := !(stats.entries) + 1; valueFound; in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in let x  = aux in x 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let result = (memoize memo_cat stats) (n) in (result,stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let result = (f x) in match result with | None -> find_map f xs | _ -> result ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun x (l1, l2) -> if (p x) then (x :: l1, l2) else (l1, x::l2)) l ([],[]))   let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ops_count = ref 0 in let wrong_count = ref 0 in let cur_mp = ref masterpass in  let check_mp mp = if mp = !cur_mp then (wrong_count := 0; ops_count := !ops_count + 1; true) else false in  let save mp ad pw = if !wrong_count = 3 then raise AccountLocked else (if check_mp mp then ref_list := !ref_list @ [(ad, encrypt !cur_mp pw)] else (wrong_count := !wrong_count + 1; raise WrongPassword) ) in  let get_force mp ad =  let tmp_list = List.map (fun (ad, pw) -> (ad,Some pw)) !ref_list in  let pw = (find_map (fun (address, pw) -> if ad = address then pw else None) tmp_list) in match pw with | None -> None | Some p -> Some (decrypt mp p) in  let get mp ad = if !wrong_count = 3 then raise AccountLocked else (if check_mp mp then get_force mp ad else (wrong_count := !wrong_count + 1; raise WrongPassword)) in   let update_master cmp nmp = if !wrong_count = 3 then (if check_mp cmp then cur_mp := nmp else raise WrongPassword) else (if check_mp cmp then (wrong_count := 0; cur_mp := nmp; let tmp_list = List.map (fun (ad, pw) -> (ad,decrypt cmp pw)) !ref_list in ref_list := List.map (fun (ad, pw) -> (ad, encrypt nmp pw)) tmp_list) else (wrong_count := !wrong_count + 1; raise WrongPassword)) in   let count_ops mp = if !wrong_count = 3 then raise AccountLocked else ( if check_mp mp then !ops_count else (wrong_count := !wrong_count + 1; raise WrongPassword)) in  {save; get_force; get; update_master; count_ops}   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = count_rec_calls := ! count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + helper i * helper (n - i)) in aux 0 (n-1) 0 in let c = helper n in (c, ! count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let value = (f f' x) in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value | Some v -> (stats.lkp := !(stats.lkp) + 1; v) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 1 in let lkp = ref 0 in let stats = {entries; lkp} in (memo_cat (memoize memo_cat stats) n, stats)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> ( if (f h) = None then find_map f t else f h ) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (y,z) -> if p x then (x::y, z) else (y, x::z) ) l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ogmpass = ref masterpass in let previouspass = ref masterpass in let counter = ref 0 in let wrongpass = ref 0 in  let checkpass m = if m = !ogmpass then (counter := !counter + 1; wrongpass := 0) else (wrongpass := !wrongpass + 1;raise WrongPassword) in let lock = if (!wrongpass >= 3) then raise AccountLocked in let updatecheck oldmpass newmpass = if oldmpass = !ogmpass then (counter := !counter + 1; wrongpass := 0; previouspass := oldmpass; ogmpass := newmpass) else (wrongpass := !wrongpass + 1;raise WrongPassword) in let ufun = (fun (x,y) -> (x, encrypt !ogmpass (decrypt !previouspass y) ) ) in  let get_force = ( fun mpass add -> find_map (fun (x,y) -> (if x = add then let z = decrypt mpass y in Some z else None)) !ref_list) in   { save = (fun mpass add pass -> (lock; checkpass mpass; ref_list := (add,encrypt mpass pass)::(!ref_list))); get_force; get = ( fun mpass add -> (lock; checkpass mpass; get_force mpass add) ); update_master = (fun oldmpass newmpass -> (updatecheck oldmpass newmpass; ref_list := List.map ufun !ref_list )) ; count_ops = (fun mpass ->  (lock; checkpass mpass ; !counter)  ); } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec cat n = (count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + cat i * cat (n - i)) in (aux 0 (n-1) 0) ) in let y = cat n in (y, !count_rec_calls)   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = ( if Hashtbl.find_opt hash x = None then (stats.entries := !(stats.entries) + 1;Hashtbl.add hash x (f f' x); Hashtbl.find hash x ) else (stats.lkp := !(stats.lkp) + 1 ; Hashtbl.find hash x) ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let temp = f h in match temp with | None -> find_map f t | Some _ -> temp ;; ",
  "temp *) let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f curr (l1, l2) = (curr::l1, l2) (l1, curr::l2) in List.fold_right f l ([], []) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrongPwordCount : (int ref) = ref 0 in let currMaster : masterpass ref = ref masterpass in let countSuccess : int ref = ref 0 in  let save (masterpass:masterpass) (addr:address) (pword:password) = if (!wrongPwordCount >= 3) then raise AccountLocked else if masterpass = !currMaster then let _ = (countSuccess := !countSuccess + 1) in let _ = (wrongPwordCount := 0) in let encryptedPword = encrypt masterpass pword in  ref_list := ((addr, encryptedPword) :: !ref_list)  let _ = (wrongPwordCount := !wrongPwordCount + 1) in raise WrongPassword in  let get_force (masterpass:masterpass) (addr:address) = if (!wrongPwordCount >= 3) then raise AccountLocked else find_map (function (address, password) -> if address = addr then let p = decrypt masterpass password in Some p else None) !ref_list in  let get (masterpass:masterpass) (addr:address) = if (!wrongPwordCount >= 3) then raise AccountLocked else if masterpass = !currMaster then let _ = (wrongPwordCount := 0) in let _ = (countSuccess := !countSuccess + 1) in let p = get_force masterpass addr in p else let _ = (wrongPwordCount := !wrongPwordCount + 1) in raise WrongPassword in  let update_master (master: masterpass) (newMaster: masterpass) = if master = !currMaster then let _ = (countSuccess := !countSuccess + 1) in let _ = (wrongPwordCount := 0) in let _ = (currMaster := newMaster) in ref_list := List.map (fun (address,password) -> let pword = (decrypt master password) in let p = (encrypt newMaster pword) in (address, p)) !ref_list else raise WrongPassword in  let count_ops (masterpass:masterpass)= if (!wrongPwordCount >= 3) then raise AccountLocked else if masterpass = !currMaster then let _ = (wrongPwordCount := 0) in let _ = (countSuccess := !countSuccess + 1) in !countSuccess else let _ = (wrongPwordCount := !wrongPwordCount + 1) in raise WrongPassword in { save; get_force; get; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan2 n = let _ = (count_rec_calls := !count_rec_calls +1) in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan2 i * catalan2 (n - i)) in aux 0 (n-1) 0 in let res = catalan2 n in (res, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let inTable = Hashtbl.mem hash x in if inTable then let _ = stats.lkp := !(stats.lkp) + 1 in let elem = Hashtbl.find hash x in elem let x' = f f' x in let _ = stats.entries := !(stats.entries) + 1 in let _ = Hashtbl.add hash x x' in x' in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i num acc = if i > num then acc else aux (i + 1) num (acc + recf i * recf (num - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let newStats = { entries = ref 0; lkp = ref 0} in let x = memoize memo_cat newStats n in (x, newStats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option =  match l with | [] -> None | x::l-> match f x with | None -> find_map f l | x-> x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let x y (t,f)= match p y with |true->(y::t, f) |false-> (t, y::f) in List.fold_right x l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let  mp = ref masterpass in let success =  ref 0 in let attempts =  ref 1 in let x= ref 0 in  let helper (masterpass) (password): bool = match !attempts >=  3 with |true-> raise AccountLocked |false-> match masterpass=password with |true-> let x= success:=!success+1 in let y= attempts:= 1 in true |false-> let x= success:=!success in let y= attempts :=!attempts+1 in  false  in   let save  (masterpass) (address) (password) :unit= match helper(masterpass) (!mp)  with |true-> let z= x:=!x +1 in let e= (encrypt !mp password) in ref_list:=(address,e)::!ref_list |false->  raise WrongPassword in    let get_force (masterpass) (address): password option=  raise NotImplemented  in  let get(masterpass) (address):password option = raise NotImplemented in   let update_master (mp1) (mp2):unit= match helper (mp1) (!mp) with |true-> let _=mp:=mp2 in let str=(encrypt mp1 mp2) in ref_list:=(\"idk\",str)::!ref_list |false-> raise WrongPassword in   let count_ops (masterpass): int =  match helper (masterpass) (!mp)  with |true-> !success |false-> raise WrongPassword in    let pM:pass_manager = { save : masterpass -> address -> password -> unit; get_force : masterpass -> address -> password option; get : masterpass -> address -> password option; update_master : masterpass -> masterpass -> unit; count_ops : masterpass -> int } in pM ;; ",
  "    let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cata n count_rec_calls= match n with |0 ->(1, !count_rec_calls+1) |n-> let rec aux i n acc count_rec_calls = match i>n with |true->(acc, !count_rec_calls+1) |false-> let (ci, count) = cata i count_rec_calls in let inc= count_rec_calls := !count_rec_calls+1 in let (cni, count) = cata (n-i) count_rec_calls in let inc= count_rec_calls := !count_rec_calls+1 in aux (i + 1) n (acc + ci * cni) count_rec_calls in aux 0 (n-1) 0 count_rec_calls in cata n count_rec_calls ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try Hashtbl.find hash x;stats.lkp:=!(stats.lkp)+1; Hashtbl.find hash x with |Not_found->  let v= f f' x in Hashtbl.add hash x v; stats.entries:=!(stats.entries)+1; v  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let hash = Hashtbl.create 1000 in let 0=n in 1   ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let aTob a_list b_func = match a_list with | [] -> None | x::xs -> if (b_func(x)!=None) then b_func(x) else find_map b_func xs in aTob l f  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let sort r (a1,a2) = if ((p r)=true) then (r::a1,a2) else (a1,r::a2)   in List.fold_right sort l ([],[])    ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in raise NotImplemented ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let v = f x in match v with | Some x -> v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l1 = [] in let l2 = [] in List.fold_right (fun  x (l1,l2) -> if p x then (x::l1,l2) else (l1,x::l2)) l (l1,l2)    ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master_ref = ref masterpass in let count = ref 0 in let wrongPassCount = ref 0 in let check master = master = !master_ref in let save masterpass address password = if !wrongPassCount > 3 then raise AccountLocked else if check masterpass then (ref_list := (address,(encrypt masterpass password))::(!ref_list); wrongPassCount := 0; (count := !count +1)) else (wrongPassCount := !wrongPassCount +1; raise WrongPassword) in let get_force masterpass address = find_map (fun (x,y) -> if x = address then Some  (decrypt masterpass y) else None) !ref_list in let get masterpass address = if !wrongPassCount > 3 then raise AccountLocked else  if check masterpass then (count := !count + 1; wrongPassCount := 0; get_force masterpass address) else (wrongPassCount := !wrongPassCount +1; raise WrongPassword) in let update_master currmaster newmaster = let old_ref = ref !ref_list in ref_list := []; let rec update_passwords oldmaster newmaster lst = match lst with | [] -> () | x::xs -> let (a,p) = x in ref_list := (a,encrypt newmaster (decrypt oldmaster p))::!ref_list; update_passwords oldmaster newmaster xs in if check currmaster then (update_passwords currmaster newmaster !old_ref; wrongPassCount := 0; master_ref := newmaster) else (wrongPassCount := !wrongPassCount +1; raise WrongPassword) in let count_ops masterpass = if !wrongPassCount > 3 then raise AccountLocked else if check masterpass then (count := !count + 1; wrongPassCount := 0; !count) else (wrongPassCount := !wrongPassCount +1; raise WrongPassword) in  {save; get_force; get; update_master; count_ops}    ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (catalan i) * (catalan (n - i))) in aux 0 (n-1) 0 in let g = catalan n in g, !count_rec_calls ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x =  if Hashtbl.mem hash x then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else (Hashtbl.add hash x (f f' x); stats.entries := !(stats.entries) + 1; Hashtbl.find hash x) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n=0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n  (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp = ref 0 in  let statistics = {entries ;lkp} in let v = memoize memo_cat statistics n in v, statistics ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |a::b -> if f a != None then f a else find_map f b ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper (a : 'a) (b : 'a list)= if p a then a::b else b in let helper_f (a :'a) (b: 'a list) = if not(p a) then a::b else b in (List.fold_right (helper) (l) ([]), List.fold_right (helper_f) (l) ([])) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref( masterpass ) in let counter = ref 0 in let s_counter = ref 0 in  let test (t : password) = if !counter > 2 then raise AccountLocked else if t = !master then let _ = (counter:=0) in let _ = (s_counter := !s_counter + 1) in () else let _ = (counter := !counter + 1) in let _ = (s_counter := 0) in if !counter > 2 then raise AccountLocked else raise WrongPassword in   let get_force (m : masterpass) (a : address)= let check( (d, s) : (address * password)) = if a = d then Some (decrypt m s) else None in find_map check !ref_list in  { save  = (fun(m : masterpass) (a : address) (p : password) -> let _ = test m in ref_list := (a,encrypt m p)::!ref_list  );  get_force ;  get  = (fun(m : masterpass) (a : address) -> let _ = test m in get_force m a );   update_master  = (fun(m : masterpass) (p : password) -> let r = test m in let _ = master:=p in let helper (a,b) = (a, encrypt p (decrypt m b)) in let _ = ref_list := List.map helper !ref_list in () );   count_ops  = (fun(m : masterpass) -> let r = test m in  !s_counter) }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n : int = let _ = count_rec_calls := !count_rec_calls + 1 in if n = 0 then 1 else let rec aux i n acc : int = if i>n then acc else aux (i+1) n (acc + catalan_helper i * catalan_helper (n-i)) in aux 0 (n-1) 0 in let a = catalan_helper n in (a, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let c = Hashtbl.find_opt hash x in match c with | None -> let b = f f' x in let _ = Hashtbl.add hash x b in let _ = stats.entries := !(stats.entries) + 1 in b | Some d -> let _ = stats.lkp := !(stats.lkp) + 1 in d in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc : int = if i>n then acc else aux (i+1) n (acc + recf i * recf(n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let a = {entries = ref 0; lkp = ref 0} in let b = memoize memo_cat a n in (b, a) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f (x) with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let lamb p el (t,f) = if p el then (el::t, f) else (t, el::f) in List.fold_right (lamb p) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let count_call = ref 0 in let wrong_attempt = ref 0 in let check_master pass  = if !master = pass then begin count_call := !count_call + 1; wrong_attempt := 0; pass end else begin wrong_attempt := !wrong_attempt + 1; raise WrongPassword end in  let save masterpass add pass = let mp = if !wrong_attempt >= 3 then raise AccountLocked else check_master masterpass  in let new_pass = encrypt mp pass in ref_list := (!ref_list)@[(add, new_pass)] in  let get_force masterpass add = match find_map (fun (x,y) -> if add=x then Some y else None) !ref_list with | Some y -> Some (decrypt masterpass y) | None -> None in  let get masterpass add = let mp = if !wrong_attempt >= 3 then raise AccountLocked else check_master masterpass  in get_force mp add in  let update_master masterpass new_master = let mp = check_master masterpass in ref_list := List.map (fun (x,y) -> (x,encrypt new_master (decrypt mp y))) !ref_list; master := new_master in  let count_ops masterpass = let _ = if !wrong_attempt >= 3 then raise AccountLocked else check_master masterpass  in !count_call    in let pm = { get_force = get_force;  get = get; update_master = update_master; count_ops = count_ops; save = save } in pm   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_help n = count_rec_calls := !count_rec_calls + 1; if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else let (num1, _) = catalan_help i in let (num2, _) = catalan_help (n-i) in aux (i + 1) n (acc + num1 * num2) in aux 0 (n-1) 0 in catalan_help n  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some b -> stats.lkp := !(stats.lkp) + 1; b | None -> let func = f f' x in Hashtbl.add hash x (func); stats.entries := !(stats.entries) + 1; func in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = { entries = ref 0; lkp = ref 0} in (memoize memo_cat stat n, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | None -> find_map f xs | Some(v) -> Some(v) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (el : 'a) ((l1, l2) : 'a list * 'a list) : ('a list * 'a list) = match (p el) with |true -> (el::l1, l2) |_ -> (l1, el::l2) in List.fold_right f l ([],[]) let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master : masterpass ref = ref masterpass in let ref_count_ops : int ref = ref 0 in let ref_attempts : int ref = ref 0 in let pass_checker = fun p -> if p = !ref_master then (ref_count_ops := !ref_count_ops + 1; ref_attempts := 0) else (ref_attempts := !ref_attempts + 1; raise WrongPassword) in let att_checker = fun () -> if !ref_attempts >= 3 then raise AccountLocked in let save = (fun m -> fun a -> fun localp -> if (att_checker () = ()) && (pass_checker m = ()) then ref_list := (a, (encrypt m localp))::!ref_list ); in let get_force = (fun m -> fun a -> match (find_map (fun (locala, p) -> if a = locala then Some(p) else None ) !ref_list) with | Some(v) -> Some(decrypt m v) | None -> None); in let get = (fun m -> fun a -> if (att_checker () = ()) && (pass_checker m = ()) then get_force m a else None);  in let update_master = (fun m -> fun newm -> if pass_checker m = () then ref_list := (ref_master := newm; List.map (fun (a, p) -> (a, encrypt newm (decrypt m p)) ) !ref_list) ); in let count_ops = (fun m -> if (att_checker () = ()) && (pass_checker m = ()) then !ref_count_ops else -1 ); in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then (count_rec_calls := !count_rec_calls + 1 ; acc) else aux (i + 1) n (acc + catalan i * catalan (n - i)) in (count_rec_calls := !count_rec_calls + 2 ; aux 0 (n - 1) 0) in if n = 0 then (1,1) else let result = catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in (stats.lkp := !(stats.lkp) + 1; value) with Not_found -> let value = f f' x in (Hashtbl.add hash x value ; (stats.entries := !(stats.entries) + 1 ; value)) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let recf = function n -> if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 in recf n ;; ",
  "let catalan_m (n : int) : int * stats = let mystats : stats = { entries = ref 0; lkp = ref 0; } in let result = (memoize memo_cat mystats) n in (result, mystats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match (f h) with | Some h -> Some h | None -> (find_map f t) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let rec aux tst (pass, fail) = match p tst with | true -> (tst::pass, fail) | false -> (pass, tst::fail) in List.fold_right aux l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let attempts = ref 0 in let ref_list : (address * password) list ref = ref [] in let ops = ref 0 in let masterpass : string ref = ref masterpass in    let verify_master (masterpassIn : masterpass) : bool = if masterpassIn = !masterpass then (attempts := 0 ; incr ops; true) else (incr attempts; false) in    let locked : bool = !attempts > 3 in     let save (masterpassIn : masterpass) (address : address) (localpw : password) : unit = if locked then raise AccountLocked else if verify_master masterpassIn then ref_list := (address, (encrypt masterpassIn localpw))::!ref_list else raise WrongPassword in     let get_force (masterpassIn : masterpass) (address : address) : password option = let passes((adds, pass) : 'a) = if address = adds then Some pass else None in match find_map passes !ref_list with | None -> None | Some x -> Some (decrypt masterpassIn x) in      let get (masterpassIn : masterpass) (address : address) : password option = if locked then raise AccountLocked else if verify_master masterpassIn then get_force masterpassIn address else raise WrongPassword in     let update_master masterpassCurr masterpassNew  : unit = if locked then (raise AccountLocked) else if verify_master masterpassCurr then let currList = !ref_list in let newList : (address*password) list ref = ref [] in let rec iterator currList newList = match currList with | [] ->  ref_list := !newList; masterpass := masterpassNew | (adds, pwd)::t -> newList := !newList@[(adds, encrypt masterpassNew (decrypt masterpassCurr pwd))]; iterator t newList in iterator currList newList else raise WrongPassword in   let count_ops (masterpassIn : masterpass) = if locked then raise AccountLocked else if verify_master masterpassIn then !ops else raise WrongPassword in    { save; get_force; get; update_master; count_ops; }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in match n with | 0 -> (1,1) | 1 -> (1,3) | n ->  let rec cat n = (incr count_rec_calls; match n with | 0 -> 1 | n -> let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (cat i) * (cat (n - i))) in aux 0 (n-1) 0 ) in let c = cat n in (c , !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let out = f f' x in incr stats.entries; Hashtbl.add hash x out; out in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let my_Hash = Hashtbl.create 1000 in let rec recf n = match Hashtbl.find_opt my_Hash n with | Some v -> v | None -> match n with | 0 -> (Hashtbl.add my_Hash n 0; 1) | 1 -> (Hashtbl.add my_Hash n 1; 3) | n -> let b = recf (n - 2) + recf (n - 1) in (Hashtbl.add my_Hash n b; b) in recf n ;; ",
  "let catalan_m (n : int) : int * stats = let cat_stats = {entries= ref 0; lkp= ref 0} in let memoized = memoize (fun cat n -> if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (cat i) * cat (n-i)) in aux 0 (n-1) 0) cat_stats in (memoized n, cat_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> if f h <> None then f h else find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with | [] -> ([],[]) | h::t -> ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let inc() = count_rec_calls := (!count_rec_calls + 1) in let rec counter n = inc(); if n = 0 then 1 else let rec other i n acc = if i > n then acc else other (i + 1) n (acc + counter i * counter (n - i)) in other 0 (n-1) 0 in (counter n, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | a::l' -> match f a with ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let partition_helper el (acc1, acc2) = if p el then else in List.fold_right partition_helper l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let ref_list : (address * password) list ref = ref [] in let ref_master = ref masterpass in let ref_counter = ref 0 in let ref_wrongs = ref 0 in  let check_locked () = if !ref_wrongs >= 3 then raise AccountLocked else () in  let verify master_pw = if master_pw <> !ref_master then (ref_wrongs := !ref_wrongs + 1; raise WrongPassword) else (ref_wrongs := 0; ref_counter := !ref_counter + 1) in  let save master_pw address pw = ref_list := (address, encrypt !ref_master pw)::!ref_list in  let get_force master_pw address = let map_pw (ad, pw) = if ad = address then Some (decrypt master_pw pw) else None in find_map map_pw !ref_list in  let get master_pw address = get_force master_pw address in  let update_master master_pw new_master_pw = let rec update_pw_list old_list new_list = match old_list with | [] -> new_list | (address, old_pw)::old_list' -> let new_pw = encrypt new_master_pw (decrypt master_pw old_pw) in update_pw_list old_list' ((address, new_pw)::new_list) in let new_list_rev = update_pw_list !ref_list [] in ref_list := List.rev new_list_rev; ref_master := new_master_pw in  let count_ops master_pw = !ref_counter in  { save; get_force; get; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + ((catalan_helper i) * (catalan_helper (n - i)))) in aux 0 (n - 1) 0 in let c_n = catalan_helper n in (c_n, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try v) with Not_found -> v) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (recf i) * (recf (n - i))) in aux 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let value = (memoize memo_cat stats) n in (value, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | None -> find_map f xs | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (l1,l2) = if p x then ((x::l1),l2) else (l1,(x::l2)) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let count = ref 0 in let wrong_pass_count = ref 0 in  let verify_master (given_master : masterpass) : unit = if given_master = (!master) then wrong_pass_count := 0 else (wrong_pass_count := (!wrong_pass_count + 1); raise WrongPassword) in  let save (given_master : masterpass) (given_addr : address) (given_pass : password) : unit = if !wrong_pass_count >= 3 then raise AccountLocked; verify_master given_master; ref_list := ((given_addr, encrypt !master given_pass) :: !ref_list); count := (!count + 1); in  let get_force (master : masterpass) (given_addr : address) : password option = let map_helper (address : address) ((addr : address), (pass : password)) = if address = addr then Some (decrypt master pass) else None in find_map (map_helper given_addr) !ref_list in  let get (given_master : masterpass) (given_addr : address) : password option = if !wrong_pass_count >= 3 then raise AccountLocked; verify_master given_master; count := (!count + 1); get_force given_master given_addr in  let update_master (curr_master : masterpass) (new_master : masterpass) : unit = let new_ref_list : (address * password) list ref = ref [] in let rec update_list old_l new_l = match old_l with | [] -> new_l | x::xs -> let (addr, pass) = x in (addr, encrypt new_master (decrypt curr_master pass)) :: update_list xs new_l; in verify_master curr_master; master := new_master; count := (!count + 1); ref_list := (update_list !ref_list !new_ref_list); in  let count_ops (given_master : masterpass) : int = if !wrong_pass_count >= 3 then raise AccountLocked; verify_master given_master; count := (!count + 1); !count; in  {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let res = catalan n in (res, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> (stats.lkp := !(stats.lkp) + 1); v | None -> let v = (f f' x) in Hashtbl.add hash x v; (stats.entries := !(stats.entries) + 1); v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let res = memoize (fun f n -> (if n = 0 then 1 else memo_cat f n)) stats n in (res, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | a :: rest -> match f a with | None -> find_map f rest | b -> b ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let step a (l, r) = if p a then (a :: l, r) else (l, a :: r) in List.fold_right step l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ps : (address * password) list ref = ref [] in let al = ref false in let mp = ref masterpass in let cw = ref 0 in let cs = ref 0 in let ck m f = if !al then raise AccountLocked else (if m = !mp then (cw := 0; cs := !cs + 1; f ()) else (cw := !cw + 1; (if !cw = 3 then al := true); raise WrongPassword)) in let sv m a p = ck m (fun () -> ps := (a, (encrypt !mp p)) :: !ps) in let gf m a = if !al then raise AccountLocked else find_map (fun (b, p) -> if a = b then Some (decrypt m p) else None) !ps in let gt m a = ck m (fun () -> gf m a) in let re m n (a, p) = (a, (encrypt n (decrypt m p))) in let up m n = (mp := n; ps := List.map (re m n) !ps) in let um m n = if m = !mp then (if !al then (al := false; cw := 0); up m n) else raise WrongPassword in let co m = ck m (fun () -> !cs) in { save = sv; get_force = gf; get = gt; update_master = um; count_ops = co } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_sum s i a = if i = -1 then a else catalan_sum s (i - 1) (a + (catalan_ i * catalan_ (s - 1 - i))) and catalan_ c = count_rec_calls := !count_rec_calls + 1; if c = 0 then 1 else catalan_sum c (c - 1) 0 in let a = catalan_ n in (a, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' a = match Hashtbl.find_opt hash a with | None -> let b = f f' a in (Hashtbl.add hash a b; stats.entries := !(stats.entries) + 1; b) | Some(b) -> (stats.lkp := !(stats.lkp) + 1; b) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec memo_cat_sum f s i a = if i = - 1 then a else memo_cat_sum f s (i - 1) (a + ((f i) * (f (s - 1 - i)))) in if n = 0 then 1 else memo_cat_sum recf n (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = { entries= ref 0; lkp = ref 0 } in (memoize memo_cat s n, s) ;; ",
  "let find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_helper (f) (l) (acc) = match l with | [] -> acc | x::xs -> if (f x) = None then find_map_helper (f) (xs) (f x) else (f x) in if (List.length l) = 0 then None else find_map_helper f l (f (List.hd l)) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list)  = (List.fold_right(fun acc (li) -> if p acc then acc::li else li) l ([]), List.fold_right(fun acc (li)-> if not (p acc) then acc::li else li) l ([])) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mas = ref masterpass in let counter = ref 0 in let counterEr = ref 0 in let lockingChck = if !counterEr = 3 then raise AccountLocked in let chckMatch = (fun mast -> if mast = !mas then (counter:= ! counter + 1; counterEr := 0) else begin counterEr := ! counterEr + 1; lockingChck; raise  WrongPassword end) in let save = (fun masterP address password -> chckMatch masterP; (ref_list := ref_list.contents @ [(address, (encrypt masterP password))])) in let get_force = (fun masterP address -> find_map (fun (x, y)-> if x = address then  Some (decrypt masterP y) else None) ref_list.contents) in let get = (fun masterP address -> chckMatch masterP; get_force masterP address)  in let update_master = (fun masterP newMasterpass -> chckMatch masterP; mas := newMasterpass; ref_list := List.map (fun (a,b) -> (a, encrypt newMasterpass (decrypt masterP b))) (ref_list.contents)) in let count_ops = (fun masterP -> chckMatch masterP; !counter) in { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec f n = count_rec_calls:=!count_rec_calls+1; if n = 0 then 1 else (aux 0 (n - 1) 0) and aux i n acc = if i > n then acc else (aux (i + 1) n (acc + (f i) * (f (n - i)))) in let c = f n in (c, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let out = (f f' x) in Hashtbl.add hash x out; stats.entries  := !(stats.entries)+1; out | Some v -> stats.lkp := !(stats.lkp)+1;v in f' let rec memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp = ref 0 in let statrf = { entries; lkp } in (memoize memo_cat statrf n, statrf) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::l' -> match f x with | Some v -> Some v | None -> find_map f l' ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (cond : bool) (x : 'a) (acc : 'a list) : 'a list = if p x == cond then x::acc else acc in let pass_list = List.fold_right (f true) l [] in let fail_list =  List.fold_right (f false) l [] in (pass_list, fail_list) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let master : (masterpass) ref = ref masterpass in let ref_list : (address * password) list ref = ref [] in let wrong_pass_count : int ref = ref 0 in let ops_counter : int ref = ref 0 in  let check_pass (pass : masterpass) (update: bool): bool = if (!wrong_pass_count >= 3 && not update) then raise AccountLocked else if (pass = !master) then ( wrong_pass_count := 0; incr ops_counter; true ) else ( incr wrong_pass_count; raise WrongPassword ) in   let save = fun m a p -> if (check_pass m false) then ref_list := (a, encrypt m p)::!ref_list in  let get_force = fun m a -> let eq_opt (a',p) = if (a = a') then Some p else None in let encrypted_pass = find_map eq_opt !ref_list in match encrypted_pass with | None -> None | Some p -> Some (decrypt m p) in  let get = fun m a -> if (check_pass m false) then get_force m a else None in  let update_master = fun m1 m2 -> if (check_pass m1 true) then ( wrong_pass_count := 0; master := m2;  let rec update_encryption l l'= match l with | [] -> l' | (a,p)::xs -> let d_p = decrypt m1 p in let p' = encrypt m2 d_p in update_encryption xs l' @ [(a,p')] in ref_list := update_encryption !ref_list []; ); in  let count_ops = fun m -> if (check_pass m false) then !ops_counter else -1 in  { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = incr count_rec_calls; if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else let (c_i, _) = catalan i in let (c_n_i, _) = catalan (n - i) in aux (i + 1) n (acc + c_i * c_n_i) in aux 0 (n-1) 0 in catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let v = f f' x in Hashtbl.add hash x v; incr stats.entries; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | _ -> let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let newStats = { entries = ref 0; lkp = ref 0 } in let result = memoize memo_cat newStats n in (result, newStats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> match f(h) with | Some x -> Some x | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let divide element lists = let (t_list, f_list) = lists in match p(element) with | true -> (element::t_list, f_list) | false -> (t_list, element :: f_list) in List.fold_right divide l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager  = let ref_list : (address * password) list ref = ref [] in let mp = ref masterpass in let num_attempts : int ref = ref 0 in let num_succ_calls: int ref= ref 0 in let correct_master (pass:string)= if !num_attempts >= 3  then raise AccountLocked else match pass = !mp with | true -> num_attempts := 0; num_succ_calls := !num_succ_calls +1; () |false -> num_attempts := !num_attempts +1 ; if !num_attempts < 3 then raise WrongPassword else raise AccountLocked in let save master add pass = correct_master master; ref_list := (add, encrypt !mp pass) :: !ref_list in let get_force master add = let f e= let (a, p) =e  in if a = add then Some (decrypt master p) else None in find_map f !ref_list in let get master add : password option  = correct_master master; get_force master add in let update_master master_cur master_new = let inside = match master_cur = !mp with | true -> num_attempts := 0; num_succ_calls := !num_succ_calls +1; () |false -> num_attempts := !num_attempts +1 ; raise WrongPassword in mp := master_new; let f e = let (a, p) =e in  let decrypt_p = decrypt master_cur p in (a, encrypt master_new decrypt_p) in ref_list := (List.map f !ref_list) in let count_ops master = correct_master master; !num_succ_calls in { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops; }   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls+1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let cat = catalan n  in (cat, !count_rec_calls)   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let obj = Hashtbl.find_opt hash x in match obj with | None -> let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) +1; value | Some y -> stats.lkp := !(stats.lkp) +1; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let stat = {entries = ref 0; lkp = ref 0} in let catalan = memoize memo_cat stat  n in (catalan, stat)   ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_h f xs = match xs with | [] -> None | h :: t -> match (f h) with | None -> find_map_h f t | Some v -> Some v in find_map_h f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let p_helper ele acc: 'a list * 'a list  = if (p ele) then let (first, second) = acc in (ele :: first, second) else let (first, second) = acc in (first, ele :: second) in List.fold_right p_helper l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let masterpass = ref masterpass in let ref_list : (address * password) list ref = ref [] in let ref_list2 : (address * password) list ref = ref [] in let c_o = ref 0 in  let save (m_c : masterpass) (address: address) (password : password) = if !masterpass = m_c then let (en_pass : password) = encrypt !masterpass password in ref_list := !ref_list @ [(address, en_pass)]; incr c_o;  else raise WrongPassword in  let get_force (ma: masterpass) (address: address) =  let mat ele = let (addr, pass) = ele in if address = addr then (Some pass) else None in find_map mat !ref_list  in  let rec get m address = if m = !masterpass then (incr c_o; get_force m address) else raise WrongPassword in  let update_master m_c n_pass = if m_c = !masterpass then (incr c_o; let { contents =  n_pass} = masterpass in let rec h1 ref_list = let h::t = !ref_list in let (a,p) = h in let pass = encrypt n_pass (decrypt !masterpass p) in ref_list2 := !ref_list2 @ [(a, pass)] in h1 ref_list) else raise WrongPassword in let count_ops ma = if !masterpass = ma then !c_o else raise WrongPassword in  {save; get_force; get; count_ops; update_master } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec compute n = if n = 0 then 1 else  let rec aux i n acc = if i > n then acc else (  aux (i + 1) n (acc + (compute i) * (compute (n-i))) ) in aux 0 (n-1) 0 in let rec count n = if n = 0 then ( incr count_rec_calls; 1) else let rec aux1 i n = if i > n then !count_rec_calls else( incr count_rec_calls; count i + count (n-i); aux1 (i+1) n ) in aux1 0 (n-1) in  (compute n, count n) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let result = f (f') x in Hashtbl.add hash x result; incr stats.entries; result in incr stats.entries; f f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let  catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in catalan n ;; ",
  "let stats1 = { entries = ref 0 ; lkp = ref 0} let catalan_m (n : int) : int * stats = (memoize memo_cat stats1 n, stats1) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | None -> find_map f t | _ -> f h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f e (pass, fail) = if p e then (e::pass, fail) else (pass, e::fail) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let lock_count = ref 0 in let operation_count = ref 0 in let mas = ref masterpass in  let locing_sys m =  if not(m = !mas) then (lock_count := !lock_count+1; if (!lock_count >= 3) then raise AccountLocked else raise WrongPassword) else (operation_count:= !operation_count+1; lock_count := 0 ) in  let save (m:masterpass)(a:address)(p:password) = locing_sys m; ref_list := !ref_list@[(a,encrypt m p)] in  let get_force (m:masterpass)(a:address) = (find_map( fun (add, pwd) -> if add = a then Some (decrypt m pwd) else None) !ref_list) in  let get (m:masterpass)(a:address) = locing_sys m; get_force m a in  let update_master (currp:masterpass)(newp:masterpass) =  if not (currp = !mas) then (lock_count := !lock_count+1; raise WrongPassword); lock_count := 0; operation_count:= !operation_count+1; mas := newp;  let newlst = List.map(fun(x,y) -> (x, decrypt currp y)) !ref_list in let uplst = List.map(fun(x,y) -> (x, encrypt newp y)) newlst in ref_list := uplst in  let count_ops (m:masterpass) = locing_sys m; !operation_count   in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n =  count_rec_calls :=  (!count_rec_calls) + 1;  if n = 0 then (1) else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)); in aux 0 (n-1) 0 in let f = catalan n in (f, !count_rec_calls) ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = match Hashtbl.find_opt hash x with | None -> let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) +1; value; | Some va -> stats.lkp := !(stats.lkp) +1; va in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int =  if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats =  let stats = { entries = ref 0; lkp = ref 0; } in let return = memoize memo_cat stats in (return n, stats)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | a :: someVal -> match (f) (a) with | None -> find_map (f) (someVal) | b -> b  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let doWork (element) (left, right) = if p element in List.fold_right doWork (l) ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let lock = ref false in let unlock = ref true in let mstpsw = ref masterpass in  let warning = ref 0 in let success = ref 0 in  let encr = encrypt !mstpsw in let decr = decrypt !mstpsw in  let verify (master) (takeAction) = if !lock then raise WrongPassword else (if master = !mstpsw warning := 0; takeAction()) success := 0; then lock := true); raise WrongPassword)) in   let save (master) (address) (password) = verify master (function() -> ref_list := (address, encr password) :: !ref_list) in  let get_force (master) (address) = if !lock then raise AccountLocked else find_map (function(recorded, password) -> if address = recorded then Some(decrypt (master) (password)) else None) !ref_list in  let get (master) (address) = verify (master) (function() -> get_force (master) (address)) in  let recrypt (master) (newmaster)  (address, password) = (address,(encrypt (newmaster) (decrypt (master) (password)))) in   let update_master (master) (newmaster) = if master = !mstpsw then (if !unlock then warning := 0; success := !success + 1; ref_list := List.map(recrypt (master) (newmaster)) !ref_list) else raise WrongPassword in  let count_ops (master) = verify (master) (function() -> !success) in  { save ; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let calls = ref 0 in  let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) (n) (acc + catalan (i) * catalan (n - 1 - i)) in aux 0 (n-1) 0 in (catalan n, !calls) ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  raise NotImplemented ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_tr (f : 'a -> 'b option) (l2 : 'a list) : 'b option = match l2 with | [] -> None | el::rest -> let result = (f el) in if result != None then result else find_map_tr f rest in find_map_tr f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun head list -> if (p head) then head::list else list) l [], List.fold_right (fun head list -> if not(p head) then head::list else list) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let checkMasterPass (given : masterpass) (masterpass : masterpass) (count : int ref) (tries: int ref) : bool = if (!tries < 3) then if masterpass = given then let _ = count := !count+1 in let _ = tries := 0 in true else let _ = tries := !tries + 1 in false else raise AccountLocked in let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let masterPassRef = ref masterpass in let s_tries = ref 0 in let save = (fun masterpass address password -> let check = checkMasterPass masterpass !masterPassRef counter s_tries in if check then let p = (encrypt !masterPassRef password) in ref_list := (address, p)::!ref_list else raise WrongPassword ) in let get_force = (fun masterpass address -> let func = ((fun address x -> let (a,b) = x in if a = address then Some(b) else None) address) in let b = find_map func !ref_list in match b with | Some(value) -> Some(decrypt masterpass value) | None -> None) in let get = (fun masterpass address -> let check = checkMasterPass masterpass !masterPassRef counter s_tries in if check then get_force masterpass address else raise WrongPassword ) in let update_master = (fun (x: masterpass) (n: masterpass) -> let check = checkMasterPass x !masterPassRef counter s_tries in if check then let rec update_pass (passList: ((address * password) list)) (acc: ((address * password) list)) (oldPass : masterpass) (newPass: masterpass) = match passList with | (first,second)::xs -> (first, encrypt newPass (decrypt oldPass second)) :: (update_pass xs acc oldPass newPass) | [] -> [] in let acc : (address * password) list = [] in ref_list := (update_pass !ref_list acc x n); masterPassRef := n else raise WrongPassword ) in let count_ops = (fun masterpass -> let check = checkMasterPass masterpass !masterPassRef counter s_tries in if check then !counter else raise WrongPassword ) in let x : pass_manager = { save; get_force; get; update_master; count_ops} in x ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalanNew n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (catalanNew i) * (catalanNew (n-i))) in aux 0 (n-1) 0 in let catNum = catalanNew n in (catNum, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let result = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; result with | Not_found -> (stats.entries := !(stats.entries) +1); let ans = f f' x in Hashtbl.add hash x ans; ans in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let catalan_memoized = memoize memo_cat stats in (catalan_memoized n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | y :: ys -> match f y with | None -> find_map f ys | x -> x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (a : 'a) (l2 : 'a list * 'a list) : ('a list * 'a list) = let x = p a in match l2 with | ([],[]) -> if x then ([a], []) else ([], [a]) | ((z::zs), []) -> if x then ([a] @ (z::zs), []) else ((z::zs), [a]) | ([], (y:: ys)) -> if x then ([a], (y:: ys)) else ([], [a] @ (y:: ys)) | ((z::zs),(y::ys)) -> if x then ([a] @ (z::zs), (y::ys)) else ((z::zs), [a] @ (y::ys)) in let s = ([],[]) in List.fold_right f l s  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let master_ref = ref masterpass in let p = Some \"\" in  let ref_list : (address * password) list ref = ref [] in let unit_ref = ref () in let ops_ref = ref 0 in let wrong_pass_ref = ref 0 in let verify (m : masterpass) : bool = m = !master_ref in let inc_ops () : unit = (ops_ref := !ops_ref + 1); (wrong_pass_ref := 0) in  let wrong_pass () : unit = (wrong_pass_ref := !wrong_pass_ref + 1) ; if !wrong_pass_ref >= 3 then raise AccountLocked else raise WrongPassword in  let add_pass ( m : masterpass) (a : address) (p : password) : unit = let e = encrypt m p in let f () = (ref_list := [(a,e)]@(!ref_list)) in f () in () ;  let get_force_f (m :masterpass) (a : address) : password option = let f ((x,y) : (address * password)) : password option = match (x,y) with | (a,_) -> Some y | _ -> None in let e = find_map f !ref_list in if e = None then None else let extract (b : password option) : string = match e with | Some z -> z | None -> \"\" in let encode (c : string) : password option = match c with | d -> Some d | \"\" -> None in let d = decrypt m (extract e) in Some d; in  let get_f (m : masterpass) (a : address) : password option = if verify m then ( inc_ops () ; get_force_f m a ) else ( wrong_pass () ; None ; ) in let update_master_f (m1 : masterpass) (m2 : masterpass) : unit = let re_encrypt (r : (address * password)) : (address * password) = let (x,y) = r in let de = decrypt m1 y in let en = encrypt m2 de in (x, en) in if verify m1 then ( ref_list := (List.map re_encrypt !ref_list) ; master_ref := m2 ; inc_ops () ) else wrong_pass (); in let count_ops_f (m : masterpass) : int = if verify m then (inc_ops () ; !ops_ref ;) else (wrong_pass () ; 0); in  { save  = (fun m a p -> unit_ref := if verify m then (add_pass m a p ; inc_ops () ; ()) else wrong_pass () ; ());   get_force = (fun m a -> get_force_f m a);      }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let f() = (count_rec_calls := !count_rec_calls + 1) in let rec catalan n=  f () ; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (catalan i) * (catalan (n - i))) in (aux 0 (n-1) 0) in let v = catalan n in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = let y = Hashtbl.find_opt hash x in match y with | None -> let z = f f' x in Hashtbl.add hash x z ; incr stats.entries ; z | Some z -> incr stats.lkp ; z in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats = let make_new_stat = { entries = ref 0 ; lkp = ref 0 ; } in let new_stat = make_new_stat in let i = memoize memo_cat new_stat n in (i, new_stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> if (f h) = None then find_map f t else (f h) ;; ",
  " let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right ( fun el (pass, fail) -> if (p el) then (el::pass, fail) else (pass, el::fail) ) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass = ref masterpass in let ops_counter = ref 0 in let ref_wrong_pw = ref 0 in let check_master = fun pw -> incr ops_counter; if (pw = !ref_masterpass) then (ref_wrong_pw := 0; true) else (incr ref_wrong_pw; if !ref_wrong_pw <= 3 then raise WrongPassword else raise AccountLocked) in let save = fun mpw addr pw -> if check_master mpw then ref_list := ((addr, (encrypt masterpass pw)) :: !ref_list) in let get_force = fun mpw addr -> let pw_option = find_map (fun addr -> let (addr, pw) = addr in Some pw ) !ref_list in let password = match pw_option with | Some pw -> pw | None -> \"none\" in if (password <> \"none\") then Some (decrypt mpw password) else None in let get = fun mpw addr -> if check_master mpw then get_force mpw addr else None in let update_master = fun cur_mpw new_mpw -> let reencrypt = fun (addr, pw) -> (addr, encrypt new_mpw (decrypt cur_mpw pw)) in if (check_master cur_mpw) then ref_masterpass := new_mpw; ref_list := List.map reencrypt !ref_list; in let count_ops = fun mpw -> if check_master mpw then !ops_counter else 0 in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan = fun n -> incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let ans = catalan n in (ans, !count_rec_calls); ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.mem hash x) then (incr stats.lkp; Hashtbl.find hash x) else let y = (f f' x) in (Hashtbl.add hash x y; incr stats.entries; y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let st = { entries = ref 0; lkp = ref 0 } in let memoized = (memoize memo_cat st) n in (memoized, st) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | (Some h) -> (Some h) | None ->  find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun h t -> if p h then h::t else t) l [], List.fold_right (fun h t -> if p h then t else h::t) l [] ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let calls = ref 0 in let current_masterpassword = ref masterpass in let helper (m : masterpass): unit = if (!current_masterpassword = m) then (counter := 0; calls := !calls + 1) else if (!counter < 3) then ((counter := !counter + 1); raise WrongPassword) else ((counter := !counter + 1);raise AccountLocked) in let save = fun (m: masterpass)(a: address)(p: password) : unit -> helper m; ref_list := ((a, encrypt m p) :: !ref_list) in let get_force = fun (m : masterpass)(a : address) : password option -> find_map (fun (x,p) -> if x = a then Some (decrypt m p) else None) !ref_list in let get = fun (m: masterpass)(a: address) : password option -> helper m; get_force m a in let update_master = fun (current_m: masterpass)(new_m: masterpass) :unit -> if (!current_masterpassword = current_m) then (ref_list := List.map (fun (x,p) -> (x, decrypt current_m p)) !ref_list; ref_list := List.map (fun (x,p) -> (x, encrypt new_m p)) !ref_list; current_masterpassword := new_m; calls := !calls + 1;counter := 0) else (counter := !counter + 1;raise WrongPassword ) in let count_ops = fun (m: masterpass) : int -> helper m; !calls in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan1 n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux(i + 1) (n) (acc + catalan1 i * (catalan1 (n - i))) in aux 0 (n-1) 0 in let cat = catalan1 n in (cat, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let value = (f f' x) in Hashtbl.add hash x value; (stats.entries := !(stats.entries) + 1); value | Some v -> (stats.lkp := !(stats.lkp) + 1); v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let f = memoize memo_cat stats in ((f n), stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::[] -> f h | h::t -> match f h with | None -> find_map f t | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let partitioning (x : 'a) ((t, f) : 'a list * 'a list) : ('a list * 'a list) = if (p x) then (x :: t, f) else (t, x :: f) in List.fold_right partitioning l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let errors = ref 0 in let master = ref masterpass  in let check_master (m : masterpass)  : bool = if !errors > 3 then raise AccountLocked; if m = !master then ( counter := !counter + 1; errors := 0; true ) else ( errors := !errors + 1; false )  in let save (m : masterpass) (a : address) (p : password) : unit = if check_master m then ref_list := (a, encrypt m p) :: !ref_list else raise WrongPassword  in let get_force (m : masterpass) (a : address) : password option = let find_address (adr, pwd) = if (a == adr) then Some pwd else None in match find_map find_address !ref_list with | None -> None | Some s -> Some (decrypt m s)  in let get (m : masterpass) (a : address) : password option = if check_master m then get_force m a else raise WrongPassword  in let update_master (m : masterpass) (n : masterpass) : unit = if check_master m then let rec re_encrypt l = match l with | [] -> [] | (a, h) :: t -> (a, encrypt n (decrypt m h)) :: re_encrypt t in ( ref_list := re_encrypt !ref_list; master := n ) else raise WrongPassword  in let count_ops (m : masterpass) : int = if (check_master m) then !counter else raise WrongPassword  in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else ( let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 ) in let cat = catalan n in (cat, !count_rec_calls) let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let value = f f' x in stats.entries := !(stats.entries) + 1; Hashtbl.add hash x value; value | Some value -> stats.lkp := !(stats.lkp) + 1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  " let catalan_m (n : int) : int * stats = let cat_stats = {entries = ref 0; lkp = ref 0} in (memoize memo_cat cat_stats n, cat_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | head::tail -> let myOption = f head in if myOption = None then find_map f tail else myOption ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun (myVal: 'a) ((l1, l2): ('a list * 'a list)) -> if (p myVal) then (myVal::l1, l2) else (l1, myVal::l2)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_count_ops : int ref = ref 0 in let ref_exc_pass : int ref = ref 0 in let ref_masterpass : password ref = ref masterpass in  let check_pass (psw: masterpass): bool = if (psw = !ref_masterpass) && !ref_exc_pass < 3 then (ref_count_ops := (!ref_count_ops + 1); ref_exc_pass := 0; true) else (if !ref_exc_pass > 2 then raise AccountLocked else ref_exc_pass := !ref_exc_pass + 1; raise WrongPassword) in  let check_pass_update (psw: masterpass): bool = if (psw = !ref_masterpass) then (ref_count_ops := (!ref_count_ops + 1); ref_exc_pass := 0; true) else (ref_exc_pass := (!ref_exc_pass + 1); raise WrongPassword) in  let save (mp: masterpass) (adr: address) (pw: password) = if check_pass mp then ref_list := !ref_list@[(adr, encrypt mp pw)] in  let get_force (mp: masterpass) (addr: address) = find_map (fun ((adr, passwo): (address * password)) -> if  adr = addr then Some (decrypt mp passwo) else None) !ref_list in  let get (mp: masterpass) (addr: address) = if check_pass mp then get_force mp addr else None in let rec update_encrypt (myL: (address * password) list) (acc: (address * password) list) (mp: masterpass)  = match myL with | [] -> ref_list := acc | (add, pass)::tail -> update_encrypt tail ((add, (encrypt !ref_masterpass (decrypt mp pass)))::acc) mp in  let update_master (mp: masterpass) (newMp: masterpass) = if check_pass_update mp then (ref_masterpass := newMp; update_encrypt !ref_list [] mp) in  let count_ops (mp: masterpass) = (check_pass mp; !ref_count_ops) in  {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let acc = let rec myCatalan inner_n = (count_rec_calls := !count_rec_calls + 1); if inner_n = 0 then 1 else let rec aux i inner_n acc = if i > inner_n then acc else aux (i + 1) inner_n (acc + myCatalan i * myCatalan (inner_n - i)) in aux 0 (inner_n-1) 0 in myCatalan n in (acc, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let myVal = (Hashtbl.find_opt hash x) in if myVal = None then (let myVal = (f f' x) in Hashtbl.add hash x myVal; stats.entries := !(stats.entries) + 1; myVal) else (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let mystat = let entries = ref 0 in let lkp = ref 0 in {entries; lkp} in let res =  memoize (memo_cat) mystat n  in (res, mystat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> if f h = None then find_map f t else f h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun element (true_list,false_list) -> if p element then (element::true_list,false_list) else (true_list,element::false_list)) l ([],[]);; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let masterpass = ref masterpass in let opcount = ref 0 in let wrongpwdcount = ref 0 in let ref_list : (address * password) list ref = ref [] in  let mastercheck (password : password) = if !wrongpwdcount >= 3 then (raise AccountLocked) else if password = !masterpass then (opcount := !opcount + 1; wrongpwdcount := 0) else (wrongpwdcount := !wrongpwdcount + 1 ; raise WrongPassword) in  let save masterpass address password = mastercheck masterpass ; ref_list := !ref_list@[(address,encrypt masterpass password)] ; in  let get_force masterpass address : password option = let find_password_from_address tuple : password option = let (address_to_find, password) = tuple in if address_to_find = address then Some password else None in let password_received : password option = find_map find_password_from_address !ref_list in match password_received with | None -> None | Some password -> Some (decrypt masterpass password) in  let get masterpass address : password option = mastercheck masterpass ; get_force masterpass address in  let perform_update_master old_masterpass new_masterpass = let add_encryptedPassword tuple : (address * password) = let (cur_address, encrypted_password) = tuple in (cur_address, encrypt new_masterpass (decrypt old_masterpass encrypted_password)) in ref_list := List.map add_encryptedPassword !ref_list in  let update_master old_masterpass new_masterpass = try mastercheck old_masterpass ; perform_update_master old_masterpass new_masterpass ; masterpass := new_masterpass with AccountLocked -> if new_masterpass = old_masterpass then (perform_update_master old_masterpass new_masterpass ; masterpass := new_masterpass ; wrongpwdcount := 0) else raise WrongPassword in  let count_ops masterpass : int = mastercheck masterpass ; !opcount in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec new_catalan n = count_rec_calls := !count_rec_calls+1 ; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + new_catalan i * new_catalan (n - i)) in aux 0 (n-1) 0 in let v = new_catalan n in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1 ; value with Not_found -> let value = f f' x in Hashtbl.add hash x value ; stats.entries := !(stats.entries) + 1 ; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp = ref 0 in let calc_value = memoize memo_cat {entries; lkp} in let value = calc_value n in (value, {entries; lkp}) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> if f x != None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with |[] -> [], [] |x::xs -> let acc1 = [] in let acc2 = [] in List.fold_right (fun x (acc1, acc2) -> if p x then (x::acc1, acc2) else (acc1, x::acc2)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let address_list: address list = fst (List.split !ref_list) in let pass_list: password list = snd (List.split !ref_list) in let count = 0 in  let save masterpass1 address password = if masterpass1 = masterpass then ref_list := [(address, encrypt masterpass password)] else raise WrongPassword in  let get_force masterpass address = raise NotImplemented in  let get masterpassi address = raise NotImplemented in  let update_master masterpass1 masterpass2= if masterpass1 = masterpass then raise NotImplemented in  let count_ops masterpass = raise NotImplemented in {save; get_force; get; update_master; count_ops;} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  if n = 0 then (1,1) else let rec aux i n (acc1, acc2) = if i > n then (acc1, acc2) else aux (i + 1) n ((acc1 + catalan i * catalan (n - i)), acc2*3) in (aux 0 (n-1) (0, 1)) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.find_opt hash x != None then (incr stats.lkp; Hashtbl.find hash x) else (Hashtbl.add hash x (f f' x); incr stats.entries; Hashtbl.find hash x;) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let recf n = if n = 0 then 1 else let rec aux i n acc = if i < 0 then acc else aux (i - 1) n (acc + recf i * recf (n - i)) in aux (n-1) (n-1) 0 in recf n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let m = memoize memo_cat stats n in m, stats; ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with let result = f x in match result with ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let trueList = [] in let falseList = [] in  let triage (element : 'a) (tList, fList : 'a list * 'a list) : ('a list * 'a list) = if isGood then (element::tList, fList) else  (tList, element::fList)  in List.fold_right triage l (trueList, falseList) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let _ref_list            : (address * password) list ref = ref [] in let _master              : masterpass ref = ref masterpass in let _entryCounter        : int ref = ref 0 in let _consecutiveFailures : int ref = ref 0 in let _isLocked            : bool ref = ref false in let authenticate = fun (mstr : masterpass) : unit -> if !_isLocked then raise AccountLocked else if (String.compare mstr !_master) != 0 then ( _consecutiveFailures := !_consecutiveFailures + 1; if !_consecutiveFailures > 3 then ( _isLocked := false; raise AccountLocked ) else ( raise WrongPassword ) ) else ( _consecutiveFailures := 0; _entryCounter := !_entryCounter + 1; ) in let unlock = fun () : unit -> _consecutiveFailures := 0; _isLocked := false in let get_force = fun (mstr:masterpass) (searchAddr:address) : password option -> let myPredicate = fun ((curAddr:address), (curEncryptedPass:password)) : password option -> ( if (String.compare curAddr searchAddr) = 0 then Some (decrypt mstr curEncryptedPass) else None ) in find_map (myPredicate) (!_ref_list) in { save = (fun (mstr : masterpass) (newAddr : address) (newPass : password) : unit -> authenticate mstr; _ref_list := (newAddr, (encrypt mstr newPass)) :: !_ref_list );  get_force = get_force; get = (fun (mstr:masterpass) (searchAddr:address) -> authenticate mstr; get_force mstr searchAddr ); update_master = (fun (oldMaster:masterpass) (newMaster:masterpass) -> if !_isLocked then if (String.compare oldMaster !_master) = 0 then ( unlock (); ); authenticate oldMaster; let reindex (curAddr, curValue) = ( (curAddr, encrypt newMaster (decrypt oldMaster curValue)) ) in _ref_list := List.map reindex !_ref_list; _master := newMaster ); count_ops = (fun (mstr:masterpass) -> authenticate mstr; !_entryCounter; ) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_1 x = count_rec_calls := (!count_rec_calls + 1); if x = 0 then 1 else let rec aux i n acc = if i > n then acc else ( aux (i + 1) n (acc + catalan_1 i * catalan_1 (n - i)) ) in aux 0 (x-1) 0 in let result = catalan_1 n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' (x:'a) = try ( let value = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; value ) with Not_found -> ( let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let myStats = {entries = ref 0; lkp = ref 0} in let result = memoize memo_cat myStats n in (result, myStats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |[x] -> f x |h::t -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (pass, fail) = if p x then (x::pass, fail) else (pass, x::fail) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec inc = fun() -> count_rec_calls := !count_rec_calls + 1 in  (catalan n, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | Some v -> Some v | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let trueList p' l' = List.fold_right (fun x a -> if p' x then x::a else a) l' [] in let falseList q t = List.fold_right (fun x a -> if q x then a else x::a) t [] in ((trueList p l), (falseList p l)) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let successful = ref 0 in let wrong = ref 0 in let check mpass = if mpass = !master then (wrong := 0; true) else ( wrong := !wrong + 1; raise WrongPassword; false) in let save = (fun mpass addy pass -> if !wrong = 3 then raise AccountLocked else ( if check mpass then (successful :=  !successful + 1; ref_list := (addy,encrypt mpass pass)::(!ref_list)) )) in let get_force = (fun mpass addy -> match (find_map ( fun (a,b) -> if a = addy then Some b else None ) !ref_list) with | Some v -> Some (decrypt mpass (v)) | None -> None ) in let get = (fun mpass addy -> if !wrong = 3 then raise AccountLocked else ( if check mpass then successful := !successful + 1; get_force mpass addy )) in let update_master = (fun mpass newpass -> if check mpass then (master := newpass; successful := !successful + 1; ref_list := List.map (fun (a,b) -> (a, encrypt newpass (decrypt mpass b) ) ) !ref_list )) in let count_ops = (fun mpass -> if !wrong = 3 then raise AccountLocked else ( if check mpass then successful := !successful + 1; !successful )) in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = if n = 0 then (count_rec_calls := !count_rec_calls + 1; 1) else let rec aux i n acc = if i > n then (count_rec_calls := !count_rec_calls + 1; acc) else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let v = catalan n in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> stats.lkp := !(stats.lkp) + 1; v | None -> Hashtbl.add hash x (f f' x); stats.entries := !(stats.entries) +1; Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let st = {entries = ref 0; lkp = ref 0} in (memoize memo_cat st n, st) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let partition_helper x (l1,l2) = match p x with | true -> (x::l1,l2) | false -> (l1, x::l2) in List.fold_right partition_helper l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let the_master = ref masterpass in let counter = ref 0 in let acct_lock_count = ref 0 in let ref_list : (address * password) list ref = ref [] in let verify given_pass = if given_pass = !the_master then ((acct_lock_count := 0); (counter := !counter + 1); true) else ((acct_lock_count := !acct_lock_count + 1); false) in let save save_master save_addr save_pass = if !acct_lock_count >= 3 then raise AccountLocked else if verify save_master then (ref_list := (save_addr, encrypt save_master save_pass)::(!ref_list)) else raise WrongPassword in let get_force force_master force_addr = match find_map (fun x -> let (addr,pass) = x in if addr = force_addr then Some (decrypt force_master pass) else None) !ref_list with | None -> None | Some found_pass -> Some found_pass in let get get_master get_addr = if !acct_lock_count >= 3 then raise AccountLocked else if verify get_master then get_force get_master get_addr else raise WrongPassword in let update_master curr_mast new_pass = if verify curr_mast then ((ref_list := List.map (fun (addr,pass) -> let d = decrypt curr_mast pass in (addr,encrypt new_pass d)) !ref_list); the_master := new_pass) else if !acct_lock_count >= 3 then raise AccountLocked else raise WrongPassword in let count_ops curr_mast = if !acct_lock_count >= 3 then raise AccountLocked else if verify curr_mast then !counter else raise WrongPassword in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec compute_catalan n = if n = 0 then 1 else let rec aux i n acc = if (i > n) then acc else ((count_rec_calls := !count_rec_calls + 2); aux (i + 1) n (acc + compute_catalan i * compute_catalan (n - i))) in aux 0 (n-1) 0 in let x = compute_catalan n in (x, !count_rec_calls+1) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some z -> (stats.lkp := !(stats.lkp) + 1); z | None -> let new_val = f f' x in (stats.entries := !(stats.entries) + 1); (Hashtbl.add hash x new_val); new_val in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let my_stats = {entries = ref 0; lkp = ref 0} in let improved_cat = memoize memo_cat my_stats in let x = improved_cat n in (x, my_stats) ;; ",
  "let find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_tl (f : 'a -> 'b option) (l : 'a list) (value : 'b option) : 'b option = match l with | [] -> value | h::t -> (if (f h) <> None then (f h) else find_map_tl f t (f h)) in find_map_tl f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let predicate value (right, wrong) = if (p value) then (value::right, wrong) else (right, value::wrong) in List.fold_right predicate l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterPassword : password ref = ref masterpass in let wrongCount : int ref = ref 0 in let successCount : int ref = ref 0 in let check_password (mPass : masterpass) = if ( mPass = !masterPassword) then ((wrongCount := 0) ; (successCount := !successCount + 1)) else ((wrongCount := !wrongCount + 1); (successCount := 0); raise WrongPassword) in  let save (mPass : masterpass) (addr : address) (pass : password) = check_password mPass; if (!wrongCount >= 3) then raise AccountLocked else let encrypted_pass = encrypt mPass pass in (ref_list := (addr,encrypted_pass)::(!ref_list)) in  let get_force (mPass : masterpass) (addr : address) : password option = let get_force_helper ((addrss,pass) : address * password) : password option = if (addr = addrss) then let decrypted_pass = decrypt mPass pass in Some decrypted_pass else None in find_map get_force_helper !ref_list in  let get (mPass : masterpass) (addr : address) : password option = check_password mPass; if (!wrongCount >= 3) then raise AccountLocked else (get_force mPass addr) in  let update_master (oldMPass : masterpass) (newMPass : masterpass) =  let update_master_helper ((addrss,pass) : address * password) = let decr_pass = decrypt oldMPass pass in let encr_pass = encrypt newMPass decr_pass in (addrss, encr_pass) in  check_password oldMPass; let _ = masterPassword := newMPass in (ref_list := List.map update_master_helper !ref_list) in  let count_ops (mPass : masterpass) = check_password mPass; if (!wrongCount >= 3) then raise AccountLocked else !successCount in  {save; get_force; get; update_master; count_ops }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = (if i > n then (acc, !count_rec_calls) else let (value1, _) = catalan i in let (value2, _) = catalan (n - i) in aux (i + 1) n (acc + value1 * value2)) in aux 0 (n-1) 0 in catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try (let value = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; value) with Not_found -> ( let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let myStats = { entries = ref 0; lkp = ref 0  } in  let newfunc = memoize memo_cat myStats in  let value = newfunc n in  (value, myStats)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let b = (f x) in (match b with | None -> find_map f xs | Some v -> Some v) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let (f: 'a -> ('a list * 'a list) -> ('a list * 'a list)) = fun x (yes, no) -> match (p x) with | true -> (x::yes, no) | false -> (yes, x::no) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let correct_mp = ref masterpass in let num_success = ref 0 in let num_exceptions = ref 0 in let check_mp mp = (if !num_exceptions <= 3 then (if mp = !correct_mp then (num_exceptions := 0; num_success := !num_success + 1) else (num_exceptions := !num_exceptions + 1; raise WrongPassword)) else raise AccountLocked) in let get_force = (fun mp ad -> let pw = (find_map (fun (address, password) -> if address = ad then Some password else None) !ref_list) in match pw with | None -> None | Some str -> Some (decrypt mp str) ) in { save = (fun mp ad pw -> check_mp mp; (let encrypted = encrypt !correct_mp pw in ref_list := (ad, encrypted)::!ref_list) ); get_force; get = (fun mp ad -> check_mp mp; (get_force mp ad) ); update_master = (fun mp np -> if mp = !correct_mp then (if !num_exceptions > 3 then num_exceptions := 0 else (); num_success := !num_success + 1; (correct_mp := np; let rec func l = match l with | [] -> [] | (a, p)::ls -> (a, (encrypt np (decrypt mp p)))::(func ls) in ref_list := (func !ref_list))) else raise WrongPassword); count_ops = (fun mp -> check_mp mp; !num_success ); } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec inner_catalan n = (count_rec_calls := 1 + !count_rec_calls; (if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + inner_catalan i * inner_catalan (n - i)) in aux 0 (n-1) 0)) in let result = inner_catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let binding = Hashtbl.find hash x in stats.lkp := stats.lkp.contents + 1; binding with | Not_found -> let result = f f' x in Hashtbl.add hash x result; stats.entries := stats.entries.contents + 1; result in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let (s : stats) = { entries = ref 0; lkp = ref 0; } in ((memoize (memo_cat) s n), s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |h::t -> if  f h <> None  then f h else find_map f t |[] -> None  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =    let pass element acc = if p element then  element::acc  else acc in let fail element acc = if p element then acc else  element::acc in (List.fold_right pass l [],  List.fold_right fail l [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let count = ref 0 in let strikes = ref 0 in let masterpass_ref = ref masterpass in  let strike_update = if !strikes+1 >2 then (strikes:= 0 ; raise AccountLocked) else strikes:= !strikes+1;-1; in  let ref_list : (address * password) list ref = ref [] in   let count_ops masterp = if masterp = !masterpass_ref then ((count:= !count+1);!count) else try ignore(strike_update); raise WrongPassword with AccountLocked -> raise AccountLocked in  let save masterpass (addr:address) (p:string) = if count_ops masterpass > (-1) then   ref_list:= ((addr, ((encrypt !masterpass_ref p): password) ):: !ref_list ) ;  in  let get_force masterp (addr:address)  = find_map (fun (a, (p:string)) ->  if addr = a then Some ( (decrypt masterp p):password ) else None ) !ref_list in  let get m a = if (count_ops m)> (-1) then get_force m a else  raise WrongPassword in    let update_master curr_master new_passwrd = if curr_master = !masterpass_ref then ( masterpass_ref:= new_passwrd; let  de_re_encrypt (a,p) = (a, encrypt !masterpass_ref (decrypt curr_master p)) in  ref_list := List.map de_re_encrypt !ref_list  ; ) else try ignore(strike_update); raise WrongPassword  with AccountLocked ->  raise WrongPassword in     {save;get_force;get;update_master;count_ops}     ;; ",
  "let catalan_count (n : int) : (int * int) =  let count_rec_calls = ref 0 in  let rec catalan n  =  count_rec_calls:= (!count_rec_calls + 1);  if n = 0 then 1 else let rec aux i n acc  = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)   ) in aux 0 (n-1) 0  in let result = catalan n in (result  , !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then  let _  = stats.lkp  := !(stats.lkp) + 1 in Hashtbl.find hash x;  else let _ = stats.entries := !(stats.entries) + 1 in  let y = f f' x in let _ =  Hashtbl.add hash x y in Hashtbl.find hash x  in f f'  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats =  let cat_stats = { entries =  ref 0; lkp = ref 0 } in let s = cat_stats in (memoize memo_cat cat_stats n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | None -> find_map f t | Some x -> Some x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (e: 'a) ((l1, l2): ('a list * 'a list)) : ('a list * 'a list) = match p e with | true -> (e::l1, l2) | false -> (l1,e::l2) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_mp : masterpass ref = ref masterpass in let ref_lock: int ref = ref 0 in let ref_count: int ref = ref 0 in let ref_list : (address * password) list ref = ref [] in let save (mp: masterpass) (a: address) (p: password) = if !ref_lock = 3 then raise AccountLocked else (ref_count := !ref_count + 1; if mp = !ref_mp then (ref_lock := 0; ref_list := (a, encrypt mp p)::!ref_list) else (ref_lock := !ref_lock + 1; raise WrongPassword)) in let get_force (mp: masterpass) (a: address) = let f ((ad, p): (address * password)) = if ad = a then Some (decrypt mp p) else None in find_map f !ref_list in let get (mp: masterpass) (a: address) = if !ref_lock = 3 then raise AccountLocked else (ref_count := !ref_count + 1; if mp = !ref_mp then (ref_lock := 0; get_force mp a) else (ref_lock := !ref_lock + 1; raise WrongPassword)) in let update_master (old_pass: masterpass) (new_pass: masterpass) = ref_count := !ref_count + 1; if old_pass = !ref_mp then (ref_mp := new_pass; ref_lock := 0; ref_list := List.map (fun (s, p) -> (s, encrypt new_pass (decrypt old_pass p))) !ref_list) else raise WrongPassword in let count_ops (mp: masterpass) = if !ref_lock = 3 then raise AccountLocked else (if mp = !ref_mp then ( ref_lock := 0; ref_count := !ref_count + 1; !ref_count ) else (ref_lock := !ref_lock + 1; raise WrongPassword)) in { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc =  if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let num = catalan n in (num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> ( stats.lkp := !(stats.lkp) + 1; v ) | None -> let v = f f' x in (Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else (let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (recf i) * (recf (n - i))) in aux 0 (n-1) 0 ) ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats : stats ref = ref { entries = ref 0; lkp = ref 0 } in let c = memoize memo_cat !new_stats n in (c, !new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> let r = f x in match r with | Some b -> r ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with | [] -> ([],[]) | _ -> List.fold_right (fun x a -> let (f,g) = a in if (p x) then (x::f,g) else (f,x::g)) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let s_counter = ref 0 in let f_counter = ref 0 in let masterpass = ref masterpass in let verify test_pass = if (test_pass = !masterpass) then (s_counter := !s_counter + 1; f_counter := 0; l_state := false; true) else (f_counter := !f_counter + 1; if !f_counter > 2 && not !l_state then ((l_state := true); raise AccountLocked) else raise WrongPassword); in let ref_list : (address * password) list ref = ref [] in let get_force = (fun mp addr -> find_map (fun x -> let (a,p) = x in if a = addr then Some (decrypt mp p) else None) !ref_list) in { save = (fun mp addr pass -> if not !l_state then if (verify mp) then ref_list := (addr,(encrypt mp pass))::!ref_list else raise AccountLocked); get =(fun mp addr -> if not !l_state then if (verify mp) then (get_force mp addr) else raise WrongPassword else raise AccountLocked); get_force; update_master = (fun mp_old mp_new -> if (verify mp_old) then (ref_list := List.map (fun x -> let (a, p) = x in (a, encrypt mp_new (decrypt mp_old p))) !ref_list; masterpass := mp_new) else raise WrongPassword); count_ops = (fun mp -> if not !l_state then if (verify mp) then !s_counter else raise WrongPassword else raise AccountLocked); } ;; ",
  "test.save \"ben\" \"loc1\" \"sa\" ;; ",
  "test.save \"be\" \"loc1\" \"sam\" ;; ",
  "test.get_force \"be\" \"loc1\";; ",
  "test.get_force \"ben\" \"loc\" ;; ",
  "test.get_force \"be\" \"loc\";; ",
  "test.get \"be\" \"loc1\";; ",
  "test.get \"ben\" \"loc\" ;; ",
  "test.get \"be\" \"loc\";; ",
  "test.update_master \"ben\" \"mp\" ;; ",
  "test.count_ops \"mp\";; ",
  "test.count_ops \"ben\";; ",
  "test.save \"ben\" \"loc1\" \"sam\" ;; ",
  "test.save \"ben\" \"loc1\" \"sam\" ;; ",
  "test.get \"ben\" \"loc1\" ;; ",
  "test.count_ops \"ben\";; ",
  "test.save \"mp\" \"loc2\" \"who\" ;; ",
  "test.get \"mp\" \"loc2\" ;; ",
  "test.count_ops \"mp\";; ",
  "*) let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let cat_counter = (fun () -> count_rec_calls := !count_rec_calls + 1) in let rec catalan n = (cat_counter(); if n = 0 then 1 else let rec aux i n acc = if i > n then acc else  aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 ) (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some s -> (stats.lkp := !(stats.lkp) + 1; s) | None -> let new_val = (f f' x) in (Hashtbl.add hash x new_val; stats.entries := !(stats.entries) + 1; new_val) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let our_stat = { entries = ref 0; lkp = ref 0} in let result = ((memoize memo_cat our_stat) n) in (result, our_stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = if (List.length l == 0) then None else if (f (List.hd l) == None) then find_map f (List.tl l) else f (List.hd l) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let list_yes = List.filter p l in let f x xs = x :: xs  in let list_no = List.fold_right f l []  in let list_empty = List.fold_right f [] [] in if (List.length list_yes = 0) then (list_empty, l) else (list_yes, list_empty) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter = ref 2 in  let save masterpass address password = incr counter; let list2 = [address, encrypt password] in if (masterpass == password) then () in  let get_force masterpass address = incr counter; None in  let update_master masterpass password = incr counter; () in  let count_ops masterpass = 3 in {save = save ; get_force = get_force; get = get_force; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan2 n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan2 i * catalan2 (n - i)) in aux 0 (n-1) 0 in let j = catalan2 n in (j, !count_rec_calls); ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.mem hash x == true) then Hashtbl.find hash x else Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = 1 ;; ",
  "let catalan_m (n : int) : int * stats = if (n == 0) then (1, {entries = {contents = 1}; lkp = {contents = 0}}) else  (catalan(n), {entries = {contents = n}; lkp = {contents = n*2}})  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if (f x) <> None then (f x) else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let seperate_list element (true_list, false_list) = if (p element) then (element::true_list, false_list) else (true_list, element::false_list) in List.fold_right seperate_list l ([],[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master_password = ref masterpass in let count_protected_fun = ref 0 in let verify_master password f ref_list = if password = !master_password then (incr count_protected_fun; f ()) else if !count_protected_fun >= 3 then raise AccountLocked else raise WrongPassword in let lock_account master_pass f = if !count_protected_fun >= 3 then raise AccountLocked else verify_master master_pass f in let save master_pass (address: address) password = lock_account master_pass (fun () -> let (encrypt_pass: password) = encrypt master_pass password in ref_list := (address, encrypt_pass)::ref_list.contents ) ref_list in let get_force (master_pass: masterpass) (address: address) = find_map (fun (saved_address, saved_password) -> if address = saved_address then Some ((decrypt master_pass saved_password):password) else None ) !ref_list in let get (master_pass: masterpass) (address: address) = if master_pass = !master_password then (incr count_protected_fun; get_force master_pass address) else if !count_protected_fun >= 3 then raise AccountLocked else raise WrongPassword in let update_master (master_pass: masterpass) (new_pass: masterpass) = if master_pass = !master_password then let new_ref_list = ( List.map (fun (address, password) -> let decrypt_pass = decrypt master_pass password in let re_encrypt = encrypt new_pass decrypt_pass in (address, re_encrypt) ) !ref_list) in (incr count_protected_fun; master_password := new_pass;ref_list := new_ref_list) else if !count_protected_fun >= 3 then raise AccountLocked else raise WrongPassword in let count_ops master_pass = if master_pass = !master_password then (incr count_protected_fun; !count_protected_fun) else if !count_protected_fun >= 3 then raise AccountLocked else raise WrongPassword in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = (count_rec_calls := !count_rec_calls + 1; match n with | 0 -> 1 | n -> let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 ) in let num = catalan n in (num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec g x = match Hashtbl.find_opt hash x with | Some value -> incr stats.lkp; value | None -> let value_2 = f g x in Hashtbl.add hash x value_2; incr stats.entries; value_2; in g ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries= ref 0; lkp= ref 0} in let memoized = memoize memo_cat stats in let answer = memoized n in (answer, stats) ;; ",
  "let find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find f l acc = match l with | [] -> acc | h::t -> if not (f h = None) then f h else find f t acc in find f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f elem (acc1, acc2) = if p elem then (elem::acc1, acc2) else (acc1, elem::acc2) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let ref_list : (address * password) list ref = ref [] in let count = ref 0 in let fail_att = ref 0 in let ref_pass = ref masterpass in  let save = ( fun masterpass address password -> if (!ref_pass = masterpass && !fail_att < 3) then ( count := !count + 1; fail_att := 0; ref_list := (address, encrypt masterpass password )::!ref_list ) else if (!fail_att >= 3) then (fail_att := !fail_att + 1; raise AccountLocked) else (fail_att := !fail_att + 1; raise WrongPassword) ); in  let get_force = (fun masterpass address -> find_map (fun (a, pass) -> if (a = address) then Some (decrypt masterpass pass) else None) !ref_list ); in  let get = (fun masterpass address -> if (!ref_pass = masterpass && !fail_att < 3) then (count := !count + 1; fail_att := 0; get_force masterpass address) else if (!fail_att >= 3) then (fail_att := !fail_att + 1; raise AccountLocked) else (fail_att := !fail_att + 1; raise WrongPassword) ); in  let update_master = (fun old_pass  new_pass -> if (!ref_pass = old_pass ) then (count := !count + 1; fail_att := 0; ref_list := (let rec ite l = match l with | [] -> l | (a,p)::t -> (a, (encrypt new_pass (decrypt old_pass p) ) )::ite t in ite (!ref_list) ); ref_pass := new_pass) else (fail_att := !fail_att + 1; raise WrongPassword) ) in  let count_ops = (fun masterpass -> if (!ref_pass = masterpass && !fail_att < 3) then (fail_att := 0; !count + 1) else if (!fail_att >= 3) then (fail_att := !fail_att + 1; raise AccountLocked) else (fail_att := !fail_att + 1; raise WrongPassword) ); in  { save;  get_force;  get;  update_master;  count_ops; }  ;; ",
  "let rec catal n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catal i * catal (n - i)) in aux 0 (n-1) 0 ;; ",
  "let rec cata n r = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else ( r:= !r + 2; aux (i + 1) n (acc + cata i r * cata (n - i) r) ) in aux 0 (n-1) 0 ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in if n = 0 then 1,1 else let rec aux i n acc = if i > n then acc, !count_rec_calls + 1 else ( count_rec_calls := !count_rec_calls + 2; aux (i + 1) n (acc + cata i count_rec_calls * cata (n - i) count_rec_calls) ) in aux 0 (n-1) 0 ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some b -> ( stats.lkp := !(stats.lkp) + 1; b ) | None -> ( stats.entries := !(stats.entries) + 1; let answ = f f' x in Hashtbl.add hash x answ; answ ) in ( stats.entries := !(stats.entries) + 1;  f f' ) ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = catal n  ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let num = catal n in let x = memoize memo_cat stats in  num, stats ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | None -> find_map f xs | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let seperate a (l1,l2) = if (p a) then (a::l1,l2) else (l1,a::l2) in List.fold_right seperate l ([],[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let success_count = ref 0 in let fail_count = ref 0 in let master_ref = ref masterpass in let updatelist new_master old_master = let reencrypt new_master old_master item = let (a,p) = item in (a, encrypt new_master (decrypt old_master p)) in ref_list := List.map (reencrypt new_master old_master) !ref_list in   let verify_master master = if master = !master_ref then (success_count := !success_count +1;fail_count:=0;true) else (fail_count := !fail_count +1;false) in let save master address password = ( if !fail_count = 3 then raise AccountLocked else if verify_master master then (let encrypted = encrypt master password in ref_list:= (address, encrypted)::!ref_list) else raise WrongPassword) in let get_force master address = let addressfinder address item = let (a,p) = item in if a = address then Some p else None in match (find_map (addressfinder address) !ref_list) with | Some encrypted -> Some (decrypt master encrypted) | _ -> None in let get master address = ( if !fail_count = 3 then raise AccountLocked else if verify_master master then get_force master address else raise WrongPassword) in let update_master old_master new_master = if verify_master old_master then (updatelist new_master old_master; master_ref:=new_master;) else raise WrongPassword in let count_ops master = if !fail_count = 3 then raise AccountLocked else if verify_master master then !success_count else raise WrongPassword in {save; get_force;get;update_master;count_ops};  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_r n = (count_rec_calls:= !count_rec_calls + 1); if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_r i * catalan_r (n - i)) in aux 0 (n-1) 0 in let result = catalan_r n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try (let value = Hashtbl.find hash x in ((stats.lkp := !(stats.lkp) + 1); value)) with Not_found -> (let value =  f f' x in (Hashtbl.add hash x value;stats.entries:= !(stats.entries) + 1;value)) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc +  recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let somestats =  { entries = ref 0; lkp = ref 0 }  in let result = memoize memo_cat somestats n in (result, somestats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |h::t-> if (f h) <> None then f h else find_map f t; |[]->None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list)  = List.fold_right(fun (x: 'a) (acc:('a list * 'a list)) -> if p x <> true then (fst acc, x::(snd acc)) else (x::(fst acc), snd acc)) l ([],[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_wrongcount: int ref = ref 0 in let ref_rightcount: int ref = ref 0 in let ref_mp : masterpass ref = ref masterpass in let ref_list : (address * password) list ref = ref [] in  let increment_right = fun () -> ref_rightcount := !ref_rightcount+1 in let increment_wrong = fun () -> ref_wrongcount := !ref_wrongcount+1 in let verify = fun (new_mp:masterpass)-> if new_mp = !ref_mp then begin increment_right(); ref_wrongcount := 0; true end else begin increment_wrong();false end in  let is_locked = fun () -> if !ref_wrongcount>3 then raise AccountLocked in let unlock = fun (mp:masterpass) -> if mp = !ref_mp then ref_wrongcount := 0 in  let re_encrypt (oldref: (address * password) list ref) (old_mp:masterpass) (new_mp:masterpass) = let templist:(address * password) list =[] in let rec go acc cur_ref = match cur_ref with |{contents=[]} -> ref acc; |{contents=h::t} -> go (acc @ [(fst h),(encrypt new_mp (decrypt old_mp(snd h)))]) (ref t) in go templist oldref in  let update_master (cur_mp:masterpass) (new_mp:masterpass) = unlock(cur_mp); is_locked(); if verify cur_mp then begin ref_list := !(re_encrypt ref_list cur_mp new_mp) ; ref_mp := new_mp; end else raise WrongPassword in  let save (mp:masterpass) (a:address) (p:password) = is_locked(); if verify mp then ref_list := (a,(encrypt mp p)) :: !ref_list else raise WrongPassword in  let get_force (mp:masterpass) (a:address) : password option = find_map(fun (cur_a, cur_p)-> if cur_a=a then Some (decrypt mp cur_p) else None) !ref_list in  let get (mp:masterpass) (a:address) : password option = is_locked(); if verify mp then get_force mp a else raise WrongPassword in  let count_ops (mp:masterpass) = is_locked(); if verify mp then !ref_rightcount else raise WrongPassword in   {update_master=update_master; save=save; get_force=get_force; get=get; count_ops=count_ops } ;; ",
  " let catalan_count (n : int) : (int*int) = let count_rec_calls = ref 0 in let rec my_catalan n = if n = 0 then begin count_rec_calls := !count_rec_calls+1; 1 end else begin count_rec_calls := !count_rec_calls+1; let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + my_catalan i * my_catalan (n - i)) in aux 0 (n-1) 0 end  in let cat_num = my_catalan n in (cat_num,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b)  (stats:stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then begin stats.lkp := !(stats.lkp)+1; Hashtbl.find hash x end else begin let new_val = f f' x in Hashtbl.add hash x new_val; stats.entries := !(stats.entries)+1; new_val end in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc+ recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in let mh = memoize memo_cat s in (mh n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[]->None |x::tl-> match (f x) with |None-> find_map f tl |Some v->Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = ((List.fold_right (fun x y -> if (p x) then x::y else y) l []), (List.fold_right (fun x y -> if not (p x) then x::y else y) l [])) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let m=ref masterpass in let matching (master:masterpass):bool=(!m=master) in let counts= ref 0 in let counts_wrong= ref 0 in let save (master: masterpass) (addr:address) (pwd:password):unit = if matching master then (ref_list:= [(addr,encrypt master pwd)];counts:= !counts +1;counts_wrong:=0) else  (counts_wrong:=!counts_wrong+1;if !counts_wrong>=3 then raise AccountLocked else raise WrongPassword) in  let get_force (master : masterpass) (addr:address):password option= find_map (fun (ad,p) -> if ad = addr then Some (decrypt master p) else None ) !ref_list in  let get (master : masterpass) (addr:address):password option= if matching master then (counts_wrong:=0;counts:= !counts +1;get_force master addr) else (counts_wrong:=!counts_wrong+1;if !counts_wrong>=3 then raise AccountLocked else raise WrongPassword) in  let update_master (master:masterpass) (pwd:password):unit= let rec f1 l = match l with |(a,b)::tl->(a, encrypt pwd (decrypt master b))::(f1 tl) |[]->[] in if matching master then (m:= pwd;ref_list:= (f1 !ref_list);counts:= !counts +1) else (counts_wrong:=!counts_wrong+1;raise WrongPassword) in  let count_ops (master:masterpass):int= if matching master then (counts_wrong:=0;counts:= !counts +1;!counts) else (counts_wrong:=!counts_wrong+1;if !counts_wrong>=3 then raise AccountLocked else raise WrongPassword) in {save;get_force;get;update_master;count_ops};; ",
  " let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let e a= let (x,_) = a in x in let rec ca n = (count_rec_calls:= !count_rec_calls+1; if n = 0 then (1,1) else let rec aux i n acc = if i > n then (acc,!count_rec_calls) else aux (i + 1) n (acc + e (ca i) * e (ca (n - i))) in aux 0 (n-1) 0) in (ca n) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b= let hash = Hashtbl.create 1000 in let rec f' x = try (Hashtbl.find hash x;stats.lkp := !(stats.lkp)+1;Hashtbl.find hash x) with |Not_found -> let f2 =f f' x in (Hashtbl.add hash x f2;stats.entries := !(stats.entries)+1;f2) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc +recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let s={ entries =ref 0; lkp =ref 0} in (memoize memo_cat s n,s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |h::t -> let result = f(h) in if result = None then find_map f t else result ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun el tup -> let (l_yes, l_no) = tup in if p(el) then (el::l_yes, l_no) else (l_yes, el::l_no)) l ([],[]) ;; ",
  "let rec make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass : masterpass ref = ref masterpass in let ref_num_ops : int ref = ref 0 in let ref_wrong_num : int ref = ref 0 in  let check_locked fn = ( if !ref_wrong_num < 3 then fn else raise AccountLocked ) in  let check_masterpass masterpass fn = ( ref_num_ops := !ref_num_ops + 1; if masterpass = !ref_masterpass then ( ref_wrong_num := 0; fn ) else ( ref_wrong_num := !ref_wrong_num + 1; raise WrongPassword ) ) in  let rec create_new_list old_masterpass new_masterpass old_list = match old_list with |[] -> [] |tup::t -> let (address, encrypted_pwd) = tup in let new_encrypted = encrypt(new_masterpass)(decrypt(old_masterpass)(encrypted_pwd))in (address, new_encrypted)::(create_new_list old_masterpass new_masterpass t) in  let rec record = { save = ( fun masterpass address password -> check_locked check_masterpass masterpass ( (fun masterpass address password -> ref_list := (address,encrypt(masterpass)(password))::(!ref_list) )(masterpass)(address)(password) ) );  get_force = ( fun masterpass address -> find_map ( fun tup -> let (id, password) = tup in if id = address then Some(decrypt(masterpass)(password)) else None ) !ref_list );  get = ( fun masterpass address -> check_locked check_masterpass masterpass (record.get_force(masterpass)(address)) );  update_master = ( fun masterpass_old masterpass_new -> let fn =  check_masterpass masterpass_old ( ( fun masterpass_old masterpass_new -> ref_masterpass := masterpass_new; ref_list := (create_new_list masterpass_old masterpass_new !ref_list); ) ) in ( fn(masterpass_old)(masterpass_new) ) );  count_ops = ( fun masterpass -> let fn = check_locked check_masterpass masterpass (fun x -> x) in fn(!ref_num_ops) ) } in record  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_inner n = (count_rec_calls := !count_rec_calls + 1); if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_inner i * catalan_inner (n - i)) in aux 0 (n-1) 0 in let cat = catalan_inner n in (cat, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let binding = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; binding with Not_found -> let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec memo_cat_tr i n acc = if i > n then acc else ( memo_cat_tr (i+1) n (acc+recf(n-i)*recf(i)) ) in memo_cat_tr 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let catalan_num = memoize memo_cat stats n in (catalan_num, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let r = f h in match r with | Some h -> Some h | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let list_one e l = if p e then e::l else l in let list_two e l = if p e then l else e::l in ( List.fold_right list_one l [] , List.fold_right list_two l [] ) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master = ref masterpass in let counter = ref 0 in let failed = ref 0 in let verify input = if input = !ref_master then counter := !counter + 1 else raise WrongPassword; failed := !failed + 1 in let save m a p = if !failed < 3 then (verify m; ref_list := (a , encrypt m p)::!ref_list) else  raise AccountLocked in let get_force m a = find_map (fun x -> let (y,z) = x in if a = y then Some(decrypt m z) else None) !ref_list  in let get m a = if !failed < 3 then (verify m; get_force m a) else raise AccountLocked in let update_master m1 m2 = verify m1; let rec update_pass l acc = match l with |[] -> acc |(add, pass)::t -> update_pass t (acc@[(add,encrypt m2 (decrypt m1 pass))]) in ref_list := update_pass !ref_list []; ref_master := m2 in let count_ops m = if !failed < 3 then (verify m; !counter) else raise AccountLocked in { save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n-i)) in aux 0 (n-1) 0 in if n = 0 then 1 , 1 else let cat_num = catalan n in (cat_num , !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with |Some v -> stats.lkp := !(stats.lkp) + 1; v; |None -> Hashtbl.add hash x (f f' x); stats.entries := !(stats.entries) + 1; let Some s = Hashtbl.find_opt hash x in s in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = { entries = ref 0; lkp = ref 0} in let cat = memoize memo_cat stat n in (cat, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec tr_find (f: 'a -> 'b option) (l: 'a list) (element : 'b option)  : 'b option = match l with |[] -> element |x::xs -> match (f x) with |Some b -> Some b |None -> tr_find f xs element   in  tr_find f l None  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let f  a (firstList, secondList)= if p a  then ( a :: firstList, secondList) else (firstList, a ::secondList) in List.fold_right f l ([] ,[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in    let tries = ref 0 in  let counter = ref 0 in  let masterpassword = ref masterpass in  let save master address password =  if (!tries) >= 3 then raise AccountLocked else if !masterpassword <> master then (tries := (!tries + 1) ; raise WrongPassword )  else ( tries := 0; counter := !counter + 1;   ref_list:= !ref_list@[(address , (encrypt master password))] ) in   let get_force master address =  find_map (fun (x,y) -> if x == address then Some (decrypt master y) else None) !ref_list  in  let get master address =  if (!tries) >= 3 then raise AccountLocked else if !masterpassword <> master then (tries := (!tries + 1) ; raise WrongPassword )  else ( tries:= 0; counter := !counter + 1; get_force master address  ) in  let update_master master password =  if !masterpassword <> master then ( raise WrongPassword )  else (  ref_list := (List.map( fun (x,y) -> (x,(encrypt password (decrypt !masterpassword y)) )) !ref_list);  masterpassword := password; tries := 0; counter := !counter + 1 ) in   let count_ops masterpass =  if (!tries) >= 3 then raise AccountLocked  else if !masterpassword <> masterpass then (tries := (!tries + 1) ; raise WrongPassword ) else( tries:= 0; counter := !counter +1 ; !counter )  in    { save;   get_force;  get;  update_master;  count_ops;    } let catalan_count (n : int) : (int * int) =  let count_rec_calls = ref 0 in let rec catalan n i acc = if n = 0 then 1 else if i >= n then acc   else ( let acc = acc + catalan i 0 0 * catalan (n -1 -i) 0 0 in  count_rec_calls := !count_rec_calls +2; catalan  n (i+1) acc ; )    in  catalan n 0 0; (catalan n 0 0 , !count_rec_calls + 1) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match (Hashtbl.find_opt hash x) with |None -> let y = f f' x in (Hashtbl.add hash x y; stats.entries := !(stats.entries) + 1; y) |Some y -> ( stats.lkp := !(stats.lkp) + 1 ; y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let statistic= {entries =  ref 0 ; lkp =  ref 0  } in let result =  memoize memo_cat   statistic n  in  (result ,statistic)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | hd :: rest -> match (f hd, rest) with | Some v, _ -> Some v | _ -> find_map f rest ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let place el (l1, l2) = if p el then (el::l1, l2) else (l1, el::l2) in List.fold_right place l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let check_mast to_check = if wrong_row.contents >= 3 then raise AccountLocked else if to_check = mastpass_ref.contents then (wrong_row:= 0; num_ops:= !num_ops + 1) else (wrong_row:= !wrong_row + 1; raise WrongPassword) in let save mastpass addr passwd = check_mast mastpass; ref_list := (addr, encrypt mastpass passwd)::ref_list.contents in let get_force mastpass addr = find_map (fun x -> let (t1,t2) = x in if t1 = addr then Some (decrypt mastpass t2) else None) ref_list.contents in let get mastpass adr = check_mast mastpass; get_force mastpass adr in let update_master cur_mast new_mast = check_mast cur_mast; mastpass_ref := new_mast; ref_list := List.map (fun (x,y) -> (x, encrypt new_mast (decrypt cur_mast y))) ref_list.contents in let count_ops mastpass = check_mast mastpass; num_ops.contents in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1 ; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let cat_n = catalan n in (cat_n, count_rec_calls.contents) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> Hashtbl.add hash x (f f' x) ; stats.entries := !(stats.entries) + 1; Hashtbl.find hash x | Some v -> stats.lkp := !(stats.lkp) + 1; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux(i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let temp = (memoize (memo_cat) stats) n in (temp, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | Some v -> Some v | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f e (passed, failed) = if p e then (e::passed, failed) else (passed, e::failed) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mpass = ref masterpass in let attempts = ref 0 in let ops = ref 0 in  let check_masterpass master = if master <> !mpass then (attempts := !attempts + 1; raise WrongPassword) else if !attempts = 3 then raise AccountLocked else ops := !ops + 1; attempts := 0   in let save mp addr pwd = check_masterpass mp; let local = encrypt mp pwd in ref_list := (addr, local)::!ref_list   in let get_force mp2 addr2 : password option= find_map (fun (ad, pw) -> if ad = addr2 then Some (decrypt mp2 pw) else None) !ref_list   in let get mp3 addr3= check_masterpass mp3; get_force mp3 addr3   in let update_master curr newp = check_masterpass curr; if curr = !mpass then (attempts := 0; let update_ref (addr, pass) = let local1 = (encrypt newp (decrypt curr pass)) in (addr, local1) in ref_list := List.map update_ref !ref_list; mpass := newp;)  else raise WrongPassword  in let count_ops mp4 = check_masterpass mp4; !ops  in let return_manager = ref { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops } in !return_manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else let (new_num, _) = catalan i in let (new_i_num, _) = catalan (n-i) in aux (i + 1) n (acc + new_num * new_i_num) in aux 0 (n-1) 0 in catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let res = Hashtbl.find_opt hash x in match res with | Some value -> (stats.lkp := !(stats.lkp) + 1); value | None -> let new_val = f f' x in Hashtbl.add hash x new_val; stats.entries := !(stats.entries) + 1; new_val in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (recf i * recf (n-i))) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = ref {entries = ref 0; lkp = ref 0} in let cat = memoize memo_cat !new_stats in let value = cat n in (value, !new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_tr (f : 'a -> 'b option) (l : 'a list) (acc : 'b option) : 'b option = match l with | [] -> acc | h :: t -> match f h with | None -> find_map_tr f t acc | Some v -> Some v in find_map_tr f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = raise NotImplemented let help_partition (p : 'a -> bool) ((ltrue : 'a list),(lfalse : 'a list)) : ('a list * 'a list) = match  with |(_ -> true) -> (_::ltrue),lfalse |(_ ->false) -> (ltrue, _::lfalse)  in List.fold_right (help_partition) l ([], [])  ;; ",
  "  let rec split p l (ltrue : 'a list) (lfalse : 'a list)= match l with | [] -> [] | h ::t -> if p h then List.fold_left ltrue h split p t ltrue lfasle else List.fold_left lfalse h split p t ltrue lfalse in split p l [] [] *) *)  let make_manager (masterpass : masterpass) : pass_manager = let chkpwd = fun (pwd : password) -> raise AccountLocked ( numincorrect := !numincorrect + 1 ; raise AccountLocked else in let ref_list : (address * password) list ref = ref [] in  let get_force = fun (masterpass : masterpass) (addy : address) -> let helper = fun ((add : address), (pwd : password)) -> if add = addy then Some pwd else None in match find_map helper ref_list.contents with | None -> None |Some v-> Some (decrypt masterpass v) in {  save = (fun (masterpass : masterpass) (addy : string) (localpwd : string) -> if chkpwd masterpass then ref_list.contents <- (addy, (encrypt masterpass localpwd))::!ref_list) ; get_force = get_force ; ; update_master = (fun (oldmasterpass : masterpass) (newmasterpass : masterpass) -> try if chkpwd oldmasterpass then let pwd_changer = fun ((addy : address), (pwd : password)) -> let uncript = decrypt oldmasterpass pwd  in let recript = encrypt newmasterpass uncript in (addy, recript) in ref_list := List.map pwd_changer !ref_list ; mypass := newmasterpass with AccountLocked -> if !mypass = oldmasterpass then ( numincorrect := 0 ; let pwd_changer = fun ((addy : address), (pwd : password)) -> let uncript = decrypt oldmasterpass pwd  in let recript = encrypt newmasterpass uncript in (addy, recript) in ref_list := List.map pwd_changer !ref_list ; mypass := newmasterpass) else raise WrongPassword ) ; count_ops = (fun (masterpass) -> if chkpwd masterpass then !counter else 0) ; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec help_catalan_count1 n = count_rec_calls := (!count_rec_calls + 1); if n=0 then (1) else let rec help_catalan_count2 i n acc = if i > n then (acc) else help_catalan_count2 (i + 1) n (acc + help_catalan_count1 i * help_catalan_count1 (n - i)) in help_catalan_count2 0 (n-1) 0 in let result = help_catalan_count1 n in (result, !count_rec_calls ) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try if Hashtbl.find hash x then stats.lkp := !(stats.lkp) + 1 ; Hashtbl.find hash x with Not_found -> let valuex = f f' x in Hashtbl.add hash x valuex ; stats.entries := !(stats.entries) + 1 ; Hashtbl.find hash x  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec help_memo_cat1 n = if n = 0 then 1 else let rec help_memo_cat2 i n acc = if i > n then acc else help_memo_cat2 (i + 1) n (acc + help_memo_cat1 i * help_memo_cat1  (n - i)) in help_memo_cat2 0 n 0 in help_memo_cat1 n ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  " let count_rec_calls = ref 0 in  let rec help_catalan_count (i : int) n acc : int = count_rec_calls := !count_rec_calls + 1 ; if n=0 then (1) else if i > n then (acc) else help_catalan_count (i + 1) n (acc + help_catalan_count i n acc * help_catalan_count (n - i) n acc) in ((help_catalan_count 0 (n-1) 0), !count_rec_calls)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None | x::xs -> if (f x) = None then find_map f xs else f x; ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f element (passed, notYet)= if p element then (element :: passed, notYet) else (passed, element::notYet) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let master = ref masterpass in let ref_list : (address * password) list ref = ref [] in let num_success = ref 0 in let num_fail = ref 0 in let helper password address = let f (x, y) = if x = address then Some (decrypt !master y) else None in find_map f !ref_list in { get_force= ( fun password address -> let f (x, y) = if x = address then Some (decrypt !master y) else None in find_map f !ref_list); get = (fun password address -> if password = !master then (num_success := !num_success+1 ; helper password address) else (num_fail := !num_fail + 1; raise WrongPassword)); save = (fun password address localPass -> if password = !master then (num_success := !num_success + 1 ; ref_list := ! ref_list @ [(address, (encrypt password localPass))]) else (num_fail := !num_fail + 1; raise WrongPassword)); update_master = ( fun masterpass1 masterpass2 -> (if masterpass1 = !master then (num_fail := 0; num_success := !num_success+1; master := masterpass2) else (num_fail := !num_fail + 1; raise WrongPassword) )); count_ops = ( fun masterpass1 -> (if masterpass1 = !master then (num_fail := 0 ; num_success := !num_success + 1 ; !num_success) else if !num_fail >=3 then raise AccountLocked else (num_fail := !num_fail + 1; raise  WrongPassword) )); } ;; ",
  " let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let k = catalan n in (k, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let result = f f' x in Hashtbl.add hash x result ; stats.entries := 1 + !(stats.entries) ; result | Some v -> stats.lkp := !(stats.lkp)+1 ; v in stats.entries := !(stats.entries) + 1 ; f f' ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_tail f l acc = match l with | [] -> acc | x :: xs -> if (f x) = None then find_map_tail f xs acc else f x in find_map_tail f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let a = List.fold_right (fun x y -> if ( p x ) then x :: y else y) l [] in let b = List.fold_right (fun x y -> if ( p x ) then y else x :: y) l [] in (a, b) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let fail_counter = ref 0 in let correct_counter = ref 0 in let ref_mas = ref masterpass in let check_pass ( pass : password ) : bool = if (!fail_counter < 3) then if (pass = !ref_mas) then (fail_counter := 0 ; incr correct_counter ; true) else (incr fail_counter; if ( !fail_counter < 3 ) then raise WrongPassword else raise AccountLocked) else raise AccountLocked in let get_force = (fun master_p a -> find_map (fun (ad, pa) -> if ad = a then Some (decrypt master_p pa) else None) !ref_list) in let get = (fun m_p a -> if (check_pass m_p) then get_force m_p a else None) in let update_master = (fun old_p new_p -> if old_p = !ref_mas then (fail_counter := 0; incr correct_counter; ref_list := List.map (fun (x, y) -> (x, encrypt new_p (decrypt old_p y))) !ref_list; ref_mas := new_p;) else (incr fail_counter ; if !fail_counter < 3 then raise WrongPassword else raise AccountLocked)) in { save = (fun master_p a p -> if (check_pass master_p) then let e_p = encrypt master_p p in ref_list := !ref_list @ [(a, e_p)]) ; get_force ; get ; update_master ; count_ops = (fun m_p -> if (check_pass m_p) then !correct_counter else -1) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec my_catalan n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + (my_catalan i) * (my_catalan (n - i))) in aux 0 (n-1) 0 in let v = my_catalan n in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let v = Hashtbl.find hash x in incr (stats.lkp); v with Not_found  -> let value = f f' x in Hashtbl.add hash x value; incr stats.entries; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats' = { entries = ref 0 ; lkp = ref 0 } in let f = memoize memo_cat stats' in (f n , stats') ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[]-> None |x::xs-> if f x = None then  find_map f xs else f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper_1 element list = if p element then element::list else list in let helper_2 element list = if not(p element) then element::list else list in ((List.fold_right helper_1 l []),(List.fold_right helper_2 l [])) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let realPass : masterpass ref = ref masterpass in let goodCall : int ref = ref 0 in let badCall : int ref = ref 0 in let isLocked :  bool ref= ref false in let isCorrect mstGiven= (mstGiven = !realPass) in  let save mstGiven addressGiven passwordGiven= if !isLocked then raise AccountLocked else if isCorrect mstGiven then ( (badCall:= 0); (goodCall:= !goodCall+1); ref_list:=(addressGiven,encrypt mstGiven passwordGiven)::(!ref_list); () ) else ((badCall:= !badCall+1);(if !badCall=3 then ((isLocked:=true);raise WrongPassword) else raise WrongPassword))  in  let get_force mstGiven addressGiven=  find_map (fun v-> let (a,p)=v in if a=addressGiven then Some (decrypt mstGiven p) else None ) !ref_list in  let get mstGiven addressGiven = if !isLocked then raise AccountLocked else if isCorrect mstGiven then ( (badCall:= 0); (goodCall:= !goodCall+1); get_force mstGiven addressGiven) else ((badCall:= !badCall+1);(if !badCall=3 then ((isLocked:=true);raise WrongPassword) else raise WrongPassword))  in  let update_master mstGiven newPass = if (!isLocked && not((isCorrect mstGiven))) then raise WrongPassword else if (!isLocked && isCorrect mstGiven) then ((isLocked:= false); ((goodCall:= !goodCall+1); ref_list:=List.map (fun v-> let (a,p)= v in (a,decrypt mstGiven p)) !ref_list; ref_list:=List.map (fun v-> let (a,p)=v in (a,encrypt newPass p)) !ref_list; realPass:=newPass; ())) else if isCorrect mstGiven then ((goodCall:= !goodCall+1); ref_list:=List.map (fun v-> let (a,p)= v in (a,decrypt mstGiven p)) !ref_list; ref_list:=List.map (fun v-> let (a,p)=v in (a,encrypt newPass p)) !ref_list; realPass:=newPass; ()) else raise WrongPassword in  let count_ops mstGiven = if !isLocked then raise AccountLocked else if isCorrect mstGiven then ((badCall:= 0);(goodCall:= !goodCall+1); !goodCall ) else ((badCall:= !badCall+1);(if !badCall=3 then ((isLocked:=true);raise WrongPassword) else raise WrongPassword)) in { save;get_force;get;update_master;count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let increment ()= (count_rec_calls:=!count_rec_calls+1);() in let rec catalan2 n = if n = 0 then 1  else let rec aux i n acc = if i > n then acc else (increment();increment();aux (i + 1) n (acc + catalan2 i * catalan2 (n - i))) in aux 0 (n-1) 0 in let _= (catalan2 n) in(catalan2 n,!count_rec_calls+1)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with  |None-> Hashtbl.add hash x (f f' x); stats.entries:=!(stats.entries)+1;Hashtbl.find hash x |_->(stats.lkp:=!(stats.lkp)+1;Hashtbl.find hash x) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats2={entries=ref 0;lkp=ref 0} in (memoize memo_cat stats2 n,stats2 ) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f x != None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with | [] -> ([], []) | _ -> List.fold_right (fun el (l1,l2) -> if p el then ((el::l1),l2) else (l1, (el::l2)) ) l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass = ref masterpass in let ref_count_ops = ref 0 in let ref_error = ref 0 in let check_masterpass masterpass = if (!ref_error = 3) then raise AccountLocked else if (masterpass = !ref_masterpass) then let _ = (ref_count_ops := !ref_count_ops + 1) in (ref_error := 0) else let _ = (ref_error := !ref_error + 1) in raise WrongPassword in let save masterpass address password = check_masterpass masterpass ; (ref_list := (address, (encrypt masterpass password) )::!ref_list) in let get_force (masterpass : masterpass) (address : address) = find_map ( fun a -> let (cAddress, password) = a in if (cAddress = address) then Some (decrypt masterpass password) else None ) !ref_list in let get masterpass address = check_masterpass masterpass ; get_force masterpass address in let update_pass masterpass newMasterPass= let new_ref_list = ref [] in List.iter (fun a -> let (address, password) = a in new_ref_list := (address, encrypt newMasterPass (decrypt masterpass password) ) :: !new_ref_list ) !ref_list ; (ref_list := !new_ref_list) in let update_master masterpass newMasterPass = try if (check_masterpass masterpass = ()) then (ref_masterpass := newMasterPass) ; update_pass masterpass newMasterPass with | AccountLocked -> if ( masterpass = !ref_masterpass ) then (ref_masterpass := newMasterPass) ; update_pass masterpass newMasterPass | WrongPassword -> raise WrongPassword in let count_ops masterpass = check_masterpass masterpass ; !ref_count_ops in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in if n = 0 then (1, 1) else let rec catalan_c n = let _ = (count_rec_calls := !count_rec_calls + 1) in if n = 0 then 1 else let rec catalan i n acc = if i > n then acc else catalan (i + 1) n (acc + (catalan_c i) * catalan_c (n - i)) in catalan 0 (n - 1) 0 in let x = catalan_c n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.mem hash x with | true -> (stats.lkp := !(stats.lkp) + 1); Hashtbl.find hash x | false -> let y = f f' x in (Hashtbl.add hash x y) ; (stats.entries := !(stats.entries) + 1) ; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | _ -> let rec aux i n acc = if i > n then acc else aux ( i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 1 in let lkp = ref 0 in let stats = { entries ; lkp } in ((memo_cat (memoize memo_cat stats) n), stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | None -> find_map f t | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (t_list, f_list) = match p x with | true -> (x::t_list, f_list) | false -> (t_list, x::f_list) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass : masterpass ref = ref masterpass in let ref_wpcounter : int ref = ref 0 in let ref_opcounter : int ref = ref 0 in let authenticate (mp: masterpass) = if !ref_wpcounter > 2 then raise AccountLocked; if mp <> !ref_masterpass then (ref_wpcounter := !ref_wpcounter + 1; raise WrongPassword;) else (ref_opcounter := !ref_opcounter + 1; ref_wpcounter := 0;) in let save (mp: masterpass) (ad: address) (pw: password) = authenticate mp; ref_list :=  (ad, (encrypt mp pw)) :: !ref_list; in let get_force (mp: masterpass) (ad: address) = match List.find_opt (fun (ad', pw) -> ad' = ad) !ref_list with | Some (_, enc_pw) -> Some (decrypt mp enc_pw) | None -> None in let get (mp: masterpass) (ad: address) = authenticate mp; get_force mp ad in let update_master (old_mp: masterpass) (new_mp: masterpass) = if !ref_wpcounter < 3 then authenticate old_mp else (if old_mp <> !ref_masterpass then raise WrongPassword else ref_wpcounter := 0); ref_masterpass := new_mp; ref_list := List.map (fun (ad, pw) -> (ad, (pw |> (decrypt old_mp) |> (encrypt new_mp)))) !ref_list; in let count_ops (mp: masterpass) = authenticate mp; !ref_opcounter in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let inc _ = count_rec_calls := (!count_rec_calls + 1) in let rec cat (n: int) : int = inc (); if n = 0 then 1 else let rec r i n acc = if i > n then acc else r (i + 1) n (acc + ((cat i) * (cat (n - i)))) in r 0 (n - 1) 0 in let res = cat n in (res, !count_rec_calls)   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let inc (r: 'a ref) = r := !r + 1 in let rec f' x = match Hashtbl.find_opt hash x with | Some y -> (inc stats.lkp; y) | None -> (inc stats.entries; let y = f f' x in (Hashtbl.add hash x y; y) ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec r i n acc = if i > n then acc else r (i + 1) n (acc + recf i * recf (n - i)) in r 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {lkp = ref 0; entries = ref 0} in ((memoize memo_cat stats) n, stats) ;; ",
  "let test (f: 'a -> 'b) ((msg: string), (args: 'a), (exp: 'b)) = print_string msg; print_newline (); assert (f args = exp) ;; ",
  "let assert_test m b = print_endline m; assert b ;; ",
  "let assert_throws m f exn = let reaches = ref false in print_endline m; begin try f () with exn -> reaches := true end; assert !reaches ;; ",
  "let find_map_tests = [ ( \"basics\", ( (fun x -> if x mod 2 = 0 then Some x else None), [1; 2; 3; 4; 5; 6] ), Some 2 ); ( \"at end\", ( (fun x -> if x mod 2 = 0 then Some x else None), [1; 3; 5; 7; 9; 2] ), Some 2 ); ( \"none\", ( (fun x -> if x mod 2 = 0 then Some x else None), [1; 3; 5; 7; 9; 11] ), None ); ( \"empty list\", ( (fun x -> if x mod 2 = 0 then Some x else None), [] ), None ); ( \"one element some\", ( (fun x -> if x mod 2 = 0 then Some x else None), [2] ), Some 2 ); ( \"one element none\", ( (fun x -> if x mod 2 = 0 then Some x else None), [1] ), None ); ];; ",
  "let partition_tests = [ ( \"basic\", ( (fun x -> x mod 2 = 0), [1; 2; 3; 4; 5; 6] ), ([2; 4; 6], [1; 3; 5]) ); ( \"first empty\", ( (fun x -> x mod 2 = 0), [1; 3; 5] ), ([], [1; 3; 5]) ); ( \"second empty\", ( (fun x -> x mod 2 = 0), [2; 4; 6] ), ([2; 4; 6], []) ); ( \"all empty\", ( (fun x -> x mod 2 = 0), [] ), ([], []) ); ( \"duplicated elements\", ( (fun x -> x mod 2 = 0), [1; 1; 1; 2; 1; 1; 1; 1] ), ([2], [1; 1; 1; 1; 1; 1; 1]) ) ];; ",
  "print_endline \"===find_map===\";; ",
  "List.iter (test (fun (a, b) -> find_map a b)) find_map_tests;; ",
  "print_endline \"===partition==\";; ",
  "List.iter (test (fun (a, b) -> partition a b)) partition_tests;; ",
  "let test_password_manager () = let mpw = \"pass!!!!!!!!!!!!!!\" in let nmpw = \"new pass...........\" in let mng = make_manager mpw in let la1, lp1 = \"local_address_1\", \"local_password_1\" in let la2, lp2 = \"local_address_2\", \"local_password_2\" in let la3, lp3 = \"local_address_3\", \"local_password_3\" in assert_throws \"save throws wrongpassword\" (fun () -> mng.save \"incorrect\" la1 lp1;) WrongPassword; mng.save mpw la1 lp1; mng.save mpw la2 lp2; mng.save mpw la3 lp3; assert_test \"encrypted\" begin match mng.get_force \"incorrect\" la1 with | None -> false | Some epw -> print_endline epw; epw <> lp1 end; assert_throws \"get throws wrongpassword\" (fun () -> let _ = mng.get \"incorrect\" la1 in ()) WrongPassword; assert_test \"decrypt\" begin match mng.get mpw la1 with | None -> false | Some dpw -> print_endline dpw; dpw = lp1 end; assert_test \"count ops\" (mng.count_ops mpw = 5); mng.update_master mpw nmpw; assert_throws \"old pw no longer works + update_master throws WrongPassword\" (fun () -> mng.update_master mpw nmpw;) WrongPassword; assert_test \"new pw works\" begin match mng.get nmpw la2 with | Some x when x = lp2 -> true | _ -> false end; for _ = 1 to 3 do assert_throws \"try thrice: count_ops throws WrongPassword\" (fun () -> let _ = mng.count_ops mpw in ()) WrongPassword; done; assert_throws \"save throws AccountLocked\" (fun () -> mng.save nmpw la3 lp3) AccountLocked; assert_throws \"get throws AccountLocked\" (fun () -> let _ = mng.get nmpw la3 in ()) AccountLocked; assert_throws \"count_ops throws AccountLocked\" (fun () -> let _ = mng.count_ops nmpw in ()) AccountLocked; assert_throws \"update_master throws WrongPassword\" (fun () -> let _ = mng.update_master mpw nmpw in ()) WrongPassword; mng.update_master nmpw mpw; assert_test \"get now works\" begin match mng.get mpw la2 with | None -> false | Some dpw -> print_endline dpw; dpw = lp2 end; assert_test \"count ops again\" (mng.count_ops mpw = 9); ;; ",
  "print_endline \"==password manager==\";; ",
  "test_password_manager ();; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | hd :: tl -> ( match f hd with | None -> find_map f tl | Some e -> Some e ) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x acc -> if (p x) then (x::(fst acc), snd acc) else (fst acc, x::(snd acc)))  l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let saved_mp : masterpass ref = ref masterpass in let all_count : int ref = ref 0 in let err_count : int ref = ref 0 in let save (m : masterpass) (a : address ) (p : password) : unit = if (!err_count) >= 3 then raise AccountLocked else if m = !saved_mp then (ref_list := (a, (encrypt (!saved_mp) p)) :: (!ref_list); all_count := !all_count + 1) else (err_count := !err_count + 1; raise WrongPassword) in let get_force (m : masterpass) (a : address ) : password option = match (List.find_opt (fun (x, _) -> x = a) !ref_list) with | Some ap -> Some (decrypt m (snd ap)) | None -> None in let get (m : masterpass) (a : address ): password option = if (!err_count) >= 3 then raise AccountLocked else if m = (!saved_mp) then (all_count := !all_count + 1; get_force m a) else (err_count := !err_count + 1; raise WrongPassword) in let update_master (m1 : masterpass) (m2 : masterpass) : unit = if m1 = (!saved_mp) then (saved_mp := m2; ref_list := List.map (fun ap -> ((fst ap), (encrypt m2 (decrypt m1 (snd ap))))) (!ref_list); err_count := -1; all_count := !all_count + 1) else (err_count := !err_count + 1; raise WrongPassword) in let count_ops (m : masterpass) : int = if (!err_count) >= 3 then raise AccountLocked else if m = (!saved_mp) then (all_count := !all_count + 1; !all_count) else (err_count := !err_count + 1; raise WrongPassword)  in {save=save; get_force=get_force; get=get; update_master=update_master; count_ops=count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec mycatalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + mycatalan i * mycatalan (n - i)) in aux 0 (n-1) 0 in let k = mycatalan n in (k, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else let data = f f' x in stats.entries := !(stats.entries) + 1; Hashtbl.add hash x data; data in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = { entries=ref 1; lkp=ref 0 } in let f = memoize memo_cat stat in let r = memo_cat f n in (r, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | x::xs -> match f x with ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper x (ts, fs) = match p x with | true -> (x::ts, fs) | false -> (ts, x::fs) in List.fold_right helper l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let current_mp = ref masterpass in let success_count = ref 0 in let failed_count = ref 0 in let is_locked () = !failed_count >= 3 in let check_access mp = if mp = !current_mp then (failed_count := 0; success_count := !success_count + 1) else (if is_locked () then raise AccountLocked; success_count := 0; failed_count := !failed_count + 1; raise WrongPassword) in let save mp addr lp = (check_access mp; ref_list := (addr, encrypt mp lp)::!ref_list) in let get_force mp addr = find_map (fun (a, p) -> if a = addr then Some (decrypt mp p) else None) !ref_list in let get mp addr = (check_access mp; get_force mp addr) in let update_master old_mp new_mp = if old_mp = !current_mp then (failed_count := 0; current_mp := new_mp; ref_list := List.map (fun (a, p) -> (a, encrypt new_mp (decrypt old_mp p))) !ref_list) else raise WrongPassword in let count_ops mp = (check_access mp; !success_count) in { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = (count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec loop acc i = if i = n then acc else loop (acc + helper i * helper (n - 1 - i)) (i + 1) in loop 0 0) in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some(v) -> (stats.lkp := !(stats.lkp) + 1; v) | None -> let v = f f' x in (stats.entries := !(stats.entries) + 1; Hashtbl.add hash x v; v) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec loop acc i = if i = n then acc else loop (acc + recf i * recf (n - 1 - i)) (i + 1) in loop 0 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = { entries = ref 0; lkp = ref 0 } in let v = memoize memo_cat stat n in (v, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | Some h -> Some h | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let (l1, l2) = List.fold_right ( fun h (t1, t2) -> if p h then ((h::t1), t2) else (t1, (h::t2)) ) l ([], []) in (l1, l2) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ops = ref 0 in let wrong = ref 0 in let master = ref masterpass in let locked = ref false in let matchpass (masterpass : masterpass) (trial : string) : bool = if trial = masterpass then (wrong := 0; ops := !ops + 1; true) else if !wrong < 3 then (wrong := !wrong + 1; false) else (locked := true; false) in let save = ( fun m a p -> if matchpass !master m then ref_list := !ref_list @ [(a, encrypt m p)] else if !locked then raise AccountLocked else raise WrongPassword ) in let get_force = ( fun m a -> match find_map ( fun (x, y) -> if x = a then Some (x, y) else None ) !ref_list with | Some (_, y) -> Some (decrypt m y) | None -> None ) in let get = ( fun m a -> if matchpass !master m then get_force m a else if !locked then raise AccountLocked else raise WrongPassword ) in let update_master = ( fun mcurr mnew -> if matchpass !master mcurr then ( locked := false; ref_list := List.map ( fun (x, y) -> (x, encrypt mnew (decrypt mcurr y)) ) !ref_list; master := mnew) else raise WrongPassword ) in let count_ops = ( fun m -> if matchpass !master m then !ops else if !locked then raise AccountLocked else raise WrongPassword ) in let new_pass_manager () = { save; get_force; get; update_master; count_ops } in new_pass_manager () ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let swap (x, y) = (y, x) in count_rec_calls := !count_rec_calls + 1; let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else ( count_rec_calls := !count_rec_calls + 2; aux (i + 1) n (acc + catalan i * catalan (n - i)) ) in aux 0 (n - 1) 0 in swap (!count_rec_calls, catalan n) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> (stats.lkp := !(stats.lkp) + 1; v) | None -> let v = f f' x in ( Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf (i) * recf (n - i)) in aux 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let cat_stats = { entries = ref 0; lkp = ref 0 } in let catalan_memo = memoize memo_cat cat_stats in (catalan_memo n, cat_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |h::tl -> if f h <> None then f h else find_map f tl ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l1 = [] in let l2 = [] in let helper index ( t_list , f_list ) = if p index then ( index :: t_list , f_list ) else ( t_list , index :: f_list ) in List.fold_right helper l (l1 ,l2) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrong_attempt: int ref = ref 0 in let masterpass_saved: masterpass ref = ref masterpass in let count_operation: int ref = ref 0 in  let save (masterpass1:masterpass) addr (pass:password) :unit = if !wrong_attempt >= 3 then raise AccountLocked; wrong_attempt := !wrong_attempt + 1; if masterpass1 <> !masterpass_saved then raise WrongPassword else count_operation := !count_operation +1; ref_list := !ref_list @ [(addr,encrypt masterpass pass)] ; wrong_attempt := 0; in  let get_force masterpass1 addr :(password option)  =  let check (address,pass) = if address = addr then Some (decrypt masterpass1 pass) else None in find_map check !ref_list in  let get masterpass1 addr : (password option) = if !wrong_attempt >= 3 then raise AccountLocked; wrong_attempt := !wrong_attempt + 1; if masterpass1 <> !masterpass_saved then raise WrongPassword else wrong_attempt := 0; count_operation := !count_operation +1; get_force masterpass1 addr in  let update_master pass_old (pass_new:masterpass) = let rec encryption l acc = match l with |[] -> acc |(addr,pass) ::tl -> encryption tl ((addr,(encrypt pass_new pass)) :: acc) in  let rec decryption l acc = match l with |[] -> acc |(addr,pass) ::tl -> decryption tl ((addr,(decrypt pass_old pass)) :: acc) in if !wrong_attempt >= 3 then raise AccountLocked; wrong_attempt := (!wrong_attempt)+1; if pass_old <> !masterpass_saved then raise WrongPassword else let l_copy = decryption !ref_list [] in ref_list := encryption l_copy []; count_operation := !count_operation +1; wrong_attempt := 0 in  let count_ops masterpass1 = if !wrong_attempt >= 3 then raise AccountLocked; wrong_attempt := !wrong_attempt+1; if masterpass1 <> !masterpass_saved then raise WrongPassword else count_operation := !count_operation + 1; wrong_attempt := 0; !count_operation ;  in { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let res = catalan n in (res, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let res = Hashtbl.find_opt hash x in match res with |None -> let v = f f' x in Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v |Some(element) -> stats.lkp := !(stats.lkp) + 1; element in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp = ref 0 in let stats = {entries = entries; lkp = lkp} in let mem_cat = memoize memo_cat stats in ((mem_cat n), stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> let result = f h in if result = None then find_map f t else result ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let op x (pass_list, fail_list) = if p x then (x :: pass_list, fail_list) else (pass_list, x :: fail_list) in List.fold_right op l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master_pass : string ref = ref masterpass in let success_counter : int ref = ref 0 in let fail_counter : int ref = ref 0 in let account_locked : bool ref = ref false in  let check_pass test_pass = if test_pass = !master_pass then (success_counter := !success_counter + 1; fail_counter := 0; true) else (fail_counter := !fail_counter + 1; if !fail_counter > 2 then account_locked := true; false) in  let check_address addr (x, y) = if addr = x then Some y else None in  let save test_pass addr pass = if !account_locked then raise AccountLocked else if check_pass test_pass then ref_list := (addr, (encrypt !master_pass pass)) :: !ref_list else raise WrongPassword in  let get_force pass addr = let result = find_map (check_address addr) !ref_list in match result with | None -> None | Some y -> Some (decrypt pass y) in  let get test_pass addr = if !account_locked then raise AccountLocked else if check_pass test_pass then get_force test_pass addr else raise WrongPassword in  let rec update_list curr_pass new_pass l = match l with | [] -> [] | h :: t -> let (addr, pass) = h in (addr, (encrypt new_pass (decrypt curr_pass pass))) :: update_list curr_pass new_pass t in let update_master curr_pass new_pass = if check_pass curr_pass then (account_locked := false; master_pass := new_pass; ref_list := update_list curr_pass new_pass !ref_list) else raise WrongPassword in  let count_ops test_pass = if !account_locked then raise AccountLocked else if check_pass test_pass then !success_counter else raise WrongPassword in  {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec direct_catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + direct_catalan i * direct_catalan (n - i)) in aux 0 (n-1) 0 in let nr_catalan = direct_catalan n in (nr_catalan, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> stats.lkp := !(stats.lkp) + 1; v | None -> let v = f f' x in (Hashtbl.add hash x v); stats.entries := !(stats.entries) + 1; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0 } in (memoize memo_cat stats) n, stats ;; ",
  "let fun1 (a : 'a option) : 'b option = if (a = None) then None else a ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> match (f x) with |None -> find_map f xs |_ -> f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with |[] -> ([],[]) |x::xs -> List.fold_left(fun acc x -> match (p x) with |true -> ((fst acc) @ [x],(snd acc)) |false -> ((fst acc),(snd acc) @ [x])) ([],[]) l ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass = ref masterpass in let ref_count = ref 0 in let ref_attemps = ref 0 in  let check (pass : masterpass) : bool = if (pass = !ref_masterpass) then (incr ref_count;(ref_attemps := 0); true) else if (!ref_attemps > 2) then raise AccountLocked else (incr ref_attemps; false)   in let extract_pass (local_add : address) (curr : address * password) : password option = let (a,p) = curr in if local_add = a then Some (p) else None in  let save (mast_pass : masterpass) (local_add : address) (local_pass : password) = if (check mast_pass) then ref_list := (local_add,(encrypt masterpass local_pass))::!ref_list else raise WrongPassword in  let get_force (mast_pass : masterpass) (local_add: address): password option = let p =  find_map (extract_pass local_add) !ref_list in match p with |Some v -> Some (decrypt mast_pass v) |none -> None in  let get (mast_pass : masterpass) (local_add : address) : password option = if (check mast_pass) then get_force mast_pass local_add else raise WrongPassword in  let update_master old_pass new_pass = if (check old_pass) then let temp = !ref_masterpass in ( ref_masterpass := encrypt old_pass new_pass; ref_list := List.map (fun(a,p)-> (a, encrypt new_pass(decrypt temp p))) !ref_list) else raise WrongPassword in let count_ops (mast_pass : masterpass) = if check mast_pass then !ref_count else raise WrongPassword in  { save; get_force; get; update_master; count_ops} ;; ",
  " let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = (incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + helper i * helper (n - i)) in aux 0 (n-1) 0) in let result = helper n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let b = f f' x in incr stats.entries; Hashtbl.add hash x b; b in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let (s : stats) = {entries = ref 0; lkp = ref 0} in let result = (memoize memo_cat s) n in (result,s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if ((f x) <> None) then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let emptylists = ([], []) in List.fold_right (fun e (newlisttrue, newlistfalse) -> if (p e) then (e::newlisttrue, newlistfalse) else (newlisttrue, e::newlistfalse)) l emptylists ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mp = ref masterpass in let wrongcount = ref 0 in let ops = ref 0 in  let checkmp master = if !mp = master then (if !wrongcount >= 3 then raise AccountLocked else true) else (if !wrongcount >= 3 then raise AccountLocked else wrongcount := !wrongcount + 1; raise WrongPassword) in  let save = (fun master adr pw -> if checkmp master then ref_list := !ref_list @ [(adr, encrypt master pw)]; ops := !ops +1; wrongcount := 0) in  let get_force = (fun master adr -> find_map (fun (key, value) -> if key = adr then Some (decrypt master value) else None) !ref_list) in  let get = (fun master adr -> if checkmp master then ops := !ops + 1; wrongcount := 0; get_force master adr) in  let update_master = (fun master pw -> try (if checkmp master then let temp = !mp in mp := pw; ref_list := List.map (fun (key, value) -> (key, encrypt !mp (decrypt temp value))) !ref_list; ops := !ops +1; wrongcount := 0) with AccountLocked -> if !mp = master then (let temp = !mp in mp := pw; ref_list := List.map (fun (key, value) -> (key, encrypt !mp (decrypt temp value))) !ref_list; ops := !ops +1; wrongcount := 0) else raise WrongPassword) in let count_ops = (fun master -> if checkmp master then wrongcount := 0; ops:= !ops +1; !ops) in  let pm = { save = save; get_force = get_force; get  = get; update_master = update_master; count_ops = count_ops } in pm ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n = (count_rec_calls := !count_rec_calls +1); if n = 0 then (1) else let rec aux i n acc = if i > n then acc else (aux (i + 1) n (acc + catalan_helper i * catalan_helper (n - i))) in aux 0 (n-1) 0 in let r = catalan_helper n in (r, !count_rec_calls) ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let r = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; r with Not_found -> stats.entries := !(stats.entries) + 1; Hashtbl.add hash x (f f' x); Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in (memoize memo_cat stats n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> if f x <> None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (l1, l2) -> if p x then ((x::l1), l2) else (l1,(x::l2))) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass : password ref = ref masterpass in let count : int ref = ref 0 in let lock_count : int ref = ref 0 in let pass_check m = if !lock_count >=3 then raise AccountLocked else if m = !ref_masterpass then (count := !count + 1; lock_count := 0) else (lock_count := !lock_count + 1 ; raise WrongPassword) in let save masterpassword address password = pass_check masterpassword; ref_list := (address, encrypt masterpassword password) :: !ref_list  in let get_force masterpassword address = find_map (fun (add, pass) -> if add = address then Some (decrypt masterpassword pass) else None) !ref_list in let get masterpassword address = pass_check masterpassword; get_force masterpassword address  in let update_master masterpassword newpass = if (masterpassword = !ref_masterpass) then (lock_count := 0; ref_list := List.map (fun (add, pass) -> (add, encrypt newpass (decrypt masterpassword pass))) !ref_list; ref_masterpass := newpass; count := !count + 1) else (lock_count := !lock_count + 1; raise WrongPassword) in let count_ops masterpassword = pass_check masterpassword; !count in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = if n = 0 then (count_rec_calls := !count_rec_calls + 1; 1) else let rec aux i n acc = if i > n then (count_rec_calls := !count_rec_calls + 1; acc) else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let x = catalan n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then ( stats.lkp := !(stats.lkp) + 1 ; Hashtbl.find hash x) else ( let value = f f' x in Hashtbl.add hash x value ; stats.entries := !(stats.entries) + 1; value ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int =  if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let e = ref 0 in let l = ref 0 in let s : stats = {entries = e; lkp = l} in ((memoize memo_cat s) n , s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> begin let x = f x in if(x = None) then find_map f xs else x end ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l1 = [] in let l2 = [] in let test (y: 'a) ((x1,x2) : 'a list * 'a list) : ('a list * 'a list) = if(p y) then (x1 @ [y], x2) else (x1, x2 @ [y]) in let pairList = List.fold_right test l (l1,l2) in let l3 = List.rev (fst pairList) in let l4 = List.rev (snd pairList) in (l3, l4) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let count = ref 0 in let currentMasterPass = ref masterpass in let ref_list : (address * password) list ref = ref [] in let numOfOps = ref 0 in  let checkMasterPass (input : masterpass) : bool = input = (!currentMasterPass) in  let save = fun masterpass2 address password -> begin if(checkMasterPass masterpass2) then begin let encryptedPass : password = (encrypt masterpass2 password) in let newRef = ref (address, encryptedPass) in count := 0; numOfOps := !numOfOps + 1; ref_list := !newRef :: !ref_list; end else begin count := !count + 1; raise WrongPassword end end in  let get_force = fun masterpass2 address -> begin let pass = (find_map (fun (x,y) -> if(x = address) then Some y else None) !ref_list) in match pass with | Some y -> Some (decrypt masterpass2 y) | None -> None end in  let get = fun masterpass2 address -> begin if(checkMasterPass masterpass2) then begin count := 0; numOfOps := !numOfOps + 1; get_force masterpass2 address end else begin count := !count + 1; raise WrongPassword end end in  let update_master = fun masterpass2 newmasterpass -> begin if(checkMasterPass masterpass2) then begin currentMasterPass := newmasterpass; let tempList : (address * password) list ref = ref [] in let reEncrypt ((x,y) : (address * password)) = let tempPass = (x, (encrypt newmasterpass (decrypt masterpass2 y))) in tempList := tempPass :: !tempList; ref_list := !tempList in count := 0; numOfOps := !numOfOps + 1; List.iter (reEncrypt) !ref_list end else begin count := !count + 1; raise WrongPassword end end in  let count_ops = fun masterpass2 -> begin if(!count = 3) then raise AccountLocked else if(checkMasterPass masterpass2) then begin count := 0; numOfOps := !numOfOps + 1; !numOfOps end else begin count := !count + 1; raise WrongPassword end end in { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 1 in let rec compute n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else begin count_rec_calls := !count_rec_calls + 2; aux (i + 1) n (acc + compute i * compute(n - i)) end in aux 0 (n-1) 0 in let catalanNum = compute n in (catalanNum, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try begin let value = (Hashtbl.find hash x) in stats.lkp := !(stats.lkp) + 1; value end with Not_found -> begin let val2 = f f' x in Hashtbl.add hash x val2; stats.entries := !(stats.entries) + 1; val2 end in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 1 in let lkp = ref 0 in let stats = {entries; lkp} in let catalanNum = memo_cat (memoize (memo_cat) stats) n in (catalanNum, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[]-> None |x::t -> let v = (f x) in match v with |None -> find_map f t |_ -> v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let helper (element: 'a) (t: ('a list * 'a list)):('a list * 'a list)  = let (tlist,flist) = t in match p element with |true -> (element::tlist, flist) |false -> (tlist, element ::flist) in  List.fold_right helper l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpassUser = ref masterpass in let wrongPasswordCount = ref 0 in let successPasswordCount = ref 0 in  let checkPass (masterpass: masterpass) = if (!wrongPasswordCount >=3) then raise AccountLocked else if(!masterpassUser = masterpass) then (successPasswordCount := !successPasswordCount +1; wrongPasswordCount := 0) else (wrongPasswordCount := !wrongPasswordCount +1 ; raise WrongPassword) in    let save (masterpass: masterpass) (address: address) (password: password) = checkPass masterpass; ref_list := (address,encrypt (masterpass) (password))::(!ref_list); in  let get_force (masterpass: masterpass) (address:address) =  let iterate (element : (address*password)) = let (uAddress, pass) = element in if uAddress = address then Some (decrypt (masterpass) (pass)) else None in  find_map iterate !ref_list in  let get (masterpass: masterpass) (address: address) : password option = checkPass masterpass; get_force (masterpass) (address) in  let update_master (currentMasterpass: masterpass) (newMasterpassword: masterpass) =  let replace (element : (address * password)) = let (lAddress,lpassword) = element in let decryptedpass = decrypt (currentMasterpass) (lpassword) in let newEncryptedpass = encrypt (newMasterpassword) (decryptedpass) in (lAddress, newEncryptedpass) in  checkPass currentMasterpass;  masterpassUser := newMasterpassword ; ref_list := List.map replace !ref_list in  let count_ops (masterpass: masterpass) = checkPass masterpass; !successPasswordCount;  in  {save; get_force; get ;update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) =  let count_rec_calls = ref 0 in  let rec catalan n = count_rec_calls := !count_rec_calls +1; if n = 0 then (1) else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) (0) in let cNum = catalan n in (cNum, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.mem hash x) then let numlkp = !(stats.lkp) in stats.lkp := numlkp+1; Hashtbl.find hash x  else let cp = f f' x in Hashtbl.add hash x  cp; let numEntries = !(stats.entries) in stats.entries := numEntries+1; cp  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries= ref 0; lkp = ref 0} in let num = memoize memo_cat stats n in  (num, stats)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let x = find_map f t in match x with | None -> f h | y -> y ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (pass, fail) = if p x then (x::pass, fail) else (pass, x::fail) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let wrong_count = ref 0 in let right_count = ref 0 in let master_pass = ref masterpass in let ref_list : (address * password) list ref = ref [] in  let validate_master (masterpass : masterpass) : bool= if masterpass = !master_pass then if !wrong_count > 3 then raise AccountLocked else let _ = wrong_count := 0 in let _ = right_count := !right_count + 1 in true else let _ = wrong_count := !wrong_count + 1 in if !wrong_count > 3 then raise AccountLocked else raise WrongPassword in  let save (masterpass : masterpass) (address : address) (password : password) : unit = if validate_master masterpass then let encrypted_pass = encrypt masterpass password in ref_list := (address, encrypted_pass)::!ref_list  in let get_force (masterpass : masterpass) (address : address) : password option =  let is_pair ( (a, p) : address * password) : (address * password) option= if a = address then Some (a,p) else None in  let pair = find_map is_pair !ref_list in match pair with | None -> None | Some (_ , password) -> let dec = decrypt masterpass password in Some dec  in let get (masterpass : masterpass) (address : address) : password option = if validate_master masterpass then get_force masterpass address else None  in let update_master (old_master : masterpass) (new_master : masterpass) : unit=  let rec decrypt_list l decrypted_list= match l with | [] -> decrypted_list | h::t -> let (a, enc_pass) = h in let decrypted = decrypt old_master enc_pass in decrypt_list t ((a, decrypted)::decrypted_list) in  let rec encrypt_list l encrypted_list = match l with | [] -> encrypted_list | h::t -> let (a, dec_pass) = h in let encrypted = encrypt new_master dec_pass in encrypt_list t ((a, encrypted)::encrypted_list)  in  if old_master = !master_pass then let _ = wrong_count := 0 in let _ = right_count := !right_count + 1 in let _ = master_pass := new_master in let dec_list = decrypt_list !ref_list [] in ref_list := encrypt_list dec_list [] else let _ = wrong_count := !wrong_count + 1 in raise WrongPassword  in let count_ops (masterpass : masterpass) : int = if validate_master masterpass then !right_count else 0  in  { save; get_force; get; update_master; count_ops;  } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec my_catalan n = let _ = count_rec_calls := !count_rec_calls + 1 in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + my_catalan i * my_catalan (n - i)) in aux 0 (n-1) 0  in let cat_result = my_catalan n in (cat_result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let value_found = Hashtbl.find_opt hash x in match value_found with | None -> let computed_value = f f' x in let _ = stats.entries := !(stats.entries) + 1 in let _ = Hashtbl.add hash x computed_value in computed_value  | Some v -> let _ = stats.lkp := !(stats.lkp) + 1 in v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let my_stats = {entries = ref 0 ; lkp = ref 0 } in let result = memoize memo_cat my_stats n in (result, my_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let res = f x in match res with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let tru = [] in let fal = [] in let filter pred x acc = if pred x then x::acc else acc in let tru = List.fold_right (filter p) l tru in let p x = not(p x) in let fal = List.fold_right (filter p) l fal in (tru, fal) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpassword = ref masterpass in let count : int ref = ref 0 in let errors : int ref = ref 0 in  let save (mpass : masterpass) (add : address) (pw : password) : unit = if !errors = 3 then raise AccountLocked else if mpass = !masterpassword then let epw : password = encrypt mpass pw in let new_entry = (add, epw) in ref_list := (new_entry::!ref_list); errors := 0; count := !count+1; else let errors = ref (!errors+1) in if !errors = 3 then raise AccountLocked else raise WrongPassword in  let get_force (mpass : masterpass) (add : address) : (password option) = let f (add : address) (x : address*password) : (password option) = let (ad, pw) = x in if ad = add then Some pw else None in match find_map (f add) !ref_list with | None -> None | Some res -> let decrypted_pw = decrypt mpass res in Some decrypted_pw in let get (mpass : masterpass) (add : address) : password option= if !errors = 3 then raise AccountLocked else if mpass = !masterpassword then let count = ref (!count+1) in errors := 0; get_force mpass add else let errors = ref (!errors+1) in if !errors = 3 then raise AccountLocked else raise WrongPassword in  let update_master (mpass : masterpass) (newmpass : masterpass) : unit= if mpass = !masterpassword then let (addresses, pws) = List.split !ref_list in let decrypted = List.map (decrypt mpass) pws in  masterpassword := newmpass; count := !count+1; errors := 0; let encrypted = List.map (encrypt newmpass) decrypted in let _ = List.map2 (save newmpass) addresses encrypted in ()  else if !errors = 3 then raise WrongPassword else let errors = ref (!errors+1) in if !errors = 3 then raise AccountLocked else raise WrongPassword in  let count_ops (mpass : masterpass) : int= if !errors = 3 then raise AccountLocked else if mpass = !masterpassword then let count = ref (!count + 1) in errors := 0; !count else let errors = ref (!errors+1) in if !errors = 3 then raise AccountLocked else raise WrongPassword in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let num = catalan n in (num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = match Hashtbl.mem hash x with | true -> stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x | false -> let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries)+1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let stat = { entries = ref 1; lkp = ref 0; } in   let value = memo_cat (memoize memo_cat stat) n in (value, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | hd::rest -> match (f hd) with | None -> find_map f rest | _ -> f hd ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right ( fun element (lt, lf)-> if (p element) then (element::lt, lf) else (lt, element::lf)) l ([], [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else (aux (i + 1) n (acc + catalan i * catalan (n - i))) in aux 0 (n-1) 0 in let cat = catalan n in (cat, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> if (f x) = None then find_map f xs else f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (list1,list2) = if (p x) then ([x]@list1,list2) else (list1,[x]@list2) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let count_ops_value = ref 0 in let wrong_password_count = ref 0 in let masterpass_ = ref masterpass in   let save (masterpass1 : masterpass) ( address : address) (password : password) : unit =  if !wrong_password_count >=3 then raise AccountLocked else let x = 1 in if masterpass1 = !masterpass_ then let f = 1 in incr count_ops_value; wrong_password_count := 0; ref_list := !ref_list@[( address  , encrypt !masterpass_ password  )] else let y = 1 in incr wrong_password_count; raise WrongPassword    in  let get_force (masterpass1 : masterpass) ( address : address) : password option = find_map (fun x -> let (address_l, e_password) = x in if address_l = address then Some (decrypt masterpass1 e_password) else None) !ref_list  in  let get (masterpass1 : masterpass) ( address : address) : password option =  if !wrong_password_count >= 3 then raise AccountLocked else let z = 1 in if masterpass1 = !masterpass_ then let e = 1 in wrong_password_count := 0; incr count_ops_value; get_force masterpass1 address else let a = 1 in incr wrong_password_count; raise WrongPassword  in let update_master (cur_masterpass : masterpass) (new_masterpass : masterpass) : unit = if cur_masterpass = !masterpass_ then let g = 1 in incr count_ops_value; wrong_password_count := 0; ref_list := List.map (fun x -> let (address, e_password) = x in (address, encrypt new_masterpass (decrypt cur_masterpass e_password))) !ref_list; masterpass_ := new_masterpass else let b = 1 in incr wrong_password_count; raise WrongPassword  in let count_ops (masterpass1 : masterpass) : int = if !wrong_password_count >= 3 then raise AccountLocked else let c = 1 in if masterpass1 = !masterpass_ then let u = 1 in incr count_ops_value; wrong_password_count := 0; !count_ops_value else let d = 1 in incr wrong_password_count; raise WrongPassword in let p : pass_manager = {save; get_force; get; update_master;count_ops} in p ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat_helper n = incr count_rec_calls; if n = 0 then 1 else let rec sum i n acc = if i > n then acc else sum (i + 1) n (acc + cat_helper i * cat_helper (n - i)) in sum 0 (n-1) 0 in let x = cat_helper n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try Hashtbl.find hash x; stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x with Not_found -> Hashtbl.add hash x (f f' x); stats.entries := !(stats.entries) + 1; Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let c n = if n = 0 then 1 else let rec sum i n acc = if i > n then acc else sum (i + 1) n (acc + recf i * recf (n - i)) in sum 0 (n-1) 0 in c n ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in let m = memoize memo_cat s in (m n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | cur_elem::rest -> if f cur_elem = None then find_map f rest else f cur_elem ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let f x (left,right) = if p x then (x::left,right) else (left,x::right) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass : masterpass ref = ref masterpass in let wrong_pass_count = ref 1 in let wrong_pass_raised = ref false in let successful_ops = ref 0 in let check_input_masterpass (input_pass : masterpass) = if !wrong_pass_count = 3 then raise AccountLocked else (if input_pass = !ref_masterpass then let reset = (wrong_pass_count := 1; wrong_pass_raised := false; successful_ops := !successful_ops + 1) in reset else (if !wrong_pass_raised then wrong_pass_count := !wrong_pass_count + 1 else wrong_pass_raised := true; raise WrongPassword )) in    let get_force = (fun (masterpass : masterpass) -> fun (address : string) -> let f (addr, password) = if address = addr then Some password else None in let local_pass = find_map f !ref_list in match local_pass with | Some v -> Some (decrypt masterpass v) | _ -> None ) in    let get = (fun masterpass -> fun address -> check_input_masterpass masterpass; get_force masterpass address) in    { save = (fun masterpass -> fun address -> fun password -> let f = ref_list := (!ref_list@[(address, encrypt masterpass password)]) in check_input_masterpass masterpass; f   );  get_force = get_force;  get = get;  update_master = (fun old_masterpass -> fun new_masterpass -> if old_masterpass <> !ref_masterpass then check_input_masterpass old_masterpass else let rec update_pass_list new_masterpass l acc = match l with |[] -> acc |(address,local_pass)::rest -> update_pass_list new_masterpass rest (acc@[(address, encrypt new_masterpass (decrypt old_masterpass local_pass))]) in ref_masterpass := new_masterpass; wrong_pass_raised := false; wrong_pass_count := 1; successful_ops := !successful_ops + 1; ref_list := update_pass_list new_masterpass !ref_list [] );  count_ops = (fun masterpass -> check_input_masterpass masterpass; !successful_ops) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec accum_cat n i acc = if i > n then acc else accum_cat n (i+1) (acc + helper i * helper (n-i)) in accum_cat (n-1) 0 0 in let catalan_val = helper n in (catalan_val, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let y = Hashtbl.find hash x in stats.lkp.contents <- stats.lkp.contents +1; y with | Not_found -> stats.entries.contents <- stats.entries.contents + 1; let y =  f f' x in Hashtbl.add hash x y; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let catalan_sum n = if n = 0 then 1 else let rec accum_cat n i acc = if i > n then acc else accum_cat n (i+1) (acc + ((recf i) * (recf (n-i)))) in accum_cat (n-1) 0 0 in catalan_sum n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let f' = memoize memo_cat stats in let v = f' n in (v, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (l1,l2) -> if p x then (x::l1, l2) else (l1, x::l2)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let m_pass : masterpass ref = ref masterpass in let num_fail : int ref = ref 0 in let num_suc : int ref = ref 0 in let locked : bool ref = ref false in let check_pw mpw : unit = if !locked then raise AccountLocked else ( if mpw = !m_pass then ( num_fail := 0; num_suc := !num_suc + 1; )else( num_fail := !num_fail + 1; if(!num_fail >= 3) then ( locked := true; raise WrongPassword ) else ( raise WrongPassword ) ) ) in let save = (fun (mpw : masterpass) (a : address) (lpw : password) -> check_pw mpw; ref_list :=  ((a, (encrypt mpw lpw)) :: !ref_list)) in let get_force = (fun (mpw : masterpass) (a : address) -> (let f = fun ((ads, pwd) : (address * password)) : password option -> (if ads = a then Some (decrypt mpw pwd) else None) in find_map f !ref_list ) ) in let get = (fun (mpw : masterpass) (a : address) -> check_pw mpw; get_force mpw a) in let update_master = (fun (mpw : masterpass) (npw : masterpass) -> let update_helper l npw mpw = List.map (fun (a, p) -> (a, (encrypt npw (decrypt mpw p)))) l in if (mpw = !m_pass) then ( num_fail := 0; locked := false; num_suc := !num_suc + 1; ref_list := (update_helper !ref_list npw mpw); m_pass := npw; ) else ( num_fail := !num_fail + 1; if(!num_fail >= 3) then ( locked := true; raise WrongPassword ) else ( raise WrongPassword ) ) ) in let count_ops = (fun (mpw : masterpass) -> check_pw mpw; !num_suc) in { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n = incr count_rec_calls; if n = 0 then 1 else let rec helper i n acc = if i > n then acc else helper (i + 1) n (acc + cat i * cat (n - i)) in (helper 0 (n-1) 0) in let result = cat n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some(v) -> incr stats.lkp; v | None -> let result = f f' x in Hashtbl.add hash x result; incr stats.entries; result in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in ((memoize memo_cat s) n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find (fn: 'a -> 'b option) (t: 'a list) = match t with | [] -> None | h :: t' -> match fn h with |Some v -> Some v |None -> find fn t'  in find f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let par ele (l1, l2)= if p ele then (ele :: l1, l2) else (l1, ele :: l2) in List.fold_right par l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_Master = ref masterpass in  let matchCounter = ref 0 in let failConter = ref 0 in let add counter = counter := !counter + 1 in  let wrongMaster = add failConter ; false in let matchMaster = failConter :=0 ; add matchCounter; true in   let checkMaster masterp = if masterp = !ref_Master then matchMaster  else wrongMaster in   let save = fun (masterp : masterpass) (add: address) (psw: password) -> if !failConter >= 3 then raise AccountLocked; if checkMaster masterp  then let enpsw = encrypt !ref_Master psw in ref_list  := (add,enpsw) :: !ref_list;  else raise WrongPassword; in     let get_force = fun (masterp : masterpass) (add:address) -> let psw = find_map (fun (elem: address*password)-> if fst elem = add then Some (snd elem) else None)  !ref_list in match psw with | Some v ->  Some (decrypt masterp v) | None -> None in     let get = fun (masterp : masterpass) (add:address) -> if !failConter >= 3 then raise AccountLocked; if checkMaster masterp then let psw = find_map (fun (elem: address*password)-> if fst elem = add then Some (snd elem) else None)  !ref_list in match psw with | Some v ->  Some (decrypt masterp v) | None -> None else raise WrongPassword; in     let update_master = fun (currMP : masterpass) (newMP : masterpass) -> if checkMaster currMP then ref_Master := newMP else raise WrongPassword; in     let count_ops = fun (masterp : masterpass) -> if !failConter >= 3 then raise AccountLocked; else raise WrongPassword  in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let callCounter() = count_rec_calls := !count_rec_calls + 1 in  let rec catalan n = callCounter(); if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let catn = catalan n in (catn, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let accu ref = ref := !ref +1 in try let value = Hashtbl.find hash x in (accu stats.lkp ; value) with Not_found -> ( let value = f f' x in Hashtbl.add hash x value; accu stats.entries;   value) in f'; ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | x -> let rec aux i n acc  = if i >n-1 then acc else aux (i+1) n (acc + recf i * recf (n-1-i)) in aux 0 n 0  ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0 ; lkp = ref 0} in let  b = memoize  memo_cat stats n  in (b, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec helper (f : 'a -> 'b option) (l : 'a list) (acc: 'c option) = match l with |[] -> acc |x::xs -> if f x = None then helper f xs None else f x in helper f l None    ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let pass = [] in let fail = [] in let helper x (pass,fail)  = if p x then (x::pass, fail) else (pass,x::fail) in  List.fold_right helper l (pass,fail)   ;; ",
  "    let make_manager (masterpass : masterpass) : pass_manager =  let print_tuple = fun x -> let (a,b) = x in print_string \"(\"; print_string a; print_string \"*\"; print_string b; print_string \")\" in   let ref_list : (address * password) list ref = ref [] in  let (ref_master : masterpass ref) = ref masterpass in  let (ref_wrong : int ref) = ref 0 in let (ref_succ : int ref) = ref 0 in   let check_master  = fun mymaster ->  if !ref_wrong = 3 then raise AccountLocked else if mymaster = !ref_master then fun() -> ref_succ := !ref_succ + 1; ref_wrong := 0  else fun() -> ref_wrong := !ref_wrong + 1; raise WrongPassword  in       {  save  = ( fun master add pword ->  check_master master (); ref_list := [(add, encrypt !ref_master pword)]@ !ref_list; List.iter print_tuple !ref_list; ()           )     ;    get_force  = ( fun master add ->  let is_address add1   = match add1 with |(a,p) -> if a = add then  let decrypted = decrypt master p in  Some (decrypted)   else None  |_ -> None   in find_map is_address !ref_list ) ;   get  = (  fun master address ->  check_master master ();  let get_force  =  fun master add ->  let is_address add1   = match add1 with |(a,p) -> if a = add then  let decrypted = decrypt !ref_master p in  Some (decrypted)   else None  |_ -> None   in find_map is_address !ref_list  in get_force master address     );  update_master  = ( fun currentmaster newmaster ->  check_master currentmaster ();  let new_list = ref [] in  let aux = fun m -> let (a,p) = m in let decrypted = decrypt currentmaster p in let newp = encrypt newmaster decrypted in new_list := [(a,newp)]@ !new_list  in ref_master := newmaster; List.map aux !ref_list; ref_list := !new_list; ()   );  count_ops = ( fun master -> check_master master (); !ref_succ )    }   ;; ",
  "  let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = (incr count_rec_calls; match n with |0->1 |n-> let rec aux i n acc = if i>n then acc else aux (i+1) n (acc + catalan i * catalan (n-i) ) in aux 0 (n-1) 0 ) in  let f = catalan n in (f,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : ('a -> 'b) = let hash = Hashtbl.create 1000 in let entries = stats.entries in let lkp = stats.lkp in let rec f' x = match Hashtbl.find_opt hash x with |Some v -> lkp:=!lkp+1; v |None -> let y = f f' x in entries:=!entries+1; (Hashtbl.add hash x y;y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n=0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = { entries=ref 0; lkp= ref 0 } in let result_memoized = memoize memo_cat new_stats in (result_memoized n, new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match (f x) with | None -> find_map f xs | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f = fun a (b1, b2) -> if p a then (a::b1, b2) else (b1, a::b2) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let successes = ref 0 in let failures = ref 0 in let locked = ref false in let masterpass = ref masterpass in let lock () = if !failures > 2 then locked := true in let unlock () = locked := false; successes := !successes + 1 in let check mp : unit = if !locked then raise AccountLocked else match mp = !masterpass with | true -> (successes := !successes + 1); (failures := 0) | false -> failures := (!failures + 1); lock (); raise WrongPassword in let save mp address localpass = check mp; ref_list := ((address, encrypt mp localpass)::(!ref_list)) in let get_force mp address = find_map (fun (a, pw) -> (if (a = address) then Some (decrypt mp pw) else None)) !ref_list in let get mp address = check mp; get_force mp address in let update_master mp_current mp_new = if mp_current = !masterpass then begin unlock (); masterpass := mp_new; end else begin failures := !failures + 1; lock (); raise WrongPassword end; ref_list := List.fold_right (fun (a, pw) b -> ((a, encrypt mp_new (decrypt mp_current pw)))::b) !ref_list [] in let count_ops mp = check mp; !successes in let pass_manager = { save; get_force; get; update_master; count_ops } in pass_manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = let _ = count_rec_calls := (!count_rec_calls + 1) in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let x = catalan n in let y = !count_rec_calls in (x, y) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let v = f f' x in Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v | Some v -> stats.lkp := !(stats.lkp) + 1; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp = ref 0 in let stats = {entries; lkp} in let memoized_cat = memoize memo_cat stats in let ans = memoized_cat n in (ans, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if (f x) <> None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun x acc -> if (p x) then x::acc else acc) l [] , List.fold_right (fun x acc -> if not (p x) then x::acc else acc) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpassword = ref masterpass in let times_success = ref 0 in let wrong_attempts = ref 0 in let check_master mp = if encrypt mp mp = encrypt !masterpassword !masterpassword then (wrong_attempts := 0 ; true) else (wrong_attempts := !wrong_attempts + 1 ; false) in let save mp addr p = let r = check_master mp in if !wrong_attempts >= 3 then raise AccountLocked else if not r then raise WrongPassword else (ref_list := (addr, encrypt mp p)::!ref_list ; times_success := !times_success + 1 ;()) in let get_force mp a = find_map (fun x -> let (addr, p) = x in if addr = a then Some (decrypt mp p) else None) !ref_list in  let get mp p = let r = check_master mp in if !wrong_attempts >= 3 then raise AccountLocked else if not r then raise WrongPassword else times_success := !times_success + 1 ; get_force mp p in let update_master mp_old mp_new = let r = check_master mp_old in if not r then raise WrongPassword else times_success := !times_success + 1 ; ref_list := (List.map (fun (addr, p) -> let dp = decrypt mp_old p in (addr, encrypt mp_new dp)) !ref_list) ; masterpassword := mp_new ; wrong_attempts := 0 in let count_ops mp = let r = check_master mp in if !wrong_attempts >= 3 then raise AccountLocked else if not r then raise WrongPassword else times_success := !times_success + 1 ; !times_success in let pass_manager = { save = save ; get_force = get_force ; get = get ; update_master = update_master ; count_ops = count_ops } in pass_manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec calculate_catalan n = count_rec_calls := !count_rec_calls + 1 ; if n = 0 then (1, 1) else let rec cat_aux i n acc = if i > n then (acc, !count_rec_calls) else cat_aux (i+1) n (acc + let (p, _) = calculate_catalan i in p * let (q, _) = calculate_catalan (n - i) in q) in cat_aux 0 (n-1) 0 in calculate_catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try (let y = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1 ; y) with Not_found -> let z = f f' x in Hashtbl.add hash x z ; stats.entries := !(stats.entries) + 1 ; z in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n-i)) in aux 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0 ; lkp = ref 0 } in ((memoize memo_cat stats) n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x :: xs -> if f x <> None then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper elem (acc1, acc2) = if p elem then (elem :: acc1, acc2) else (acc1, elem :: acc2) in List.fold_right helper l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_input : masterpass ref = ref masterpass in let check = ref 0 in let wrong_check = ref 0 in let s = fun masterpass1 -> fun address1 -> fun password1 -> if !wrong_check >= 3 then raise AccountLocked else if !ref_input = masterpass1 then ( incr check; wrong_check := 0; let local = encrypt masterpass1 password1 in ref_list := (address1, local) :: !(ref_list) ) else (incr wrong_check; if !wrong_check >= 3 then raise AccountLocked else raise WrongPassword ) in let gf = fun masterpass11 -> fun address11 -> find_map (fun ((ad,pw) : (address * password)) -> if address11 = ad then Some (decrypt masterpass11 pw) else None) !ref_list in let g = fun masterpass111 -> fun address111 -> if !wrong_check >= 3 then raise AccountLocked else (if masterpass111 = !ref_input then (incr check; wrong_check := 0; gf masterpass111 address111) else (incr wrong_check; if !wrong_check >= 3 then raise AccountLocked else raise WrongPassword ) ) in let um = fun masterpass_cur -> fun masterpass_new -> if !ref_input = masterpass_cur then let x = masterpass_cur in ref_input := masterpass_new; incr check; ref_list := List.map (fun (p,q) : (address * password) -> (p, encrypt !ref_input (decrypt x q)) ) !ref_list else ( incr wrong_check; raise WrongPassword ) in let co = fun masterp -> if masterp = !ref_input then (wrong_check := 0; incr check; !check ) else (incr wrong_check; if !wrong_check >= 3 then raise AccountLocked else raise WrongPassword) in {save = s; get_force = gf; get = g; update_master = um; count_ops = co}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = if n = 0 then (1, !count_rec_calls + 1) else let rec aux i n acc = if i > n then (acc, !count_rec_calls + 1) else ( incr count_rec_calls; let (x, _) = helper i in incr count_rec_calls; let (m, _) = helper (n-i) in aux (i+1) n (acc + x * m) ) in aux 0 (n-1) 0 in helper n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let re = Hashtbl.find hash x in incr stats.lkp; re with Not_found -> ( let a = f f' x in Hashtbl.add hash x a; incr stats.entries; a ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s:stats = {entries = ref 0; lkp = ref 0} in let result = memoize memo_cat s n in (result, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs ->  let apply_fun = f x in if apply_fun <> None then apply_fun else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let check_partition elem (pass, fail) = if p elem then (elem::pass, fail) else (pass, elem::fail) in List.fold_right check_partition l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mpRef : masterpass ref = ref masterpass in let wrongAttempts : int ref = ref 0 in let opRef : int ref = ref 0 in let refreshCounters = wrongAttempts := 0; incr opRef in let checkMasterpass (pass: password) : bool = try let boolCheck = (pass = (!mpRef)) in match boolCheck with | true -> refreshCounters; true | false -> raise WrongPassword with WrongPassword -> false in let checkIfLocked : bool = try if !wrongAttempts >= 3 then raise AccountLocked else false with AccountLocked -> true in let encryptNewMaster (oldMaster: masterpass) (newMaster: masterpass) ((oldAddress : address), (oldPassword: password)) : (address * password) = let decryptedPass = decrypt oldMaster oldPassword in let recryptedPass = encrypt newMaster decryptedPass in (oldAddress, recryptedPass) in  let save (masterAttempt: masterpass) (saveAddress: address) (savePassword: password) = try if not checkIfLocked then if checkMasterpass masterAttempt then let encryptedPass = encrypt !mpRef savePassword in let newRefList = !ref_list @ [saveAddress, encryptedPass] in ref_list := newRefList else raise WrongPassword else raise AccountLocked with WrongPassword -> incr wrongAttempts; () | AccountLocked -> wrongAttempts := 0; () in  let get_force (masterAttempt : masterpass) (getForceAddress : address) = let getAddressFromTuple ((currentAddress: address), (currentPass: password)) = if currentAddress = getForceAddress then Some currentPass else None in let optToString (optToSwap : password option) = match optToSwap with | Some str -> str | None -> \"\" in let strToOpt (strToSwap : string) = match strToSwap with | \"\" -> None | _ -> Some strToSwap in let returnedString = find_map getAddressFromTuple !ref_list in let returnedPass = decrypt masterAttempt (optToString returnedString) in let getForcePass = strToOpt returnedPass in getForcePass in   let get (masterAttempt : masterpass) (getAddress : address) = try if not checkIfLocked then if checkMasterpass masterAttempt then get_force masterAttempt getAddress else raise WrongPassword else raise AccountLocked with WrongPassword -> incr wrongAttempts; None | AccountLocked -> wrongAttempts := 0 ; None  in  let update_master (masterAttempt: masterpass) (newMaster : masterpass) = try if not checkIfLocked then if checkMasterpass masterAttempt then let oldMP = !mpRef in let newRefList = List.map (encryptNewMaster oldMP newMaster) !ref_list in mpRef := newMaster; ref_list := newRefList else raise WrongPassword else raise AccountLocked with WrongPassword -> incr wrongAttempts; () | AccountLocked -> if checkMasterpass masterAttempt then let oldMP = !mpRef in let newRefList = List.map (encryptNewMaster oldMP newMaster) !ref_list in mpRef := newMaster; ref_list := newRefList else wrongAttempts := 0; () in  let count_ops (masterAttempt : masterpass) : int = try if not checkIfLocked then if checkMasterpass masterAttempt then (!opRef) else raise WrongPassword else raise AccountLocked with WrongPassword -> incr wrongAttempts; raise WrongPassword | AccountLocked -> wrongAttempts := 0; raise AccountLocked  in { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let increment_count num = (count_rec_calls := !count_rec_calls + num) in let rec catalan_rec rec_n = if rec_n = 0 then 1 else let rec aux i rec_n (acc: int) = if i > rec_n then acc else (increment_count 2; aux (i + 1) rec_n (acc + catalan_rec i * catalan_rec (rec_n - i))) in aux 0 (rec_n-1) 0 in let run_catalan = increment_count 1; catalan_rec n in (run_catalan, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let found_value = Hashtbl.find hash x in incr stats.lkp; found_value with Not_found -> let new_hash = f f' x in incr stats.entries; Hashtbl.add hash x new_hash; new_hash  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i rec_n (acc: int) = if i > rec_n then acc else (aux (i + 1) rec_n (acc + recf i * recf (rec_n - i))) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let cat_stats : stats = {entries = ref 0; lkp = ref 0} in (memoize memo_cat cat_stats n, cat_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> match f x with |Some v -> Some v |None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = if l = [] then ( [],[] ) else let f e ( l1 , l2) = match p e with |true -> ( e::l1 , l2 ) |false -> ( l1 , e::l2) in List.fold_right f l ([] ,[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let masterpass_ref = ref masterpass in  let counter_success = ref 0 in let incr_counter_success () = incr counter_success; !counter_success in  let counter_excep = ref 0 in let incr_counter_excep () = incr counter_excep; !counter_excep in  let save (master_password1:masterpass) (add:address) (pwd:password)= if !masterpass_ref = master_password1 then (incr_counter_success (); let encrypted_pwd = encrypt masterpass pwd in ref_list := (add,encrypted_pwd)::!ref_list) else (raise WrongPassword; incr_counter_excep (); if !counter_excep = 3 then raise AccountLocked) in    let get_force (master_password2:masterpass) (add:address) = find_map (fun (x, y) -> if x=add then Some (decrypt master_password2 y)  else None) !ref_list in  let get (master_password3:masterpass) (add:address) = if !masterpass_ref = master_password3 then (incr_counter_success (); get_force master_password3 add) else ( incr_counter_excep (); if !counter_excep = 3 then raise AccountLocked; raise WrongPassword; ) in let update_master (master_password4:masterpass) (new_pwd:password) = if !masterpass_ref = master_password4 then (incr_counter_success (); masterpass_ref:= new_pwd) else (raise WrongPassword; incr_counter_excep (); if !counter_excep = 3 then raise AccountLocked) in  let count_ops (master_password5:masterpass) = incr_counter_success() in {save;get_force;get;update_master;count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let count() = incr count_rec_calls in let rec inner_cat n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + inner_cat i * inner_cat (n - i)); in aux 0 (n-1) 0 in  (inner_cat n, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None; | h::tl -> match f h with | None -> find_map f tl | _ -> f h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f el (t_list, f_list) = if p el then (el::t_list, f_list) else (t_list, el::f_list) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let m_pass = ref masterpass in let count = ref 0 in let wrong_count = ref 0 in let passcheck (masterpass : masterpass) = masterpass = !m_pass in  let save_fun = (fun (m_password: masterpass) (address: address) (pass: password) -> if !wrong_count >= 3 then raise AccountLocked else if passcheck m_password then (ref_list := !ref_list @ [(address, encrypt m_password pass)]; count := !count + 1; wrong_count := 0) else (wrong_count := !wrong_count + 1; raise WrongPassword)) in  let get_force_fun = (fun (m_password: masterpass) (address: address) -> let f = (fun ((add, pass): (address * password)) -> if address = add then Some (decrypt m_password pass) else None ) in find_map f !ref_list ) in  let get_fun = (fun (m_password: masterpass) (address: address) -> if !wrong_count >= 3 then raise AccountLocked else if passcheck m_password then (count := !count + 1; wrong_count := 0; get_force_fun m_password address) else (wrong_count := !wrong_count + 1; raise WrongPassword)) in  let update_master_fun = (fun (cur_m_password: masterpass) (new_m_password: masterpass) -> if passcheck cur_m_password then (wrong_count := 0; count := !count + 1; m_pass := new_m_password; let (addr, pass) = List.split !ref_list in let decrypted =  List.map (decrypt cur_m_password) pass in let re_encrypted = List.map (encrypt new_m_password) decrypted in ref_list := List.combine addr re_encrypted ) else (wrong_count := !wrong_count + 1; raise WrongPassword)  ) in  let count_ops_fun = (fun (m_password: masterpass) -> if !wrong_count >= 3 then raise AccountLocked else if passcheck m_password then (count := !count + 1; wrong_count := 0; !count) else (wrong_count := !wrong_count + 1; raise WrongPassword)) in { save = save_fun; get_force = get_force_fun; get = get_fun; update_master = update_master_fun; count_ops = count_ops_fun } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = (count_rec_calls:= !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (catalan i) * (catalan (n - i))) in aux 0 (n-1) 0 ) in let result = catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x ) else let value = f f' x in (Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n-i) ) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let loc_stat = {entries = ref 0; lkp = ref 0} in let funct = memoize memo_cat loc_stat in let result = funct n in (result, loc_stat)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f x <> None then f x else find_map f xs   ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f el (l1,l2) = if p el then (el::l1,l2) else (l1,el::l2) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager  = let ref_list : (address * password) list ref = ref [] in let ref_master = ref masterpass in let success = ref 0 in let fail = ref 0 in let mpChecker mp = if (mp <> !ref_master) then (incr fail ; raise WrongPassword)in let lockChecker ()= if !fail >= 3 then raise AccountLocked in  let rec x = { save = (fun mp address password -> begin lockChecker(); mpChecker mp ; let epass = encrypt mp password in ref_list := (address,epass )::!ref_list; incr success;fail:=0 end) ; get_force =(fun mp address -> begin let x = find_map (fun (add,pass) ->  if add = address then Some pass else None ) !ref_list in match x with | None -> None | Some pass -> Some (decrypt mp pass )  end); get = (fun mp address -> begin lockChecker();mpChecker mp ; incr success; fail:=0; x.get_force mp address end); update_master = (fun mp newMP -> begin mpChecker mp; ref_list:= List.map (fun (add,pass) -> (add,encrypt newMP (decrypt mp pass))) !ref_list ; ref_master := newMP ; incr success;fail:=0 end); count_ops = (fun mp -> begin lockChecker(); mpChecker mp ; incr success ; fail:=0; !success end) } in x ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec helper  = function | 0 ->incr count_rec_calls;1 | n ->incr count_rec_calls; let rec sum i n acc = if i> n-1 then acc else sum (i+1) n (acc + (helper i) * (helper (n-1-i))) in sum 0 n 0 in  let x = helper n in (x,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in (incr stats.lkp;value) with Not_found -> ( let value = f f' x in Hashtbl.add hash x value; incr stats.entries; value) in f'; ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec sum i n acc = if i > n -1 then acc else sum (i+1) n (acc + recf i * recf (n-1-i)) in sum 0 n 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries=ref 0;lkp=ref 0} in let result = memoize memo_cat stats n in (result,stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> match f h with | Some v -> Some v | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (x : 'a )  (a,b)  = if p x then (x :: a, b) else (a, x :: b) in  List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let attempts = ref 0 in let successes = ref 0 in let m = ref masterpass in  let password_check (pass : masterpass) (key : masterpass) : bool = pass = key in  let extract x (a,b) = if x = a then Some b else None in  let get_force = fun (master : masterpass) (ad : address) -> begin  match (find_map (extract ad) !ref_list) with | None -> None | Some x -> Some (decrypt master x) end in  {save = (fun(master : masterpass) (ad : address) (pass : password) -> if attempts.contents < 3 then  if password_check master !m then begin ref_list := (ad, encrypt master pass) :: !ref_list; incr successes; attempts := 0 end else begin incr attempts; raise WrongPassword end else raise AccountLocked );  get_force = (fun (master : masterpass) (ad : address) -> get_force master ad);  get = (fun(master : masterpass) (ad : address) -> if attempts.contents < 3 then if password_check master !m then begin attempts := 0; incr successes; get_force master ad; end else begin incr attempts; raise WrongPassword end else raise AccountLocked );  update_master = (fun (master: masterpass) (neww : masterpass) -> if password_check master !m then begin attempts := 0; m:= neww ; incr successes; let recrypt (a,b) = (a, encrypt neww (decrypt master b)) in ref_list := List.map recrypt !ref_list end else begin incr attempts; raise WrongPassword end );  count_ops = (fun (master : masterpass) -> if attempts.contents < 3 then if password_check master !m then begin incr successes; !successes end else begin incr attempts; raise WrongPassword end else raise AccountLocked)} ;; ",
  "let catalan_count (n : int) = let count_rec_calls = ref 0 in  let rec cat (n : int) = count_rec_calls := !count_rec_calls + 1;  if n = 0 then 1 else let rec inner i n acc = if i > n then acc else inner (i + 1) n (acc + cat i * cat (n-i)) in  inner 0 (n-1) 0 in let x = cat n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some y -> begin incr stats.lkp; y end | None -> let y = f f' x in Hashtbl.add hash x y; incr stats.entries; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec inner i f n  = if i > n then 0 else (f i) * (f (n-i)) + (inner (i+1) f n) in inner 0 recf (n-1) ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in  let result = memoize memo_cat s n in (result, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |h::t -> match f h with | None -> find_map f t | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (a, b) = match p x with |true -> (x::a, b) |false -> (a, x::b) in List.fold_right f l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpass = ref masterpass in let ref_success = ref 0 in let ref_failure = ref 0 in let inc_success = fun () -> ref_success := (!ref_success) + 1; ref_failure := 0; in let inc_failure = fun() -> if !ref_failure = 3 then raise AccountLocked  else ref_failure := (!ref_failure) + 1 in let check_status = fun () -> if !ref_failure = 3 then raise AccountLocked else () in let encrypt_decrypt master new_pass lst = let rec e_d lst = match lst with | [] -> [] | (a,p)::l -> let r = (a, encrypt new_pass (decrypt master p)) in r :: e_d l in e_d lst in let check_pass (master : masterpass) : bool = if master = !masterpass then (inc_success(); true) else (inc_failure(); false) in let save = (fun master address local_pass -> check_status(); if check_pass master then ref_list := ((address, encrypt master local_pass) :: !ref_list ) else raise WrongPassword) in let get_force = (fun master g_address -> let r = find_map (fun t -> match t with |(a, y) when a = g_address -> Some y |_,_ -> None) !ref_list in match r with |None -> None |Some y -> Some (decrypt master y)) in let get = (fun m address -> check_status(); if check_pass m then get_force m address else raise WrongPassword) in let update_master = (fun m new_pass -> if not (m = !masterpass) then (if !ref_failure = 3 then raise WrongPassword else inc_failure(); raise WrongPassword) else if check_pass m then ref_list := encrypt_decrypt m new_pass !ref_list;masterpass := new_pass) in let count_ops = (fun master -> check_status(); if check_pass master then !ref_success else raise WrongPassword) in {save; get_force; get; update_master; count_ops}   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let next_val = fun () -> count_rec_calls := (!count_rec_calls) + 1; in let (value, counter) = let rec catalan (n : int) = next_val(); if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else aux (i + 1) n (acc + fst (catalan i) * fst (catalan (n - i))) in aux 0 (n-1) 0 in catalan n in (value, counter)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.mem hash x with |true -> stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x |false -> let (value) = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  " let catalan_m (n : int) : int * stats = let stats_return = {entries = ref 0; lkp = ref 0} in let i = memoize (memo_cat) stats_return n in (i, stats_return)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> if (f h = None) then find_map f t else f h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (t,f) = if (p x) then (x::t, f) else (t, x::f) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mpass = ref masterpass in let nop = ref 0 in let nwp = ref 0 in  let check = (fun m -> (if (m = !mpass) then (nwp := 0; nop := !nop + 1) else (nwp := !nwp + 1); m = !mpass)) in  let save = (fun m a p -> if (check m) then ref_list := (a, encrypt m p)::!ref_list else if (!nwp = 3) then raise AccountLocked else raise WrongPassword) in let get_force = (fun m a -> let p = find_map (fun (x,y) -> if (x = a) then Some y else None) !ref_list in match p with | Some x -> Some (decrypt m x) | None -> Some (decrypt m \"\")) in let get = (fun m a -> if (check m) then get_force m a else if (!nwp = 3) then raise AccountLocked else raise WrongPassword) in let update_master = (fun m n -> if (check m) then (mpass := n; ref_list := List.map (fun (x,y) -> (x, encrypt n (decrypt m y))) !ref_list) else raise WrongPassword) in let count_ops = (fun m -> if (check m) then !nop else if (!nwp = 3) then raise AccountLocked else raise WrongPassword) in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if (n = 0) then 1 else let rec aux i n acc = if (i > n) then acc else aux (i+1) n (acc + catalan i * catalan (n-i)) in aux 0 (n-1) 0 in let c = catalan n in (c, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.mem hash x) then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else (let y = f f' x in Hashtbl.add hash x y; stats.entries := !(stats.entries) + 1; y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if (n = 0) then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf(n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in let c = memoize memo_cat s n in (c, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | [x]-> f (x) | x :: xs -> if ((f (x)) != None) then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun  x (trues , falses)  -> if (p x) then ( x :: trues, falses) else (trues ,   x :: falses ))  l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in   let mpw_check (input: masterpass) : bool = (if((!wrong_counter) >=3 && (input != !mpw) ) then (account_locked := true; raise AccountLocked) else ( if(input = !mpw) then (ops := !ops +1; wrong_counter := 0; account_locked := false; else (wrong_counter := !wrong_counter + 1; raise WrongPassword))) in    { save = (fun input_mpw adrs local_pw -> if not(mpw_check input_mpw) then(  ref_list := List.cons (adrs, encrypt !mpw local_pw) !ref_list) );   get_force = (fun input_mpw adrs -> let gf (address,password) = if (address = adrs) then Some (decrypt input_mpw password) else None  in let pw_option = find_map (gf) (!ref_list) in pw_option );   get = (fun input_mpw adrs -> (if not(mpw_check input_mpw) then  (let gf (address,password) = if (address = adrs) then Some (decrypt !mpw password) else None  in let pw_option = find_map (gf) (!ref_list) in pw_option) else raise WrongPassword ) );   update_master = (fun input_mpw new_mpw -> if (input_mpw = (!mpw)) then let old_list = !ref_list in  let reboot (adr, oencry) = (adr, encrypt new_mpw (decrypt input_mpw oencry)) in  let new_list = List.map reboot old_list in (wrong_counter := 0; ops := !ops +1; account_locked := false;  ref_list := new_list; mpw := new_mpw;  () ) else (wrong_counter := !wrong_counter + 1; raise WrongPassword) );   count_ops = (fun input_mpw -> if not(mpw_check input_mpw) then let count = !ops in count else raise WrongPassword ) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan2 n =  if (n == 0) then (count_rec_calls := !count_rec_calls +1;1) else let rec aux i n acc = if i > n then (count_rec_calls := !count_rec_calls +1;acc) else ( aux (i + 1) n (acc + catalan2 i * catalan2 (n - i))) in aux 0 (n-1) 0   in let v = (catalan2 n)  in (v,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = if ( Hashtbl.find_opt hash x != None) then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else (Hashtbl.add hash x (f (f') x); stats.entries := !(stats.entries) + 1; Hashtbl.find hash x) in (f') ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats = let data = {entries = ref 0; lkp = ref 0} in let cat = memoize (memo_cat) data in let v = cat n in   (v , data) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec aux acc f l = match l with | [] -> None | x::xs -> match f x with | Some v -> f x | None -> aux acc f xs in aux None f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f a (true_list, false_list) = if (p a) then (a::true_list, false_list) else (true_list, a::false_list) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let success = ref 0 in let fail = ref 0 in let passref = ref masterpass in  let get_force = fun mpass address -> let aux = fun(cur_elem: (address * password)) -> if((fst cur_elem) != address) then None else Some (decrypt mpass (snd cur_elem)) in find_map aux !ref_list in { save = (fun mpass address password -> if !fail >= 3 then raise AccountLocked else if mpass = !passref then (success := !success + 1; fail := 0; ref_list := !ref_list @ [address, encrypt mpass password]) else (fail := !fail + 1; raise WrongPassword)); get_force = get_force; get = (fun mpass address -> if !fail >= 3 then raise AccountLocked else if mpass = !passref then (success := !success + 1; fail := 0; get_force mpass address) else (fail := !fail + 1; raise WrongPassword)); update_master = (fun mpass npass -> if mpass = !passref then (success := !success + 1; fail := 0; passref := npass; let (tmp1, tmp2) = List.split !ref_list in ref_list := List.combine tmp1 (List.map (encrypt npass) (List.map (decrypt mpass) tmp2))) else (fail := !fail + 1; raise WrongPassword)); count_ops = (fun mpass -> if !fail >= 3 then raise AccountLocked else if not (mpass = !passref) then (fail := !fail + 1; raise WrongPassword) else (success := !success + 1; fail := 0; !success)); } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec my_cat n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + my_cat i * my_cat (n - i)) in aux 0 (n-1) 0 in let cnt = my_cat n in (cnt, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else let a = f f' x in (stats.entries := !(stats.entries) + 1; Hashtbl.add hash x a; a) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0 } in (memoize memo_cat  stats n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | []-> None |x:: xs-> match  f x with |None-> find_map f xs |Some (r) ->Some (r)  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = match l with |[]-> ([],[]) |x::xs->let t x m = match p x with |true -> x :: m| false-> m  in let f x n =match p x with |true -> n |false-> x:: n in ((List.fold_right t l []),(List.fold_right f l [])) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let pass = ref masterpass in let success = ref 0 in let fail =ref 0 in let lock n= if(n<3)then () else raise AccountLocked in let save (pwd:masterpass)(a:address) (lp:password): unit = let elp = encrypt pwd lp in if pwd = !pass then (((a,elp)::!ref_list);incr success)else raise WrongPassword;incr fail in let get_force(pwd:masterpass)(a:address):password option= raise NotImplemented in let get (pwd:masterpass)(a:address):password option= if pwd= !pass then ((get_force pwd a)) else raise WrongPassword in let update_master(pwd:masterpass)(npwd:masterpass):unit = raise NotImplemented in let count_ops(pwd:masterpass):int=if pwd= !pass then (incr success; !success)else raise WrongPassword in {save;get_force;get;update_master;count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 1 in let rec catalan n = ((if n = 0 then count_rec_calls := 1 else count_rec_calls:=!count_rec_calls*3 ); (match n with | 0 -> 1 | 1 -> 1 | n ->catalan (n - 1) * 2 * (2 * n - 1) / (n + 1))) in let f = catalan n in (f,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec g a = match Hashtbl.find_opt hash a with | Some v -> incr stats.lkp; v | None -> let b = f g a in Hashtbl.add hash a b;incr stats.entries;b  in g ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  let catalan_m (n : int) : int * stats = let stats = {entries= ref 0; lkp= ref 0} in let memoized= memoize (memo_cat) stats in (memoized n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match f x with | Some v -> Some v | None -> f x ; find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f elt (list_true, list_false) = if (p elt == true) then (elt :: list_true, list_false) else (list_true, elt :: list_false) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let list_addr_pssw = ref [] in  let counter = ref 1 in  let new_list = ref [] in  let rec change l new_masterp current_masterp = match l with | [] -> [] | (a, Some p) :: t -> (a, Some (encrypt new_masterp (decrypt current_masterp p))) :: change t new_masterp current_masterp in  let save = (fun masterp -> (fun addr -> (fun pssw -> if masterp == masterpass then begin counter := !counter + 1 ; list_addr_pssw := (addr, Some (encrypt masterp pssw)) :: !list_addr_pssw end else raise WrongPassword ))) in  let get_force = fun masterp -> fun addr -> find_map((fun (addr1, Some v) -> if addr1 == addr then Some (decrypt masterp v) else None)) !list_addr_pssw in  let get = (fun masterp -> (fun addr -> if masterp == masterpass then begin counter := !counter + 1 ; get_force masterp addr end else raise WrongPassword )) in  let update_master = (fun current_masterp -> (fun new_masterp -> if current_masterp != masterpass then raise WrongPassword else begin counter := !counter + 1 ; masterpass = new_masterp; end)) in  let count_ops = (fun masterp -> if masterp == masterpass then !counter else raise WrongPassword     in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops}   ;; ",
  "let catalan_count (n : int) : (int * int) = let rec catalan count_rec_calls n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan count_rec_calls i * catalan count_rec_calls (n - i)) in aux 0 (n-1) 0 in let count_rec_calls = ref 0 in let result = catalan count_rec_calls n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let value = f f' x in Hashtbl.add hash x value; incr stats.entries; value | Some v -> incr stats.lkp; v in incr stats.entries; f f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc +  (recf i) *  (recf (n - i))) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = { entries = ref 0; lkp = ref 0 } in let result = memoize memo_cat new_stats n in (result, new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | el::arr -> let v = f el in if v != None then v else find_map f arr ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let par el (p_arr, f_arr) = if p el then (el::p_arr, f_arr) else (p_arr, el::f_arr) in List.fold_right par l ([], [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrong_counter : int ref = ref 0 in let ops_counter : int ref = ref 0 in let mpw : masterpass ref = ref masterpass in  let is_correct pw = if pw = !mpw then (wrong_counter := 0; ops_counter := !ops_counter + 1;) else wrong_counter := !wrong_counter + 1; if !wrong_counter >= 3 then raise AccountLocked else if not (pw = !mpw) then raise WrongPassword in  let save (mp : masterpass) (addr : address) (p : password) = is_correct mp; ref_list := !ref_list @ [(addr, (encrypt mp p))]; in  let get_force (mp : masterpass) (addr : address) = find_map (fun (ad, pw) -> if ad = addr then Some (decrypt mp pw) else None) !ref_list in  let get (mp : masterpass) (addr : address) = is_correct mp; get_force mp addr; in  let update_master (mp : masterpass) (nmp : masterpass) = let is_correct_um pw = if pw = !mpw then (wrong_counter := 0; ops_counter := !ops_counter + 1;) else (wrong_counter := !wrong_counter + 1; raise WrongPassword;) in let rec update f l = match f with | [] -> l | el::arr -> let (ad, pw) = el in update arr (l @ [(ad, encrypt nmp (decrypt mp pw))]) in is_correct_um mp; mpw := nmp; ref_list := update !ref_list [] in  let count_ops (mp : masterpass) = is_correct mp; !ops_counter; in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec c n = count_rec_calls := !count_rec_calls + 1; if n = 0 then (1, !count_rec_calls) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else let (acc1, ctr1) = c i in let (acc2, ctr2) = c (n - i) in aux (i + 1) n (acc + acc1 * acc2) in aux 0 (n - 1) 0 in c n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let n = f f' x in Hashtbl.add hash x n; incr stats.entries; n | Some v -> incr stats.lkp; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec r_cat i n acc = if i > n then acc else r_cat (i + 1) n (acc + (recf i) * (recf (n - i))) in r_cat 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = {entries = ref 0; lkp = ref 0} in ((memoize memo_cat stat) n, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match f x with | Some a -> Some a | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (xs, ys)= if p x then (x::xs, ys) else (xs, x::ys) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper x = (count_rec_calls := !count_rec_calls +1; if x = 0 then 1 else let rec aux i x acc = if i>x then acc else (aux (i + 1) x (acc + (helper i) * (helper (x - i)))) in aux 0 (x-1) 0) in let y = helper n in (helper n, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let aux = f (f') x in Hashtbl.add hash x aux; incr stats.entries; aux | Some y -> (incr stats.lkp; y) in incr stats.entries; f f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let m = memoize memo_cat stats n in (m, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if (f x) = None then find_map f xs else (f x) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (acc1, acc2)-> if (p x) then (x::acc1,acc2) else (acc1, x::acc2)) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrong_attempts_num = ref 0 in let global_masterpass = ref masterpass in let success_calls = ref 0 in let pass_lock masterpass1 = if ((!wrong_attempts_num) >= 3) then raise AccountLocked else if (!global_masterpass = masterpass1) then ((wrong_attempts_num := 0) ; (success_calls := !success_calls + 1)) else ((wrong_attempts_num := !wrong_attempts_num + 1) ; raise WrongPassword) in let save = (fun masterpass1 address password -> pass_lock masterpass1 ; (ref_list := (address, encrypt masterpass1 password)::(!ref_list))) in let get_force = (fun masterpass1 address -> (find_map (fun (address2, password2) -> let new_pass = decrypt masterpass1 password2 in if address2 = address then Some(new_pass) else None) !ref_list)) in let get = (fun masterpass1 address -> (pass_lock masterpass1 ; get_force masterpass1 address)) in let update_master = (fun masterpass1 new_password ->  if !global_masterpass = masterpass1 then  (global_masterpass := new_password; (wrong_attempts_num := 0) ; ref_list := (List.map (fun (address2, password2) -> (address2, encrypt new_password (decrypt masterpass1 password2))) !ref_list)) else raise WrongPassword )   in let count_ops = (fun masterpass1 -> (pass_lock masterpass1 ; !success_calls)) in { save ; get_force; get ; update_master ; count_ops ; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec count_help n = (count_rec_calls := !count_rec_calls + 1) ;if n = 0 then 1 else catalan_count_tr 0 (n-1) 0 and catalan_count_tr count n acc = if count > n then acc else catalan_count_tr (count+1) n acc+(count_help count)*(count_help (n-count)) in let v = count_help n in (v, !count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let number = Hashtbl.find hash x in (stats.lkp := !(stats.lkp) + 1) ; number with Not_found -> let final_num = (f f' x) in Hashtbl.add hash x final_num ; (stats.entries := !(stats.entries) + 1) ; final_num in f'  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec memo_cat_rec i n acc = if i > n then acc else memo_cat_rec (i + 1) n (acc + recf i * recf (n-i)) in memo_cat_rec 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats1 ={entries = ref 0; lkp = ref 0} in let memoize_cat = memoize memo_cat stats1 in let catalan_numbers = memoize_cat n in  (catalan_numbers,stats1)   ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> match (f x) with |Some b -> Some b |None -> find_map f xs  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f a (l1,l2) = if (p a) then ((a::l1),l2) else (l1,(a::l2)) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cc n = let _ = (count_rec_calls := !count_rec_calls + 1) in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + cc i * cc (n - i)) in aux 0 (n-1) 0 in let g = cc n in (g,!count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try Hashtbl.find hash x with Not_found -> let y = f x in Hashtbl.add hash x y; stats.lkp := !(stats.lkp) + 1; y in raise NotImplemented ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let tmp = f x in if tmp = None then find_map f xs else tmp ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun a b -> if p a then let y,n = b in (a::y,n) else let y,n = b in (y, a::n) ) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let count = ref 0 in let tries = ref 0 in let locked = ref false in let key = ref (encrypt masterpass masterpass ) in let check (k:masterpass) : bool = ( if (encrypt k k = !key) then (incr count; tries := 0; true) else (incr tries; (if !tries = 3 then locked := true); raise WrongPassword) ) in let save = (fun (k:masterpass) (a:address) (p:password) : unit -> ( if !locked then raise AccountLocked else (if check k then ref_list := (a, (encrypt k p))::!ref_list) )) in let get_force = (fun (k:masterpass) (a:address) : password option -> ( find_map ( fun x -> let a2,p = x in if a2 = a then Some(decrypt k p) else None ) !ref_list )) in let get = (fun (k:masterpass) (a:address) : password option -> ( if !locked then raise AccountLocked else (if check k then (get_force k a) else None) )) in let update_master = (fun (k:masterpass) (n:masterpass): unit -> ( if check k then ( key := encrypt n n; locked := false; ref_list := List.map ( fun (element:(address*password)):(address*password) -> let a,p = element in (a, encrypt n (decrypt k p)) ) !ref_list ) )) in let count_ops = (fun (k:masterpass) : int -> ( if !locked then raise AccountLocked else (if check k then !count else 0) )) in {save; get_force; get; update_master; count_ops}   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n = incr count_rec_calls; if n = 0 then 1 else sum 0 n and sum i n = if i < n then (cat i)*cat(n-i-1) + sum (i+1) n else 0 in let ans = cat n in (ans, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> (incr stats.entries; Hashtbl.add hash x (f f' x); Hashtbl.find hash x) | Some ans -> incr stats.lkp; ans in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else (let rec aux i n acc = if i> n then acc else aux (i+1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ) ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in ((memoize (memo_cat) stats) n),stats  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x:: xs -> if f x = None then find_map f xs else (f x)  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (trueList,falseList) -> if p x then (x::trueList,falseList) else (trueList,x::falseList)) l ([],[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let failedAttempts : int ref = ref 0 in let sucessfulAttempts : int ref = ref 0 in let saved_master : masterpass ref = ref masterpass in  let valid_pass (given_master : masterpass) = if !failedAttempts > 3 then raise AccountLocked else if  given_master = !saved_master then (failedAttempts := 0; sucessfulAttempts := !sucessfulAttempts+1; true) else  (failedAttempts := !failedAttempts+1;raise WrongPassword) in  let save (given_master : masterpass) (givenaddress : address) (givenpassword : password) = if valid_pass given_master then let adrs_pswd = (givenaddress, (encrypt !saved_master givenpassword)) in ref_list := (adrs_pswd :: !ref_list) in  let get_force (givenMaster : masterpass) (givenAddress : address) = let matched = find_map (fun (x,y) -> if x = givenAddress then Some (decrypt givenMaster y) else None) !ref_list in matched in  let get (given_master : masterpass) (givenAddress : address) = if valid_pass given_master then get_force given_master givenAddress else None in  let update_master (given_master : masterpass) (newMaster : masterpass) = if (compare given_master !saved_master) != 0 then (failedAttempts := !failedAttempts+1; raise WrongPassword) else let newRefList : (address * password)  list = List.map (fun ((x:address),(y:password)) -> (x, (encrypt newMaster(decrypt !saved_master y)))) !ref_list in ref_list := newRefList; saved_master := newMaster; sucessfulAttempts := !sucessfulAttempts+1; failedAttempts :=0;   in let count_ops (given_master : masterpass) = valid_pass given_master; !sucessfulAttempts; in let pass_manager = {save; get_force; get; update_master; count_ops} in pass_manager   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n = count_rec_calls := !count_rec_calls+1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_helper i * catalan_helper (n - i)) in aux 0 (n-1) 0 in let catalan_num = catalan_helper n in let answer = (catalan_num, !count_rec_calls) in answer  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.mem hash x) then (stats.lkp := !(stats.lkp)+ 1; Hashtbl.find hash x) else let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries)+1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats : stats = {entries= ref 0; lkp= ref 0} in let catalan = memoize memo_cat in let answer = catalan stats n in (answer, stats)   ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None  | x :: [] -> if f x != None then f x  | x :: y -> ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  List.fold_right (fun el (passList, failList) -> ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =   let resetFailCount : unit = wrongPasswordCount := 0; lockedStatus := false in  let  verifyMasterPwd (inputMasterPwd : masterpass) : bool = if (encrypt inputMasterPwd inputMasterPwd = !encryptedMaster) then resetFailCount; else in  let tryTurnOnLock : unit = if (!wrongPasswordCount >= 3) then lockedStatus := true in   let save (masterPWD : masterpass) (localAdrss : address) (localPWD: password) = if (!lockedStatus) then raise AccountLocked else match verifyMasterPwd masterPWD with | false -> raise WrongPassword; tryTurnOnLock | true -> ref_list := (localAdrss, encrypt masterPWD localPWD) :: (!ref_list) in  let get_force (masterPWD: masterpass) (addressInp : address) : password option = let getSomeP = find_map (fun el -> let (ad,pass) = el in if ad = addressInp then Some pass else None) !ref_list in match getSomeP with | Some pass -> Some (decrypt masterPWD pass) | None -> None in  let get (masterPWD : masterpass) (addressInp : address) : password option = if (!lockedStatus) then raise AccountLocked else match verifyMasterPwd masterPWD with | false -> raise WrongPassword | true -> get_force masterPWD addressInp in  let update_master (curMasterPwd : masterpass) (newMasterPwd : masterpass) : unit = match verifyMasterPwd curMasterPwd with | false -> raise WrongPassword | true -> temp_list := List.fold_right (fun el acc -> let (add, pass) = el in let decryptPwd = decrypt curMasterPwd pass in (add, decryptPwd)::acc ) !ref_list [];  ref_list := List.fold_right (fun el acc-> let (add, pass) = el in let newEncryptPass = encrypt newMasterPwd pass in (add, newEncryptPass)::acc ) !temp_list []; encryptedMaster := encrypt newMasterPwd newMasterPwd; in  let count_ops (masterPWD : masterpass) : int = if (!lockedStatus) then raise AccountLocked else match verifyMasterPwd masterPWD with | false -> raise WrongPassword | true -> !successOps in  { save; get_force; get; update_master; count_ops; } ;; ",
  "let count_rec_calls = ref 0 in  let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i  * catalan (n - i)) in aux 0 (n-1) 0 in let catalanEval = catalan n in (catalan n, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in try let y = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; y  with let newVal = f f' x in stats.entries := !(stats.entries) + 1; newVal in ;; ",
  "if n = 0 then 1 let rec aux i n acc = if i > n then acc in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let finalCat = memoize memo_cat newStat in (finalCat n, newStat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let result = f x in if result = None then find_map f xs else result ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let fe f e acc = if f e then e::acc else acc in let filter unfilter pred = List.fold_right (fe pred) unfilter [] in let negate f = fun x -> not (f x) in (filter l p, filter l (negate p)) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let success = ref 0 in let fail = ref 0 in let pw = ref masterpass in let verify m = if m = !pw then begin success := !success + 1; true end else begin fail := !fail + 1; false end in let save = fun m a p -> if !fail >= 3 then raise AccountLocked else if verify m then ref_list := (a, encrypt m p)::!ref_list else raise WrongPassword in let get_force = fun m a -> find_map (fun x -> let y, z = x in if y = a then Some(decrypt m z) else None) !ref_list in let get = fun m a -> if !fail >= 3 then raise AccountLocked else if verify m then get_force m a else raise WrongPassword in let update_master = fun m p -> if m = !pw then begin pw := p; fail := 0; success := !success + 1; ref_list := List.map (fun x -> let y, z = x in (y, encrypt m (decrypt masterpass z))) !ref_list end else begin fail := !fail + 1; raise WrongPassword end in let count_ops = fun m -> begin success := !success + 1; !success end in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec c n = begin count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + c i * c(n - i)) in aux 0 (n - 1) 0 end in let r = c n in (r, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in raise NotImplemented ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let opt = f h in match opt with | None -> find_map f t | Some b -> Some b ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper a (true_list, false_list) = if p a then (a::true_list, false_list) else (true_list, a::false_list) in List.fold_right helper l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let num_accessed = ref 0 in let num_wrong_pw = ref 0 in let check_password = num_wrong_pw >= (ref 3) in let add_accessed = let new_num =  !num_accessed+1 in num_accessed := new_num in let add_wrong_pw = let wrong_num = !num_wrong_pw+1 in num_wrong_pw := wrong_num in let reset = let n = 0 in num_wrong_pw := n in { save = if check_password then raise AccountLocked else (fun mp -> if masterpass == mp then (if add_accessed == () then (fun address -> fun password -> let new_list = !ref_list @ [(address, encrypt masterpass password)] in ref_list := new_list) else raise NotImplemented) else if add_wrong_pw == () then raise WrongPassword else raise NotImplemented);  get_force = ( fun mp -> fun address -> match find_map (fun h -> let (add, pw) = h in if add == address then Some pw else None) !ref_list with | None -> None | Some p -> Some (decrypt mp p)) ;   get = if check_password then raise AccountLocked else (fun mp -> fun address -> if masterpass == mp then else raise NotImplemented) else (if add_wrong_pw == () then raise WrongPassword else raise NotImplemented));  update_master = (fun mp -> if masterpass == mp then (if add_accessed == () then (fun password -> let rec helper password r_list new_list= match r_list with | [] -> ref_list := new_list | h::t -> let (add, pw) = h in let old_pw = decrypt mp pw in let new_pw = encrypt password old_pw in helper password t (new_list@[(add, new_pw)]) in helper password !ref_list []) else raise NotImplemented) else (if add_wrong_pw == () then raise WrongPassword else raise NotImplemented));  count_ops = fun mp -> if masterpass == mp then (if check_password then raise AccountLocked else !num_accessed) else (if add_wrong_pw == () then raise WrongPassword else raise NotImplemented); } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let add_count = let a = (!count_rec_calls+1) in count_rec_calls := a in let rec catalan n = if add_count = () then if n = 0 then 1 else let rec aux i n acc = if add_count == () then if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) else raise NotImplemented in aux 0 (n-1) 0 else raise NotImplemented in catalan n, !count_rec_calls ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in fun y -> let f' x = let find = Hashtbl.find_opt hash x in if find == None then let value = f x in let {entries; lkp} = stats in let add = let vl = !entries+1 in entries:= vl in let stats = {entries; lkp} in if (Hashtbl.add hash x value) == () then value else raise NotImplemented else let Some y = find in let {entries; lkp} = stats in let add = let vl = !lkp+1 in lkp:= vl in let stats = {entries; lkp} in y in f' y ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = memoize catalan ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::y -> match f x with | None -> find_map f y | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (a: 'a) (list_tuple : ('a list * 'a list)) = let pass, fail = list_tuple in if p a then (a::pass,fail) else (pass, a::fail) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let rmasterpass = ref masterpass in let function_count = ref 0 in let wrong_password = ref 0 in let acc_locked = ref false in  let check_mpass (mpass:masterpass) = function_count := !function_count + 1; if (((mpass <> !rmasterpass) && (!wrong_password >= 3))|| !acc_locked) then (acc_locked := true; raise AccountLocked) else if mpass <> !rmasterpass then (wrong_password := !wrong_password + 1; raise WrongPassword) else (wrong_password := 0 ; ()) in  let save (mpass : masterpass) (addr : address)  (passwd : password) = check_mpass mpass; ref_list := (addr, encrypt !rmasterpass passwd)::(!ref_list); () in  let get_force (mpass : masterpass) (addr : address) = let get_force_helper = fun ((addr2, passwd) : (address * password)) -> if addr = addr2 then Some (decrypt mpass passwd) else None in find_map get_force_helper (!ref_list) in  let get (mpass : masterpass) (addr : address) = check_mpass mpass; get_force mpass addr in  let update_master (oldm : masterpass) (newm: masterpass) = function_count := !function_count + 1; if oldm <> !rmasterpass then raise WrongPassword else let rec update_passwords l acc = match l with | [] -> acc | (a, p)::tail -> update_passwords tail ((a, (encrypt newm (decrypt oldm p)))::acc) in ref_list := update_passwords !ref_list []; rmasterpass := newm; acc_locked := false; () in  let count_ops (mpass : masterpass) = check_mpass mpass; !function_count in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan m = count_rec_calls := !count_rec_calls + 1; if m = 0 then 1 else let rec aux i m acc = if i>m then acc else aux (i+1) m (acc+ catalan i * catalan (m - i)) in aux 0 (m-1) 0 in let x = catalan n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let y = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; y with Not_found -> let y = f f' x in Hashtbl.add hash x y; stats.entries := !(stats.entries) + 1; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i m acc = if i > m then acc else aux (i + 1) m (acc + recf i * recf (m-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let f = memoize memo_cat stats in (f n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::l' -> if f x <> None then f x else find_map f l' ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l1, l2 = [], [] in let f e (a, b) = if p e then (e::a, b) else (a, e::b) in List.fold_right f l (l1, l2) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_wrong_count = ref 0 in let ref_count = ref 0 in let ref_masterpass = ref masterpass in let check_password mp = if mp <> !ref_masterpass then (ref_wrong_count := !ref_wrong_count + 1; false) else true in let save mp a p = if !ref_wrong_count >= 3 then raise AccountLocked else if not (check_password mp) then raise WrongPassword else (ref_list := (a, (encrypt mp p))::!ref_list; ref_wrong_count := 0; ref_count := !ref_count + 1) in let get_force mp a = match (find_map (fun (x, y) -> if x = a then Some(y) else None) !ref_list) with Some y -> Some (decrypt mp y) | None -> None in let get mp a = if !ref_wrong_count >= 3 then raise AccountLocked else if not (check_password mp) then raise WrongPassword else (ref_wrong_count := 0; ref_count := !ref_count + 1; get_force mp a) in let update_master mp p = if not (check_password mp) then raise WrongPassword else (ref_masterpass := p; let (a, b) = List.split !ref_list in (ref_list := List.combine a (List.map (encrypt p) (List.map (decrypt mp) b)); ref_wrong_count := 0; ref_count := !ref_count + 1)) in let count_ops mp = if !ref_wrong_count >= 3 then raise AccountLocked else if not (check_password mp) then raise WrongPassword else (ref_wrong_count := 0; ref_count := !ref_count + 1; !ref_count) in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = if n = 0 then (count_rec_calls := !count_rec_calls+1; 1) else (count_rec_calls := !count_rec_calls+1; let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0) in let res = catalan n in let count = !count_rec_calls in (res, count) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) else (let temp = f f' x in Hashtbl.add hash x temp; stats.entries := !(stats.entries) + 1; temp) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let catalan_stats = {entries = ref 0; lkp = ref 0} in let res = memoize memo_cat catalan_stats n in (res, catalan_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | None -> find_map f xs | Some x -> Some x ;; ",
  "let par x = (x / 2) = 0 ;; ",
  "let lst = [1;2;3;4;5;6;7;8;9]  let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper = fun el (tr, fa) -> if p el then el :: tr, fa else tr, el :: fa in List.fold_right helper l([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let failed_counter = ref 0 in let ref_master = ref masterpass in let verify_pass masterpass_input  = if masterpass_input = !ref_master then counter := !counter + 1 else ( if !failed_counter > 2 then raise AccountLocked else raise WrongPassword; failed_counter := !failed_counter + 1 ) in let save master address password_in = if !failed_counter >= 3 then raise AccountLocked else ( verify_pass master; ref_list := (address, encrypt master password_in) :: !ref_list ) in let get_force master address = let f = fun output -> let (a, p) = output in if address = a then Some (decrypt master p) else None in find_map f !ref_list in let get master address = if !failed_counter >= 3 then raise AccountLocked else ( verify_pass master; get_force master address ) in let update_master p1 p2 = verify_pass p1; List.map ( fun output -> let (a,p) = output in encrypt p2 (decrypt p1 p) ) !ref_list; ref_master := p2 in let count_ops master = if !failed_counter >= 3 then raise AccountLocked else ( verify_pass master; !counter ) in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n != 0 then ( let rec helper i n acc = if i <= n then helper (i + 1) n (catalan i * catalan (n - i) + acc) else acc in helper 0 (n-1) 0 ) else 1 in if n != 0 then let output = catalan n in (output, !count_rec_calls) else (1, 1) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let elemeent = f f' x in stats.entries := !(stats.entries) + 1; Hashtbl.add hash x elemeent; let Some new_entry = Hashtbl.find_opt hash x in new_entry | Some entry -> stats.lkp := !(stats.lkp) + 1; entry in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n != 0 then ( let rec helper i n acc = if i <= n then helper (i + 1) n (recf i * recf (n - i) + acc) else acc in helper 0 (n - 1) 0 ) else 1 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { lkp = ref 0; entries = ref 0; } in let catalan_no = memoize memo_cat stats n in (catalan_no, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[]-> None |h::rest-> match f h with |Some v-> Some v |None-> find_map f rest ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let partition_help (el: 'a) ((s1, s2):'a list *'a list) = match p el with |true-> (el::s1,s2) |false-> (s1,el::s2) in List.fold_right partition_help l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let ref_masterpass: masterpass ref= ref masterpass  in  let ref_successful_ops: int ref= ref 0 in let ref_failed_ops: int ref= ref 0 in let is_account_locked: bool ref = ref false in  let check_num_failed: unit= if !ref_failed_ops>=3 then is_account_locked:=true in  let verify_master (master_to_verify: masterpass): bool= match !ref_masterpass with |m when m = master_to_verify-> true |_-> check_num_failed; ref_failed_ops:=!ref_failed_ops +1; raise WrongPassword    in  let save (m_pass:masterpass) (addy_add:address) (local_pass:password): unit = if !is_account_locked then raise AccountLocked else match verify_master m_pass with |true-> ref_list:= (addy_add, encrypt m_pass local_pass) :: !ref_list; ref_successful_ops:= !ref_successful_ops+1 |_->raise WrongPassword in  let get_force (m_pass:masterpass) (addy_to_find:address): password option=  let find_pass ((addy,pword):address * password) : password option= match addy with |address when address=addy_to_find-> Some ( decrypt m_pass pword) |_-> None in find_map find_pass !ref_list in  let get (m_pass:masterpass) (addy_to_find:address): password option= if !is_account_locked then raise AccountLocked else match verify_master m_pass with |true-> ref_successful_ops:= !ref_successful_ops+1; get_force m_pass addy_to_find |_->raise WrongPassword in  let update_master (cur_m_pass:masterpass) (new_m_pass:masterpass): unit= match verify_master cur_m_pass with |true-> ref_masterpass:=new_m_pass ; ref_successful_ops:= !ref_successful_ops+1; if !ref_list = [] then ref_masterpass:=new_m_pass else let old_list=List.split( !ref_list ) in let old_addys,old_passwords= old_list in  let partial_decrypt=decrypt cur_m_pass in let decrypted_pwords=List.map partial_decrypt old_passwords in let partial_encrypt= encrypt new_m_pass in let encrypted_pwords= List.map partial_encrypt decrypted_pwords in let updated_list=List.combine old_addys encrypted_pwords in ref_list := updated_list; |_->raise WrongPassword in   let count_ops (m_pass:masterpass) : int= if !is_account_locked then raise AccountLocked else match verify_master m_pass with |true-> ref_successful_ops:=!ref_successful_ops+1; !ref_successful_ops |_->raise WrongPassword in  {save;get_force;get;update_master;count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) =  let count_rec_calls = ref 0 in  let rec cc_calc (n:int) =  count_rec_calls:= !count_rec_calls+1;  if n=0 then (1,!count_rec_calls) else  let rec cc_count i n acc=  if i>n then (acc,!count_rec_calls) else let term_i,_= cc_calc i in let term_ni,_= cc_calc (n-i) in cc_count (i+1) n (acc + term_i * term_ni) in cc_count 0 (n-1) 0  in cc_calc n  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try Hashtbl.find hash x; stats.lkp:= !(stats.lkp)+1; Hashtbl.find hash x with Not_found -> Hashtbl.add hash x ( f f' x); stats.entries:=!(stats.entries)+1; Hashtbl.find hash x in f'  ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let entries=ref 0 in let lkp=ref 0 in (memoize (memo_cat) {entries;lkp} n,{entries;lkp})    ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option =  let tRec f e xs = let h = f(e) in if h != None then h else (find_map f xs)  in match l with |h::xs -> tRec f h xs |[] -> None  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun head accum  -> if (p head) then head::accum else accum) l [], List.fold_right (fun head accum  -> if not (p head)then head::accum else accum) l[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mpass = ref masterpass in let counter = ref 0 in let tries_saved = ref 0 in  let check_master (given : masterpass) (masterpass : masterpass) (count : int) (tries : int) : (bool * int * int) =  if tries < 3 then if masterpass = given then (true,(count+1), 0) else let tries = tries + 1 in (false, count, tries)  else raise AccountLocked in  let save = (fun masterpass address password -> let (check, count, tries) = check_master masterpass !mpass !counter !tries_saved in let _=counter := count in let _=tries_saved := tries in if check then let p = (encrypt !mpass password) in  ref_list := (address, p)::!ref_list  else raise WrongPassword) in   let find_map_pass = (fun address x -> let (a,b) = x in if a = address then Some(b) else None) in  let get_force = (fun masterpass address -> let func = (find_map_pass address) in let b = find_map func !ref_list  in match b with |Some(string) -> Some(decrypt masterpass string) |None -> None ) in  let get = (fun masterpass address -> let (check, count, tries) = check_master masterpass !mpass !counter !tries_saved in let _=counter := count in let _=tries_saved := tries in if check then get_force masterpass address else raise WrongPassword) in  let rec password_update (ref: ((address * password) list))  (accum: ((address * password) list)) (oldP : masterpass) (newP :masterpass)  = match ref with |(a,b)::xs ->  (a, encrypt newP (decrypt oldP b)) :: (password_update xs accum oldP newP) |[] -> []   in   let update_master = (fun (x : masterpass) (n :masterpass) -> let (check, count, tries) = check_master x !mpass !counter !tries_saved in let _=counter := count in let _=tries_saved := tries in if check then let accum : (address * password) list  = [] in let _=ref_list := (password_update !ref_list accum x n) in  mpass := n  else raise WrongPassword) in  let count_ops = (fun masterpass ->  let (check, count, tries) = check_master masterpass !mpass !counter !tries_saved in let _=counter := count in let _=tries_saved := tries in if check then count else raise WrongPassword) in  let x : pass_manager = { save; get_force; get; update_master; count_ops} in x ;; ",
  " let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan n count_rec_calls = count_rec_calls := !count_rec_calls+1; if n = 0 then (1, !count_rec_calls) else  let rec aux i n acc count_rec_calls = if i > n then (acc, !count_rec_calls) else  let (a, _) = catalan i count_rec_calls in let p = n-i in let (b, _) = catalan p count_rec_calls in aux (i + 1) n (acc + a * b) count_rec_calls  in aux 0 (n-1) 0 count_rec_calls  in catalan n count_rec_calls ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = try let value = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; value with  |Not_found -> stats.entries := !(stats.entries) + 1; let y = f f' x in Hashtbl.add hash x y ; y  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let finder = memoize memo_cat stats in (finder n, stats)    ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f x = None then find_map f xs else f x ;; ",
  "let rec helper (x : 'a) (l : 'a list) : 'a list = match l with | [] -> [] | a::tail -> if a != x then a::(helper x tail) else helper x tail ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.filter p l, List.fold_right helper (List.filter p l) l) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master : masterpass ref = ref masterpass in let count : int ref = ref 0 in let fail : int ref = ref 0 in let compare (m1:masterpass) (m2:masterpass) : bool = if m1=m2 then (count:=!count+1;fail:=0;true) else (fail:=!fail+1;false) in let save = (fun mp ad pw -> if compare mp !master then ref_list:= List.cons (ad, encrypt !master pw) !ref_list else if !fail=3 then raise AccountLocked else raise WrongPassword) in let get_force = (fun mp ad -> find_map (fun (address,pw) -> if address = ad then Some (decrypt mp pw) else None) !ref_list) in let get = (fun mp ad -> if compare mp !master then get_force mp ad else if !fail=3 then raise AccountLocked else raise WrongPassword) in let update_master = (fun cur new_master -> if compare cur !master then (fail:=0;master:=new_master;ref_list:=List.map (fun (ad,pw)->(ad,encrypt !master (decrypt cur pw))) !ref_list) else raise WrongPassword) in let count_ops = (fun mp -> if compare mp !master then !count else if !fail=3 then raise AccountLocked else raise WrongPassword) in {save = save;get_force=get_force;get=get;update_master=update_master;count_ops=count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n = count_rec_calls:=!count_rec_calls+1; if n = 0 then (1,!count_rec_calls) else let rec aux i n acc = if i > n then (acc,!count_rec_calls) else let (a,_) = cat i in let (c,_) = cat (n-i) in aux (i + 1) n (acc + a  * c) in aux 0 (n-1) 0 in cat n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then (stats.lkp:=!(stats.lkp)+1;Hashtbl.find hash x) else (Hashtbl.add hash x (f f' x);stats.entries:=!(stats.entries)+1;Hashtbl.find hash x)  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int =  if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let stats : stats  = {entries = ref 0; lkp = ref 0} in (memoize memo_cat stats n,stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | []      -> None | x :: xs -> match f x with | Some v -> Some v | None   -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (x : 'a) ((a, b) : ('a list * 'a list)) : ('a list * 'a list) = if (p x) then (x :: a, b) else          (a     , x :: b) in List.fold_right f l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let wpCounter = ref 0 in let ops       = ref 0 in let mpRef     = ref masterpass in let ref_list : (address * password) list ref = ref [] in  let save inputMP inputAdd inputP : (unit) = if (!wpCounter > 2) then raise AccountLocked; if inputMP = !mpRef then begin ops:= !ops + 1; wpCounter:= 0; ref_list := (inputAdd, encrypt inputMP inputP) :: !ref_list; end else begin wpCounter:= !wpCounter + 1; raise WrongPassword end in  let get_force inputMP inputAdd : password option = let f ((add, pass) : (address * password)) : password option = if add = inputAdd then Some pass else None in let pw = find_map f !ref_list in match pw with | None   -> None | Some p -> Some (decrypt inputMP p) in   let get inputMP inputAdd : password option = if !wpCounter > 2 then raise AccountLocked; if inputMP = !mpRef then begin ops:= !ops + 1; wpCounter:= 0; get_force inputMP inputAdd end else begin wpCounter:= !wpCounter + 1; raise WrongPassword end in   let update_master cMP nMP = if cMP = !mpRef then begin ops:= !ops + 1; wpCounter:= 0; let f (a, p) l = (a, encrypt nMP (decrypt cMP p)) :: l in ref_list := List.fold_right f !ref_list []; mpRef := nMP end else begin wpCounter:= !wpCounter + 1; raise WrongPassword end in  let count_ops inputMP : int = if (!wpCounter > 2) then raise AccountLocked; if (inputMP = !mpRef) then begin wpCounter:= 0; ops := !ops + 1; !ops end else begin wpCounter:= !wpCounter + 1; raise WrongPassword end in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls:= !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let result = catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let v = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; v with Not_found -> let v = f f' x in Hashtbl.add hash x v; stats.entries := !(stats.entries)  + 1; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 in let lkp = ref 0 in let (stats : stats) = {entries; lkp} in let f = memoize memo_cat stats in let result = f n in (result, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | x::xs -> if(f x = None) then find_map f xs else f x | [] -> None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x y -> let (y1,y2) = y in if p x then (x::y1,y2) else (y1,x::y2)) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterp = ref masterpass in let op_ctr = ref 0 in let lock_ctr = ref 0 in let tick n = n := !n+1 in   let check_correct  = fun p -> (if p= !masterp then (tick op_ctr; true) else (tick lock_ctr; false)) in  let save = (fun master addr local -> if !lock_ctr < 3 then (if (check_correct master) then (ref_list :=  (addr, (encrypt (!masterp) local)):: !ref_list) else raise WrongPassword) else raise AccountLocked) in let get_force = (fun master addr -> (find_map (fun x -> let (addr_,pass) = x in if addr_ = addr then Some(decrypt master pass) else None) !ref_list)) in let get = (fun master addr -> if !lock_ctr < 3 then (if (check_correct master) then (get_force master addr) else raise WrongPassword) else raise AccountLocked) in let update_master = (fun master new_pass -> if (check_correct master) then (ref_list := List.map (fun x -> let (addr,pass) = x in (addr,(encrypt new_pass (decrypt !masterp pass) ))) !ref_list; masterp := new_pass; lock_ctr:= 0) else (raise WrongPassword)) in   let count_ops =(fun master -> if !lock_ctr < 3 then (if (check_correct master) then (!op_ctr) else (raise WrongPassword)) else raise AccountLocked) in { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let tick n = count_rec_calls := !count_rec_calls+1 ; n in  let rec cal n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i+1) n (acc + tick (cal i) * tick (cal (n-i))) in aux 0 (n-1) 0 in let a = cal n in (a, !count_rec_calls+1) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.mem hash x then (stats.lkp := !(stats.lkp) + 1 ; Hashtbl.find hash x ) else (stats.entries := !(stats.entries) + 1 ; let a = f f' x in Hashtbl.add hash x a ; a) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0; lkp = ref 0} in let f = memoize (memo_cat) s in (f n, s) ;; ",
  "let find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_helper f l = match l with | [] -> None | x :: xs -> if (f x) <> None then (f x) else find_helper f xs in find_helper f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let rec part_helper p l (pass, fail) = match l with | [] -> (pass, fail) | x :: xs -> let current = p x in if List.fold_right (fun a -> (&&) (p a)) pass current then part_helper p xs (pass @ [x], fail) else part_helper p xs (pass, fail @ [x]) in part_helper p l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let ref_list : (address * password) list ref = ref [] in let masterp : masterpass ref = ref masterpass in let lock : int ref = ref 0 in let ops : int ref = ref 0 in  let check_master (mp : masterpass) = if !lock >= 3 then raise AccountLocked; if mp = !masterp then lock := 0 else (lock := (!lock + 1); raise WrongPassword) in   let save (m : masterpass) (a : address) (localp : password) = check_master m; ref_list := (!ref_list @ [(a, encrypt m localp)]) in  let get_force (m : masterpass) (a : address) : password option = find_map (fun pair -> let (addr, pw) = pair in if addr = a then Some (decrypt m pw) else None) !ref_list in  let get (m : masterpass) (a : address) = check_master m; get_force m a; in  let update_master (m : masterpass) (n : password) = check_master m; let updated_reflist : (address * password) list ref = ref [] in updated_reflist := List.map (fun pair -> let (a, p) = pair in (a, encrypt n (decrypt m p))) !ref_list; ref_list := !updated_reflist in  let count_ops (m : masterpass) : int = check_master m; !ops in  {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = if n = 0 then (count_rec_calls := !count_rec_calls + 1; 1) else (count_rec_calls := !count_rec_calls + 1; let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 ) in let result = catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try (stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x) with Not_found -> (stats.lkp := !(stats.lkp) - 1; let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec calc i n result = if i > n then result else calc (i + 1) n (result + recf i * recf (n - i)) in calc 0 (n - 1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let create_stats (e : int) (l : int) = let entries = ref e in let lkp = ref l in { entries; lkp } in let cat_stats = create_stats 0 0 in ((memoize memo_cat cat_stats) n, cat_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> match (f x) with |None -> find_map f xs |(Some v) -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x (apply, napply) -> if (p x) then (x :: apply, napply) else (apply, x :: napply)) l ([] , [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master : masterpass ref = ref masterpass in let ref_wrong : int ref = ref 0 in let count : int ref = ref 0 in let wrongPass = fun () -> (ref_wrong := !ref_wrong + 1); if (!ref_wrong > 3) then raise AccountLocked else raise WrongPassword in let save = fun (master : masterpass) (add : address) (pass : password) -> if (master <> !ref_master) then wrongPass() else let enc = encrypt master pass in (ref_wrong := 0); count := !count + 1; ref_list := (add, enc) :: !ref_list in let get_force = fun (master : masterpass) (add : address) -> find_map (fun (addr , pass) -> if (addr = add) then let dec = decrypt master pass in Some dec else None) !ref_list in let get = fun (master : masterpass) (add : address) -> if (master <> !ref_master) then wrongPass() else (ref_wrong := 0); (count := !count +1); get_force !ref_master add in let update_master = fun (old : masterpass) (new_ : masterpass) -> if (!ref_master <> old) then ((ref_wrong := !ref_wrong + 1); raise WrongPassword) else (ref_wrong := 0);(ref_master := new_); ref_list := List.fold_right (fun (a , p) list -> let dec = decrypt old p in let enc = encrypt new_ dec in (a, enc) :: list) !ref_list []; in let count_ops = fun (master : masterpass) -> if (master <> !ref_master) then wrongPass() else (ref_wrong := 0);(count := !count +1); !count in {save = save ; get_force = get_force ; get = get ; update_master = update_master ; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalans n = (count_rec_calls := !count_rec_calls +1); if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalans i  * catalans (n - i) ) in aux 0 (n-1) 0 in let z = catalans n in ( z, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with |None -> let ans = (f f' x) in (stats.entries := 1 + !(stats.entries)); (Hashtbl.add hash x ans);ans |Some z -> (stats.lkp := 1 + !(stats.lkp)); z in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = {entries = ref 0; lkp = ref 0} in let ans =  (memoize (memo_cat) stat) n in (ans, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if (f x <> None) then f x else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f (j: 'a) ((l1 : 'a list) , (l2 : 'a list)) : ('a list * 'a list) = match (p j) with | true -> (j::l1, l2) | _ -> (l1, j::l2) in let (x, y) = List.fold_right f l ([], []) in (x, y) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let (mp: masterpass ref) = ref masterpass and (wrong_count: int ref) = ref 0 and (correct_count: int ref) = ref 0 in  let check_masterpass (mpass: masterpass): bool = if (mpass = !mp) then begin incr correct_count; wrong_count := 0; true end else begin incr wrong_count; false end in  let count_ops (mpass: masterpass) : int = begin if (!wrong_count >= 3) then raise AccountLocked; if (check_masterpass mpass) then !correct_count else raise WrongPassword end in  let update_master (mpass: masterpass) (new_mpass: masterpass) = let rec f (mpass: masterpass) (new_mpass: masterpass) (lst: (address * password) list) : (address * password) list= match lst with | [] -> [] | x::xs -> let (a, p) = x in (a, encrypt new_mpass (decrypt mpass p))::(f mpass new_mpass xs) in if (check_masterpass mpass) then begin ref_list:= f mpass new_mpass !ref_list; mp := new_mpass; wrong_count := 0 end else raise WrongPassword in  let get_force (mpass: masterpass) (address: address) : password option = let f ((a, p): address * password): password option= if (a = address) then Some (decrypt mpass p) else None in begin if (!wrong_count >= 3) then raise AccountLocked; find_map f !ref_list end in  let get (mpass: masterpass) (address: address) : password option = begin if (!wrong_count >= 3) then raise AccountLocked; if (check_masterpass mpass) then get_force mpass address else raise WrongPassword end in  let save (mpass: masterpass) (address: address) (password: password) = begin if (!wrong_count >= 3) then raise AccountLocked; if (check_masterpass mpass) then ref_list := (address, encrypt mpass password)::!ref_list else raise WrongPassword end in  {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec mycatalan n = begin incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + mycatalan i * mycatalan (n - i)) in aux 0 (n-1) 0 end in let x = mycatalan n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try begin let n = Hashtbl.find hash x in incr stats.lkp; n end with Not_found -> begin Hashtbl.add hash x (f f' x); incr stats.entries; Hashtbl.find hash x end in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let entries = ref 0 and lkp = ref 0 in let (stats : stats) = {entries; lkp} in let f = (memoize memo_cat stats) in let x = f n in (x, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> let h :: t = List.map f l in match h with | None -> find_map f xs | Some h -> Some h ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let p_split v (tl, fl) = if (p v) = true then (v::tl, fl) else (tl, v::fl) in List.fold_right p_split l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in raise NotImplemented ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in raise NotImplemented ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find = function | [] -> None | x::xs -> match f x with | None -> find xs | Some _ as v -> v in find l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f element (pass, fail) = if p element then (element::pass, fail) else (pass, element::fail) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterref = ref masterpass in let function_count = ref 0 in let wrong_occur = ref 0 in let helper (pass1 : masterpass) (pass2 : masterpass) = if (pass1 = pass2) then wrong_occur := 0 else ( incr wrong_occur ) in let helper2 master addr = find_map (fun (x,y) -> if x = addr then Some (decrypt master y) else None) !ref_list in  let save (master : masterpass) (addr : address) (pass : password) = helper master !masterref; if !wrong_occur = 0 then ( ref_list := (addr, encrypt !masterref pass)::(!ref_list); incr function_count )  else if !wrong_occur = 1 || !wrong_occur = 2 then raise WrongPassword else raise AccountLocked  in  let get_force (master : masterpass) (addr : address) = helper2 master addr;  in let get (master : masterpass) (addr : address) = helper master !masterref; if !wrong_occur = 0 then ( incr function_count; get_force master addr; ) else if !wrong_occur = 1 || !wrong_occur = 2 then raise WrongPassword else raise AccountLocked in let update_master (master : masterpass) (pass : password) = helper master !masterref; if !wrong_occur = 0 then( masterref := pass ; wrong_occur := 0; incr function_count; ) else if !wrong_occur = 1 || !wrong_occur = 2 then raise WrongPassword else raise AccountLocked in let count_ops (master : masterpass): int = !function_count in {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in raise NotImplemented ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let res = f (f') x in Hashtbl.add hash x res; incr stats.entries; res | Some v -> incr stats.lkp; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n-i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> match f x with | Some x -> Some x | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper v (a, b) = if p v then (v::a, b) else (a, v::b) in List.fold_right helper l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in if m = !ref_mast then ((ref_ops := !ref_ops + 1; ref_wrong := 0) ; true) else ((ref_wrong := !ref_wrong + 1; raise WrongPassword)) in let rec replace_pass m2 temp_l ref_list = match ref_list with | [] -> () | h::t -> let var = snd(h) in replace_pass m2 temp_l t) in let get_force = (fun m2 addy -> (let match_addy (curr_addy, curr_pass) = if curr_addy = addy then Some curr_pass else None in match find_map match_addy !ref_list with | None -> None | Some returned_pass -> Some (decrypt m2 returned_pass))) in { save = (fun m2 addy loc_pass -> if helper m2 then let enc_pass = encrypt m2 loc_pass in else () ); get_force = get_force ; get = (fun m2 addy -> if helper m2 then get_force m2 addy else None ); update_master = (fun m_old m_new -> let temp_l : (address * password) list ref = ref [] in if helper m_old then (replace_pass m_new temp_l !ref_list ; ref_mast := m_new ; ref_list := !temp_l) else () ); count_ops = (fun m2 -> if helper m2 then !ref_ops else 0 ) } ;; ",
  "let catalan_count (n : int) : int * int = let count_rec_calls = ref 0 in let inc () = count_rec_calls := !count_rec_calls + 1 in let rec catalan' n = inc (); if n = 0 then 1 else let rec aux' i n acc = if i > n then acc else aux' (i + 1) n (acc + (catalan' i * catalan' (n - i))) in aux' 0 (n - 1) 0 in let result = catalan' n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some y -> stats.lkp := !(stats.lkp) + 1; y | None -> let y = f f' x in Hashtbl.add hash x y; stats.entries := !(stats.entries) + 1; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let var = { entries = ref 0 ; lkp = ref 0 } in (memoize memo_cat var n, var) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> if f h = None then find_map f t else f h  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let func x (_true, _false) = if p x then (x :: _true, _false) else (_true, x :: _false) in List.fold_right func l ([] ,[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let m = ref masterpass in let attempts = ref 0 in let ops = ref 0 in  let correct p = if !attempts > 2 then raise AccountLocked else match p = !m with | true -> attempts := 0; ops := !ops + 1; () | false -> attempts := !attempts + 1 ; if !attempts > 2 then raise AccountLocked else raise WrongPassword in  let save =  fun masterp a p -> correct masterp; ref_list := (a, (encrypt !m p))::!ref_list in  let get_force = fun masterp ad -> let f e = let (a, p) = e in if a = ad then Some (decrypt masterp p) else None in find_map f !ref_list in  let get = fun masterp a -> correct masterp; get_force masterp a in  let update_master = fun m_cur m_new -> let list_temp = ref_list in let ref_list = ref [] in match m_cur = !m with | true -> attempts := 0; correct m_cur; m := m_new;  let rec encrypt_decrypt l = match l with | [] -> () | h :: t -> let (a, p) = h in ref_list := (a, encrypt m_new (decrypt m_cur p)) :: !ref_list; encrypt_decrypt t in encrypt_decrypt !list_temp | false -> correct m_cur in  let count_ops = fun masterp -> correct masterp; !ops in  {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in if n = 0 then (1, 1) else if n = 1 then (1, 3) else (2, 9)   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = raise NotImplemented in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |h::t -> if (f h) = None then find_map f t else (f h)   let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper e (t, f) = if p e then (e::t, f) else (t, e::f) in List.fold_right helper l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_master = ref masterpass in let ref_locked = ref true in let ref_list : (address * password) list ref = ref [] in let ref_count = ref 0 in let ref_exception = ref 0 in let check_except = if !ref_exception > 3 then raise AccountLocked else true in let check m = if ( m = !ref_master ) then (ref_exception := 0 ;ref_count := !ref_count + 1;true) else ((ref_exception := !ref_exception + 1; raise WrongPassword))  in let s = fun master addr pass -> if (if !ref_exception >= 3 then raise AccountLocked else true ) && (check master)  then (ref_list := (addr , encrypt master (pass)) :: !ref_list) else ref_list := !ref_list in let g_f = fun master addr -> (find_map (fun (x,y) -> if x = addr then Some (decrypt master (y)) else None) !ref_list) in let g = fun master addr -> if (if !ref_exception >= 3 then raise AccountLocked else true) && (check master) then (g_f master addr) else None in let update_pass cur new_m = ref_list :=  List.map (fun (a, p) -> (a, encrypt new_m (decrypt cur p))) !ref_list in let u = fun cur new_m -> if (check cur) then (ref_exception := 0 ;update_pass cur new_m; ref_master := new_m) else  ref_list := !ref_list in let c master = if (if !ref_exception >= 3 then raise AccountLocked else true) && (check master) then (!ref_count) else raise WrongPassword in let p = { save = s; get_force = g_f; get = g; update_master = u; count_ops = c   }  in p ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan_help n = if n = 0 then ( count_rec_calls := !count_rec_calls + 1; 1)  else (count_rec_calls := !count_rec_calls + 1; let rec aux i n acc = if i > n then acc else (aux (i + 1) n (acc + catalan_help i * catalan_help (n - i))) in aux 0 (n-1) 0) in let num = catalan_help n in (num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> (stats.lkp := ! (stats.lkp) + 1 ; v) | None -> let y = f f' x in Hashtbl.add hash x y; stats.entries := !( stats.entries) + 1;y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = { entries = ref 0 ; lkp = ref 0} in let v = memoize memo_cat s in (v n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let ans = f x in match ans with | None -> find_map f xs | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let parter item (trues, falses) = if p item then (item::trues, falses) else (trues, item::falses) in List.fold_right parter l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let ref_list : (address * password) list ref = ref [] in let wrong_pwd : int ref = ref 0 in let success_counter : int ref = ref 0 in let masterpass : string ref = ref masterpass in let account_locked : bool ref = ref false in  let check_match (inp_masterpass: masterpass) : bool = if !account_locked then false else if inp_masterpass = !masterpass then let () = wrong_pwd := 0 in true else let () = wrong_pwd := !wrong_pwd + 1 in if !wrong_pwd = 3 then let () = account_locked := true in false else false   in   let save (inp_masterpass : masterpass) address password : unit = if !account_locked then (raise AccountLocked) else if check_match inp_masterpass then ( let() = (success_counter := !success_counter + 1) in let encrypted = encrypt inp_masterpass password in ref_list := !ref_list@[(address, encrypted)] )  else (raise WrongPassword)  in  let get_force inp_masterpass address : password option = let matches (tuple : 'a) : 'b option = let addr, pwd = tuple in if address = addr then Some pwd else None in match find_map matches !ref_list with | None -> None | Some v -> Some (decrypt inp_masterpass v)  in  let get (inp_masterpass: masterpass) (inp_address : address) : password option = if !account_locked then (raise AccountLocked) else if check_match inp_masterpass then ( let () = (success_counter := !success_counter + 1) in get_force inp_masterpass inp_address ) else (raise WrongPassword)  in  let update_master (old_mp : masterpass) (new_mp : masterpass) : unit =  if !account_locked then ( if check_match old_mp then account_locked := false else raise WrongPassword ) else if check_match old_mp then ( let () = (success_counter := !success_counter + 1) in let old_list = !ref_list in let new_list : (address * password) list ref = ref [] in let rec iter_list old_list new_list = match old_list with | [] -> let () = ref_list := !new_list in masterpass := new_mp | x::xs -> let addr, pwd = x in let () = new_list := !new_list@[(addr, encrypt new_mp (decrypt old_mp pwd))] in iter_list xs new_list in iter_list old_list new_list )  else (raise WrongPassword)  in  let count_ops inp_masterpass : int = if !account_locked then (raise AccountLocked) else if check_match inp_masterpass then ( let () = (success_counter := !success_counter + 1) in !success_counter ) else (raise WrongPassword)  in  {save = save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec catalan n = let () = count_rec_calls := !count_rec_calls + 1 in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let result = catalan n in (result, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let my_hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt my_hash x with | Some v -> incr stats.lkp; v | None -> let result = f f' x in let () = stats.entries := !(stats.entries) + 1 in let () = Hashtbl.add my_hash x result in result in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let my_table = Hashtbl.create 1000 in let rec recf n = match Hashtbl.find_opt my_table n with | Some v -> v | None -> match n with | 0 -> (Hashtbl.add my_table n 0; 1) | _ -> let value = recf (n-2) + recf (n-1) in let () = Hashtbl.add my_table n value in value in recf n ;; ",
  "let catalan_m (n : int) : int * stats = let my_stats = {entries = ref 0; lkp = ref 0} in  let cat_mem = memoize (fun num_cat n -> if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (num_cat i) * num_cat (n-i)) in aux 0 (n-1) 0) my_stats in cat_mem n, my_stats ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_helper f l acc: 'b option = match l with | [] -> acc | x::xs -> let res = f x in if res = None then find_map_helper f xs acc else find_map_helper f xs res in find_map_helper f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let partition_helper el (pass, fail) = if p el then (el::pass, fail) else (pass, el::fail) in List.fold_right partition_helper l ([], []) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master = ref masterpass in let attempts = ref 0 in  let ops = ref 0 in let check_account_locked = if !attempts >= 3 then raise AccountLocked in let verify_password provided = match provided = !ref_master with | true -> incr ops; attempts := 0 | false -> incr attempts; raise WrongPassword in  let save_func master addr password = check_account_locked; verify_password master; let combo = (addr, encrypt !ref_master password) in ref_list :=  combo::!ref_list in  let get_force_func master addr = let selector add tuple = match add == fst tuple with | true -> Some (decrypt master (snd tuple)) | false -> None in find_map (selector addr) !ref_list in  let get_func master addr  = check_account_locked; verify_password master; get_force_func master addr in let update_master_func old_master new_master = verify_password old_master; ref_master := new_master; ref_list := List.map (fun tuple -> ((fst tuple), (encrypt new_master (decrypt old_master (snd tuple))))) !ref_list in let count_ops_func master = check_account_locked; verify_password master; !ops in let manager = { save = save_func; get_force = get_force_func; get = get_func; update_master = update_master_func; count_ops = count_ops_func; } in manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n = incr count_rec_calls; match n with | 0 -> (1, !count_rec_calls) | x ->  let rec helper i n acc = if i > n then (acc, !count_rec_calls) else let t1 = fst (catalan_helper i) in let t2 = fst (catalan_helper (n - i)) in helper (i + 1) n  (acc +  t1 * t2) in helper 0 (x-1) 0 in catalan_helper n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let res = Hashtbl.find_opt hash x in match res with | None -> incr stats.entries; let computed = f f' x in Hashtbl.add hash x computed; computed | Some res -> incr stats.lkp; res in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | x -> let rec helper i acc = match i == x with | true -> acc | false -> helper (i + 1) (acc + recf(i) * recf(n - 1 - i)) in helper 0 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries=ref 0; lkp=ref 0} in let func = memoize memo_cat s in (func n, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None |x::xs -> match (f x) with |Some v -> Some v |None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun x acc -> let (tlist,flist) = acc in if (p x) then (x::tlist,flist) else (tlist,x::flist) ) l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let lock = ref 0 in let mp = ref masterpass in let ops = ref 0 in let save = ( fun (m:masterpass) (add:address) (pw:password) -> if !lock = 3 then raise AccountLocked else if m = !mp then let _=(lock := 0)in let _= (ops := (!ops + 1)) in ref_list := (add, (encrypt !mp pw) ) ::!ref_list else let _= (lock := !lock + 1) in raise WrongPassword ) in let get_force = ( fun (m:masterpass) (add:address) -> find_map (fun (add_list,pw_list)-> if add_list = add then Some (decrypt m pw_list ) else None ) !ref_list ) in let get = ( fun (m:masterpass) (add:address)-> if !lock = 3 then raise AccountLocked else if m = !mp then let _=(lock := 0)in let _= (ops := (!ops + 1)) in get_force m add else let _= (lock := !lock + 1) in raise WrongPassword ) in let update_master = ( fun (m:masterpass) (newP:masterpass)-> if m = !mp then let _=(lock := 0)in let _= (ops := (!ops + 1)) in let oldList = !ref_list in let rec parseList l = match l with |[] -> [] |(a,p)::xs -> (a,(encrypt newP (decrypt !mp p)))::(parseList xs) in ref_list := parseList oldList; mp := newP else let _= (lock := !lock + 1) in raise WrongPassword ) in let count_ops = ( fun (m:masterpass) -> if !lock = 3 then raise AccountLocked else if m = !mp then let _=(lock := 0)in let _= (ops := (!ops + 1)) in !ops else let _= (lock := !lock + 1) in raise WrongPassword ) in {save;get_force;get;update_master;count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan2 n = let _=(count_rec_calls := !count_rec_calls + 1)in if n = 0 then 1 else let rec aux2 i n acc = if i > n then acc else aux2 (i + 1) n (acc + catalan2 i * catalan2 (n - i)) in aux2 0 (n-1) 0 in let rs = catalan2 n in (rs, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.find_opt hash x = None) then let _=(stats.entries := !(stats.entries) + 1) in let result = (f f' x) in Hashtbl.add hash x result;result else let _=(stats.lkp := !(stats.lkp) + 1) in let Some v = Hashtbl.find_opt hash x in v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux3 i n acc = if i > n then acc else aux3 (i + 1) n (acc + recf i * recf (n - i)) in aux3 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = ref 0;lkp = ref 0} in ((memoize memo_cat s) n,s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xl -> match (f x) with |None -> find_map f xl |Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun ap ((ad, bd) : 'a list*'a list) -> if p ap then (ap::ad,  bd) else (ad, ap::bd)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let correct_num = ref 0 in let wrong_num = ref 0 in let master = ref masterpass in let check_of_pass (pass_in :password) = if (pass_in = !master) then (wrong_num := 0; incr correct_num; true) else (incr wrong_num; if (!wrong_num >= 3) then raise AccountLocked else raise WrongPassword) in let get_force master_p add = let decrypt_p (ad, pas) = if ad = add then Some(decrypt master_p pas) else None in find_map decrypt_p !ref_list in let get master2 add = if (check_of_pass master2) then get_force master2 add else None in let save master_p address pass = if (check_of_pass master_p)then ref_list := !ref_list @ [(address,(encrypt master_p pass))] in  let update_master (current_pass:password) (new_pass:password) = let new_list = ref [] in let rec update1 old1 new1 = match old1 with | [] -> new1 | x::xs -> let (a,b) = x in update1 xs (new1 @ [(a, encrypt new_pass (decrypt current_pass b))]) in if (check_of_pass current_pass) then (wrong_num := 0; ref_list := update1 !ref_list !new_list; master:= new_pass) else ()in  let count_ops master_p = if (check_of_pass master_p ) then !correct_num else -1 in  { save; get_force; get; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let grab_first (ad: 'a*'a) = let (a1, _) = ad in a1 in let count_rec_calls = ref 0 in let rec s_catalan n = incr count_rec_calls; if n = 0 then (1,!count_rec_calls) else let rec s_aux i n acc = if i > n then (acc,!count_rec_calls) else s_aux (i + 1) n (acc + grab_first (s_catalan i) * grab_first (s_catalan (n - i))) in s_aux 0 (n-1) 0 in s_catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> stats.lkp := !(stats.lkp) + 1; (Hashtbl.find hash x) | None -> let f2 = f f' x in Hashtbl.add hash x f2 ; stats.entries := !(stats.entries) + 1; f2 in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (recf i )* (recf (n - i))) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0; } in (memoize memo_cat stats n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None; |h::l -> let v = (f h) in match v with |None -> find_map f l |_ -> v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun h t -> if p h then h::t else t) l [], List.fold_right (fun h t -> if p h then t else h::t) l []    ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list = ref [] in let ref_masterpass = ref masterpass in let ref_counter = ref 0 in let ref_wrongpass = ref 0 in let check_pass checking = let matched = ref false in if !ref_wrongpass=3 then raise AccountLocked else (if !ref_masterpass=checking then ( matched:=true; ref_counter:=!ref_counter+1; ref_wrongpass:=0) else (ref_wrongpass:= !ref_wrongpass+1; raise WrongPassword)); !matched; in let save masterpass address (pass:password) = if check_pass masterpass then ref_list:= (address, encrypt masterpass pass) :: !(ref_list); in  let get_force masterpass address = let same_address = (fun addpass -> let (add,pass) = addpass in if address= add then Some (decrypt masterpass pass) else None ) in find_map same_address !ref_list in  let get masterpass address = if check_pass masterpass then get_force masterpass address else raise WrongPassword in  let update_master oldpass newpass = match check_pass oldpass with |true -> ref_masterpass:=newpass; (ref_list:= (List.map (fun en_list -> let (address,pass)=en_list in (address, encrypt newpass pass)) (List.map (fun de_list -> let (address1,pass1)=de_list in (address1, decrypt oldpass pass1)) !ref_list)))  |false -> raise WrongPassword in  let count_ops masterpass = match check_pass masterpass with |true -> !ref_counter |false -> -1 in { save; get_force; get; update_master; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n = count_rec_calls := !count_rec_calls+1; if n = 0 then 1 else let rec aux i n acc = match i>n with |true -> acc |false -> aux (i + 1) n (acc + cat i * cat (n - i)) in aux 0 (n-1) 0 in let num = cat n in(num ,!count_rec_calls) ;; ",
  "let memoize f s = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let n = f f' x in Hashtbl.replace hash x n; s.entries:=!(s.entries)+1; n | Some k -> s.lkp:=!(s.lkp)+1; k in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = {entries=ref 0;lkp=ref 0} in (memoize memo_cat stat n, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | []     -> None | x::xs  -> match f(x) with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let partition_h x (func, listA, listB ) = match func(x) with | true  -> ( func, (x::listA), listB ) | false -> ( func, listA, (x::listB) )  in let (a,b,c) = List.fold_right partition_h l (p, [], []) in (b, c) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in  let count_rec_calls = ref 0 in let tick = (fun () -> count_rec_calls := 1 + !count_rec_calls) in  let count_wrong = ref 0 in let tickW = (fun () -> count_wrong := 1 + !count_wrong) in let resetW = (fun () -> count_wrong := 0) in  let saveH = ( fun (masterpass1: masterpass) (address1: address) (password1: password) -> if (!count_wrong > 2) then raise AccountLocked else if (masterpass1 = !master) then (resetW(); tick (); ref_list := ( (address1, encrypt masterpass password1)::(!(ref_list)) )) else (tickW(); raise WrongPassword) ) in let get_forceH = (fun (masterpass2: masterpass) (address2: address) -> let help addP (add, pass) = if add = addP then Some (decrypt masterpass2 pass) else None in find_map (help address2) !ref_list ) in let getH = (fun (masterpass3: masterpass) (address3: address) -> if (!count_wrong > 2) then raise AccountLocked else if (masterpass3 = !master) then (resetW(); tick (); get_forceH masterpass3 address3) else (tickW(); raise WrongPassword) ) in let update_masterH = (fun (masterpass4: masterpass) (newmasterpass: masterpass) -> if (masterpass4 = !master) then let updater f (x,y) = (x, f y) in (resetW(); tick (); ref_list := List.map (updater (decrypt masterpass)) !ref_list; ref_list := List.map (updater (encrypt newmasterpass)) !ref_list; master := newmasterpass;) else (tickW(); raise WrongPassword) ) in let count_opsH = fun (masterpass5: masterpass) -> if (!count_wrong > 2) then raise AccountLocked else if (masterpass5 = !master) then (resetW(); tick (); !count_rec_calls) else (tickW(); raise WrongPassword) in  { save = saveH ; get_force = get_forceH ; get = getH ; update_master = update_masterH ; count_ops = count_opsH }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let tick = (fun () -> count_rec_calls := 1 + !count_rec_calls) in  let rec catalanHelp n = tick ();  if n = 0 then 1 else let rec auxH i n acc = if i > n then acc else auxH (i + 1) n (acc + catalanHelp i * catalanHelp (n - i)) in auxH 0 (n-1) 0 in let a = catalanHelp n in (a, !count_rec_calls) ;; ",
  "   let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = try let tempval = (Hashtbl.find hash x) in (stats.lkp := 1 + !(stats.lkp)); tempval with Not_found -> let tempval2 = (f f' x) in (Hashtbl.add hash x tempval2); (stats.entries := 1 + !(stats.entries)); tempval2 in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux2 i n acc2 = if i > n then acc2 else aux2 (i + 1) n (acc2 + recf i * recf (n - i)) in aux2 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let statBlock = {entries = ref 0; lkp = ref 0} in ((memoize memo_cat statBlock n), statBlock) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | head :: rest -> let result = f head in if result = None then find_map f rest else result | [] -> None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun elt acc -> let passed, failed = acc in if p elt then (elt :: passed, failed) else (passed, elt :: failed) ) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass = ref masterpass in let op_counter = ref 0 in let access_attempts = ref 0 in let acct_locked = ref false in  let verify_master (pwd : masterpass) = if !acct_locked then raise AccountLocked else if pwd = !ref_masterpass then ( access_attempts := 0; op_counter := !op_counter + 1; ) else ( access_attempts := !access_attempts + 1; if !access_attempts = 3 then acct_locked := true; raise WrongPassword ) in   let save master address password = ( verify_master master; ref_list := (address, encrypt master password) :: !ref_list ) in  let get_force master address = match List.find_opt (fun record -> fst record = address) !ref_list with | Some (_, pw) -> Some (decrypt master pw) | None -> None in  let get master address = ( verify_master master; get_force master address ) in  let count_ops master = ( verify_master master; !op_counter ) in  let update_master old_master new_master = ( (try verify_master old_master with AccountLocked -> if old_master = !ref_masterpass then ( op_counter := !op_counter + 1; access_attempts := 0; acct_locked := false; ) else raise WrongPassword );  ref_masterpass := new_master;  ref_list := List.map (fun record -> let addr, pw = record in (addr, encrypt new_master (decrypt old_master pw)) ) !ref_list;  ) in  { save; get_force; get; count_ops; update_master } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec sum (i : int) (f : int -> int) acc : int = if i < 0 then acc else sum (i - 1) f (acc + f i) in  let rec cat n = ( count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else sum (n - 1) (fun i -> (cat i) * cat (n - 1 - i)) 0 ) in  let result = cat n in let final_counter = !count_rec_calls in (result, final_counter) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let v = f f' x in ( Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v ) | Some v -> ( stats.lkp := !(stats.lkp) + 1; v ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec sum (i : int) (f : int -> int) acc : int = if i < 0 then acc else sum (i - 1) f (acc + f i) in  let cat n = ( if n = 0 then 1 else sum (n - 1) (fun i -> (recf i) * recf (n - 1 - i)) 0 ) in  cat n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0; } in let memoized = memoize memo_cat stats in (memoized n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let el = f x in if el = None then find_map f xs else el ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let decide x (pass, fail) = if p x then (x::pass, fail) else (pass, x::fail) in List.fold_right decide l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master_ref = ref masterpass in let good_counter = ref 0 in let bad_counter = ref 0 in  let check_master master = if !bad_counter = 3 then raise AccountLocked else if master = !master_ref then (good_counter := !good_counter + 1; bad_counter := 0) else (bad_counter := !bad_counter + 1; raise WrongPassword) in  let get_force = fun master -> fun add -> let get_passwd (address, passwd) = if add = address then Some (decrypt master passwd) else None in find_map get_passwd !ref_list in  { save = (fun master -> fun add -> fun passwd -> check_master master; ref_list := (add, encrypt master passwd)::!ref_list);  get_force = get_force;  get = (fun master -> check_master master; get_force master);  update_master = (fun master -> fun new_master -> bad_counter := min !bad_counter 2; check_master master; ref_list := List.map (fun (add, passwd) -> (add, encrypt new_master (decrypt master passwd))) !ref_list; master_ref := new_master);  count_ops = (fun master -> check_master master; !good_counter) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec cat n = count_rec_calls := !count_rec_calls + 1; if n=0 then 1 else let rec cat_inner i = if  i=n then 0 else cat i * cat (n-1-i) + cat_inner (i+1) in cat_inner 0 in let x = cat n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let v = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; v with Not_found -> stats.entries := !(stats.entries) + 1; let v = f f' x in Hashtbl.add hash x v; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let cat n = if n=0 then 1 else let rec cat_inner i = if  i=n then 0 else recf i * recf (n-1-i) + cat_inner (i+1) in cat_inner 0 in cat n ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0 } in let result = memoize memo_cat stats n in (result, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let outputtedValue = f h in match outputtedValue with | Some(v) -> Some(v) | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let listPassingElements = List.fold_right ( fun x a -> if p x then x :: a else a) l [] in let listFailingElements = List.fold_right ( fun x a -> if (not (p x)) then x :: a else a) l [] in (listPassingElements,listFailingElements) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let number_operations = ref 0 in let number_wrongPasswordsInputted = ref 0 in let masterpass_Reference = ref masterpass in  let checkValidity_MasterPassword local_masterpass = if !masterpass_Reference = local_masterpass then ( number_wrongPasswordsInputted := 0 ; number_operations := !number_operations + 1 ; true ) else ( number_wrongPasswordsInputted := !number_wrongPasswordsInputted ; raise WrongPassword ; false ) in  let checkIf_AccountLocked = if !number_wrongPasswordsInputted >= 3 then raise AccountLocked else () in  let saveHelperFunc local_masterpass address password = checkIf_AccountLocked ; if checkValidity_MasterPassword local_masterpass then ref_list := ( address , ( encrypt local_masterpass password ) ) :: !ref_list else () in  let get_forceHelperFunc local_masterpass address = find_map (fun (adrs,pword) -> if adrs = address then Some (decrypt local_masterpass pword) else None) !ref_list in let getHelperFunc local_masterpass address = checkIf_AccountLocked ; if checkValidity_MasterPassword local_masterpass then get_forceHelperFunc local_masterpass address else None in  let update_masterHelperFunc master_current_password new_password = if !number_wrongPasswordsInputted >= 3 then ( if not (master_current_password = !masterpass_Reference) then raise WrongPassword else (number_wrongPasswordsInputted := 0 ; masterpass_Reference := new_password ; ref_list := ( List.map (fun (adres,pword) -> (adres, encrypt new_password (decrypt master_current_password pword) ) )  !ref_list ) ) ) else () ; if checkValidity_MasterPassword master_current_password then ( masterpass_Reference := new_password ; ref_list := ( List.map (fun (adres,pword) -> (adres, encrypt new_password (decrypt master_current_password pword) ) )  !ref_list ) ) else () in  let count_opsHelperFunc local_masterpass = checkIf_AccountLocked ; if checkValidity_MasterPassword local_masterpass then (!number_operations) else 0 in   let recordToBeReturned = { save = saveHelperFunc; get_force = get_forceHelperFunc; get = getHelperFunc; update_master = update_masterHelperFunc; count_ops = count_opsHelperFunc } in (recordToBeReturned) ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalanHelper n = count_rec_calls := (!count_rec_calls + 1) ; if n = 0 then (1,1) else let rec auxHelper i n acc = if i > n then (acc, !count_rec_calls) else let ( cat_i_val , _ ) = catalanHelper i in let ( cat_nMinusi_val , _ ) = catalanHelper (n - i) in auxHelper (i + 1) n (acc + cat_i_val * cat_nMinusi_val) in auxHelper 0 (n - 1) 0 in catalanHelper n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if ( Hashtbl.mem hash x ) then ( stats.lkp := !(stats.lkp) + 1 ; Hashtbl.find hash x ) else let f_function_valComputed = f f' x in Hashtbl.add hash x f_function_valComputed; stats.entries:= !(stats.entries) + 1 ; f_function_valComputed in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let statsReference = { entries = ref 0; lkp = ref 0 } in let memoFunc = ( memoize ( memo_cat )  (statsReference) ) in ( memoFunc n, statsReference) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f(x) <> None then f(x) else find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let partition_helper (el: 'a) (acc: 'a list * 'a list) = if p el then let (t,f) = acc in (el::t, f) else let (t,f) = acc in (t, el::f) in List.fold_right partition_helper l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let masterpass : masterpass ref = ref masterpass in let ops : int ref = ref 0 in let fattempts : int ref = ref 0 in let acclock : bool ref = ref false in let ref_list : (address * password) list ref = ref [] in let mpcheck (mp : masterpass) : bool = if mp = !masterpass then (ops := !ops + 1; fattempts := 0 ; true) else (fattempts := !fattempts + 1; (if !fattempts >= 3 then acclock := true); raise WrongPassword) in  let save = (fun (mp: masterpass) (add : address) (pass : password) -> if !acclock then raise AccountLocked else if mpcheck mp then ref_list := (add, (encrypt mp pass))::!ref_list ) in  let get_force = (fun (mp : masterpass) (add : address) : password option -> find_map (fun (a: address * password) -> let (x,pass) = a in if x = add then Some(decrypt mp pass) else None) !ref_list) in  let get = (fun (mp : masterpass) (add : address) : password option -> if !acclock then raise AccountLocked else if mpcheck mp then (get_force mp add) else None ) in  let update_master = (fun (oldmp : masterpass) (newmp : masterpass) -> if mpcheck oldmp then ( masterpass := newmp; acclock := false; ref_list := (List.map (fun (a : address * password) -> let (add, pass) = a in (add, (encrypt newmp (decrypt oldmp pass)))) !ref_list))  ) in  let count_ops = (fun (mp : masterpass) -> if !acclock then raise AccountLocked else if mpcheck mp then !ops else raise WrongPassword ) in { save; get_force; get; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_aux n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan_aux i * catalan_aux (n-i)) in aux 0 (n-1) 0 in let x = catalan_aux n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let y = (Hashtbl.find_opt hash x) in if y <> None then let Some el = y in (stats.lkp := !(stats.lkp) + 1; el) else (stats.entries := !(stats.entries) + 1; Hashtbl.add hash x (f f' x); Hashtbl.find hash x ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let statsrec = {entries = ref 0; lkp = ref 0} in ((memoize (memo_cat) statsrec n), statsrec) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option =   match l with | []->None |x::xs -> let v = f (x) in match v with |None ->find_map (f) (xs) |Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun  x (left,right) -> match p (x) with |true -> (x::left,right) |false-> (left,x::right)) (l) (([],[]))  ; ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpassword =ref masterpass in let counter = ref 0 in let wrongcounter = ref 0 in let wrongchecker = fun ()-> if !wrongcounter>2 then raise AccountLocked in let rec updatevalues list newpassword = match list with |[]->[] |(address,pass)::xs->( address, encrypt (newpassword) (decrypt (!masterpassword) (pass))):: updatevalues (xs) (newpassword)  in  let save =(fun master address pass ->wrongchecker(); if master =  (!masterpassword) then (ref_list:= (address,encrypt (master) (pass)) :: !ref_list; counter:= !counter+1; wrongcounter:=0; ) else (    wrongcounter:=!wrongcounter+1 ;raise WrongPassword; ) ) in let get_force= (fun master address -> (find_map (fun (addre,pass)->if addre = address then  (Some (decrypt (master)(pass)) ) else (None)) (!ref_list)) ) in let get = (fun master address -> wrongchecker(); if master = !masterpassword then (counter:=!counter+1;wrongcounter:=0; get_force (master) (address)) else (wrongcounter:=!wrongcounter+1; raise WrongPassword; )) in let update_master = (fun currpass newpassword->  if currpass = !masterpassword then ( ref_list:=updatevalues (!ref_list) (newpassword); masterpassword:=newpassword; counter:=!counter+1;  wrongcounter:=0; ) else (wrongcounter:=!wrongcounter+1;raise WrongPassword;) ) in let count_ops = (fun master -> wrongchecker(); if master = !masterpassword then (counter:= !counter +1 ; wrongcounter:=0; !counter) else (wrongcounter:=!wrongcounter+1;raise WrongPassword;)   ) in   { save=save; get_force= get_force; get=get; update_master=update_master; count_ops = count_ops;  }   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let getNum(a,b)=a in  let rec catalan n = count_rec_calls:=!count_rec_calls+1; if n = 0 then (1,!count_rec_calls ) else let rec aux i n acc =  if i > n then (acc,!count_rec_calls) else aux (i + 1) n (acc + getNum(catalan i) * getNum(catalan (n - i))) in aux 0 (n-1) 0 in catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = let finded = Hashtbl.find_opt (hash) (x) in  if finded = None then (Hashtbl.add (hash) (x) (f f' x ); stats.entries:=!(stats.entries)+1;Hashtbl.find (hash) (x) ) else ( stats.lkp:=!(stats.lkp)+1; Hashtbl.find (hash) (x))  in  f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[]-> None |_-> let (el::lst) = l in match f(el) with |Some x-> Some x |None-> find_map f lst ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let list1 =List.fold_right (fun x a -> if p x then x :: a else a) l [] in let list2 =List.fold_right(fun x a-> if p x then a else x::a) l [] in list1,list2 ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let mp = ref masterpass in let op_counter = ref 0 in let wrong_counter = ref 0 in let temp_list = ref !ref_list in let check_master (masterpass): bool = if masterpass = !mp then (wrong_counter:= 0; op_counter := !op_counter + 1; true) else (wrong_counter:= !wrong_counter + 1; false) in let save (masterpass:masterpass)(address:address)(password:password) = if check_master (masterpass) then ref_list := ((address, encrypt(masterpass)(password))::!ref_list) else if !wrong_counter = 3 then raise AccountLocked else raise WrongPassword in let get_force (masterpass:masterpass)(address:address) = let rec address_lst (l)  = match l with |[]->[] |[(x,y)]->[x] |(x,y)::lst-> (x::(address_lst (lst))) in match l with |[]->None |[(a,p)]   -> if a = address then Some p else None |(a,p)::ls -> if a = address then Some p else helper address l in match find_map (fun address->helper(address)(!ref_list))(address_lst(!ref_list)) with |Some x -> let y = decrypt(masterpass)(x) in Some y |None-> None in let get (masterpass:masterpass) (address:address) = if check_master (masterpass) then get_force(masterpass)(address) else if !wrong_counter = 3 then raise AccountLocked else raise WrongPassword in let update_master (masterpass:masterpass)(new_master:masterpass) = if check_master (masterpass) then let rec update_ref (l) = match l with |[]->[] |[(x,y)]->let d =  decrypt(masterpass)(y) in [(x,encrypt(new_master)(d))] |(x,y)::lst-> let d =  decrypt(masterpass)(y) in ((x,encrypt(new_master)(d))::update_ref(l)) in ref_list := update_ref(!ref_list); mp:= new_master else if !wrong_counter = 3 then raise AccountLocked else raise WrongPassword in let count_ops (masterpass) = if check_master (masterpass) then !op_counter else if !wrong_counter = 3 then raise AccountLocked else raise WrongPassword in let passmang = {save; get_force; get; update_master; count_ops} in passmang ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let x = count_rec_calls in let rec cat n = (x:= 1+ !x; if n = 0 then  (1,!x) else let rec interm i n acc  = if i > n then (acc,!x) else let (acc1,_) = cat (i)in let (acc2,_) = cat (n-i)in interm (i+1)(n)(acc + acc1 * acc2) in interm 0 (n-1) 0) in cat n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let result = Hashtbl.find_opt hash x in let lkp = stats.lkp in let entries = stats.entries in match result with |None -> let result = f (f') x in stats.entries := !entries + 1; Hashtbl.add hash x result; result |Some x -> (stats.lkp := !lkp + 1; x) in let entries = stats.entries in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n ( acc + recf(i) * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0;lkp = ref 0} in let f  = memoize memo_cat stats in f n, stats ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | []->None |h::t->let ans = f h in match ans with |None -> find_map f t |Some _ -> ans ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f e (pass,fail)= let ans = p e in match ans with |true -> (e::pass,fail) |false-> (pass,e::fail) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let attempt = ref 0 in let s_called=ref 0 in let mp= ref masterpass in let check_correct (p:masterpass):bool = let ans = (!mp = p) in match ans with |true->  attempt := 0; s_called := !s_called+1;ans |false-> attempt := !attempt+1; raise WrongPassword in  let save=(fun (mpass:masterpass) (ad:address)(passwd:password) -> if (check_correct mpass) then let (newpass:password) =encrypt mpass passwd in let pair =(ad,newpass) in ref_list:= (pair::!ref_list); else if(!attempt>=3) then raise AccountLocked) in  let get_force=(fun(mpass:masterpass)(ad:address)-> find_map(fun ((a,p):(address*password)) ->if a= ad then let (p_1:password)= decrypt mpass p in Some p_1 else None) !ref_list ) in  let get=(fun(mpass:masterpass)(ad:address)-> if (check_correct mpass) then (get_force mpass ad) else if(!attempt>=3) then raise AccountLocked else None) in  let update_master=(fun (c_mpass:masterpass)(n_mpass:masterpass)-> if (check_correct c_mpass) then (mp := n_mpass; let change=(fun ((a,l_p):(address*password)) -> let (b:password)=  decrypt c_mpass l_p in let (c:password)=encrypt n_mpass b in (a,c)) in ref_list:= (List.map change !ref_list)) else if(!attempt>=3) then raise AccountLocked) in  let count_ops =fun(mpass:masterpass)-> if check_correct(mpass) then !s_called else if(!attempt>=3) then raise AccountLocked else !s_called in  {save=save; get_force=get_force; get=get; update_master=update_master; count_ops=count_ops }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 1 in let rec catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else let update count_rec_calls = count_rec_calls:= !count_rec_calls +2 in update count_rec_calls; aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let v =catalan n in (v,!count_rec_calls) ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let ans = Hashtbl.find_opt hash x in match ans with | Some s->  stats.lkp := !(stats.lkp)+1;s | None -> let value = (f f') x in Hashtbl.replace hash x value; stats.entries := !(stats.entries)+1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec sum_sigma f i = match i with | 0 -> f 0 | i -> f i + sum_sigma f (i - 1) in match n with |0 ->1 |_-> sum_sigma (fun i -> recf i * recf (n - 1 - i)) (n - 1) ;; ",
  "let catalan_m (n : int) : int * stats = let stats={ entries=ref 0 ; lkp=ref 0 ; } in let memocall = memoize memo_cat stats  in let z= memocall n in (z,stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | x :: xl -> if (f x) = None then find_map f xl else (f x) | [] -> None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f x (l1,l2) = if (p x) then (x :: l1,l2) else (l1,x :: l2) in List.fold_right f l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let error_count = ref 0 in let masterpass = ref masterpass in let success_count = ref 0 in { save = (fun mp add lp -> if !error_count >= 3 then raise AccountLocked else if !masterpass <> mp then (error_count := !error_count + 1; raise WrongPassword) else (success_count := !success_count + 1; ref_list := (add,encrypt mp lp) :: !ref_list; error_count := 0)) ; get_force = (fun mp add -> let f = fun (address,password) -> if address = add then Some (decrypt mp password) else None in find_map f !ref_list); get = (fun mp add -> if !error_count >= 3 then raise AccountLocked else if !masterpass <> mp then (error_count := !error_count + 1; raise WrongPassword) else (error_count := 0; success_count := !success_count + 1; (let f = fun (address,password) -> if address = add then Some (decrypt mp password) else None in find_map f !ref_list))); update_master = (fun odd_mp new_mp -> let rec update odd_mp new_mp l = match l with | [] -> [] | (add,lp) :: xl -> (add, encrypt new_mp (decrypt odd_mp lp)) :: update odd_mp new_mp xl in if !masterpass <> odd_mp then (error_count := !error_count + 1; raise WrongPassword) else (masterpass := new_mp; error_count := 0; success_count := !success_count + 1; ref_list := update odd_mp new_mp !ref_list)); count_ops = (fun mp -> if !error_count >= 3 then raise AccountLocked else if !masterpass <> mp then (error_count := !error_count + 1; raise WrongPassword) else (error_count := 0; success_count := !success_count + 1; !success_count))   } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_helper n = count_rec_calls := !count_rec_calls + 1; print_string (string_of_int n) ; if n = 0 then 1 else let rec catalan_sum n i acc = if i = (n - 1) then ((catalan_helper i) * (catalan_helper (n-1-i)) + acc) else catalan_sum n (i+1) ((catalan_helper i) * (catalan_helper (n-1-i)) + acc) in catalan_sum n 0 0  in let acc = catalan_helper n in (acc, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; value with Not_found -> let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec memo_cat_helper n j acc = if n = j then acc else (print_string \"1\"; memo_cat_helper n (j+1) (acc + (recf j) * (recf (n-1-j)))) in memo_cat_helper n 0 0 ;; ",
  "let catalan_m (n : int) : int * stats = let create_stats () = {entries = ref 0; lkp = ref 0} in let stats1 =  ref (create_stats ()) in let value = memoize memo_cat !stats1 n in (value,!stats1) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map' (f : 'a -> 'b option) (l : 'a list) acc: 'b option = match l with |h::t -> let acc= f h in if acc <> None then acc else find_map' f t acc |[] -> None in if l=[] then None else find_map' f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let rec partition'  (l : 'a list) (acc, acc2 : 'a list * 'a list): ('a list * 'a list)= match l with |[]-> (acc,acc2) |h::t-> if p h then partition' t ((acc@h::[]), acc2) else partition' t (acc, (acc2@h::[])) in if l=[] then ([], []) else List.fold_right partition' (l::[]) ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpassword= ref masterpass in let numberofop = ref 0 in let wrongattempts = ref 0 in let increment() = numberofop := !numberofop + 1 in let passcheck (mp:masterpass)= if !wrongattempts = 3 then raise AccountLocked else if mp = !masterpassword then (increment(); (wrongattempts := 0) ) else ((increment());(wrongattempts := !wrongattempts + 1); raise WrongPassword) in   let save (mp: masterpass) (address: address) (password: password):unit= passcheck mp; (ref_list := (address, encrypt mp password)::!ref_list)  in   let get_force (masterp: masterpass) (address: address): password option = let f ((ad, pass): address*password):password option= if ad=address then Some (decrypt masterp pass)  else None in find_map f !ref_list in  let get (masterpassw: masterpass) (address: address): password option = passcheck masterpassw; (get_force masterpassw address)  in  let update_master (masterpass: masterpass) (newpass: masterpass): unit = if masterpass= !masterpassword then ((wrongattempts := 0); let update (address, password) = (address,encrypt newpass (decrypt masterpass password)) in ((ref_list := List.map update !ref_list)); (increment(); masterpassword := newpass)) else raise WrongPassword in   let count_ops (masterpass: masterpass): int = passcheck masterpass; !numberofop in {save;get_force;get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan' n = (count_rec_calls := !count_rec_calls + 1); if n = 0 then (1, 1) else let rec aux i n acc = if i > n then (acc, !count_rec_calls) else let (a,_) = catalan' i in let (c,_) = catalan' (n-i) in aux (i + 1) n (acc + a * c) in aux 0 (n-1) 0 in catalan' n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let result = Hashtbl.find hash x in (stats.lkp := !(stats.lkp) + 1); result; with Not_found -> let v = f f' x in Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let rec memo_cat' x n acc = if x > n then acc else memo_cat' (x+1) n (acc + (recf x * recf (n-x))) in if n=0 then 1 else memo_cat' 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let x = ref {entries = ref 0; lkp = ref 0} in let final = memoize memo_cat !x n, !x in final ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h :: t -> if (f h) = None then find_map (f) (t) else (f h)  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let f elem (trues, falses) = if p elem then (elem::trues, falses) else (trues, elem::falses) in List.fold_right f l ([] , []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let success = ref 0 in let curr_master = ref masterpass in let helper (add: address) (tuple: (address * password)): password option= let (x,y) = tuple in if add = x then Some y else None in let update_helper (old_master: masterpass) (new_master: masterpass)(tuple: (address * password)) : (address * password) = let (add, pass) = tuple in let decrypted = decrypt old_master pass in let encrypted = encrypt new_master decrypted in (add, encrypted) in   let save master add pass = if !counter >= 3 then raise AccountLocked else if master = !curr_master then begin ref_list := ((add, encrypt (master) (pass)) :: !ref_list); counter :=0; success := !success + 1 end else begin counter := !counter +1; raise WrongPassword end in  let get_force master add = let password = find_map (helper add) !ref_list in match password with | None -> begin  counter := 0; None end | Some v -> begin counter := 0; Some (decrypt master v) end in  let get master add = let mass = !curr_master in if !counter >= 3 then raise AccountLocked else if master = mass then begin success := !success + 1; counter := 0; get_force (master) (add) end else begin counter := !counter +1; raise WrongPassword end in  let update_master old_mass new_mass = let copy_list = !ref_list in let mass = !curr_master in if old_mass = mass then let list = List.map (update_helper old_mass new_mass) copy_list in begin success := !success +1; counter := 0; ref_list := list; curr_master := new_mass end else begin counter := !counter + 1; raise WrongPassword end  in  let count_ops mass = let curr = !curr_master in if !counter >= 3 then raise AccountLocked else if mass = curr then begin success := !success + 1; counter := 0; !success end else begin counter := !counter +1; raise WrongPassword end  in {save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops;}    ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; match n with |0 -> 1 |n -> let rec aux i n acc= if i > n then acc else aux (i+1) n (acc + catalan i * catalan (n-i)) in aux 0 (n-1) 0 in let (calls, result) = (!count_rec_calls, catalan n) in (result, calls)    ;; ",
  " let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let b = f f' x in incr stats.entries; Hashtbl.add hash x b; b  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec f i n acc = if i > n then acc else f (i+1) n (acc + recf i * recf(n-i)) in f 0 (n-1) 0    ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = { entries = ref 0; lkp = ref 0 } in let f = memoize memo_cat new_stats in (f n, new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match (f x) with | None -> find_map f xs | Some _ as result -> result   ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =    match l with | [] -> ([],[]) | x::xs ->  let part x (yes, no) = if p x then (x :: yes, no) else (yes, x :: no) in List.fold_right part l ([],[])   ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let ref_mapa = ref masterpass in let correct_op = ref 0 in let wrong_op = ref 0 in  let check_pw (pw : password) : bool = if (!wrong_op < 3) then( if (pw = !ref_mapa) then (incr correct_op; wrong_op := 0;true) else (incr wrong_op; raise WrongPassword) ) else raise AccountLocked in  let save mapa ad cur_pw = if check_pw mapa then let en_pw = encrypt mapa cur_pw in ref_list := (ad,en_pw) :: !ref_list;  in  let get_force mapa ad = find_map (fun (a,p) -> if a = ad then Some (decrypt mapa p) else None) !ref_list in   let get mapa ad = if check_pw mapa then (get_force mapa ad) else None in   let update_master cur_mapa new_pw = try if check_pw cur_mapa then (ref_mapa := new_pw; ref_list := List.map(fun (a,p) ->(a, encrypt new_pw (decrypt cur_mapa p))) !ref_list )  with AccountLocked -> if (cur_mapa = !ref_mapa) then ( incr correct_op; wrong_op := 0; ref_mapa := new_pw; ref_list := List.map(fun (a,p) ->(a, encrypt new_pw (decrypt cur_mapa p))) !ref_list ) else (incr wrong_op;raise WrongPassword)   in  let count_ops mapa = if check_pw mapa then !correct_op else 0   in {save=save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops}     ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec comp_catalan n = count_rec_calls := !count_rec_calls +1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + comp_catalan i * comp_catalan (n - i)) in aux 0 (n-1) 0 in let v = comp_catalan n in (v,!count_rec_calls)  ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some value -> stats.lkp := !(stats.lkp) + 1; value | None -> let result = f (f') x in Hashtbl.add hash x result; stats.entries := !(stats.entries) + 1; result  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + (recf i) * (recf (n - i))) in aux 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats =   let s = { entries = ref 0; lkp = ref 0 } in let result = memoize memo_cat s n in (result,s)     ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | Some v -> f x | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun e (acc1, acc2) -> if p e then (e :: acc1, acc2) else (acc1, e :: acc2)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let masterpass :masterpass ref = ref masterpass in let cnt_success : int ref = ref 0 in let cnt_wrong : int ref = ref 0 in let locked: bool ref = ref false in let is_correct mp = if !masterpass = mp then let _ = cnt_success := !cnt_success + 1 in let _ = cnt_wrong := 0 in true else let _ = cnt_wrong := !cnt_wrong + 1 in let _ = if !cnt_wrong >= 3 then locked := true in raise WrongPassword in let save mp addr pass = if !locked then raise AccountLocked else if is_correct mp then ref_list := (addr, encrypt mp pass) :: !ref_list in let get_force mp addr = let map (a, p) = if a = addr then Some p else None in match find_map map !ref_list with | None -> None | Some ps -> Some (decrypt mp ps) in let get mp addr = if !locked then raise AccountLocked else if is_correct mp then get_force mp addr else raise WrongPassword in let update_master mp new_mp = if is_correct mp then let _ = masterpass := new_mp in let change_pass = fun (addr, pass) -> (addr, encrypt new_mp (decrypt mp pass)) in ref_list := List.map change_pass !ref_list in let count_ops mp = if is_correct mp then !cnt_success else raise WrongPassword in {save; get_force; get; update_master; count_ops}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = let _ = incr count_rec_calls in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let res = catalan n in (res, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> Hashtbl.add hash x (f f' x); incr stats.entries; Hashtbl.find hash x | _ -> incr stats.lkp; Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0  ;; ",
  "let catalan_m (n : int) : int * stats = let stats: stats = {entries = ref 0; lkp = ref 0} in let res = (memoize memo_cat stats) n in (res, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with |[] -> None; |hd::l -> let cool = f hd in match cool with |None -> find_map f l |_ -> cool   ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right(fun hd tail -> if p hd then hd::tail else tail) l [], List.fold_right (fun hd tail -> if p hd then tail else hd::tail) l [] ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list = ref [] in let ref_counter = ref 0 in let ref_getwrongs = ref 0 in let ref_masterpass = ref masterpass in let check_masterpass to_check = let pass_check = ref false in if !ref_getwrongs=3 then raise AccountLocked else (if !ref_masterpass=to_check then (ref_getwrongs:=0; pass_check:=true; ref_counter:=!ref_counter+1) else (ref_getwrongs:=!ref_getwrongs+1; raise WrongPassword)); !pass_check in  let cool_save = fun cool1 wow1 pass1 -> if check_masterpass cool1 then ref_list:=!ref_list@[(wow1, encrypt cool1 pass1)]; in   let cool_get_force = fun cool2 wow2 -> find_map (fun addpass -> let (my_add,my_pass) = addpass in if wow2=my_add then Some (decrypt cool2 my_pass) else None) !ref_list in  let cool_get = fun cool3 wow3 -> if check_masterpass cool3 then cool_get_force cool3 wow3 else None in let cool_update_master = fun old_pass newpass -> if check_masterpass old_pass then ref_list:= (List.map (fun this1 -> let (my_add2, my_pass2)= this1 in (my_add2, encrypt newpass my_pass2)) (List.map (fun this2 -> let (my_add3, my_pass3)= this2 in (my_add3, decrypt old_pass my_pass3)) !ref_list ) ); ref_masterpass:=newpass in let cool_count_ops = fun masterpass -> if check_masterpass masterpass then !ref_counter else 0 in { save = cool_save; get_force = cool_get_force; get = cool_get; update_master = cool_update_master; count_ops = cool_count_ops }   ;; ",
  " let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls+1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let cool = catalan n in(cool,!count_rec_calls)  let memoize f s = let hash = Hashtbl.create 1000 in let rec test = fun x -> if not (Hashtbl.mem hash x) then (let to_insert = f test x in s.entries:=!(s.entries)+1; Hashtbl.add hash x to_insert; to_insert) else (s.lkp:=!(s.lkp)+1; Hashtbl.find hash x) in test;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m n = let newstats = {lkp=ref 0;entries=ref 0} in let answer = (memoize memo_cat newstats) n in (answer, newstats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> if f x = None then find_map f xs else f x ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let compare = fun x (l1,l2) -> if p x then (x::l1,l2) else (l1,x::l2) in List.fold_right compare l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let wrong = ref 0 in let counter = ref 0 in let master = ref masterpass in let check_master = fun master1 -> if !wrong > 2 then raise AccountLocked else ( if master1 = !master then (counter:= !counter+1  ; wrong:= 0) else (wrong:= !wrong+1 ; raise WrongPassword) ) in let save1 = fun master1 address local -> check_master master1; ref_list := (address,encrypt master1 local)::!ref_list in let force1 = (fun master1 address -> find_map (fun (x,y) -> if address = x then Some (decrypt master1 y) else None) !ref_list) in let get1 = fun master1 address -> check_master master1; force1 master1 address in let update1 = fun master1 newmaster-> check_master master1; let tmp = ref [] in find_map (fun (x,y) -> tmp:= (x,encrypt newmaster (decrypt !master y))::!tmp ; None) !ref_list; ref_list := !tmp ; master:= newmaster in let count1 = fun master1 -> check_master master1 ; !counter in {save = save1;get_force=force1;get=get1;update_master=update1;count_ops=count1 } ;; ",
  "let rec catalan_count (n : int) : (int * int) = if n = 0 then (1,1) else let count_rec_calls = ref 1 in let rec loop i n acc calls = if i > n then (acc,calls) else let (a,b) = catalan_count i in let (c,d) = catalan_count (n - i) in calls := !calls + b +d; loop (i + 1) n (acc + a * c) (calls) in let (x,y) = loop 0 (n-1) 0 count_rec_calls in (x,!count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try Hashtbl.find hash x ; stats.lkp:= 1+ !(stats.lkp);Hashtbl.find hash x   with Not_found -> let a = f f' x in Hashtbl.add hash x a; stats.entries:= 1+ !(stats.entries); a in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n=0 then 1 else let rec loop i j acc = if i > j then acc else loop (i+1) j (acc + (recf i)*(recf (j-i))) in loop 0 (n-1) 0; ;; ",
  "let catalan_m (n : int) : int * stats = let stat = {entries=ref 0; lkp = ref 0} in let mem = memoize memo_cat stat in let mem_n = mem n in (mem_n,stat)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let result = f h in match result with | Some v -> Some v | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun element (l1,l2) -> if p element then (element::l1,l2) else (l1,element::l2)) l ([],[]);; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master_pass : string ref = ref masterpass in let succ_calls: int ref = ref 0 in let fail_calls: int ref = ref 0 in  let verify_pass (mpass : masterpass) = if !master_pass = mpass then begin succ_calls := !succ_calls + 1; fail_calls := 0; end else begin fail_calls := !fail_calls + 1; if !fail_calls = 3 then raise AccountLocked else raise WrongPassword end in  let save (mpass : masterpass) (add : address) (pass: password) = verify_pass (mpass); let enc_pass = encrypt mpass pass in ref_list := (add, enc_pass) :: !ref_list; in  let get_force (mpass : masterpass) (add : address) = let find_address ((currAdd, pass) : address * password) = if add = currAdd then Some (currAdd, pass) else None in match find_map find_address !ref_list with | Some (add, pass) -> Some (decrypt mpass pass) | None -> None in  let get (mpass : masterpass) (add : address) = verify_pass mpass; get_force mpass add in  let update_master (oldMpass : masterpass) (newMpass : masterpass) = verify_pass oldMpass; master_pass := newMpass; let rec update_reflist l nl opass npass = match l with | [] -> nl | (add, lpass)::t -> let nlpass = encrypt npass (decrypt opass lpass) in nl := (add, nlpass)::!nl; update_reflist t nl opass npass; in let new_ref_list = update_reflist !ref_list (ref []) oldMpass newMpass in ref_list := !new_ref_list in  let count_ops (mpass : masterpass) = verify_pass mpass; !succ_calls in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in  let rec cat num = count_rec_calls := !count_rec_calls + 1; if num = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + cat i * cat (n - i)) in aux 0 (num-1) 0 in  let cat_num = cat n in (cat_num, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> stats.lkp := !(stats.lkp) + 1; v; | None -> let v  = f (f') (x) in Hashtbl.add hash x v; stats.entries := !(stats.entries) + 1; v; in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let new_stats = {entries = ref 0; lkp = ref 0} in let func = memoize memo_cat new_stats in let v = func n in (v, new_stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> ( match f x with | Some v -> Some v | None -> find_map f xs )  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let f ele (a, b) = if p ele then(ele::a, b) else (a, ele::b) in List.fold_right f l ([],[])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let count = ref 0 in let wrong_attempts = ref 0 in let masterpass_ref = ref masterpass in let password_matches pass_given = if!wrong_attempts >= 3 then raise AccountLocked else if (pass_given = !masterpass_ref) then begin wrong_attempts := 0; count:= !count + 1; true end else begin wrong_attempts:= !wrong_attempts + 1; raise WrongPassword; false end in  let save mp_given address password = if password_matches mp_given then let pass_encrypt = encrypt mp_given password in ref_list := (address,pass_encrypt)::ref_list.contents in  let get_force mp_given add_given = let pass_map ref_tuple = let (address,password) = ref_tuple  in if address = add_given then Some password else None  in match find_map pass_map !ref_list with | Some v -> let v = decrypt mp_given v in Some v in  let get mp_given add_given = if password_matches mp_given then get_force mp_given add_given in  let update_master curr_mp new_mp =  let new_ref_list : (address * password) list ref = ref [] in  let rec update_encryption ref_list new_ref_list = match ref_list with | [] -> [] | h::t -> ( let (address,password) = h  in new_ref_list := (address, encrypt new_mp (decrypt curr_mp password)) ::new_ref_list.contents) ; update_encryption t new_ref_list  in  if try password_matches curr_mp with AccountLocked -> if (curr_mp = !masterpass_ref) then begin wrong_attempts := 0; true end else raise WrongPassword  then begin masterpass_ref := new_mp; update_encryption !ref_list new_ref_list else ()  in  let count_ops mp_given  = if password_matches mp_given then !count else !count  in  { save;get_force;get;update_master;count_ops }   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in   let rec aux2 n = if n = 0 then begin count_rec_calls := !count_rec_calls + 1; 1 end  else begin count_rec_calls := !count_rec_calls + 1; let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + aux2 i * aux2 (n-i))  in (aux 0 (n-1) 0) end  in let v = aux2 n in (v ,!count_rec_calls)   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x =  if Hashtbl.mem hash x then begin stats.lkp := !(stats.lkp) + 1; Hashtbl.find hash x end else begin let y = f f' x in stats.entries := !(stats.entries) + 1; Hashtbl.add hash x (y); y end in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int =  if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n- i)) in aux 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats = let s1:stats = {entries = ref 0; lkp = ref 0} in  let f = memoize memo_cat s1 in  let res = f n in  (res, s1)   ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let check_true (lis: 'a list) (el: 'a) : 'a list = if (p el) then el::lis else lis in let check_false (lis: 'a list) (el: 'a) : 'a list = if not (p el) then el::lis else lis in let one = List.fold_right (fun el acc -> check_true acc el) l [] in let zero = List.fold_right (fun el acc -> check_false acc el) l [] in (one, zero) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let cnt_ops = ref 0 in let currmaster = ref masterpass in let lock_cnt = ref 0 in  let verify_master (currmasterpass: masterpass) : bool = !currmaster = currmasterpass in  let ref_list : (address * password) list ref = ref [] in  let save (currmasterpass: masterpass) (address: address) (pass: password) = if !lock_cnt >= 3 then raise AccountLocked else if verify_master currmasterpass then (ref_list := (address, (encrypt !currmaster pass))::(!ref_list); cnt_ops := !cnt_ops + 1; lock_cnt := 0) else (lock_cnt := !lock_cnt + 1; raise WrongPassword) in  let get_force (currmasterpass: masterpass) (address: address): password option = let check pair = let (ad, pass) = pair in if ad = address then Some (decrypt currmasterpass pass) else None in find_map check !ref_list in  let get (currmasterpass: masterpass) (address: address): password option = if !lock_cnt >= 3 then raise AccountLocked else if verify_master currmasterpass then (cnt_ops := !cnt_ops + 1; lock_cnt := 0; get_force currmasterpass address) else (lock_cnt := !lock_cnt + 1; raise WrongPassword) in  let update_master (currmasterpass: masterpass) (newmasterpass: masterpass) = if verify_master currmasterpass then (currmaster := newmasterpass; let build (ad, oldpass) = let decrypted = decrypt currmasterpass oldpass in let encrypted = encrypt newmasterpass decrypted in (ad, encrypted) in let rec update_helper lis acc = match lis with | [] -> acc | x::xs -> update_helper xs (acc@[build x]) in ref_list := update_helper !ref_list []; cnt_ops := !cnt_ops + 1; lock_cnt := 0) else (lock_cnt := !lock_cnt + 1; raise WrongPassword) in  let count_ops (currmasterpass: masterpass) : int = if !lock_cnt >= 3 then raise AccountLocked else if verify_master currmasterpass then (lock_cnt := 0; cnt_ops := !cnt_ops + 1; !cnt_ops) else (lock_cnt := !lock_cnt + 1; raise WrongPassword) in  let manager: pass_manager = { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops }  in manager ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i *  catalan (n - i)) in aux 0 (n-1) 0 in let x = catalan n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let {lkp = lk} = stats in let {entries = entrie} = stats in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> (lk := !lk + 1; v) | None -> let y = f f' x in Hashtbl.add hash x y; entrie := !entrie + 1; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stat = { entries = ref 0; lkp = ref 0 } in let f = memoize memo_cat stat n in (f, stat) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec apply f l acc = match l with | [] -> acc | v :: t -> if f v = None then apply f t None else f v in apply f l None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) =  let f x (t, f) = if p x then (x::t, f) else (t, x::f) in List.fold_right f l ([] ,[]) ;; ",
  " let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in  let ref_mp = ref masterpass in  let success = ref 0 in let failure = ref 0 in  let helper = fun master -> if !failure <= 3 then if master = !ref_mp then function() -> success:= !success + 1; failure := 0; () else function() -> failure := !failure + 1; raise WrongPassword else raise AccountLocked in { save = ( fun masterp address pass -> helper masterp (); let newmp = encrypt !ref_mp pass in ref_list := !ref_list @ [ (address, newmp)]; () ) ; get_force = (fun masterp address -> let aux add = let (x,y) = add in if x <> address then None else Some (decrypt masterp y) in find_map aux !ref_list ) ; get = (fun masterp add -> helper masterp (); let get_force = fun masterp address -> let aux add = let (x,y) = add in if x <> address then None else Some (decrypt masterp y) in find_map aux !ref_list in get_force masterp add ) ; update_master = (fun oldm newm -> helper oldm (); ref_mp := newm;  let tmp = ref [] in let aux = function x -> let (m,n)=x in tmp := !tmp @ [(m,encrypt newm (decrypt oldm n))] in List.map aux !ref_list; ref_list := !tmp; () ) ; count_ops = (function mp -> helper mp (); !success ) }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls:= !count_rec_calls + 1; match n with |0->1 |n-> let rec aux i n acc = if i>n then acc else aux (i+1) n (acc + catalan i * catalan (n-i) ) in aux 0 (n-1) 0 in let result = catalan n in (result,!count_rec_calls)   ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : ('a -> 'b) = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with |Some v -> incr stats.lkp; v |None -> let y = f f' x in incr stats.entries; (Hashtbl.add hash x y;y) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n=0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let cat_stats = {entries=ref 0; lkp= ref 0} in let memo = memoize memo_cat cat_stats in let result = memo n in (result, cat_stats)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find_map_aux list = match list with | [] -> None | x :: xs -> match f x with | None -> find_map_aux xs | Some _  -> f x in find_map_aux l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let bool_aux element (list_true,list_false)= if not (p element) then (list_true,element::list_false) else (element :: list_true, list_false)  in List.fold_right bool_aux l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =   let ref_list : (address * password) list ref = ref [] in let master_ref = ref masterpass in let count=ref 0 in let correct_pass = ref 0 in let make_manager_aux master = if master = !master_ref then( correct_pass := !correct_pass+1; count :=0) else( if !count < 3 then (raise WrongPassword;count := !count+1) else raise AccountLocked ) in  let save master add pass = make_manager_aux master  ; ref_list := (add,encrypt master pass) ::!ref_list  in  let get_force master add= let helper (x,y)  = let (a,b) = (x, y)  in (if a != add then None else Some (decrypt master b)) in find_map (helper) !ref_list in  let get master add = make_manager_aux master  ; get_force master add in  let update_master master_cur master_new = make_manager_aux master_cur ; let helper1 (x,y)=  (let decr = decrypt master_cur y in (x,encrypt master_new decr)) in List.map (helper1) !ref_list; master_ref := master_new;  in  let count_ops master= make_manager_aux master ; !correct_pass in   {save;get_force;get;update_master;count_ops}         ;; ",
  "let catalan_count (n : int) : (int * int) =  let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := 1 + !count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in match n with | 0 -> (1,1) | _ -> (let temp = catalan n in (temp, !count_rec_calls)) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if (Hashtbl.find_opt hash x) = None then let temp = f f' x in stats.entries := 1 + !(stats.entries); Hashtbl.add hash x temp; let Some temp= Hashtbl.find_opt hash x in temp else let Some some = Hashtbl.find_opt hash x  in stats.lkp := 1+ !(stats.lkp); some  in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = match n with | 0 -> 1 | _ -> let rec helper n i acc = if i>n then acc else helper n (i+1) (acc + recf(n-i)*recf(i)) in helper (n-1) 0 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats_ref = { lkp = ref 0; entries = ref 0;} in let catalan_no = memoize memo_cat stats_ref n in (catalan_no, stats_ref)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> (match (f h) with | None -> find_map f t | Some v -> Some v);; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun a (l1, l2) -> if p a then (a::l1, l2) else (l1, a::l2)) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let master_pass = ref masterpass in let pass_list : (address * password) list ref = ref [] in let incorrect_attempts = ref 0 in let num_ops = ref 0 in let check_pass (mp : masterpass) : unit = if !incorrect_attempts > 3 then raise AccountLocked else (if mp <> !master_pass then (incorrect_attempts := !incorrect_attempts + 1; if !incorrect_attempts > 3 then raise AccountLocked else raise WrongPassword) else (incorrect_attempts := 0; num_ops := !num_ops + 1)) in let rec add_to_list (k, v) l = match l with | [] -> [(k,v)] | (k', v')::t -> if k = k' then (k, v)::t else (k', v')::(add_to_list (k, v) t) in let save (mp : masterpass) (ad : address) (pass : password) : unit = check_pass mp; pass_list := add_to_list (ad, encrypt mp pass) !pass_list in let get_force (mp : masterpass) (ad : address) : password option = find_map (fun (k,v) -> if k = ad then Some (decrypt mp v) else None) !pass_list in let get (mp : masterpass) (ad : address) : password option = check_pass mp; get_force mp ad in let update_master (mp : masterpass) (new_pass : masterpass) : unit = if mp <> !master_pass then (incorrect_attempts := !incorrect_attempts + 1; raise WrongPassword) else (incorrect_attempts := 0; num_ops := !num_ops + 1; pass_list := List.map (fun (x,y) -> x, encrypt new_pass (decrypt mp y)) !pass_list; master_pass := new_pass) in let count_ops (mp : masterpass) : int = check_pass mp; !num_ops in {save; get_force; get; update_master; count_ops};; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec aux i n acc = let _ = if i = 0 then count_rec_calls := !count_rec_calls + 1 else () in if n = 0 then 1 else if i > (n-1) then acc else aux (i+1) n (acc + aux 0 i 0 * aux 0 (n-i-1) 0) in let cat_val = aux 0 n 0 in (cat_val, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let x_val = f f' x in (Hashtbl.add hash x x_val; stats.entries := !(stats.entries) + 1; x_val) | Some x_val -> (stats.lkp := !(stats.lkp) + 1; x_val) in f';; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc : int= if i > (n-1) then acc else aux (i+1) n (acc + recf i * recf (n-i-1)) in aux 0 n 0;; ",
  "let catalan_m (n : int) : int * stats = let stats = {entries = ref 0; lkp = ref 0} in let cat = memoize memo_cat stats in (cat n, stats);; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: xs -> begin match f x with | Some y -> Some y | None -> find_map f xs end ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right (fun a (s, u) -> if p a then (a :: s, u) else (s, a :: u) ) l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let storage_masterpass = ref masterpass in let storage_passwords = ref [] in let storage_ops = ref 0 in let storage_failed = ref 0 in let masterpass_check masterpass' = if !storage_masterpass <> masterpass' then (incr storage_failed; raise WrongPassword) else (storage_failed := 0; incr storage_ops) in let lock_check () = if !storage_failed >= 3 then raise AccountLocked in let save masterpass' address pass = lock_check (); masterpass_check masterpass'; storage_passwords := (address, encrypt masterpass' pass) :: !storage_passwords in let get_force masterpass' address = match List.find_opt (fun (a, _) -> a = address) !storage_passwords with | Some (_, pass) -> Some (decrypt masterpass' pass) | None -> None in let get masterpass' address = lock_check (); masterpass_check masterpass'; get_force masterpass' address in let update_master masterpass' newmasterpass = masterpass_check masterpass'; storage_masterpass := newmasterpass; storage_passwords := List.map (fun (a, p) -> (a, encrypt newmasterpass (decrypt masterpass' p))) !storage_passwords in let count_ops masterpass' = lock_check (); masterpass_check masterpass'; !storage_ops in { save; get; get_force; update_master; count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + helper i * helper (n - i)) in aux 0 (n - 1) 0 in let c = helper n in (c, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let v = f f' x in Hashtbl.add hash x v; incr stats.entries; v in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0; } in (memoize memo_cat stats n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let res = f h in ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = if p x then else in ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in if !locked then raise AccountLocked else if pswd = !master then (onCorrect(); true) else false in let save = fun (masterpswd : masterpass) (add : address) (localpswd : password) -> if checkpswd masterpswd then else onIncorrect() in let get_force = fun (masterpswd : masterpass) (add : address) -> match result with in let get = fun (masterpswd : masterpass) (add : address) -> if checkpswd masterpswd then else onIncorrect() in let oldmaster = !master in in let update_master = fun (masterpswd : masterpass) (newmaster : masterpass) -> try if checkpswd masterpswd then update_password_list newmaster else onIncorrect() in let count_ops = fun (masterpswd : masterpass) -> else onIncorrect() in save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops; } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan_calc n = if n = 0 then 1 else let rec helper i n acc = if i > n then acc else helper (i + 1) n (acc + catalan_calc i * catalan_calc (n-i)) in helper 0 (n-1) 0 in ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let result = Hashtbl.find_opt hash x in match result with in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f x with | None -> find_map f xs | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let bool_func bool b l = if p b = bool then b::l else l in let true_func = bool_func true in let false_func = bool_func false in ((List.fold_right true_func l []), (List.fold_right false_func l [])) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ops = ref 0 in let fails = ref 0 in let master = ref masterpass in  let increment_ops() = ops := !ops + 1 in  let check_master try_master = if !fails >= 3 then raise AccountLocked else if try_master = !master then let _ = increment_ops() in fails := 0 else let _ = fails := !fails + 1 in raise WrongPassword in  let count_ops try_master = let _ = check_master try_master in !ops in  let compare_pass try_addr tuple = let (addr, pass) = tuple in if try_addr = addr then Some pass else None in  let save try_master new_addr new_pass = let _ = check_master try_master in ref_list := (new_addr, encrypt try_master new_pass)::!ref_list in  let get_force try_master addr = match find_map (compare_pass addr) !ref_list with | None -> None | Some v -> Some (decrypt try_master v) in  let get try_master addr = let _ = check_master try_master in get_force try_master addr in  let update_master try_master new_master = if try_master = !master then let _ = ref_list := List.map (fun (addr, pass) -> (addr, encrypt new_master (decrypt !master pass))) !ref_list in master := new_master; fails := 0; increment_ops(); else let _ = fails := !fails + 1 in raise WrongPassword  in { save = save ; get_force = get_force ; get = get ; update_master = update_master ; count_ops = count_ops ; }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = let _ = count_rec_calls := !count_rec_calls + 1 in if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n-i)) in aux 0 (n - 1) 0 in  let cat_n = catalan n in (cat_n, !count_rec_calls) ;; ",
  "let my_stats = { entries = ref 0 ; lkp = ref 0; } ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let value = Hashtbl.find hash x in stats.lkp := stats.lkp.contents + 1; value with Not_found -> let value = f f' x in Hashtbl.add hash x value; stats.entries := stats.entries.contents + 1; value in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats = { entries = ref 0; lkp = ref 0; } in let answer = memoize memo_cat stats n in (answer, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = let rec find myFunction = function | [] -> None | h :: t -> match f h with | None -> find f t | Some _ as element -> element in find f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let part acc (t, f) = match p acc with | true -> (acc :: t, f) | false -> (t, acc :: f) in List.fold_right part l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let num_ops = ref 0 in let wrong_attempts = ref 0 in let password_locking_system mpw = if (!wrong_attempts = 3) then raise AccountLocked else if (!master = mpw) then begin num_ops:= !num_ops + 1; wrong_attempts := 0 end else if (!master <> mpw) then begin wrong_attempts := !wrong_attempts + 1; raise WrongPassword end in let save mpw ad pw = password_locking_system mpw; ref_list := (ad, encrypt mpw pw) :: !ref_list in let get_force mpw ad = find_map (function (address, password) -> if (address == ad) then Some (decrypt mpw password) else None) !ref_list in let get mpw ad = password_locking_system mpw; get_force mpw ad; in let update_master mpw new_mpw = begin password_locking_system mpw; let _ = ref_list := List.map (function (address, password) -> (address, (decrypt mpw password))) !ref_list; in let _ = ref_list := List.map (function (address, password) -> (address, (encrypt new_mpw password))) !ref_list; in master := new_mpw end in let count_ops mpw = password_locking_system mpw; !num_ops in {save; get; get_force; count_ops; update_master}  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n - 1) 0 in let v = catalan n in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = let found = Hashtbl.find_opt hash x in match found with | None -> let value = f f' x in Hashtbl.add hash x value; stats.entries := !(stats.entries) + 1; value; | Some element -> stats.lkp := !(stats.lkp) + 1; element in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries = {contents = 0}; lkp = {contents = 0}} in let memoized = (memoize (memo_cat) s n) in (memoized, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | start :: fini -> match f start with | Some x -> Some x | None -> find_map f fini ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let f li (start, fini) = if p li then (li::start, fini) else (start, li :: fini) in List.fold_right f l ([],[]) ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = if n = 0 then (1, !count_rec_calls) else let rec helper2 index n count  = if index > n then (count, !count_rec_calls) else (count_rec_calls := 1 + !count_rec_calls; let (x,y) = helper index in count_rec_calls := 1+ !count_rec_calls; let (z,k) = helper (n-index) in helper2 (1+index) n (x*z+count)) in helper2 0 (n-1) 0 in (count_rec_calls := !count_rec_calls+1; helper n) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | None -> let temp  = f f' x in Hashtbl.add hash x temp; stats.entries := 1 + !(stats.entries); temp | Some t -> stats.lkp := 1 + !(stats.lkp); t in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec helper x n count = if x > n then count else helper (1+x) n (recf x * recf (n-x) + count) in helper 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let result = {lkp= ref 0; entries= ref 0} in let i = memoize memo_cat result n in (i,result) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> let b = f x in match b with | None -> find_map f xs | Some(b) -> Some(b) ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let make_lists (curr_el : 'a) (lsts : 'a list * 'a list) = let (passes, fails) = lsts in if p curr_el then (curr_el::passes, fails) else (passes, curr_el::fails) in let empty = ([], []) in List.fold_right make_lists l empty ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_masterpass = ref masterpass in let ref_ops = ref 1 in let ref_wrongpass = ref 0 in  let check_master = fun masterpass -> masterpass = (!ref_masterpass) in  let save = fun masterpass address password -> if not (check_master masterpass) then raise WrongPassword else ref_ops := !ref_ops + 1; let e_pass = encrypt masterpass password in ref_list := (address, e_pass)::!ref_list in  let get_force = fun masterpass address -> let f = fun (a,p) -> if a = address then Some(decrypt masterpass p) else None in find_map f !ref_list in  let get = fun masterpass address -> if not (check_master masterpass) then (ref_wrongpass := !ref_wrongpass + 1; raise WrongPassword) else ref_ops := !ref_ops + 1; get_force masterpass address in  let update_master = fun masterpass new_masterpass -> if not (check_master masterpass) then (ref_wrongpass := !ref_wrongpass + 1; raise WrongPassword) else ref_masterpass := new_masterpass; let f = fun (address, password) -> (address, encrypt new_masterpass (decrypt masterpass password)) in ref_list := List.map f !ref_list in  let count_ops = fun masterpass -> if not (check_master masterpass) then (ref_wrongpass := !ref_wrongpass + 1; raise WrongPassword) else !ref_ops in  { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let cat = ref 0 in  let rec catalan num = count_rec_calls := !count_rec_calls + 1; if num = 0 then 1 else let rec aux i num acc = if i > num then acc else aux (i+1) num (acc + catalan i * catalan (num-i)) in aux 0 (num-1) 0 in  cat := catalan n;  (!cat, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.mem hash x with | true -> let e = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; e | false -> let e = f f' x in Hashtbl.add hash x e; stats.entries := !(stats.entries) + 1; e in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let stats_ref = {entries = ref 0; lkp = ref 0} in let f = memoize memo_cat stats_ref in (f n, stats_ref) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match f(x) with | Some v -> Some v | _ -> find_map f xs  ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper  (a : 'a) ((l1,l2) : 'a list * 'a list)= match p a with | true -> ( a::l1, l2 ) | false -> ( l1, a::l2 ) in List.fold_right helper  l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master = ref masterpass in let count = ref 0 in let wrong = ref 0 in  let helper masterpass2 = if (masterpass2 = (!master)) then ((count:= !count + 1); wrong := 0) else (wrong:= 1 + !wrong; raise WrongPassword) in  let save masterpass3 address3 password3 = if (!wrong >= 3) then (raise AccountLocked) else (helper masterpass3) ; ref_list := (address3, encrypt masterpass3 password3)::(!ref_list) in  let get_force masterpass4 address4 = let get_force_helper ((local_address, local_pass) : address*password) = if (address4 = local_address) then Some (decrypt masterpass4 local_pass) else None in find_map get_force_helper !ref_list in  let get masterpass5 address5 = if (!wrong >= 3) then raise AccountLocked else (helper masterpass5) ; get_force  masterpass5  address5  in   let update_master masterpass6 password6 = (helper masterpass6) ; let decrypt2 (add, pass) = (add, decrypt masterpass6 pass) in let encrypt2 (add, pass) = (add, encrypt password6 pass) in let decryption = List.map decrypt2 !ref_list in (master := password6 ; ref_list := List.map encrypt2 decryption ) in let count_ops masterpass7 = if (!wrong >= 3) then (raise AccountLocked) else (helper masterpass7); !count in  {save; get_force; get; update_master; count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec helper n = count_rec_calls := 1+ !count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + helper i * helper (n - i)) in aux 0 (n-1) 0 in let x=helper n in (x, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let inspect = Hashtbl.find hash x in (stats.lkp := 1 + !(stats.lkp); inspect) with Not_found -> let newFind = f f' x in (stats.entries := 1 + !(stats.entries); Hashtbl.add hash x newFind; newFind) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let newStats = {entries = ref 0; lkp = ref 0} in let catalan_result = memoize memo_cat newStats n in (catalan_result, newStats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | x::xs -> if (f x) = None then find_map f xs else (f x) | [] -> None ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun x a -> if (p x) then x::a else a) l [] , List.fold_right (fun x a -> if (p x) then a else x::a) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_master : masterpass ref = ref masterpass in let counterf = ref 0 in let countert = ref 0 in let check_password (p : password) : bool = if (p = !ref_master) then (counterf := 0;incr countert;true) else (incr counterf;if !counterf > 2 then raise AccountLocked else raise WrongPassword) in { save = (fun x a b -> if !counterf > 2 then raise AccountLocked else if (check_password x) then ref_list := (a,encrypt x b)::(!ref_list)); get_force = (fun x a -> find_map (fun (m,n) -> if (m = a) then Some (decrypt x n) else None) !ref_list); get = (fun x a -> if !counterf > 2 then raise AccountLocked ; if (check_password x) then find_map (fun (m,n) -> if (m = a) then Some (decrypt x n) else None) !ref_list else None); update_master = (fun x y -> if (check_password x) then (ref_master := y;ref_list := List.map (fun (a,b) -> (a,encrypt y (decrypt x b))) !ref_list)); count_ops = (fun p -> if !counterf > 2 then raise AccountLocked else if (check_password p) then countert := !countert +1;!countert) } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = (incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0) in let c = catalan n in (c, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = if Hashtbl.find_opt hash x = None then let n= f f' x in(Hashtbl.add hash x n; incr stats.entries; n) else (incr stats.lkp; let Some v = (Hashtbl.find_opt hash x) in v) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = raise NotImplemented ;; ",
  "let catalan_m (n : int) : int * stats = raise NotImplemented ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x::xs -> match (f x) with | None -> find_map (f) (xs) | Some y -> Some y ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = (List.fold_right (fun x y -> if (p x) then x::y else y) l []), (List.fold_right (fun x y -> if (not (p x)) then x::y else y) l []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let change_to_pass (x : password) = x in let mp = ref masterpass in let num_incorrect = ref 0 in let num_correct = ref 0 in let get_fun = (fun (a1 : address) -> fun ((a2 : address), (password : password)) -> if a1 = a2 then Some password else None) in let mp_correct = (fun () -> (num_incorrect := 0) ; (num_correct := (!num_correct + 1))) in let mp_incorrect = (fun x -> if x = 2 then raise AccountLocked else (num_incorrect := (!num_incorrect + 1)) ; raise WrongPassword) in let update_list = (fun (mp1 : masterpass) (mp2 : masterpass) -> (fun (address, password) -> (address, (change_to_pass (encrypt mp2 (change_to_pass (decrypt mp1 password)))) ) ) ) in  let save = (fun (mp1 : masterpass) (a1 : address) (p1 : password) -> if mp1 = !mp then ( ref_list := ((a1, (change_to_pass (encrypt mp1 p1)))::(!ref_list)) ; (mp_correct () ) ) else mp_incorrect !num_incorrect ) in  let get_force = (fun (mp1 : masterpass) (a1 : address) -> (match find_map (get_fun a1) (!ref_list) with | Some x -> Some (change_to_pass (decrypt mp1 x)) | None -> None ) )  in  let get = (fun (mp1 : masterpass) (a1 : address) -> if mp1 = !mp then ((mp_correct () ) ; (get_force mp1 a1)) else mp_incorrect !num_incorrect ) in  let update_master = (fun (mp1 : masterpass) (mp2 : masterpass) -> if mp1 = !mp then ( (mp_correct () ) ; (ref_list := ((List.map (update_list mp1 mp2) (!ref_list))) ) ; ( (mp := mp2))) else mp_incorrect !num_incorrect) in  let count_ops = (fun (mp1 : masterpass) -> if mp1 = !mp then ((mp_correct () ) ; (!num_correct)) else mp_incorrect !num_incorrect) in { save ; get_force ; get ; update_master ; count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let i = 0 in let acc = 0 in let first = fun (x, y) -> x in let rec outer_catalan = fun n ->  (count_rec_calls := (!count_rec_calls + 1)) ;  if n = 0 then (1, !count_rec_calls) else let rec inner_catlan i n acc = (if i > n then (acc, !count_rec_calls) else ( ( inner_catlan (i + 1) n (acc + (first (outer_catalan i)) * (first (outer_catalan (n - i) ) ) ) ) ) ) in inner_catlan (i) (n-1) (acc) in outer_catalan n ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let increment_e = fun () -> (stats.entries := (!(stats.entries) + 1)) in let increment_l = fun () -> (stats.lkp := (!(stats.lkp) + 1)) in let rec f' x = if Hashtbl.mem hash x then ( (increment_l ()) ; Hashtbl.find hash x ) else ( let result = (f f' (x)) in (Hashtbl.add hash x (result)) ; (increment_e ()) ; result ) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let i = 0 in let acc = 0 in let outer_catalan = ( fun recf n -> if n = 0 then 1 else let rec inner_catlan i n acc = (if i > n then acc else ( inner_catlan (i + 1) n (acc + (recf i) * (recf (n - i) ) ) ) ) in inner_catlan (i) (n-1) (acc) ) in outer_catalan recf n ;; ",
  " let catalan_m (n : int) : int * stats = let create_stats = { entries= ref 1 ; lkp = ref 0 } in let stats1 = create_stats in let memoize1 = memoize (memo_cat) (stats1) in ((memo_cat memoize1 n) , stats1) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let opt = f h in if (opt = None) then find_map (f) (t) else  opt ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right ( fun e (pass, not_pass)-> if (p e) then (e::pass, not_pass) else (pass, e::not_pass) )l ([],[]) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> let opt = f h in if (opt = None) then find_map (f) (t) else  opt ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = List.fold_right ( fun e (pass, not_pass)-> if (p e) then (e::pass, not_pass) else (pass, e::not_pass) )l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = ( let ref_list : (address * password) list ref = ref [] and count = ref 0 and masterpw = ref masterpass in let lock_count_down = ref (-3) in let unlock = fun () -> lock_count_down := -3; () in let mas_pw_check = fun (p : masterpass) : (bool) -> ( if p = !masterpw then ( count := !count + 1; unlock (); true ) else ( lock_count_down := !lock_count_down + 1; false ) ) in let save = ( fun (maspw:masterpass) (addr:address) (pw:password) : (unit) -> if (!lock_count_down < 0) then ( if (mas_pw_check (maspw)) then ref_list := (!ref_list)@[(addr,encrypt(maspw)(pw))] else raise WrongPassword ) else raise AccountLocked )in let get_force = ( fun (maspw:masterpass) (addr:address) : (password option) -> let find = ( fun addr1 (addr2, pw)-> if(addr1=addr2) then Some (decrypt (maspw) pw) else None ) in find_map(find addr)(!ref_list) )in let get = ( fun (maspw:masterpass) (addr:address) : (password option) -> if (!lock_count_down < 0) then( if (mas_pw_check (maspw)) then get_force (maspw) (addr) else raise WrongPassword ) else raise AccountLocked )in let update_master = ( fun (maspw:masterpass) (up_maspw:masterpass) : (unit)-> if (mas_pw_check(maspw)) then( unlock (); let list = !ref_list in ref_list := ( List.map( fun (addr, pw) -> ( (addr,pw) |> fun (addr, pw) ->(addr,decrypt(maspw)(pw))) |> fun (addr, pw) -> (addr,encrypt(up_maspw)(pw)) ) )list; masterpw := up_maspw; ) else raise WrongPassword )in let count_ops = ( fun (maspw:masterpass) : (int) -> if (!lock_count_down < 0) then ( if(mas_pw_check(maspw))then( !count ) else raise WrongPassword )else raise AccountLocked )in {save; get_force; get; update_master; count_ops} );; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan(n : int) : (int) = let count = (count_rec_calls := !count_rec_calls + 1) in if n=0 then 1 else let rec helper (n)(i)(sum) = if i = n then sum else helper(n)(i+1)(sum + catalan(i)*catalan(n-1-i)) in helper(n)(0)(0) in let ret = catalan(n) in (ret, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let v=Hashtbl.find(hash)(x) in (stats.lkp := !(stats.lkp) + 1); v with Not_found -> (stats.entries := !(stats.entries) + 1); Hashtbl.add hash x y; y in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0  then 1 else let rec helper i n acc = if  i = n then acc else helper (i+1) n (acc + recf(i)*recf(n-1-i)) in helper 0 (n) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s = {entries=ref 0 ; lkp=ref 0} in let res = (memoize(memo_cat)(s))(n) in (res, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match f h with | None -> find_map f t | Some a -> Some a ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let true_list = List.fold_right (fun x y -> if p x then x::y else y) l [] in let false_list = List.fold_right (fun x y -> if not (p x) then x::y else y) l [] in if l == [] then [],[] else true_list,false_list ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let attempts = ref 0 in let mpass = ref masterpass in let counter = ref 0 in let verify_pass pwd f = if pwd = !mpass then (attempts := 0; f (); incr counter) else (incr attempts; raise WrongPassword) in let attempt pwd f = if !attempts >= 3 then raise AccountLocked else verify_pass pwd f in let save mpwd ad pwd = attempt pwd (fun () -> (ref_list := (ad, (encrypt !mpass pwd))::(!ref_list))) in let get_force mpwd ad = let verify tuple = let (add, pass) = tuple in if add = ad then Some (decrypt mpwd pass) else None in find_map verify !ref_list in let get (mpwd: masterpass) (ad: address) : password option = if !attempts >= 3 then raise AccountLocked else if !mpass = mpwd then (incr counter; attempts := 0; get_force mpwd ad) else (incr attempts; raise WrongPassword) in let update_master mpwd new_pwd = attempt mpwd (fun () -> mpass := new_pwd) in let count_ops mpwd = (attempt mpwd (fun () -> !counter); !counter) in {save;get_force;get;update_master;count_ops} ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = incr count_rec_calls; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let catalan_value = catalan n in catalan_value, !count_rec_calls ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match Hashtbl.find_opt hash x with | Some v -> incr stats.lkp; v | None -> let b = f f' x in incr stats.entries; Hashtbl.add hash x b; b in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let s1 = { entries = ref 0; lkp = ref 0 } in let f = memoize memo_cat s1 n in f,s1 ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: rest -> match (f x) with | None -> find_map f rest | Some v -> Some v ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helper curr (t, f) = if (p curr == true) then (curr :: t, f) else (t, curr :: f) in List.fold_right helper l ([],[]) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let master : masterpass ref = ref masterpass in let op_count : int ref = ref 0 in let wrong_count : int ref = ref 0 in let lock : bool ref = ref false in  let verify input_password = if !lock then raise AccountLocked (if input_password <> !master then (wrong_count := !wrong_count + 1; if !wrong_count < 3 then raise WrongPassword else (lock := true; raise WrongPassword) ) else wrong_count := 0 )  in let get_force = (fun m adrs -> (op_count := !op_count + 1; find_map (fun (addr,pw) -> if addr = adrs then Some (decrypt m pw) else None) (!ref_list) )) in { save = (fun m adrs pw -> (verify m; op_count := !op_count + 1; ref_list := (adrs, (encrypt m pw)) :: !ref_list) );  get_force;  get = (fun m adrs -> (verify m; get_force m adrs) );  update_master = (fun currMP newP -> (if !lock then (if currMP <> !master then raise WrongPassword else verify currMP); op_count := !op_count + 1; master := newP; let change (addr,pass) = (addr, encrypt newP (decrypt currMP pass)) in ref_list := List.map (change) (!ref_list); );  count_ops = (fun m -> (verify m; op_count := !op_count + 1; !op_count))  }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let ans = catalan n in (ans, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let ans1 = Hashtbl.find hash x in (stats.lkp := !(stats.lkp) + 1; ans1) with Not_found -> let ans2 = f f' x in (stats.entries := !(stats.entries) + 1; Hashtbl.add hash x ans2; ans2) in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = if n < 0 then raise NotImplemented else let stats = {entries=ref 0; lkp=ref 0} in let memo = (memoize (memo_cat) stats) in (memo n, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | x :: l -> match f x with | Some _ as res -> res | None -> find_map f l ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let split el (pass, fail) = if p el then (el::pass,fail) else (pass,el::fail) in List.fold_right split  l ([], []) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let counter = ref 0 in let errCounter = ref 0 in let tick () = incr counter; true in let tickE () = incr errCounter; false in let ref_mp = ref masterpass in let check_mp mp = if mp = !ref_mp then tick () else tickE () in  let save = (fun mp addr psw -> if !errCounter > 3 then raise AccountLocked else if check_mp mp then ref_list := (!ref_list @ [addr, encrypt mp psw]) else raise WrongPassword) in  let get_force  = (fun (mp : masterpass) (addr : address) -> let get_psw ((a: address) ,(b : password)) = if a = addr then Some (decrypt mp b) else None in find_map get_psw !ref_list ) in  let get : masterpass -> address -> password option = (fun mp addr -> if !errCounter > 3 then raise AccountLocked else if check_mp mp then (get_force mp addr) else raise WrongPassword )  in let update_master = (fun cur_mp new_mp -> if check_mp cur_mp then (ref_mp := new_mp; errCounter := 0; let change_mp  = ( fun (a,b) -> let plain = decrypt cur_mp b in (a, encrypt new_mp plain) ) in ref_list := List.map change_mp !ref_list ) else raise WrongPassword) in  let count_ops = (fun mp -> ( if !errCounter > 3 then raise AccountLocked else if check_mp mp then !counter else raise WrongPassword )) in {save; get_force; get; update_master; count_ops}   ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let tick x =  incr count_rec_calls; x in let rec catalan n = if n = 0 then tick 1 else tick ( let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0) in let v = catalan n in (v, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in  let rec f' x = try let v0 = Hashtbl.find hash x in incr stats.lkp; v0 with Not_found -> let v1 = f f' x in (Hashtbl.add hash x v1); incr stats.entries; v1 in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = let catalan n = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 in catalan n ;; ",
  "let catalan_m (n : int) : int * stats = let stats  = { entries = ref 0; lkp = ref 0} in let v = memoize memo_cat stats n in (v, stats)  ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match (f h) with | Some v -> Some v | _ -> find_map f t  ;; ",
  " let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let split v (l1, l2) = if p v then (v::l1, l2) else (l1,v::l2) in List.fold_right split l ([], [])  ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let ref_list : (address * password) list ref = ref [] in let ref_mpass = ref masterpass in in in let helper_verify (p : password) : bool = if !fail >= 3 then raise AccountLocked else if !fail < 3 then if p = !ref_mpass then (fail := 0; incr counter; true) else (incr fail; if !fail < 3 then raise WrongPassword else raise AccountLocked) else raise AccountLocked in let save masterpass addr pass = if helper_verify masterpass then ( (ref_list := (addr, encrypt masterpass pass) :: !ref_list); ) in let get_force masterpass addr = find_map (fun (a,p) -> if addr = a then Some(decrypt masterpass p) else None) !ref_list in let get masterpass addr = if helper_verify masterpass then get_force masterpass addr else None in let update_master curr_pass new_pass = if helper_verify curr_pass then ( ref_mpass := new_pass; ref_list := List.map (fun (a,p) -> (a, encrypt new_pass (decrypt curr_pass p))) !ref_list; ) in let count_ops masterpass = if helper_verify masterpass then !counter else -1 in { save = save; get_force = get_force; get = get; update_master = update_master; count_ops = count_ops } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec compute n = ( count_rec_calls := 1 + !count_rec_calls; if n = 0 then 1 else let rec helper i n acc = if i > n then acc else helper (i + 1) n (acc + compute i * compute (n - i)) in helper 0 (n-1) 0 ) in let value = compute n in (value, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = try let v = Hashtbl.find hash x in stats.lkp := !(stats.lkp) + 1; v with Not_found -> Hashtbl.add hash x (f f' x); stats.entries := !(stats.entries) + 1; Hashtbl.find hash x in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec helper i n acc = if i > n then acc else helper (i + 1) n (acc + (recf i) * (recf (n-i))) in helper 0 (n-1) 0   ;; ",
  "let catalan_m (n : int) : int * stats = let s = { entries = ref 0; lkp = ref 0 } in let result = (memoize memo_cat s) n in (result, s) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = if l = [] then None else let x::xs = l in match (f x) with | Some v -> Some v | None -> find_map f xs ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let l1 =  List.fold_right (fun x acc -> if p x then x::acc else acc) l [] in let l2 =  List.fold_right (fun x acc -> if p x then acc else x::acc) l [] in (l1 , l2) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager = let wrong = ref 0 in let count = ref 0 in let ref_master = ref masterpass in let ref_list : (address * password) list ref = ref [] in let is_correct master = if !wrong >= 3 then raise AccountLocked else( if master = !ref_master then begin incr count; wrong := 0; end else begin incr wrong; raise WrongPassword; end) in let save master address local = is_correct master; ref_list := (address, (encrypt master local))::!ref_list; in let get_force master address = find_map (fun (a,p) -> if a = address then Some (decrypt master p) else None) !ref_list in let get master address = is_correct master; get_force master address; in let update_master master latest = if master = !ref_master then begin ref_list := List.fold_right (fun (a,p) l -> (a, encrypt latest (decrypt master p))::l) !ref_list []; ref_master := latest; wrong := 0; in let count_ops password =  is_correct password; !count; in { save ; get ; get_force ; count_ops ; update_master } ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec outer_helper n = if n = 0 then ( incr count_rec_calls; 1; ) else let rec inner_helper i n acc = if i > n then ( incr count_rec_calls; acc; )else inner_helper(i + 1) n (acc + outer_helper i * outer_helper (n - i)); in inner_helper 0 (n-1) 0 in let v2 = outer_helper n in (v2 , !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match (Hashtbl.mem hash x) with | false -> incr stats.entries; Hashtbl.add hash x (f f' x); Hashtbl.find hash x; | true -> incr stats.lkp; Hashtbl.find hash x; in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else( aux (i + 1) n (acc + recf i * recf (n - i)) )in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let (stats : stats) = { entries = ref 0; lkp = ref 0 } in let memo = memoize memo_cat stats n in (memo, stats) ;; ",
  "let rec find_map (f : 'a -> 'b option) (l : 'a list) : 'b option = match l with | [] -> None | h::t -> match (f h) with | Some v -> Some v | None -> find_map f t ;; ",
  "let partition (p : 'a -> bool) (l : 'a list) : ('a list * 'a list) = let helperTrue (arg1: 'a) (trueList: 'a list) : ('a list) = if (p arg1) then arg1::trueList else trueList in let helperFalse (arg1: 'a) (falseList: 'a list) : ('a list) = if (not (p arg1)) then arg1::falseList else falseList in let tList = List.fold_right helperTrue l [] in let fList = List.fold_right helperFalse l [] in (tList, fList) ;; ",
  "let make_manager (masterpass : masterpass) : pass_manager =  let ref_list : (address * password) list ref = ref [] in let isLocked = ref false in    let verifyMaster (mGiven : masterpass) : bool = (mGiven = !currentMaster) in  let checkerFunction (wanted : address) (tuple : (address * password)) : password option = let (a, p) = tuple in if (a = wanted) then Some p else None in  let wrongPasswordSubroutine () = consecFails := !consecFails + 1; if (!consecFails = 3) then ( isLocked := true; raise WrongPassword ) else raise WrongPassword in  let re_encrypt (mOld : masterpass) (mNew : masterpass) : unit = let decryptTuple (m : masterpass) (tuple : (address * password)) : (address * password) = let (a,p) = tuple in (a, decrypt m p) in let encryptTuple (m : masterpass) (tuple : (address * password)) : (address * password) = let (a,p) = tuple in (a, encrypt m p) in let decryptedList = List.map (decryptTuple mOld) !ref_list in ref_list := List.map (encryptTuple mNew) decryptedList in   let save = ( fun m a p -> if (!isLocked) then raise AccountLocked else ( if (verifyMaster m) then ( consecFails := 0; opsCount := !opsCount + 1; ref_list := (a, encrypt m p)::!ref_list ) else wrongPasswordSubroutine () ) ) in  let get_force = ( fun m a -> match (find_map (checkerFunction a) !ref_list) with | Some p -> Some (decrypt m p) | None -> None ) in  let get = ( fun m a -> if (!isLocked) then raise AccountLocked else ( if (verifyMaster m) then ( consecFails := 0; opsCount := !opsCount + 1; get_force m a ) else wrongPasswordSubroutine () ) ) in  let update_master = ( fun m mNew -> if (verifyMaster m) then ( consecFails := 0; opsCount := !opsCount + 1; re_encrypt m mNew; isLocked := false; currentMaster := mNew ) else wrongPasswordSubroutine () ) in  let count_ops = ( fun m -> if (!isLocked) then raise AccountLocked else ( if (verifyMaster m) then ( consecFails := 0; opsCount := !opsCount + 1; !opsCount ) else wrongPasswordSubroutine () ) ) in  { save; get_force; get; update_master; count_ops; }  ;; ",
  "let catalan_count (n : int) : (int * int) = let count_rec_calls = ref 0 in let rec catalan n = count_rec_calls := !count_rec_calls + 1; if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + catalan i * catalan (n - i)) in aux 0 (n-1) 0 in let answer = catalan n in (answer, !count_rec_calls) ;; ",
  "let memoize (f : ('a -> 'b) -> 'a -> 'b) (stats : stats) : 'a -> 'b = let hash = Hashtbl.create 1000 in let rec f' x = match (Hashtbl.find_opt hash x) with | Some v -> stats.lkp := !(stats.lkp) + 1; v | None   -> let newVal = f f' x in Hashtbl.add hash x newVal; stats.entries := !(stats.entries) + 1; newVal; in f' ;; ",
  "let memo_cat (recf : int -> int) (n : int) : int = if n = 0 then 1 else let rec aux i n acc = if i > n then acc else aux (i + 1) n (acc + recf i * recf (n - i)) in aux 0 (n-1) 0 ;; ",
  "let catalan_m (n : int) : int * stats = let newStats = {entries = ref 0; lkp = ref 0} in let memoizedCatalan = memoize memo_cat newStats in let result = memoizedCatalan n in (result, newStats) ;; "
]